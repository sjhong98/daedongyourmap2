/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fhongseungjae%2FDesktop%2Flearning.js%2Fdaedongyourmap%2Fapp%2Fcomponents%2Fmap%2FmapLayout.tsx&server=false!":
/*!*************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fhongseungjae%2FDesktop%2Flearning.js%2Fdaedongyourmap%2Fapp%2Fcomponents%2Fmap%2FmapLayout.tsx&server=false! ***!
  \*************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/components/map/mapLayout.tsx */ \"(app-pages-browser)/./app/components/map/mapLayout.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZVc2VycyUyRmhvbmdzZXVuZ2phZSUyRkRlc2t0b3AlMkZsZWFybmluZy5qcyUyRmRhZWRvbmd5b3VybWFwJTJGYXBwJTJGY29tcG9uZW50cyUyRm1hcCUyRm1hcExheW91dC50c3gmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzg2ZmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvaG9uZ3NldW5namFlL0Rlc2t0b3AvbGVhcm5pbmcuanMvZGFlZG9uZ3lvdXJtYXAvYXBwL2NvbXBvbmVudHMvbWFwL21hcExheW91dC50c3hcIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fhongseungjae%2FDesktop%2Flearning.js%2Fdaedongyourmap%2Fapp%2Fcomponents%2Fmap%2FmapLayout.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ isPropValid; }\n/* harmony export */ });\n/* harmony import */ var _emotion_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @emotion/memoize */ \"(app-pages-browser)/./node_modules/@emotion/memoize/dist/emotion-memoize.esm.js\");\n\nvar reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23\nvar isPropValid = /* #__PURE__ */ (0,_emotion_memoize__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function(prop) {\n    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZW1vdGlvbi9pcy1wcm9wLXZhbGlkL2Rpc3QvZW1vdGlvbi1pcy1wcm9wLXZhbGlkLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF1QztBQUV2QyxJQUFJQyxrQkFBa0IscTlIQUFxOUgscURBQXFEO0FBRWhpSSxJQUFJQyxjQUFjLGFBQWEsR0FBRUYsNERBQU9BLENBQUMsU0FBVUcsSUFBSTtJQUNyRCxPQUFPRixnQkFBZ0JHLElBQUksQ0FBQ0QsU0FBU0EsS0FBS0UsVUFBVSxDQUFDLE9BQU8sT0FFekRGLEtBQUtFLFVBQVUsQ0FBQyxPQUFPLE9BRXZCRixLQUFLRSxVQUFVLENBQUMsS0FBSztBQUMxQjtBQUlrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vaXMtcHJvcC12YWxpZC9kaXN0L2Vtb3Rpb24taXMtcHJvcC12YWxpZC5lc20uanM/ZGM3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbWVtb2l6ZSBmcm9tICdAZW1vdGlvbi9tZW1vaXplJztcblxudmFyIHJlYWN0UHJvcHNSZWdleCA9IC9eKChjaGlsZHJlbnxkYW5nZXJvdXNseVNldElubmVySFRNTHxrZXl8cmVmfGF1dG9Gb2N1c3xkZWZhdWx0VmFsdWV8ZGVmYXVsdENoZWNrZWR8aW5uZXJIVE1MfHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ3xzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmd8dmFsdWVMaW5rfGFiYnJ8YWNjZXB0fGFjY2VwdENoYXJzZXR8YWNjZXNzS2V5fGFjdGlvbnxhbGxvd3xhbGxvd1VzZXJNZWRpYXxhbGxvd1BheW1lbnRSZXF1ZXN0fGFsbG93RnVsbFNjcmVlbnxhbGxvd1RyYW5zcGFyZW5jeXxhbHR8YXN5bmN8YXV0b0NvbXBsZXRlfGF1dG9QbGF5fGNhcHR1cmV8Y2VsbFBhZGRpbmd8Y2VsbFNwYWNpbmd8Y2hhbGxlbmdlfGNoYXJTZXR8Y2hlY2tlZHxjaXRlfGNsYXNzSUR8Y2xhc3NOYW1lfGNvbHN8Y29sU3Bhbnxjb250ZW50fGNvbnRlbnRFZGl0YWJsZXxjb250ZXh0TWVudXxjb250cm9sc3xjb250cm9sc0xpc3R8Y29vcmRzfGNyb3NzT3JpZ2lufGRhdGF8ZGF0ZVRpbWV8ZGVjb2Rpbmd8ZGVmYXVsdHxkZWZlcnxkaXJ8ZGlzYWJsZWR8ZGlzYWJsZVBpY3R1cmVJblBpY3R1cmV8ZG93bmxvYWR8ZHJhZ2dhYmxlfGVuY1R5cGV8ZW50ZXJLZXlIaW50fGZvcm18Zm9ybUFjdGlvbnxmb3JtRW5jVHlwZXxmb3JtTWV0aG9kfGZvcm1Ob1ZhbGlkYXRlfGZvcm1UYXJnZXR8ZnJhbWVCb3JkZXJ8aGVhZGVyc3xoZWlnaHR8aGlkZGVufGhpZ2h8aHJlZnxocmVmTGFuZ3xodG1sRm9yfGh0dHBFcXVpdnxpZHxpbnB1dE1vZGV8aW50ZWdyaXR5fGlzfGtleVBhcmFtc3xrZXlUeXBlfGtpbmR8bGFiZWx8bGFuZ3xsaXN0fGxvYWRpbmd8bG9vcHxsb3d8bWFyZ2luSGVpZ2h0fG1hcmdpbldpZHRofG1heHxtYXhMZW5ndGh8bWVkaWF8bWVkaWFHcm91cHxtZXRob2R8bWlufG1pbkxlbmd0aHxtdWx0aXBsZXxtdXRlZHxuYW1lfG5vbmNlfG5vVmFsaWRhdGV8b3BlbnxvcHRpbXVtfHBhdHRlcm58cGxhY2Vob2xkZXJ8cGxheXNJbmxpbmV8cG9zdGVyfHByZWxvYWR8cHJvZmlsZXxyYWRpb0dyb3VwfHJlYWRPbmx5fHJlZmVycmVyUG9saWN5fHJlbHxyZXF1aXJlZHxyZXZlcnNlZHxyb2xlfHJvd3N8cm93U3BhbnxzYW5kYm94fHNjb3BlfHNjb3BlZHxzY3JvbGxpbmd8c2VhbWxlc3N8c2VsZWN0ZWR8c2hhcGV8c2l6ZXxzaXplc3xzbG90fHNwYW58c3BlbGxDaGVja3xzcmN8c3JjRG9jfHNyY0xhbmd8c3JjU2V0fHN0YXJ0fHN0ZXB8c3R5bGV8c3VtbWFyeXx0YWJJbmRleHx0YXJnZXR8dGl0bGV8dHJhbnNsYXRlfHR5cGV8dXNlTWFwfHZhbHVlfHdpZHRofHdtb2RlfHdyYXB8YWJvdXR8ZGF0YXR5cGV8aW5saXN0fHByZWZpeHxwcm9wZXJ0eXxyZXNvdXJjZXx0eXBlb2Z8dm9jYWJ8YXV0b0NhcGl0YWxpemV8YXV0b0NvcnJlY3R8YXV0b1NhdmV8Y29sb3J8aW5jcmVtZW50YWx8ZmFsbGJhY2t8aW5lcnR8aXRlbVByb3B8aXRlbVNjb3BlfGl0ZW1UeXBlfGl0ZW1JRHxpdGVtUmVmfG9ufG9wdGlvbnxyZXN1bHRzfHNlY3VyaXR5fHVuc2VsZWN0YWJsZXxhY2NlbnRIZWlnaHR8YWNjdW11bGF0ZXxhZGRpdGl2ZXxhbGlnbm1lbnRCYXNlbGluZXxhbGxvd1Jlb3JkZXJ8YWxwaGFiZXRpY3xhbXBsaXR1ZGV8YXJhYmljRm9ybXxhc2NlbnR8YXR0cmlidXRlTmFtZXxhdHRyaWJ1dGVUeXBlfGF1dG9SZXZlcnNlfGF6aW11dGh8YmFzZUZyZXF1ZW5jeXxiYXNlbGluZVNoaWZ0fGJhc2VQcm9maWxlfGJib3h8YmVnaW58Ymlhc3xieXxjYWxjTW9kZXxjYXBIZWlnaHR8Y2xpcHxjbGlwUGF0aFVuaXRzfGNsaXBQYXRofGNsaXBSdWxlfGNvbG9ySW50ZXJwb2xhdGlvbnxjb2xvckludGVycG9sYXRpb25GaWx0ZXJzfGNvbG9yUHJvZmlsZXxjb2xvclJlbmRlcmluZ3xjb250ZW50U2NyaXB0VHlwZXxjb250ZW50U3R5bGVUeXBlfGN1cnNvcnxjeHxjeXxkfGRlY2VsZXJhdGV8ZGVzY2VudHxkaWZmdXNlQ29uc3RhbnR8ZGlyZWN0aW9ufGRpc3BsYXl8ZGl2aXNvcnxkb21pbmFudEJhc2VsaW5lfGR1cnxkeHxkeXxlZGdlTW9kZXxlbGV2YXRpb258ZW5hYmxlQmFja2dyb3VuZHxlbmR8ZXhwb25lbnR8ZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZHxmaWxsfGZpbGxPcGFjaXR5fGZpbGxSdWxlfGZpbHRlcnxmaWx0ZXJSZXN8ZmlsdGVyVW5pdHN8Zmxvb2RDb2xvcnxmbG9vZE9wYWNpdHl8Zm9jdXNhYmxlfGZvbnRGYW1pbHl8Zm9udFNpemV8Zm9udFNpemVBZGp1c3R8Zm9udFN0cmV0Y2h8Zm9udFN0eWxlfGZvbnRWYXJpYW50fGZvbnRXZWlnaHR8Zm9ybWF0fGZyb218ZnJ8Znh8Znl8ZzF8ZzJ8Z2x5cGhOYW1lfGdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsfGdseXBoT3JpZW50YXRpb25WZXJ0aWNhbHxnbHlwaFJlZnxncmFkaWVudFRyYW5zZm9ybXxncmFkaWVudFVuaXRzfGhhbmdpbmd8aG9yaXpBZHZYfGhvcml6T3JpZ2luWHxpZGVvZ3JhcGhpY3xpbWFnZVJlbmRlcmluZ3xpbnxpbjJ8aW50ZXJjZXB0fGt8azF8azJ8azN8azR8a2VybmVsTWF0cml4fGtlcm5lbFVuaXRMZW5ndGh8a2VybmluZ3xrZXlQb2ludHN8a2V5U3BsaW5lc3xrZXlUaW1lc3xsZW5ndGhBZGp1c3R8bGV0dGVyU3BhY2luZ3xsaWdodGluZ0NvbG9yfGxpbWl0aW5nQ29uZUFuZ2xlfGxvY2FsfG1hcmtlckVuZHxtYXJrZXJNaWR8bWFya2VyU3RhcnR8bWFya2VySGVpZ2h0fG1hcmtlclVuaXRzfG1hcmtlcldpZHRofG1hc2t8bWFza0NvbnRlbnRVbml0c3xtYXNrVW5pdHN8bWF0aGVtYXRpY2FsfG1vZGV8bnVtT2N0YXZlc3xvZmZzZXR8b3BhY2l0eXxvcGVyYXRvcnxvcmRlcnxvcmllbnR8b3JpZW50YXRpb258b3JpZ2lufG92ZXJmbG93fG92ZXJsaW5lUG9zaXRpb258b3ZlcmxpbmVUaGlja25lc3N8cGFub3NlMXxwYWludE9yZGVyfHBhdGhMZW5ndGh8cGF0dGVybkNvbnRlbnRVbml0c3xwYXR0ZXJuVHJhbnNmb3JtfHBhdHRlcm5Vbml0c3xwb2ludGVyRXZlbnRzfHBvaW50c3xwb2ludHNBdFh8cG9pbnRzQXRZfHBvaW50c0F0WnxwcmVzZXJ2ZUFscGhhfHByZXNlcnZlQXNwZWN0UmF0aW98cHJpbWl0aXZlVW5pdHN8cnxyYWRpdXN8cmVmWHxyZWZZfHJlbmRlcmluZ0ludGVudHxyZXBlYXRDb3VudHxyZXBlYXREdXJ8cmVxdWlyZWRFeHRlbnNpb25zfHJlcXVpcmVkRmVhdHVyZXN8cmVzdGFydHxyZXN1bHR8cm90YXRlfHJ4fHJ5fHNjYWxlfHNlZWR8c2hhcGVSZW5kZXJpbmd8c2xvcGV8c3BhY2luZ3xzcGVjdWxhckNvbnN0YW50fHNwZWN1bGFyRXhwb25lbnR8c3BlZWR8c3ByZWFkTWV0aG9kfHN0YXJ0T2Zmc2V0fHN0ZERldmlhdGlvbnxzdGVtaHxzdGVtdnxzdGl0Y2hUaWxlc3xzdG9wQ29sb3J8c3RvcE9wYWNpdHl8c3RyaWtldGhyb3VnaFBvc2l0aW9ufHN0cmlrZXRocm91Z2hUaGlja25lc3N8c3RyaW5nfHN0cm9rZXxzdHJva2VEYXNoYXJyYXl8c3Ryb2tlRGFzaG9mZnNldHxzdHJva2VMaW5lY2FwfHN0cm9rZUxpbmVqb2lufHN0cm9rZU1pdGVybGltaXR8c3Ryb2tlT3BhY2l0eXxzdHJva2VXaWR0aHxzdXJmYWNlU2NhbGV8c3lzdGVtTGFuZ3VhZ2V8dGFibGVWYWx1ZXN8dGFyZ2V0WHx0YXJnZXRZfHRleHRBbmNob3J8dGV4dERlY29yYXRpb258dGV4dFJlbmRlcmluZ3x0ZXh0TGVuZ3RofHRvfHRyYW5zZm9ybXx1MXx1Mnx1bmRlcmxpbmVQb3NpdGlvbnx1bmRlcmxpbmVUaGlja25lc3N8dW5pY29kZXx1bmljb2RlQmlkaXx1bmljb2RlUmFuZ2V8dW5pdHNQZXJFbXx2QWxwaGFiZXRpY3x2SGFuZ2luZ3x2SWRlb2dyYXBoaWN8dk1hdGhlbWF0aWNhbHx2YWx1ZXN8dmVjdG9yRWZmZWN0fHZlcnNpb258dmVydEFkdll8dmVydE9yaWdpblh8dmVydE9yaWdpbll8dmlld0JveHx2aWV3VGFyZ2V0fHZpc2liaWxpdHl8d2lkdGhzfHdvcmRTcGFjaW5nfHdyaXRpbmdNb2RlfHh8eEhlaWdodHx4MXx4Mnx4Q2hhbm5lbFNlbGVjdG9yfHhsaW5rQWN0dWF0ZXx4bGlua0FyY3JvbGV8eGxpbmtIcmVmfHhsaW5rUm9sZXx4bGlua1Nob3d8eGxpbmtUaXRsZXx4bGlua1R5cGV8eG1sQmFzZXx4bWxuc3x4bWxuc1hsaW5rfHhtbExhbmd8eG1sU3BhY2V8eXx5MXx5Mnx5Q2hhbm5lbFNlbGVjdG9yfHp8em9vbUFuZFBhbnxmb3J8Y2xhc3N8YXV0b2ZvY3VzKXwoKFtEZF1bQWFdW1R0XVtBYV18W0FhXVtScl1bSWldW0FhXXx4KS0uKikpJC87IC8vIGh0dHBzOi8vZXNiZW5jaC5jb20vYmVuY2gvNWJmZWU2OGE0Y2Q3ZTYwMDllZjYxZDIzXG5cbnZhciBpc1Byb3BWYWxpZCA9IC8qICNfX1BVUkVfXyAqL21lbW9pemUoZnVuY3Rpb24gKHByb3ApIHtcbiAgcmV0dXJuIHJlYWN0UHJvcHNSZWdleC50ZXN0KHByb3ApIHx8IHByb3AuY2hhckNvZGVBdCgwKSA9PT0gMTExXG4gIC8qIG8gKi9cbiAgJiYgcHJvcC5jaGFyQ29kZUF0KDEpID09PSAxMTBcbiAgLyogbiAqL1xuICAmJiBwcm9wLmNoYXJDb2RlQXQoMikgPCA5MTtcbn1cbi8qIForMSAqL1xuKTtcblxuZXhwb3J0IHsgaXNQcm9wVmFsaWQgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbIm1lbW9pemUiLCJyZWFjdFByb3BzUmVnZXgiLCJpc1Byb3BWYWxpZCIsInByb3AiLCJ0ZXN0IiwiY2hhckNvZGVBdCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@emotion/memoize/dist/emotion-memoize.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@emotion/memoize/dist/emotion-memoize.esm.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ memoize; }\n/* harmony export */ });\nfunction memoize(fn) {\n    var cache = Object.create(null);\n    return function(arg) {\n        if (cache[arg] === undefined) cache[arg] = fn(arg);\n        return cache[arg];\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZW1vdGlvbi9tZW1vaXplL2Rpc3QvZW1vdGlvbi1tZW1vaXplLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBU0EsUUFBUUMsRUFBRTtJQUNqQixJQUFJQyxRQUFRQyxPQUFPQyxNQUFNLENBQUM7SUFDMUIsT0FBTyxTQUFVQyxHQUFHO1FBQ2xCLElBQUlILEtBQUssQ0FBQ0csSUFBSSxLQUFLQyxXQUFXSixLQUFLLENBQUNHLElBQUksR0FBR0osR0FBR0k7UUFDOUMsT0FBT0gsS0FBSyxDQUFDRyxJQUFJO0lBQ25CO0FBQ0Y7QUFFOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL21lbW9pemUvZGlzdC9lbW90aW9uLW1lbW9pemUuZXNtLmpzPzM4NGUiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgIGlmIChjYWNoZVthcmddID09PSB1bmRlZmluZWQpIGNhY2hlW2FyZ10gPSBmbihhcmcpO1xuICAgIHJldHVybiBjYWNoZVthcmddO1xuICB9O1xufVxuXG5leHBvcnQgeyBtZW1vaXplIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6WyJtZW1vaXplIiwiZm4iLCJjYWNoZSIsIk9iamVjdCIsImNyZWF0ZSIsImFyZyIsInVuZGVmaW5lZCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@emotion/memoize/dist/emotion-memoize.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@emotion/unitless/dist/emotion-unitless.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@emotion/unitless/dist/emotion-unitless.esm.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nvar unitlessKeys = {\n    animationIterationCount: 1,\n    borderImageOutset: 1,\n    borderImageSlice: 1,\n    borderImageWidth: 1,\n    boxFlex: 1,\n    boxFlexGroup: 1,\n    boxOrdinalGroup: 1,\n    columnCount: 1,\n    columns: 1,\n    flex: 1,\n    flexGrow: 1,\n    flexPositive: 1,\n    flexShrink: 1,\n    flexNegative: 1,\n    flexOrder: 1,\n    gridRow: 1,\n    gridRowEnd: 1,\n    gridRowSpan: 1,\n    gridRowStart: 1,\n    gridColumn: 1,\n    gridColumnEnd: 1,\n    gridColumnSpan: 1,\n    gridColumnStart: 1,\n    msGridRow: 1,\n    msGridRowSpan: 1,\n    msGridColumn: 1,\n    msGridColumnSpan: 1,\n    fontWeight: 1,\n    lineHeight: 1,\n    opacity: 1,\n    order: 1,\n    orphans: 1,\n    tabSize: 1,\n    widows: 1,\n    zIndex: 1,\n    zoom: 1,\n    WebkitLineClamp: 1,\n    // SVG-related properties\n    fillOpacity: 1,\n    floodOpacity: 1,\n    stopOpacity: 1,\n    strokeDasharray: 1,\n    strokeDashoffset: 1,\n    strokeMiterlimit: 1,\n    strokeOpacity: 1,\n    strokeWidth: 1\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (unitlessKeys);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZW1vdGlvbi91bml0bGVzcy9kaXN0L2Vtb3Rpb24tdW5pdGxlc3MuZXNtLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxJQUFJQSxlQUFlO0lBQ2pCQyx5QkFBeUI7SUFDekJDLG1CQUFtQjtJQUNuQkMsa0JBQWtCO0lBQ2xCQyxrQkFBa0I7SUFDbEJDLFNBQVM7SUFDVEMsY0FBYztJQUNkQyxpQkFBaUI7SUFDakJDLGFBQWE7SUFDYkMsU0FBUztJQUNUQyxNQUFNO0lBQ05DLFVBQVU7SUFDVkMsY0FBYztJQUNkQyxZQUFZO0lBQ1pDLGNBQWM7SUFDZEMsV0FBVztJQUNYQyxTQUFTO0lBQ1RDLFlBQVk7SUFDWkMsYUFBYTtJQUNiQyxjQUFjO0lBQ2RDLFlBQVk7SUFDWkMsZUFBZTtJQUNmQyxnQkFBZ0I7SUFDaEJDLGlCQUFpQjtJQUNqQkMsV0FBVztJQUNYQyxlQUFlO0lBQ2ZDLGNBQWM7SUFDZEMsa0JBQWtCO0lBQ2xCQyxZQUFZO0lBQ1pDLFlBQVk7SUFDWkMsU0FBUztJQUNUQyxPQUFPO0lBQ1BDLFNBQVM7SUFDVEMsU0FBUztJQUNUQyxRQUFRO0lBQ1JDLFFBQVE7SUFDUkMsTUFBTTtJQUNOQyxpQkFBaUI7SUFDakIseUJBQXlCO0lBQ3pCQyxhQUFhO0lBQ2JDLGNBQWM7SUFDZEMsYUFBYTtJQUNiQyxpQkFBaUI7SUFDakJDLGtCQUFrQjtJQUNsQkMsa0JBQWtCO0lBQ2xCQyxlQUFlO0lBQ2ZDLGFBQWE7QUFDZjtBQUVBLCtEQUFlN0MsWUFBWUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vdW5pdGxlc3MvZGlzdC9lbW90aW9uLXVuaXRsZXNzLmVzbS5qcz83MTU5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB1bml0bGVzc0tleXMgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiAxLFxuICBib3JkZXJJbWFnZU91dHNldDogMSxcbiAgYm9yZGVySW1hZ2VTbGljZTogMSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogMSxcbiAgYm94RmxleDogMSxcbiAgYm94RmxleEdyb3VwOiAxLFxuICBib3hPcmRpbmFsR3JvdXA6IDEsXG4gIGNvbHVtbkNvdW50OiAxLFxuICBjb2x1bW5zOiAxLFxuICBmbGV4OiAxLFxuICBmbGV4R3JvdzogMSxcbiAgZmxleFBvc2l0aXZlOiAxLFxuICBmbGV4U2hyaW5rOiAxLFxuICBmbGV4TmVnYXRpdmU6IDEsXG4gIGZsZXhPcmRlcjogMSxcbiAgZ3JpZFJvdzogMSxcbiAgZ3JpZFJvd0VuZDogMSxcbiAgZ3JpZFJvd1NwYW46IDEsXG4gIGdyaWRSb3dTdGFydDogMSxcbiAgZ3JpZENvbHVtbjogMSxcbiAgZ3JpZENvbHVtbkVuZDogMSxcbiAgZ3JpZENvbHVtblNwYW46IDEsXG4gIGdyaWRDb2x1bW5TdGFydDogMSxcbiAgbXNHcmlkUm93OiAxLFxuICBtc0dyaWRSb3dTcGFuOiAxLFxuICBtc0dyaWRDb2x1bW46IDEsXG4gIG1zR3JpZENvbHVtblNwYW46IDEsXG4gIGZvbnRXZWlnaHQ6IDEsXG4gIGxpbmVIZWlnaHQ6IDEsXG4gIG9wYWNpdHk6IDEsXG4gIG9yZGVyOiAxLFxuICBvcnBoYW5zOiAxLFxuICB0YWJTaXplOiAxLFxuICB3aWRvd3M6IDEsXG4gIHpJbmRleDogMSxcbiAgem9vbTogMSxcbiAgV2Via2l0TGluZUNsYW1wOiAxLFxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiAxLFxuICBmbG9vZE9wYWNpdHk6IDEsXG4gIHN0b3BPcGFjaXR5OiAxLFxuICBzdHJva2VEYXNoYXJyYXk6IDEsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IDEsXG4gIHN0cm9rZU1pdGVybGltaXQ6IDEsXG4gIHN0cm9rZU9wYWNpdHk6IDEsXG4gIHN0cm9rZVdpZHRoOiAxXG59O1xuXG5leHBvcnQgZGVmYXVsdCB1bml0bGVzc0tleXM7XG4iXSwibmFtZXMiOlsidW5pdGxlc3NLZXlzIiwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQiLCJib3JkZXJJbWFnZU91dHNldCIsImJvcmRlckltYWdlU2xpY2UiLCJib3JkZXJJbWFnZVdpZHRoIiwiYm94RmxleCIsImJveEZsZXhHcm91cCIsImJveE9yZGluYWxHcm91cCIsImNvbHVtbkNvdW50IiwiY29sdW1ucyIsImZsZXgiLCJmbGV4R3JvdyIsImZsZXhQb3NpdGl2ZSIsImZsZXhTaHJpbmsiLCJmbGV4TmVnYXRpdmUiLCJmbGV4T3JkZXIiLCJncmlkUm93IiwiZ3JpZFJvd0VuZCIsImdyaWRSb3dTcGFuIiwiZ3JpZFJvd1N0YXJ0IiwiZ3JpZENvbHVtbiIsImdyaWRDb2x1bW5FbmQiLCJncmlkQ29sdW1uU3BhbiIsImdyaWRDb2x1bW5TdGFydCIsIm1zR3JpZFJvdyIsIm1zR3JpZFJvd1NwYW4iLCJtc0dyaWRDb2x1bW4iLCJtc0dyaWRDb2x1bW5TcGFuIiwiZm9udFdlaWdodCIsImxpbmVIZWlnaHQiLCJvcGFjaXR5Iiwib3JkZXIiLCJvcnBoYW5zIiwidGFiU2l6ZSIsIndpZG93cyIsInpJbmRleCIsInpvb20iLCJXZWJraXRMaW5lQ2xhbXAiLCJmaWxsT3BhY2l0eSIsImZsb29kT3BhY2l0eSIsInN0b3BPcGFjaXR5Iiwic3Ryb2tlRGFzaGFycmF5Iiwic3Ryb2tlRGFzaG9mZnNldCIsInN0cm9rZU1pdGVybGltaXQiLCJzdHJva2VPcGFjaXR5Iiwic3Ryb2tlV2lkdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@emotion/unitless/dist/emotion-unitless.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/image.js":
/*!*********************************************!*\
  !*** ./node_modules/next/dist/api/image.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport default from dynamic */ _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/lib/image-external */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js\");\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n //# sourceMappingURL=image.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2ltYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF1RDtBQUNWLENBRTdDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9pbWFnZS5qcz9kMTAxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLi4vc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbFwiO1xuZXhwb3J0ICogZnJvbSBcIi4uL3NoYXJlZC9saWIvaW1hZ2UtZXh0ZXJuYWxcIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UuanMubWFwIl0sIm5hbWVzIjpbImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/image.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/api/navigation.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n //# sourceMappingURL=navigation.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdELENBRWhELHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9uYXZpZ2F0aW9uLmpzPzFkMjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4uL2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb25cIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2aWdhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\"); //# sourceMappingURL=process.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxpQkFBaUJDO0FBQ3JCQyxPQUFPQyxPQUFPLEdBQUcsQ0FBQyxDQUFDSCxrQkFBa0JJLHFCQUFNQSxDQUFDQyxPQUFPLEtBQUssT0FBTyxLQUFLLElBQUlMLGdCQUFnQk0sR0FBRyxLQUFLLE9BQVEsRUFBQ0wsbUJBQW1CRyxxQkFBTUEsQ0FBQ0MsT0FBTyxLQUFLLE9BQU8sS0FBSyxJQUFJSixpQkFBaUJLLEdBQUcsTUFBTSxXQUFXRixxQkFBTUEsQ0FBQ0MsT0FBTyxHQUFHRSxtQkFBT0EsQ0FBQyw0R0FBNEIsR0FFelAsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/Y2E2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOlsiX2dsb2JhbF9wcm9jZXNzIiwiX2dsb2JhbF9wcm9jZXNzMSIsIm1vZHVsZSIsImV4cG9ydHMiLCJnbG9iYWwiLCJwcm9jZXNzIiwiZW52IiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/compiled/buffer/index.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n\n(function() {\n    var e = {\n        675: function(e, r) {\n            \"use strict\";\n            r.byteLength = byteLength;\n            r.toByteArray = toByteArray;\n            r.fromByteArray = fromByteArray;\n            var t = [];\n            var f = [];\n            var n = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n            var i = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n            for(var o = 0, u = i.length; o < u; ++o){\n                t[o] = i[o];\n                f[i.charCodeAt(o)] = o;\n            }\n            f[\"-\".charCodeAt(0)] = 62;\n            f[\"_\".charCodeAt(0)] = 63;\n            function getLens(e) {\n                var r = e.length;\n                if (r % 4 > 0) {\n                    throw new Error(\"Invalid string. Length must be a multiple of 4\");\n                }\n                var t = e.indexOf(\"=\");\n                if (t === -1) t = r;\n                var f = t === r ? 0 : 4 - t % 4;\n                return [\n                    t,\n                    f\n                ];\n            }\n            function byteLength(e) {\n                var r = getLens(e);\n                var t = r[0];\n                var f = r[1];\n                return (t + f) * 3 / 4 - f;\n            }\n            function _byteLength(e, r, t) {\n                return (r + t) * 3 / 4 - t;\n            }\n            function toByteArray(e) {\n                var r;\n                var t = getLens(e);\n                var i = t[0];\n                var o = t[1];\n                var u = new n(_byteLength(e, i, o));\n                var a = 0;\n                var s = o > 0 ? i - 4 : i;\n                var h;\n                for(h = 0; h < s; h += 4){\n                    r = f[e.charCodeAt(h)] << 18 | f[e.charCodeAt(h + 1)] << 12 | f[e.charCodeAt(h + 2)] << 6 | f[e.charCodeAt(h + 3)];\n                    u[a++] = r >> 16 & 255;\n                    u[a++] = r >> 8 & 255;\n                    u[a++] = r & 255;\n                }\n                if (o === 2) {\n                    r = f[e.charCodeAt(h)] << 2 | f[e.charCodeAt(h + 1)] >> 4;\n                    u[a++] = r & 255;\n                }\n                if (o === 1) {\n                    r = f[e.charCodeAt(h)] << 10 | f[e.charCodeAt(h + 1)] << 4 | f[e.charCodeAt(h + 2)] >> 2;\n                    u[a++] = r >> 8 & 255;\n                    u[a++] = r & 255;\n                }\n                return u;\n            }\n            function tripletToBase64(e) {\n                return t[e >> 18 & 63] + t[e >> 12 & 63] + t[e >> 6 & 63] + t[e & 63];\n            }\n            function encodeChunk(e, r, t) {\n                var f;\n                var n = [];\n                for(var i = r; i < t; i += 3){\n                    f = (e[i] << 16 & 16711680) + (e[i + 1] << 8 & 65280) + (e[i + 2] & 255);\n                    n.push(tripletToBase64(f));\n                }\n                return n.join(\"\");\n            }\n            function fromByteArray(e) {\n                var r;\n                var f = e.length;\n                var n = f % 3;\n                var i = [];\n                var o = 16383;\n                for(var u = 0, a = f - n; u < a; u += o){\n                    i.push(encodeChunk(e, u, u + o > a ? a : u + o));\n                }\n                if (n === 1) {\n                    r = e[f - 1];\n                    i.push(t[r >> 2] + t[r << 4 & 63] + \"==\");\n                } else if (n === 2) {\n                    r = (e[f - 2] << 8) + e[f - 1];\n                    i.push(t[r >> 10] + t[r >> 4 & 63] + t[r << 2 & 63] + \"=\");\n                }\n                return i.join(\"\");\n            }\n        },\n        72: function(e, r, t) {\n            \"use strict\";\n            /*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */ var f = t(675);\n            var n = t(783);\n            var i = typeof Symbol === \"function\" && typeof Symbol.for === \"function\" ? Symbol.for(\"nodejs.util.inspect.custom\") : null;\n            r.Buffer = Buffer;\n            r.SlowBuffer = SlowBuffer;\n            r.INSPECT_MAX_BYTES = 50;\n            var o = 2147483647;\n            r.kMaxLength = o;\n            Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n            if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n                console.error(\"This browser lacks typed array (Uint8Array) support which is required by \" + \"`buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");\n            }\n            function typedArraySupport() {\n                try {\n                    var e = new Uint8Array(1);\n                    var r = {\n                        foo: function() {\n                            return 42;\n                        }\n                    };\n                    Object.setPrototypeOf(r, Uint8Array.prototype);\n                    Object.setPrototypeOf(e, r);\n                    return e.foo() === 42;\n                } catch (e) {\n                    return false;\n                }\n            }\n            Object.defineProperty(Buffer.prototype, \"parent\", {\n                enumerable: true,\n                get: function() {\n                    if (!Buffer.isBuffer(this)) return undefined;\n                    return this.buffer;\n                }\n            });\n            Object.defineProperty(Buffer.prototype, \"offset\", {\n                enumerable: true,\n                get: function() {\n                    if (!Buffer.isBuffer(this)) return undefined;\n                    return this.byteOffset;\n                }\n            });\n            function createBuffer(e) {\n                if (e > o) {\n                    throw new RangeError('The value \"' + e + '\" is invalid for option \"size\"');\n                }\n                var r = new Uint8Array(e);\n                Object.setPrototypeOf(r, Buffer.prototype);\n                return r;\n            }\n            function Buffer(e, r, t) {\n                if (typeof e === \"number\") {\n                    if (typeof r === \"string\") {\n                        throw new TypeError('The \"string\" argument must be of type string. Received type number');\n                    }\n                    return allocUnsafe(e);\n                }\n                return from(e, r, t);\n            }\n            Buffer.poolSize = 8192;\n            function from(e, r, t) {\n                if (typeof e === \"string\") {\n                    return fromString(e, r);\n                }\n                if (ArrayBuffer.isView(e)) {\n                    return fromArrayLike(e);\n                }\n                if (e == null) {\n                    throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \" + \"or Array-like Object. Received type \" + typeof e);\n                }\n                if (isInstance(e, ArrayBuffer) || e && isInstance(e.buffer, ArrayBuffer)) {\n                    return fromArrayBuffer(e, r, t);\n                }\n                if (typeof SharedArrayBuffer !== \"undefined\" && (isInstance(e, SharedArrayBuffer) || e && isInstance(e.buffer, SharedArrayBuffer))) {\n                    return fromArrayBuffer(e, r, t);\n                }\n                if (typeof e === \"number\") {\n                    throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n                }\n                var f = e.valueOf && e.valueOf();\n                if (f != null && f !== e) {\n                    return Buffer.from(f, r, t);\n                }\n                var n = fromObject(e);\n                if (n) return n;\n                if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] === \"function\") {\n                    return Buffer.from(e[Symbol.toPrimitive](\"string\"), r, t);\n                }\n                throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \" + \"or Array-like Object. Received type \" + typeof e);\n            }\n            Buffer.from = function(e, r, t) {\n                return from(e, r, t);\n            };\n            Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);\n            Object.setPrototypeOf(Buffer, Uint8Array);\n            function assertSize(e) {\n                if (typeof e !== \"number\") {\n                    throw new TypeError('\"size\" argument must be of type number');\n                } else if (e < 0) {\n                    throw new RangeError('The value \"' + e + '\" is invalid for option \"size\"');\n                }\n            }\n            function alloc(e, r, t) {\n                assertSize(e);\n                if (e <= 0) {\n                    return createBuffer(e);\n                }\n                if (r !== undefined) {\n                    return typeof t === \"string\" ? createBuffer(e).fill(r, t) : createBuffer(e).fill(r);\n                }\n                return createBuffer(e);\n            }\n            Buffer.alloc = function(e, r, t) {\n                return alloc(e, r, t);\n            };\n            function allocUnsafe(e) {\n                assertSize(e);\n                return createBuffer(e < 0 ? 0 : checked(e) | 0);\n            }\n            Buffer.allocUnsafe = function(e) {\n                return allocUnsafe(e);\n            };\n            Buffer.allocUnsafeSlow = function(e) {\n                return allocUnsafe(e);\n            };\n            function fromString(e, r) {\n                if (typeof r !== \"string\" || r === \"\") {\n                    r = \"utf8\";\n                }\n                if (!Buffer.isEncoding(r)) {\n                    throw new TypeError(\"Unknown encoding: \" + r);\n                }\n                var t = byteLength(e, r) | 0;\n                var f = createBuffer(t);\n                var n = f.write(e, r);\n                if (n !== t) {\n                    f = f.slice(0, n);\n                }\n                return f;\n            }\n            function fromArrayLike(e) {\n                var r = e.length < 0 ? 0 : checked(e.length) | 0;\n                var t = createBuffer(r);\n                for(var f = 0; f < r; f += 1){\n                    t[f] = e[f] & 255;\n                }\n                return t;\n            }\n            function fromArrayBuffer(e, r, t) {\n                if (r < 0 || e.byteLength < r) {\n                    throw new RangeError('\"offset\" is outside of buffer bounds');\n                }\n                if (e.byteLength < r + (t || 0)) {\n                    throw new RangeError('\"length\" is outside of buffer bounds');\n                }\n                var f;\n                if (r === undefined && t === undefined) {\n                    f = new Uint8Array(e);\n                } else if (t === undefined) {\n                    f = new Uint8Array(e, r);\n                } else {\n                    f = new Uint8Array(e, r, t);\n                }\n                Object.setPrototypeOf(f, Buffer.prototype);\n                return f;\n            }\n            function fromObject(e) {\n                if (Buffer.isBuffer(e)) {\n                    var r = checked(e.length) | 0;\n                    var t = createBuffer(r);\n                    if (t.length === 0) {\n                        return t;\n                    }\n                    e.copy(t, 0, 0, r);\n                    return t;\n                }\n                if (e.length !== undefined) {\n                    if (typeof e.length !== \"number\" || numberIsNaN(e.length)) {\n                        return createBuffer(0);\n                    }\n                    return fromArrayLike(e);\n                }\n                if (e.type === \"Buffer\" && Array.isArray(e.data)) {\n                    return fromArrayLike(e.data);\n                }\n            }\n            function checked(e) {\n                if (e >= o) {\n                    throw new RangeError(\"Attempt to allocate Buffer larger than maximum \" + \"size: 0x\" + o.toString(16) + \" bytes\");\n                }\n                return e | 0;\n            }\n            function SlowBuffer(e) {\n                if (+e != e) {\n                    e = 0;\n                }\n                return Buffer.alloc(+e);\n            }\n            Buffer.isBuffer = function isBuffer(e) {\n                return e != null && e._isBuffer === true && e !== Buffer.prototype;\n            };\n            Buffer.compare = function compare(e, r) {\n                if (isInstance(e, Uint8Array)) e = Buffer.from(e, e.offset, e.byteLength);\n                if (isInstance(r, Uint8Array)) r = Buffer.from(r, r.offset, r.byteLength);\n                if (!Buffer.isBuffer(e) || !Buffer.isBuffer(r)) {\n                    throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n                }\n                if (e === r) return 0;\n                var t = e.length;\n                var f = r.length;\n                for(var n = 0, i = Math.min(t, f); n < i; ++n){\n                    if (e[n] !== r[n]) {\n                        t = e[n];\n                        f = r[n];\n                        break;\n                    }\n                }\n                if (t < f) return -1;\n                if (f < t) return 1;\n                return 0;\n            };\n            Buffer.isEncoding = function isEncoding(e) {\n                switch(String(e).toLowerCase()){\n                    case \"hex\":\n                    case \"utf8\":\n                    case \"utf-8\":\n                    case \"ascii\":\n                    case \"latin1\":\n                    case \"binary\":\n                    case \"base64\":\n                    case \"ucs2\":\n                    case \"ucs-2\":\n                    case \"utf16le\":\n                    case \"utf-16le\":\n                        return true;\n                    default:\n                        return false;\n                }\n            };\n            Buffer.concat = function concat(e, r) {\n                if (!Array.isArray(e)) {\n                    throw new TypeError('\"list\" argument must be an Array of Buffers');\n                }\n                if (e.length === 0) {\n                    return Buffer.alloc(0);\n                }\n                var t;\n                if (r === undefined) {\n                    r = 0;\n                    for(t = 0; t < e.length; ++t){\n                        r += e[t].length;\n                    }\n                }\n                var f = Buffer.allocUnsafe(r);\n                var n = 0;\n                for(t = 0; t < e.length; ++t){\n                    var i = e[t];\n                    if (isInstance(i, Uint8Array)) {\n                        i = Buffer.from(i);\n                    }\n                    if (!Buffer.isBuffer(i)) {\n                        throw new TypeError('\"list\" argument must be an Array of Buffers');\n                    }\n                    i.copy(f, n);\n                    n += i.length;\n                }\n                return f;\n            };\n            function byteLength(e, r) {\n                if (Buffer.isBuffer(e)) {\n                    return e.length;\n                }\n                if (ArrayBuffer.isView(e) || isInstance(e, ArrayBuffer)) {\n                    return e.byteLength;\n                }\n                if (typeof e !== \"string\") {\n                    throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' + \"Received type \" + typeof e);\n                }\n                var t = e.length;\n                var f = arguments.length > 2 && arguments[2] === true;\n                if (!f && t === 0) return 0;\n                var n = false;\n                for(;;){\n                    switch(r){\n                        case \"ascii\":\n                        case \"latin1\":\n                        case \"binary\":\n                            return t;\n                        case \"utf8\":\n                        case \"utf-8\":\n                            return utf8ToBytes(e).length;\n                        case \"ucs2\":\n                        case \"ucs-2\":\n                        case \"utf16le\":\n                        case \"utf-16le\":\n                            return t * 2;\n                        case \"hex\":\n                            return t >>> 1;\n                        case \"base64\":\n                            return base64ToBytes(e).length;\n                        default:\n                            if (n) {\n                                return f ? -1 : utf8ToBytes(e).length;\n                            }\n                            r = (\"\" + r).toLowerCase();\n                            n = true;\n                    }\n                }\n            }\n            Buffer.byteLength = byteLength;\n            function slowToString(e, r, t) {\n                var f = false;\n                if (r === undefined || r < 0) {\n                    r = 0;\n                }\n                if (r > this.length) {\n                    return \"\";\n                }\n                if (t === undefined || t > this.length) {\n                    t = this.length;\n                }\n                if (t <= 0) {\n                    return \"\";\n                }\n                t >>>= 0;\n                r >>>= 0;\n                if (t <= r) {\n                    return \"\";\n                }\n                if (!e) e = \"utf8\";\n                while(true){\n                    switch(e){\n                        case \"hex\":\n                            return hexSlice(this, r, t);\n                        case \"utf8\":\n                        case \"utf-8\":\n                            return utf8Slice(this, r, t);\n                        case \"ascii\":\n                            return asciiSlice(this, r, t);\n                        case \"latin1\":\n                        case \"binary\":\n                            return latin1Slice(this, r, t);\n                        case \"base64\":\n                            return base64Slice(this, r, t);\n                        case \"ucs2\":\n                        case \"ucs-2\":\n                        case \"utf16le\":\n                        case \"utf-16le\":\n                            return utf16leSlice(this, r, t);\n                        default:\n                            if (f) throw new TypeError(\"Unknown encoding: \" + e);\n                            e = (e + \"\").toLowerCase();\n                            f = true;\n                    }\n                }\n            }\n            Buffer.prototype._isBuffer = true;\n            function swap(e, r, t) {\n                var f = e[r];\n                e[r] = e[t];\n                e[t] = f;\n            }\n            Buffer.prototype.swap16 = function swap16() {\n                var e = this.length;\n                if (e % 2 !== 0) {\n                    throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n                }\n                for(var r = 0; r < e; r += 2){\n                    swap(this, r, r + 1);\n                }\n                return this;\n            };\n            Buffer.prototype.swap32 = function swap32() {\n                var e = this.length;\n                if (e % 4 !== 0) {\n                    throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n                }\n                for(var r = 0; r < e; r += 4){\n                    swap(this, r, r + 3);\n                    swap(this, r + 1, r + 2);\n                }\n                return this;\n            };\n            Buffer.prototype.swap64 = function swap64() {\n                var e = this.length;\n                if (e % 8 !== 0) {\n                    throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n                }\n                for(var r = 0; r < e; r += 8){\n                    swap(this, r, r + 7);\n                    swap(this, r + 1, r + 6);\n                    swap(this, r + 2, r + 5);\n                    swap(this, r + 3, r + 4);\n                }\n                return this;\n            };\n            Buffer.prototype.toString = function toString() {\n                var e = this.length;\n                if (e === 0) return \"\";\n                if (arguments.length === 0) return utf8Slice(this, 0, e);\n                return slowToString.apply(this, arguments);\n            };\n            Buffer.prototype.toLocaleString = Buffer.prototype.toString;\n            Buffer.prototype.equals = function equals(e) {\n                if (!Buffer.isBuffer(e)) throw new TypeError(\"Argument must be a Buffer\");\n                if (this === e) return true;\n                return Buffer.compare(this, e) === 0;\n            };\n            Buffer.prototype.inspect = function inspect() {\n                var e = \"\";\n                var t = r.INSPECT_MAX_BYTES;\n                e = this.toString(\"hex\", 0, t).replace(/(.{2})/g, \"$1 \").trim();\n                if (this.length > t) e += \" ... \";\n                return \"<Buffer \" + e + \">\";\n            };\n            if (i) {\n                Buffer.prototype[i] = Buffer.prototype.inspect;\n            }\n            Buffer.prototype.compare = function compare(e, r, t, f, n) {\n                if (isInstance(e, Uint8Array)) {\n                    e = Buffer.from(e, e.offset, e.byteLength);\n                }\n                if (!Buffer.isBuffer(e)) {\n                    throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. ' + \"Received type \" + typeof e);\n                }\n                if (r === undefined) {\n                    r = 0;\n                }\n                if (t === undefined) {\n                    t = e ? e.length : 0;\n                }\n                if (f === undefined) {\n                    f = 0;\n                }\n                if (n === undefined) {\n                    n = this.length;\n                }\n                if (r < 0 || t > e.length || f < 0 || n > this.length) {\n                    throw new RangeError(\"out of range index\");\n                }\n                if (f >= n && r >= t) {\n                    return 0;\n                }\n                if (f >= n) {\n                    return -1;\n                }\n                if (r >= t) {\n                    return 1;\n                }\n                r >>>= 0;\n                t >>>= 0;\n                f >>>= 0;\n                n >>>= 0;\n                if (this === e) return 0;\n                var i = n - f;\n                var o = t - r;\n                var u = Math.min(i, o);\n                var a = this.slice(f, n);\n                var s = e.slice(r, t);\n                for(var h = 0; h < u; ++h){\n                    if (a[h] !== s[h]) {\n                        i = a[h];\n                        o = s[h];\n                        break;\n                    }\n                }\n                if (i < o) return -1;\n                if (o < i) return 1;\n                return 0;\n            };\n            function bidirectionalIndexOf(e, r, t, f, n) {\n                if (e.length === 0) return -1;\n                if (typeof t === \"string\") {\n                    f = t;\n                    t = 0;\n                } else if (t > 2147483647) {\n                    t = 2147483647;\n                } else if (t < -2147483648) {\n                    t = -2147483648;\n                }\n                t = +t;\n                if (numberIsNaN(t)) {\n                    t = n ? 0 : e.length - 1;\n                }\n                if (t < 0) t = e.length + t;\n                if (t >= e.length) {\n                    if (n) return -1;\n                    else t = e.length - 1;\n                } else if (t < 0) {\n                    if (n) t = 0;\n                    else return -1;\n                }\n                if (typeof r === \"string\") {\n                    r = Buffer.from(r, f);\n                }\n                if (Buffer.isBuffer(r)) {\n                    if (r.length === 0) {\n                        return -1;\n                    }\n                    return arrayIndexOf(e, r, t, f, n);\n                } else if (typeof r === \"number\") {\n                    r = r & 255;\n                    if (typeof Uint8Array.prototype.indexOf === \"function\") {\n                        if (n) {\n                            return Uint8Array.prototype.indexOf.call(e, r, t);\n                        } else {\n                            return Uint8Array.prototype.lastIndexOf.call(e, r, t);\n                        }\n                    }\n                    return arrayIndexOf(e, [\n                        r\n                    ], t, f, n);\n                }\n                throw new TypeError(\"val must be string, number or Buffer\");\n            }\n            function arrayIndexOf(e, r, t, f, n) {\n                var i = 1;\n                var o = e.length;\n                var u = r.length;\n                if (f !== undefined) {\n                    f = String(f).toLowerCase();\n                    if (f === \"ucs2\" || f === \"ucs-2\" || f === \"utf16le\" || f === \"utf-16le\") {\n                        if (e.length < 2 || r.length < 2) {\n                            return -1;\n                        }\n                        i = 2;\n                        o /= 2;\n                        u /= 2;\n                        t /= 2;\n                    }\n                }\n                function read(e, r) {\n                    if (i === 1) {\n                        return e[r];\n                    } else {\n                        return e.readUInt16BE(r * i);\n                    }\n                }\n                var a;\n                if (n) {\n                    var s = -1;\n                    for(a = t; a < o; a++){\n                        if (read(e, a) === read(r, s === -1 ? 0 : a - s)) {\n                            if (s === -1) s = a;\n                            if (a - s + 1 === u) return s * i;\n                        } else {\n                            if (s !== -1) a -= a - s;\n                            s = -1;\n                        }\n                    }\n                } else {\n                    if (t + u > o) t = o - u;\n                    for(a = t; a >= 0; a--){\n                        var h = true;\n                        for(var c = 0; c < u; c++){\n                            if (read(e, a + c) !== read(r, c)) {\n                                h = false;\n                                break;\n                            }\n                        }\n                        if (h) return a;\n                    }\n                }\n                return -1;\n            }\n            Buffer.prototype.includes = function includes(e, r, t) {\n                return this.indexOf(e, r, t) !== -1;\n            };\n            Buffer.prototype.indexOf = function indexOf(e, r, t) {\n                return bidirectionalIndexOf(this, e, r, t, true);\n            };\n            Buffer.prototype.lastIndexOf = function lastIndexOf(e, r, t) {\n                return bidirectionalIndexOf(this, e, r, t, false);\n            };\n            function hexWrite(e, r, t, f) {\n                t = Number(t) || 0;\n                var n = e.length - t;\n                if (!f) {\n                    f = n;\n                } else {\n                    f = Number(f);\n                    if (f > n) {\n                        f = n;\n                    }\n                }\n                var i = r.length;\n                if (f > i / 2) {\n                    f = i / 2;\n                }\n                for(var o = 0; o < f; ++o){\n                    var u = parseInt(r.substr(o * 2, 2), 16);\n                    if (numberIsNaN(u)) return o;\n                    e[t + o] = u;\n                }\n                return o;\n            }\n            function utf8Write(e, r, t, f) {\n                return blitBuffer(utf8ToBytes(r, e.length - t), e, t, f);\n            }\n            function asciiWrite(e, r, t, f) {\n                return blitBuffer(asciiToBytes(r), e, t, f);\n            }\n            function latin1Write(e, r, t, f) {\n                return asciiWrite(e, r, t, f);\n            }\n            function base64Write(e, r, t, f) {\n                return blitBuffer(base64ToBytes(r), e, t, f);\n            }\n            function ucs2Write(e, r, t, f) {\n                return blitBuffer(utf16leToBytes(r, e.length - t), e, t, f);\n            }\n            Buffer.prototype.write = function write(e, r, t, f) {\n                if (r === undefined) {\n                    f = \"utf8\";\n                    t = this.length;\n                    r = 0;\n                } else if (t === undefined && typeof r === \"string\") {\n                    f = r;\n                    t = this.length;\n                    r = 0;\n                } else if (isFinite(r)) {\n                    r = r >>> 0;\n                    if (isFinite(t)) {\n                        t = t >>> 0;\n                        if (f === undefined) f = \"utf8\";\n                    } else {\n                        f = t;\n                        t = undefined;\n                    }\n                } else {\n                    throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n                }\n                var n = this.length - r;\n                if (t === undefined || t > n) t = n;\n                if (e.length > 0 && (t < 0 || r < 0) || r > this.length) {\n                    throw new RangeError(\"Attempt to write outside buffer bounds\");\n                }\n                if (!f) f = \"utf8\";\n                var i = false;\n                for(;;){\n                    switch(f){\n                        case \"hex\":\n                            return hexWrite(this, e, r, t);\n                        case \"utf8\":\n                        case \"utf-8\":\n                            return utf8Write(this, e, r, t);\n                        case \"ascii\":\n                            return asciiWrite(this, e, r, t);\n                        case \"latin1\":\n                        case \"binary\":\n                            return latin1Write(this, e, r, t);\n                        case \"base64\":\n                            return base64Write(this, e, r, t);\n                        case \"ucs2\":\n                        case \"ucs-2\":\n                        case \"utf16le\":\n                        case \"utf-16le\":\n                            return ucs2Write(this, e, r, t);\n                        default:\n                            if (i) throw new TypeError(\"Unknown encoding: \" + f);\n                            f = (\"\" + f).toLowerCase();\n                            i = true;\n                    }\n                }\n            };\n            Buffer.prototype.toJSON = function toJSON() {\n                return {\n                    type: \"Buffer\",\n                    data: Array.prototype.slice.call(this._arr || this, 0)\n                };\n            };\n            function base64Slice(e, r, t) {\n                if (r === 0 && t === e.length) {\n                    return f.fromByteArray(e);\n                } else {\n                    return f.fromByteArray(e.slice(r, t));\n                }\n            }\n            function utf8Slice(e, r, t) {\n                t = Math.min(e.length, t);\n                var f = [];\n                var n = r;\n                while(n < t){\n                    var i = e[n];\n                    var o = null;\n                    var u = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;\n                    if (n + u <= t) {\n                        var a, s, h, c;\n                        switch(u){\n                            case 1:\n                                if (i < 128) {\n                                    o = i;\n                                }\n                                break;\n                            case 2:\n                                a = e[n + 1];\n                                if ((a & 192) === 128) {\n                                    c = (i & 31) << 6 | a & 63;\n                                    if (c > 127) {\n                                        o = c;\n                                    }\n                                }\n                                break;\n                            case 3:\n                                a = e[n + 1];\n                                s = e[n + 2];\n                                if ((a & 192) === 128 && (s & 192) === 128) {\n                                    c = (i & 15) << 12 | (a & 63) << 6 | s & 63;\n                                    if (c > 2047 && (c < 55296 || c > 57343)) {\n                                        o = c;\n                                    }\n                                }\n                                break;\n                            case 4:\n                                a = e[n + 1];\n                                s = e[n + 2];\n                                h = e[n + 3];\n                                if ((a & 192) === 128 && (s & 192) === 128 && (h & 192) === 128) {\n                                    c = (i & 15) << 18 | (a & 63) << 12 | (s & 63) << 6 | h & 63;\n                                    if (c > 65535 && c < 1114112) {\n                                        o = c;\n                                    }\n                                }\n                        }\n                    }\n                    if (o === null) {\n                        o = 65533;\n                        u = 1;\n                    } else if (o > 65535) {\n                        o -= 65536;\n                        f.push(o >>> 10 & 1023 | 55296);\n                        o = 56320 | o & 1023;\n                    }\n                    f.push(o);\n                    n += u;\n                }\n                return decodeCodePointsArray(f);\n            }\n            var u = 4096;\n            function decodeCodePointsArray(e) {\n                var r = e.length;\n                if (r <= u) {\n                    return String.fromCharCode.apply(String, e);\n                }\n                var t = \"\";\n                var f = 0;\n                while(f < r){\n                    t += String.fromCharCode.apply(String, e.slice(f, f += u));\n                }\n                return t;\n            }\n            function asciiSlice(e, r, t) {\n                var f = \"\";\n                t = Math.min(e.length, t);\n                for(var n = r; n < t; ++n){\n                    f += String.fromCharCode(e[n] & 127);\n                }\n                return f;\n            }\n            function latin1Slice(e, r, t) {\n                var f = \"\";\n                t = Math.min(e.length, t);\n                for(var n = r; n < t; ++n){\n                    f += String.fromCharCode(e[n]);\n                }\n                return f;\n            }\n            function hexSlice(e, r, t) {\n                var f = e.length;\n                if (!r || r < 0) r = 0;\n                if (!t || t < 0 || t > f) t = f;\n                var n = \"\";\n                for(var i = r; i < t; ++i){\n                    n += s[e[i]];\n                }\n                return n;\n            }\n            function utf16leSlice(e, r, t) {\n                var f = e.slice(r, t);\n                var n = \"\";\n                for(var i = 0; i < f.length; i += 2){\n                    n += String.fromCharCode(f[i] + f[i + 1] * 256);\n                }\n                return n;\n            }\n            Buffer.prototype.slice = function slice(e, r) {\n                var t = this.length;\n                e = ~~e;\n                r = r === undefined ? t : ~~r;\n                if (e < 0) {\n                    e += t;\n                    if (e < 0) e = 0;\n                } else if (e > t) {\n                    e = t;\n                }\n                if (r < 0) {\n                    r += t;\n                    if (r < 0) r = 0;\n                } else if (r > t) {\n                    r = t;\n                }\n                if (r < e) r = e;\n                var f = this.subarray(e, r);\n                Object.setPrototypeOf(f, Buffer.prototype);\n                return f;\n            };\n            function checkOffset(e, r, t) {\n                if (e % 1 !== 0 || e < 0) throw new RangeError(\"offset is not uint\");\n                if (e + r > t) throw new RangeError(\"Trying to access beyond buffer length\");\n            }\n            Buffer.prototype.readUIntLE = function readUIntLE(e, r, t) {\n                e = e >>> 0;\n                r = r >>> 0;\n                if (!t) checkOffset(e, r, this.length);\n                var f = this[e];\n                var n = 1;\n                var i = 0;\n                while(++i < r && (n *= 256)){\n                    f += this[e + i] * n;\n                }\n                return f;\n            };\n            Buffer.prototype.readUIntBE = function readUIntBE(e, r, t) {\n                e = e >>> 0;\n                r = r >>> 0;\n                if (!t) {\n                    checkOffset(e, r, this.length);\n                }\n                var f = this[e + --r];\n                var n = 1;\n                while(r > 0 && (n *= 256)){\n                    f += this[e + --r] * n;\n                }\n                return f;\n            };\n            Buffer.prototype.readUInt8 = function readUInt8(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 1, this.length);\n                return this[e];\n            };\n            Buffer.prototype.readUInt16LE = function readUInt16LE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 2, this.length);\n                return this[e] | this[e + 1] << 8;\n            };\n            Buffer.prototype.readUInt16BE = function readUInt16BE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 2, this.length);\n                return this[e] << 8 | this[e + 1];\n            };\n            Buffer.prototype.readUInt32LE = function readUInt32LE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 4, this.length);\n                return (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;\n            };\n            Buffer.prototype.readUInt32BE = function readUInt32BE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 4, this.length);\n                return this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);\n            };\n            Buffer.prototype.readIntLE = function readIntLE(e, r, t) {\n                e = e >>> 0;\n                r = r >>> 0;\n                if (!t) checkOffset(e, r, this.length);\n                var f = this[e];\n                var n = 1;\n                var i = 0;\n                while(++i < r && (n *= 256)){\n                    f += this[e + i] * n;\n                }\n                n *= 128;\n                if (f >= n) f -= Math.pow(2, 8 * r);\n                return f;\n            };\n            Buffer.prototype.readIntBE = function readIntBE(e, r, t) {\n                e = e >>> 0;\n                r = r >>> 0;\n                if (!t) checkOffset(e, r, this.length);\n                var f = r;\n                var n = 1;\n                var i = this[e + --f];\n                while(f > 0 && (n *= 256)){\n                    i += this[e + --f] * n;\n                }\n                n *= 128;\n                if (i >= n) i -= Math.pow(2, 8 * r);\n                return i;\n            };\n            Buffer.prototype.readInt8 = function readInt8(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 1, this.length);\n                if (!(this[e] & 128)) return this[e];\n                return (255 - this[e] + 1) * -1;\n            };\n            Buffer.prototype.readInt16LE = function readInt16LE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 2, this.length);\n                var t = this[e] | this[e + 1] << 8;\n                return t & 32768 ? t | 4294901760 : t;\n            };\n            Buffer.prototype.readInt16BE = function readInt16BE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 2, this.length);\n                var t = this[e + 1] | this[e] << 8;\n                return t & 32768 ? t | 4294901760 : t;\n            };\n            Buffer.prototype.readInt32LE = function readInt32LE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 4, this.length);\n                return this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;\n            };\n            Buffer.prototype.readInt32BE = function readInt32BE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 4, this.length);\n                return this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];\n            };\n            Buffer.prototype.readFloatLE = function readFloatLE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 4, this.length);\n                return n.read(this, e, true, 23, 4);\n            };\n            Buffer.prototype.readFloatBE = function readFloatBE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 4, this.length);\n                return n.read(this, e, false, 23, 4);\n            };\n            Buffer.prototype.readDoubleLE = function readDoubleLE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 8, this.length);\n                return n.read(this, e, true, 52, 8);\n            };\n            Buffer.prototype.readDoubleBE = function readDoubleBE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 8, this.length);\n                return n.read(this, e, false, 52, 8);\n            };\n            function checkInt(e, r, t, f, n, i) {\n                if (!Buffer.isBuffer(e)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n                if (r > n || r < i) throw new RangeError('\"value\" argument is out of bounds');\n                if (t + f > e.length) throw new RangeError(\"Index out of range\");\n            }\n            Buffer.prototype.writeUIntLE = function writeUIntLE(e, r, t, f) {\n                e = +e;\n                r = r >>> 0;\n                t = t >>> 0;\n                if (!f) {\n                    var n = Math.pow(2, 8 * t) - 1;\n                    checkInt(this, e, r, t, n, 0);\n                }\n                var i = 1;\n                var o = 0;\n                this[r] = e & 255;\n                while(++o < t && (i *= 256)){\n                    this[r + o] = e / i & 255;\n                }\n                return r + t;\n            };\n            Buffer.prototype.writeUIntBE = function writeUIntBE(e, r, t, f) {\n                e = +e;\n                r = r >>> 0;\n                t = t >>> 0;\n                if (!f) {\n                    var n = Math.pow(2, 8 * t) - 1;\n                    checkInt(this, e, r, t, n, 0);\n                }\n                var i = t - 1;\n                var o = 1;\n                this[r + i] = e & 255;\n                while(--i >= 0 && (o *= 256)){\n                    this[r + i] = e / o & 255;\n                }\n                return r + t;\n            };\n            Buffer.prototype.writeUInt8 = function writeUInt8(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 1, 255, 0);\n                this[r] = e & 255;\n                return r + 1;\n            };\n            Buffer.prototype.writeUInt16LE = function writeUInt16LE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 2, 65535, 0);\n                this[r] = e & 255;\n                this[r + 1] = e >>> 8;\n                return r + 2;\n            };\n            Buffer.prototype.writeUInt16BE = function writeUInt16BE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 2, 65535, 0);\n                this[r] = e >>> 8;\n                this[r + 1] = e & 255;\n                return r + 2;\n            };\n            Buffer.prototype.writeUInt32LE = function writeUInt32LE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 4, 4294967295, 0);\n                this[r + 3] = e >>> 24;\n                this[r + 2] = e >>> 16;\n                this[r + 1] = e >>> 8;\n                this[r] = e & 255;\n                return r + 4;\n            };\n            Buffer.prototype.writeUInt32BE = function writeUInt32BE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 4, 4294967295, 0);\n                this[r] = e >>> 24;\n                this[r + 1] = e >>> 16;\n                this[r + 2] = e >>> 8;\n                this[r + 3] = e & 255;\n                return r + 4;\n            };\n            Buffer.prototype.writeIntLE = function writeIntLE(e, r, t, f) {\n                e = +e;\n                r = r >>> 0;\n                if (!f) {\n                    var n = Math.pow(2, 8 * t - 1);\n                    checkInt(this, e, r, t, n - 1, -n);\n                }\n                var i = 0;\n                var o = 1;\n                var u = 0;\n                this[r] = e & 255;\n                while(++i < t && (o *= 256)){\n                    if (e < 0 && u === 0 && this[r + i - 1] !== 0) {\n                        u = 1;\n                    }\n                    this[r + i] = (e / o >> 0) - u & 255;\n                }\n                return r + t;\n            };\n            Buffer.prototype.writeIntBE = function writeIntBE(e, r, t, f) {\n                e = +e;\n                r = r >>> 0;\n                if (!f) {\n                    var n = Math.pow(2, 8 * t - 1);\n                    checkInt(this, e, r, t, n - 1, -n);\n                }\n                var i = t - 1;\n                var o = 1;\n                var u = 0;\n                this[r + i] = e & 255;\n                while(--i >= 0 && (o *= 256)){\n                    if (e < 0 && u === 0 && this[r + i + 1] !== 0) {\n                        u = 1;\n                    }\n                    this[r + i] = (e / o >> 0) - u & 255;\n                }\n                return r + t;\n            };\n            Buffer.prototype.writeInt8 = function writeInt8(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 1, 127, -128);\n                if (e < 0) e = 255 + e + 1;\n                this[r] = e & 255;\n                return r + 1;\n            };\n            Buffer.prototype.writeInt16LE = function writeInt16LE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 2, 32767, -32768);\n                this[r] = e & 255;\n                this[r + 1] = e >>> 8;\n                return r + 2;\n            };\n            Buffer.prototype.writeInt16BE = function writeInt16BE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 2, 32767, -32768);\n                this[r] = e >>> 8;\n                this[r + 1] = e & 255;\n                return r + 2;\n            };\n            Buffer.prototype.writeInt32LE = function writeInt32LE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);\n                this[r] = e & 255;\n                this[r + 1] = e >>> 8;\n                this[r + 2] = e >>> 16;\n                this[r + 3] = e >>> 24;\n                return r + 4;\n            };\n            Buffer.prototype.writeInt32BE = function writeInt32BE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);\n                if (e < 0) e = 4294967295 + e + 1;\n                this[r] = e >>> 24;\n                this[r + 1] = e >>> 16;\n                this[r + 2] = e >>> 8;\n                this[r + 3] = e & 255;\n                return r + 4;\n            };\n            function checkIEEE754(e, r, t, f, n, i) {\n                if (t + f > e.length) throw new RangeError(\"Index out of range\");\n                if (t < 0) throw new RangeError(\"Index out of range\");\n            }\n            function writeFloat(e, r, t, f, i) {\n                r = +r;\n                t = t >>> 0;\n                if (!i) {\n                    checkIEEE754(e, r, t, 4, 34028234663852886e22, -34028234663852886e22);\n                }\n                n.write(e, r, t, f, 23, 4);\n                return t + 4;\n            }\n            Buffer.prototype.writeFloatLE = function writeFloatLE(e, r, t) {\n                return writeFloat(this, e, r, true, t);\n            };\n            Buffer.prototype.writeFloatBE = function writeFloatBE(e, r, t) {\n                return writeFloat(this, e, r, false, t);\n            };\n            function writeDouble(e, r, t, f, i) {\n                r = +r;\n                t = t >>> 0;\n                if (!i) {\n                    checkIEEE754(e, r, t, 8, 17976931348623157e292, -17976931348623157e292);\n                }\n                n.write(e, r, t, f, 52, 8);\n                return t + 8;\n            }\n            Buffer.prototype.writeDoubleLE = function writeDoubleLE(e, r, t) {\n                return writeDouble(this, e, r, true, t);\n            };\n            Buffer.prototype.writeDoubleBE = function writeDoubleBE(e, r, t) {\n                return writeDouble(this, e, r, false, t);\n            };\n            Buffer.prototype.copy = function copy(e, r, t, f) {\n                if (!Buffer.isBuffer(e)) throw new TypeError(\"argument should be a Buffer\");\n                if (!t) t = 0;\n                if (!f && f !== 0) f = this.length;\n                if (r >= e.length) r = e.length;\n                if (!r) r = 0;\n                if (f > 0 && f < t) f = t;\n                if (f === t) return 0;\n                if (e.length === 0 || this.length === 0) return 0;\n                if (r < 0) {\n                    throw new RangeError(\"targetStart out of bounds\");\n                }\n                if (t < 0 || t >= this.length) throw new RangeError(\"Index out of range\");\n                if (f < 0) throw new RangeError(\"sourceEnd out of bounds\");\n                if (f > this.length) f = this.length;\n                if (e.length - r < f - t) {\n                    f = e.length - r + t;\n                }\n                var n = f - t;\n                if (this === e && typeof Uint8Array.prototype.copyWithin === \"function\") {\n                    this.copyWithin(r, t, f);\n                } else if (this === e && t < r && r < f) {\n                    for(var i = n - 1; i >= 0; --i){\n                        e[i + r] = this[i + t];\n                    }\n                } else {\n                    Uint8Array.prototype.set.call(e, this.subarray(t, f), r);\n                }\n                return n;\n            };\n            Buffer.prototype.fill = function fill(e, r, t, f) {\n                if (typeof e === \"string\") {\n                    if (typeof r === \"string\") {\n                        f = r;\n                        r = 0;\n                        t = this.length;\n                    } else if (typeof t === \"string\") {\n                        f = t;\n                        t = this.length;\n                    }\n                    if (f !== undefined && typeof f !== \"string\") {\n                        throw new TypeError(\"encoding must be a string\");\n                    }\n                    if (typeof f === \"string\" && !Buffer.isEncoding(f)) {\n                        throw new TypeError(\"Unknown encoding: \" + f);\n                    }\n                    if (e.length === 1) {\n                        var n = e.charCodeAt(0);\n                        if (f === \"utf8\" && n < 128 || f === \"latin1\") {\n                            e = n;\n                        }\n                    }\n                } else if (typeof e === \"number\") {\n                    e = e & 255;\n                } else if (typeof e === \"boolean\") {\n                    e = Number(e);\n                }\n                if (r < 0 || this.length < r || this.length < t) {\n                    throw new RangeError(\"Out of range index\");\n                }\n                if (t <= r) {\n                    return this;\n                }\n                r = r >>> 0;\n                t = t === undefined ? this.length : t >>> 0;\n                if (!e) e = 0;\n                var i;\n                if (typeof e === \"number\") {\n                    for(i = r; i < t; ++i){\n                        this[i] = e;\n                    }\n                } else {\n                    var o = Buffer.isBuffer(e) ? e : Buffer.from(e, f);\n                    var u = o.length;\n                    if (u === 0) {\n                        throw new TypeError('The value \"' + e + '\" is invalid for argument \"value\"');\n                    }\n                    for(i = 0; i < t - r; ++i){\n                        this[i + r] = o[i % u];\n                    }\n                }\n                return this;\n            };\n            var a = /[^+/0-9A-Za-z-_]/g;\n            function base64clean(e) {\n                e = e.split(\"=\")[0];\n                e = e.trim().replace(a, \"\");\n                if (e.length < 2) return \"\";\n                while(e.length % 4 !== 0){\n                    e = e + \"=\";\n                }\n                return e;\n            }\n            function utf8ToBytes(e, r) {\n                r = r || Infinity;\n                var t;\n                var f = e.length;\n                var n = null;\n                var i = [];\n                for(var o = 0; o < f; ++o){\n                    t = e.charCodeAt(o);\n                    if (t > 55295 && t < 57344) {\n                        if (!n) {\n                            if (t > 56319) {\n                                if ((r -= 3) > -1) i.push(239, 191, 189);\n                                continue;\n                            } else if (o + 1 === f) {\n                                if ((r -= 3) > -1) i.push(239, 191, 189);\n                                continue;\n                            }\n                            n = t;\n                            continue;\n                        }\n                        if (t < 56320) {\n                            if ((r -= 3) > -1) i.push(239, 191, 189);\n                            n = t;\n                            continue;\n                        }\n                        t = (n - 55296 << 10 | t - 56320) + 65536;\n                    } else if (n) {\n                        if ((r -= 3) > -1) i.push(239, 191, 189);\n                    }\n                    n = null;\n                    if (t < 128) {\n                        if ((r -= 1) < 0) break;\n                        i.push(t);\n                    } else if (t < 2048) {\n                        if ((r -= 2) < 0) break;\n                        i.push(t >> 6 | 192, t & 63 | 128);\n                    } else if (t < 65536) {\n                        if ((r -= 3) < 0) break;\n                        i.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);\n                    } else if (t < 1114112) {\n                        if ((r -= 4) < 0) break;\n                        i.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);\n                    } else {\n                        throw new Error(\"Invalid code point\");\n                    }\n                }\n                return i;\n            }\n            function asciiToBytes(e) {\n                var r = [];\n                for(var t = 0; t < e.length; ++t){\n                    r.push(e.charCodeAt(t) & 255);\n                }\n                return r;\n            }\n            function utf16leToBytes(e, r) {\n                var t, f, n;\n                var i = [];\n                for(var o = 0; o < e.length; ++o){\n                    if ((r -= 2) < 0) break;\n                    t = e.charCodeAt(o);\n                    f = t >> 8;\n                    n = t % 256;\n                    i.push(n);\n                    i.push(f);\n                }\n                return i;\n            }\n            function base64ToBytes(e) {\n                return f.toByteArray(base64clean(e));\n            }\n            function blitBuffer(e, r, t, f) {\n                for(var n = 0; n < f; ++n){\n                    if (n + t >= r.length || n >= e.length) break;\n                    r[n + t] = e[n];\n                }\n                return n;\n            }\n            function isInstance(e, r) {\n                return e instanceof r || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === r.name;\n            }\n            function numberIsNaN(e) {\n                return e !== e;\n            }\n            var s = function() {\n                var e = \"0123456789abcdef\";\n                var r = new Array(256);\n                for(var t = 0; t < 16; ++t){\n                    var f = t * 16;\n                    for(var n = 0; n < 16; ++n){\n                        r[f + n] = e[t] + e[n];\n                    }\n                }\n                return r;\n            }();\n        },\n        783: function(e, r) {\n            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ r.read = function(e, r, t, f, n) {\n                var i, o;\n                var u = n * 8 - f - 1;\n                var a = (1 << u) - 1;\n                var s = a >> 1;\n                var h = -7;\n                var c = t ? n - 1 : 0;\n                var l = t ? -1 : 1;\n                var p = e[r + c];\n                c += l;\n                i = p & (1 << -h) - 1;\n                p >>= -h;\n                h += u;\n                for(; h > 0; i = i * 256 + e[r + c], c += l, h -= 8){}\n                o = i & (1 << -h) - 1;\n                i >>= -h;\n                h += f;\n                for(; h > 0; o = o * 256 + e[r + c], c += l, h -= 8){}\n                if (i === 0) {\n                    i = 1 - s;\n                } else if (i === a) {\n                    return o ? NaN : (p ? -1 : 1) * Infinity;\n                } else {\n                    o = o + Math.pow(2, f);\n                    i = i - s;\n                }\n                return (p ? -1 : 1) * o * Math.pow(2, i - f);\n            };\n            r.write = function(e, r, t, f, n, i) {\n                var o, u, a;\n                var s = i * 8 - n - 1;\n                var h = (1 << s) - 1;\n                var c = h >> 1;\n                var l = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n                var p = f ? 0 : i - 1;\n                var y = f ? 1 : -1;\n                var g = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;\n                r = Math.abs(r);\n                if (isNaN(r) || r === Infinity) {\n                    u = isNaN(r) ? 1 : 0;\n                    o = h;\n                } else {\n                    o = Math.floor(Math.log(r) / Math.LN2);\n                    if (r * (a = Math.pow(2, -o)) < 1) {\n                        o--;\n                        a *= 2;\n                    }\n                    if (o + c >= 1) {\n                        r += l / a;\n                    } else {\n                        r += l * Math.pow(2, 1 - c);\n                    }\n                    if (r * a >= 2) {\n                        o++;\n                        a /= 2;\n                    }\n                    if (o + c >= h) {\n                        u = 0;\n                        o = h;\n                    } else if (o + c >= 1) {\n                        u = (r * a - 1) * Math.pow(2, n);\n                        o = o + c;\n                    } else {\n                        u = r * Math.pow(2, c - 1) * Math.pow(2, n);\n                        o = 0;\n                    }\n                }\n                for(; n >= 8; e[t + p] = u & 255, p += y, u /= 256, n -= 8){}\n                o = o << n | u;\n                s += n;\n                for(; s > 0; e[t + p] = o & 255, p += y, o /= 256, s -= 8){}\n                e[t + p - y] |= g * 128;\n            };\n        }\n    };\n    var r = {};\n    function __nccwpck_require__(t) {\n        var f = r[t];\n        if (f !== undefined) {\n            return f.exports;\n        }\n        var n = r[t] = {\n            exports: {}\n        };\n        var i = true;\n        try {\n            e[t](n, n.exports, __nccwpck_require__);\n            i = false;\n        } finally{\n            if (i) delete r[t];\n        }\n        return n.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var t = __nccwpck_require__(72);\n    module.exports = t;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUM7SUFBVyxJQUFJQSxJQUFFO1FBQUMsS0FBSSxTQUFTQSxDQUFDLEVBQUNDLENBQUM7WUFBRTtZQUFhQSxFQUFFQyxVQUFVLEdBQUNBO1lBQVdELEVBQUVFLFdBQVcsR0FBQ0E7WUFBWUYsRUFBRUcsYUFBYSxHQUFDQTtZQUFjLElBQUlDLElBQUUsRUFBRTtZQUFDLElBQUlDLElBQUUsRUFBRTtZQUFDLElBQUlDLElBQUUsT0FBT0MsZUFBYSxjQUFZQSxhQUFXQztZQUFNLElBQUlDLElBQUU7WUFBbUUsSUFBSSxJQUFJQyxJQUFFLEdBQUVDLElBQUVGLEVBQUVHLE1BQU0sRUFBQ0YsSUFBRUMsR0FBRSxFQUFFRCxFQUFFO2dCQUFDTixDQUFDLENBQUNNLEVBQUUsR0FBQ0QsQ0FBQyxDQUFDQyxFQUFFO2dCQUFDTCxDQUFDLENBQUNJLEVBQUVJLFVBQVUsQ0FBQ0gsR0FBRyxHQUFDQTtZQUFDO1lBQUNMLENBQUMsQ0FBQyxJQUFJUSxVQUFVLENBQUMsR0FBRyxHQUFDO1lBQUdSLENBQUMsQ0FBQyxJQUFJUSxVQUFVLENBQUMsR0FBRyxHQUFDO1lBQUcsU0FBU0MsUUFBUWYsQ0FBQztnQkFBRSxJQUFJQyxJQUFFRCxFQUFFYSxNQUFNO2dCQUFDLElBQUdaLElBQUUsSUFBRSxHQUFFO29CQUFDLE1BQU0sSUFBSWUsTUFBTTtnQkFBaUQ7Z0JBQUMsSUFBSVgsSUFBRUwsRUFBRWlCLE9BQU8sQ0FBQztnQkFBSyxJQUFHWixNQUFJLENBQUMsR0FBRUEsSUFBRUo7Z0JBQUUsSUFBSUssSUFBRUQsTUFBSUosSUFBRSxJQUFFLElBQUVJLElBQUU7Z0JBQUUsT0FBTTtvQkFBQ0E7b0JBQUVDO2lCQUFFO1lBQUE7WUFBQyxTQUFTSixXQUFXRixDQUFDO2dCQUFFLElBQUlDLElBQUVjLFFBQVFmO2dCQUFHLElBQUlLLElBQUVKLENBQUMsQ0FBQyxFQUFFO2dCQUFDLElBQUlLLElBQUVMLENBQUMsQ0FBQyxFQUFFO2dCQUFDLE9BQU0sQ0FBQ0ksSUFBRUMsQ0FBQUEsSUFBRyxJQUFFLElBQUVBO1lBQUM7WUFBQyxTQUFTWSxZQUFZbEIsQ0FBQyxFQUFDQyxDQUFDLEVBQUNJLENBQUM7Z0JBQUUsT0FBTSxDQUFDSixJQUFFSSxDQUFBQSxJQUFHLElBQUUsSUFBRUE7WUFBQztZQUFDLFNBQVNGLFlBQVlILENBQUM7Z0JBQUUsSUFBSUM7Z0JBQUUsSUFBSUksSUFBRVUsUUFBUWY7Z0JBQUcsSUFBSVUsSUFBRUwsQ0FBQyxDQUFDLEVBQUU7Z0JBQUMsSUFBSU0sSUFBRU4sQ0FBQyxDQUFDLEVBQUU7Z0JBQUMsSUFBSU8sSUFBRSxJQUFJTCxFQUFFVyxZQUFZbEIsR0FBRVUsR0FBRUM7Z0JBQUksSUFBSVEsSUFBRTtnQkFBRSxJQUFJQyxJQUFFVCxJQUFFLElBQUVELElBQUUsSUFBRUE7Z0JBQUUsSUFBSVc7Z0JBQUUsSUFBSUEsSUFBRSxHQUFFQSxJQUFFRCxHQUFFQyxLQUFHLEVBQUU7b0JBQUNwQixJQUFFSyxDQUFDLENBQUNOLEVBQUVjLFVBQVUsQ0FBQ08sR0FBRyxJQUFFLEtBQUdmLENBQUMsQ0FBQ04sRUFBRWMsVUFBVSxDQUFDTyxJQUFFLEdBQUcsSUFBRSxLQUFHZixDQUFDLENBQUNOLEVBQUVjLFVBQVUsQ0FBQ08sSUFBRSxHQUFHLElBQUUsSUFBRWYsQ0FBQyxDQUFDTixFQUFFYyxVQUFVLENBQUNPLElBQUUsR0FBRztvQkFBQ1QsQ0FBQyxDQUFDTyxJQUFJLEdBQUNsQixLQUFHLEtBQUc7b0JBQUlXLENBQUMsQ0FBQ08sSUFBSSxHQUFDbEIsS0FBRyxJQUFFO29CQUFJVyxDQUFDLENBQUNPLElBQUksR0FBQ2xCLElBQUU7Z0JBQUc7Z0JBQUMsSUFBR1UsTUFBSSxHQUFFO29CQUFDVixJQUFFSyxDQUFDLENBQUNOLEVBQUVjLFVBQVUsQ0FBQ08sR0FBRyxJQUFFLElBQUVmLENBQUMsQ0FBQ04sRUFBRWMsVUFBVSxDQUFDTyxJQUFFLEdBQUcsSUFBRTtvQkFBRVQsQ0FBQyxDQUFDTyxJQUFJLEdBQUNsQixJQUFFO2dCQUFHO2dCQUFDLElBQUdVLE1BQUksR0FBRTtvQkFBQ1YsSUFBRUssQ0FBQyxDQUFDTixFQUFFYyxVQUFVLENBQUNPLEdBQUcsSUFBRSxLQUFHZixDQUFDLENBQUNOLEVBQUVjLFVBQVUsQ0FBQ08sSUFBRSxHQUFHLElBQUUsSUFBRWYsQ0FBQyxDQUFDTixFQUFFYyxVQUFVLENBQUNPLElBQUUsR0FBRyxJQUFFO29CQUFFVCxDQUFDLENBQUNPLElBQUksR0FBQ2xCLEtBQUcsSUFBRTtvQkFBSVcsQ0FBQyxDQUFDTyxJQUFJLEdBQUNsQixJQUFFO2dCQUFHO2dCQUFDLE9BQU9XO1lBQUM7WUFBQyxTQUFTVSxnQkFBZ0J0QixDQUFDO2dCQUFFLE9BQU9LLENBQUMsQ0FBQ0wsS0FBRyxLQUFHLEdBQUcsR0FBQ0ssQ0FBQyxDQUFDTCxLQUFHLEtBQUcsR0FBRyxHQUFDSyxDQUFDLENBQUNMLEtBQUcsSUFBRSxHQUFHLEdBQUNLLENBQUMsQ0FBQ0wsSUFBRSxHQUFHO1lBQUE7WUFBQyxTQUFTdUIsWUFBWXZCLENBQUMsRUFBQ0MsQ0FBQyxFQUFDSSxDQUFDO2dCQUFFLElBQUlDO2dCQUFFLElBQUlDLElBQUUsRUFBRTtnQkFBQyxJQUFJLElBQUlHLElBQUVULEdBQUVTLElBQUVMLEdBQUVLLEtBQUcsRUFBRTtvQkFBQ0osSUFBRSxDQUFDTixDQUFDLENBQUNVLEVBQUUsSUFBRSxLQUFHLFFBQU8sSUFBSVYsQ0FBQUEsQ0FBQyxDQUFDVSxJQUFFLEVBQUUsSUFBRSxJQUFFLEtBQUksSUFBSVYsQ0FBQUEsQ0FBQyxDQUFDVSxJQUFFLEVBQUUsR0FBQyxHQUFFO29CQUFHSCxFQUFFaUIsSUFBSSxDQUFDRixnQkFBZ0JoQjtnQkFBRztnQkFBQyxPQUFPQyxFQUFFa0IsSUFBSSxDQUFDO1lBQUc7WUFBQyxTQUFTckIsY0FBY0osQ0FBQztnQkFBRSxJQUFJQztnQkFBRSxJQUFJSyxJQUFFTixFQUFFYSxNQUFNO2dCQUFDLElBQUlOLElBQUVELElBQUU7Z0JBQUUsSUFBSUksSUFBRSxFQUFFO2dCQUFDLElBQUlDLElBQUU7Z0JBQU0sSUFBSSxJQUFJQyxJQUFFLEdBQUVPLElBQUViLElBQUVDLEdBQUVLLElBQUVPLEdBQUVQLEtBQUdELEVBQUU7b0JBQUNELEVBQUVjLElBQUksQ0FBQ0QsWUFBWXZCLEdBQUVZLEdBQUVBLElBQUVELElBQUVRLElBQUVBLElBQUVQLElBQUVEO2dCQUFHO2dCQUFDLElBQUdKLE1BQUksR0FBRTtvQkFBQ04sSUFBRUQsQ0FBQyxDQUFDTSxJQUFFLEVBQUU7b0JBQUNJLEVBQUVjLElBQUksQ0FBQ25CLENBQUMsQ0FBQ0osS0FBRyxFQUFFLEdBQUNJLENBQUMsQ0FBQ0osS0FBRyxJQUFFLEdBQUcsR0FBQztnQkFBSyxPQUFNLElBQUdNLE1BQUksR0FBRTtvQkFBQ04sSUFBRSxDQUFDRCxDQUFDLENBQUNNLElBQUUsRUFBRSxJQUFFLEtBQUdOLENBQUMsQ0FBQ00sSUFBRSxFQUFFO29CQUFDSSxFQUFFYyxJQUFJLENBQUNuQixDQUFDLENBQUNKLEtBQUcsR0FBRyxHQUFDSSxDQUFDLENBQUNKLEtBQUcsSUFBRSxHQUFHLEdBQUNJLENBQUMsQ0FBQ0osS0FBRyxJQUFFLEdBQUcsR0FBQztnQkFBSTtnQkFBQyxPQUFPUyxFQUFFZSxJQUFJLENBQUM7WUFBRztRQUFDO1FBQUUsSUFBRyxTQUFTekIsQ0FBQyxFQUFDQyxDQUFDLEVBQUNJLENBQUM7WUFBRTtZQUM5ckQ7Ozs7O0NBS0MsR0FBRSxJQUFJQyxJQUFFRCxFQUFFO1lBQUssSUFBSUUsSUFBRUYsRUFBRTtZQUFLLElBQUlLLElBQUUsT0FBT2dCLFdBQVMsY0FBWSxPQUFPQSxPQUFPQyxHQUFHLEtBQUcsYUFBV0QsT0FBT0MsR0FBRyxDQUFDLGdDQUE4QjtZQUFLMUIsRUFBRTJCLE1BQU0sR0FBQ0E7WUFBTzNCLEVBQUU0QixVQUFVLEdBQUNBO1lBQVc1QixFQUFFNkIsaUJBQWlCLEdBQUM7WUFBRyxJQUFJbkIsSUFBRTtZQUFXVixFQUFFOEIsVUFBVSxHQUFDcEI7WUFBRWlCLE9BQU9JLG1CQUFtQixHQUFDQztZQUFvQixJQUFHLENBQUNMLE9BQU9JLG1CQUFtQixJQUFFLE9BQU9FLFlBQVUsZUFBYSxPQUFPQSxRQUFRQyxLQUFLLEtBQUcsWUFBVztnQkFBQ0QsUUFBUUMsS0FBSyxDQUFDLDhFQUE0RTtZQUF1RTtZQUFDLFNBQVNGO2dCQUFvQixJQUFHO29CQUFDLElBQUlqQyxJQUFFLElBQUlRLFdBQVc7b0JBQUcsSUFBSVAsSUFBRTt3QkFBQ21DLEtBQUk7NEJBQVcsT0FBTzt3QkFBRTtvQkFBQztvQkFBRUMsT0FBT0MsY0FBYyxDQUFDckMsR0FBRU8sV0FBVytCLFNBQVM7b0JBQUVGLE9BQU9DLGNBQWMsQ0FBQ3RDLEdBQUVDO29CQUFHLE9BQU9ELEVBQUVvQyxHQUFHLE9BQUs7Z0JBQUUsRUFBQyxPQUFNcEMsR0FBRTtvQkFBQyxPQUFPO2dCQUFLO1lBQUM7WUFBQ3FDLE9BQU9HLGNBQWMsQ0FBQ1osT0FBT1csU0FBUyxFQUFDLFVBQVM7Z0JBQUNFLFlBQVc7Z0JBQUtDLEtBQUk7b0JBQVcsSUFBRyxDQUFDZCxPQUFPZSxRQUFRLENBQUMsSUFBSSxHQUFFLE9BQU9DO29CQUFVLE9BQU8sSUFBSSxDQUFDQyxNQUFNO2dCQUFBO1lBQUM7WUFBR1IsT0FBT0csY0FBYyxDQUFDWixPQUFPVyxTQUFTLEVBQUMsVUFBUztnQkFBQ0UsWUFBVztnQkFBS0MsS0FBSTtvQkFBVyxJQUFHLENBQUNkLE9BQU9lLFFBQVEsQ0FBQyxJQUFJLEdBQUUsT0FBT0M7b0JBQVUsT0FBTyxJQUFJLENBQUNFLFVBQVU7Z0JBQUE7WUFBQztZQUFHLFNBQVNDLGFBQWEvQyxDQUFDO2dCQUFFLElBQUdBLElBQUVXLEdBQUU7b0JBQUMsTUFBTSxJQUFJcUMsV0FBVyxnQkFBY2hELElBQUU7Z0JBQWlDO2dCQUFDLElBQUlDLElBQUUsSUFBSU8sV0FBV1I7Z0JBQUdxQyxPQUFPQyxjQUFjLENBQUNyQyxHQUFFMkIsT0FBT1csU0FBUztnQkFBRSxPQUFPdEM7WUFBQztZQUFDLFNBQVMyQixPQUFPNUIsQ0FBQyxFQUFDQyxDQUFDLEVBQUNJLENBQUM7Z0JBQUUsSUFBRyxPQUFPTCxNQUFJLFVBQVM7b0JBQUMsSUFBRyxPQUFPQyxNQUFJLFVBQVM7d0JBQUMsTUFBTSxJQUFJZ0QsVUFBVTtvQkFBcUU7b0JBQUMsT0FBT0MsWUFBWWxEO2dCQUFFO2dCQUFDLE9BQU9tRCxLQUFLbkQsR0FBRUMsR0FBRUk7WUFBRTtZQUFDdUIsT0FBT3dCLFFBQVEsR0FBQztZQUFLLFNBQVNELEtBQUtuRCxDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQztnQkFBRSxJQUFHLE9BQU9MLE1BQUksVUFBUztvQkFBQyxPQUFPcUQsV0FBV3JELEdBQUVDO2dCQUFFO2dCQUFDLElBQUdxRCxZQUFZQyxNQUFNLENBQUN2RCxJQUFHO29CQUFDLE9BQU93RCxjQUFjeEQ7Z0JBQUU7Z0JBQUMsSUFBR0EsS0FBRyxNQUFLO29CQUFDLE1BQU0sSUFBSWlELFVBQVUsZ0ZBQThFLHlDQUF1QyxPQUFPakQ7Z0JBQUU7Z0JBQUMsSUFBR3lELFdBQVd6RCxHQUFFc0QsZ0JBQWN0RCxLQUFHeUQsV0FBV3pELEVBQUU2QyxNQUFNLEVBQUNTLGNBQWE7b0JBQUMsT0FBT0ksZ0JBQWdCMUQsR0FBRUMsR0FBRUk7Z0JBQUU7Z0JBQUMsSUFBRyxPQUFPc0Qsc0JBQW9CLGVBQWNGLENBQUFBLFdBQVd6RCxHQUFFMkQsc0JBQW9CM0QsS0FBR3lELFdBQVd6RCxFQUFFNkMsTUFBTSxFQUFDYyxrQkFBaUIsR0FBRztvQkFBQyxPQUFPRCxnQkFBZ0IxRCxHQUFFQyxHQUFFSTtnQkFBRTtnQkFBQyxJQUFHLE9BQU9MLE1BQUksVUFBUztvQkFBQyxNQUFNLElBQUlpRCxVQUFVO2dCQUF3RTtnQkFBQyxJQUFJM0MsSUFBRU4sRUFBRTRELE9BQU8sSUFBRTVELEVBQUU0RCxPQUFPO2dCQUFHLElBQUd0RCxLQUFHLFFBQU1BLE1BQUlOLEdBQUU7b0JBQUMsT0FBTzRCLE9BQU91QixJQUFJLENBQUM3QyxHQUFFTCxHQUFFSTtnQkFBRTtnQkFBQyxJQUFJRSxJQUFFc0QsV0FBVzdEO2dCQUFHLElBQUdPLEdBQUUsT0FBT0E7Z0JBQUUsSUFBRyxPQUFPbUIsV0FBUyxlQUFhQSxPQUFPb0MsV0FBVyxJQUFFLFFBQU0sT0FBTzlELENBQUMsQ0FBQzBCLE9BQU9vQyxXQUFXLENBQUMsS0FBRyxZQUFXO29CQUFDLE9BQU9sQyxPQUFPdUIsSUFBSSxDQUFDbkQsQ0FBQyxDQUFDMEIsT0FBT29DLFdBQVcsQ0FBQyxDQUFDLFdBQVU3RCxHQUFFSTtnQkFBRTtnQkFBQyxNQUFNLElBQUk0QyxVQUFVLGdGQUE4RSx5Q0FBdUMsT0FBT2pEO1lBQUU7WUFBQzRCLE9BQU91QixJQUFJLEdBQUMsU0FBU25ELENBQUMsRUFBQ0MsQ0FBQyxFQUFDSSxDQUFDO2dCQUFFLE9BQU84QyxLQUFLbkQsR0FBRUMsR0FBRUk7WUFBRTtZQUFFZ0MsT0FBT0MsY0FBYyxDQUFDVixPQUFPVyxTQUFTLEVBQUMvQixXQUFXK0IsU0FBUztZQUFFRixPQUFPQyxjQUFjLENBQUNWLFFBQU9wQjtZQUFZLFNBQVN1RCxXQUFXL0QsQ0FBQztnQkFBRSxJQUFHLE9BQU9BLE1BQUksVUFBUztvQkFBQyxNQUFNLElBQUlpRCxVQUFVO2dCQUF5QyxPQUFNLElBQUdqRCxJQUFFLEdBQUU7b0JBQUMsTUFBTSxJQUFJZ0QsV0FBVyxnQkFBY2hELElBQUU7Z0JBQWlDO1lBQUM7WUFBQyxTQUFTZ0UsTUFBTWhFLENBQUMsRUFBQ0MsQ0FBQyxFQUFDSSxDQUFDO2dCQUFFMEQsV0FBVy9EO2dCQUFHLElBQUdBLEtBQUcsR0FBRTtvQkFBQyxPQUFPK0MsYUFBYS9DO2dCQUFFO2dCQUFDLElBQUdDLE1BQUkyQyxXQUFVO29CQUFDLE9BQU8sT0FBT3ZDLE1BQUksV0FBUzBDLGFBQWEvQyxHQUFHaUUsSUFBSSxDQUFDaEUsR0FBRUksS0FBRzBDLGFBQWEvQyxHQUFHaUUsSUFBSSxDQUFDaEU7Z0JBQUU7Z0JBQUMsT0FBTzhDLGFBQWEvQztZQUFFO1lBQUM0QixPQUFPb0MsS0FBSyxHQUFDLFNBQVNoRSxDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQztnQkFBRSxPQUFPMkQsTUFBTWhFLEdBQUVDLEdBQUVJO1lBQUU7WUFBRSxTQUFTNkMsWUFBWWxELENBQUM7Z0JBQUUrRCxXQUFXL0Q7Z0JBQUcsT0FBTytDLGFBQWEvQyxJQUFFLElBQUUsSUFBRWtFLFFBQVFsRSxLQUFHO1lBQUU7WUFBQzRCLE9BQU9zQixXQUFXLEdBQUMsU0FBU2xELENBQUM7Z0JBQUUsT0FBT2tELFlBQVlsRDtZQUFFO1lBQUU0QixPQUFPdUMsZUFBZSxHQUFDLFNBQVNuRSxDQUFDO2dCQUFFLE9BQU9rRCxZQUFZbEQ7WUFBRTtZQUFFLFNBQVNxRCxXQUFXckQsQ0FBQyxFQUFDQyxDQUFDO2dCQUFFLElBQUcsT0FBT0EsTUFBSSxZQUFVQSxNQUFJLElBQUc7b0JBQUNBLElBQUU7Z0JBQU07Z0JBQUMsSUFBRyxDQUFDMkIsT0FBT3dDLFVBQVUsQ0FBQ25FLElBQUc7b0JBQUMsTUFBTSxJQUFJZ0QsVUFBVSx1QkFBcUJoRDtnQkFBRTtnQkFBQyxJQUFJSSxJQUFFSCxXQUFXRixHQUFFQyxLQUFHO2dCQUFFLElBQUlLLElBQUV5QyxhQUFhMUM7Z0JBQUcsSUFBSUUsSUFBRUQsRUFBRStELEtBQUssQ0FBQ3JFLEdBQUVDO2dCQUFHLElBQUdNLE1BQUlGLEdBQUU7b0JBQUNDLElBQUVBLEVBQUVnRSxLQUFLLENBQUMsR0FBRS9EO2dCQUFFO2dCQUFDLE9BQU9EO1lBQUM7WUFBQyxTQUFTa0QsY0FBY3hELENBQUM7Z0JBQUUsSUFBSUMsSUFBRUQsRUFBRWEsTUFBTSxHQUFDLElBQUUsSUFBRXFELFFBQVFsRSxFQUFFYSxNQUFNLElBQUU7Z0JBQUUsSUFBSVIsSUFBRTBDLGFBQWE5QztnQkFBRyxJQUFJLElBQUlLLElBQUUsR0FBRUEsSUFBRUwsR0FBRUssS0FBRyxFQUFFO29CQUFDRCxDQUFDLENBQUNDLEVBQUUsR0FBQ04sQ0FBQyxDQUFDTSxFQUFFLEdBQUM7Z0JBQUc7Z0JBQUMsT0FBT0Q7WUFBQztZQUFDLFNBQVNxRCxnQkFBZ0IxRCxDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQztnQkFBRSxJQUFHSixJQUFFLEtBQUdELEVBQUVFLFVBQVUsR0FBQ0QsR0FBRTtvQkFBQyxNQUFNLElBQUkrQyxXQUFXO2dCQUF1QztnQkFBQyxJQUFHaEQsRUFBRUUsVUFBVSxHQUFDRCxJQUFHSSxDQUFBQSxLQUFHLElBQUc7b0JBQUMsTUFBTSxJQUFJMkMsV0FBVztnQkFBdUM7Z0JBQUMsSUFBSTFDO2dCQUFFLElBQUdMLE1BQUkyQyxhQUFXdkMsTUFBSXVDLFdBQVU7b0JBQUN0QyxJQUFFLElBQUlFLFdBQVdSO2dCQUFFLE9BQU0sSUFBR0ssTUFBSXVDLFdBQVU7b0JBQUN0QyxJQUFFLElBQUlFLFdBQVdSLEdBQUVDO2dCQUFFLE9BQUs7b0JBQUNLLElBQUUsSUFBSUUsV0FBV1IsR0FBRUMsR0FBRUk7Z0JBQUU7Z0JBQUNnQyxPQUFPQyxjQUFjLENBQUNoQyxHQUFFc0IsT0FBT1csU0FBUztnQkFBRSxPQUFPakM7WUFBQztZQUFDLFNBQVN1RCxXQUFXN0QsQ0FBQztnQkFBRSxJQUFHNEIsT0FBT2UsUUFBUSxDQUFDM0MsSUFBRztvQkFBQyxJQUFJQyxJQUFFaUUsUUFBUWxFLEVBQUVhLE1BQU0sSUFBRTtvQkFBRSxJQUFJUixJQUFFMEMsYUFBYTlDO29CQUFHLElBQUdJLEVBQUVRLE1BQU0sS0FBRyxHQUFFO3dCQUFDLE9BQU9SO29CQUFDO29CQUFDTCxFQUFFdUUsSUFBSSxDQUFDbEUsR0FBRSxHQUFFLEdBQUVKO29CQUFHLE9BQU9JO2dCQUFDO2dCQUFDLElBQUdMLEVBQUVhLE1BQU0sS0FBRytCLFdBQVU7b0JBQUMsSUFBRyxPQUFPNUMsRUFBRWEsTUFBTSxLQUFHLFlBQVUyRCxZQUFZeEUsRUFBRWEsTUFBTSxHQUFFO3dCQUFDLE9BQU9rQyxhQUFhO29CQUFFO29CQUFDLE9BQU9TLGNBQWN4RDtnQkFBRTtnQkFBQyxJQUFHQSxFQUFFeUUsSUFBSSxLQUFHLFlBQVVoRSxNQUFNaUUsT0FBTyxDQUFDMUUsRUFBRTJFLElBQUksR0FBRTtvQkFBQyxPQUFPbkIsY0FBY3hELEVBQUUyRSxJQUFJO2dCQUFDO1lBQUM7WUFBQyxTQUFTVCxRQUFRbEUsQ0FBQztnQkFBRSxJQUFHQSxLQUFHVyxHQUFFO29CQUFDLE1BQU0sSUFBSXFDLFdBQVcsb0RBQWtELGFBQVdyQyxFQUFFaUUsUUFBUSxDQUFDLE1BQUk7Z0JBQVM7Z0JBQUMsT0FBTzVFLElBQUU7WUFBQztZQUFDLFNBQVM2QixXQUFXN0IsQ0FBQztnQkFBRSxJQUFHLENBQUNBLEtBQUdBLEdBQUU7b0JBQUNBLElBQUU7Z0JBQUM7Z0JBQUMsT0FBTzRCLE9BQU9vQyxLQUFLLENBQUMsQ0FBQ2hFO1lBQUU7WUFBQzRCLE9BQU9lLFFBQVEsR0FBQyxTQUFTQSxTQUFTM0MsQ0FBQztnQkFBRSxPQUFPQSxLQUFHLFFBQU1BLEVBQUU2RSxTQUFTLEtBQUcsUUFBTTdFLE1BQUk0QixPQUFPVyxTQUFTO1lBQUE7WUFBRVgsT0FBT2tELE9BQU8sR0FBQyxTQUFTQSxRQUFROUUsQ0FBQyxFQUFDQyxDQUFDO2dCQUFFLElBQUd3RCxXQUFXekQsR0FBRVEsYUFBWVIsSUFBRTRCLE9BQU91QixJQUFJLENBQUNuRCxHQUFFQSxFQUFFK0UsTUFBTSxFQUFDL0UsRUFBRUUsVUFBVTtnQkFBRSxJQUFHdUQsV0FBV3hELEdBQUVPLGFBQVlQLElBQUUyQixPQUFPdUIsSUFBSSxDQUFDbEQsR0FBRUEsRUFBRThFLE1BQU0sRUFBQzlFLEVBQUVDLFVBQVU7Z0JBQUUsSUFBRyxDQUFDMEIsT0FBT2UsUUFBUSxDQUFDM0MsTUFBSSxDQUFDNEIsT0FBT2UsUUFBUSxDQUFDMUMsSUFBRztvQkFBQyxNQUFNLElBQUlnRCxVQUFVO2dCQUF3RTtnQkFBQyxJQUFHakQsTUFBSUMsR0FBRSxPQUFPO2dCQUFFLElBQUlJLElBQUVMLEVBQUVhLE1BQU07Z0JBQUMsSUFBSVAsSUFBRUwsRUFBRVksTUFBTTtnQkFBQyxJQUFJLElBQUlOLElBQUUsR0FBRUcsSUFBRXNFLEtBQUtDLEdBQUcsQ0FBQzVFLEdBQUVDLElBQUdDLElBQUVHLEdBQUUsRUFBRUgsRUFBRTtvQkFBQyxJQUFHUCxDQUFDLENBQUNPLEVBQUUsS0FBR04sQ0FBQyxDQUFDTSxFQUFFLEVBQUM7d0JBQUNGLElBQUVMLENBQUMsQ0FBQ08sRUFBRTt3QkFBQ0QsSUFBRUwsQ0FBQyxDQUFDTSxFQUFFO3dCQUFDO29CQUFLO2dCQUFDO2dCQUFDLElBQUdGLElBQUVDLEdBQUUsT0FBTSxDQUFDO2dCQUFFLElBQUdBLElBQUVELEdBQUUsT0FBTztnQkFBRSxPQUFPO1lBQUM7WUFBRXVCLE9BQU93QyxVQUFVLEdBQUMsU0FBU0EsV0FBV3BFLENBQUM7Z0JBQUUsT0FBT2tGLE9BQU9sRixHQUFHbUYsV0FBVztvQkFBSSxLQUFJO29CQUFNLEtBQUk7b0JBQU8sS0FBSTtvQkFBUSxLQUFJO29CQUFRLEtBQUk7b0JBQVMsS0FBSTtvQkFBUyxLQUFJO29CQUFTLEtBQUk7b0JBQU8sS0FBSTtvQkFBUSxLQUFJO29CQUFVLEtBQUk7d0JBQVcsT0FBTztvQkFBSzt3QkFBUSxPQUFPO2dCQUFLO1lBQUM7WUFBRXZELE9BQU93RCxNQUFNLEdBQUMsU0FBU0EsT0FBT3BGLENBQUMsRUFBQ0MsQ0FBQztnQkFBRSxJQUFHLENBQUNRLE1BQU1pRSxPQUFPLENBQUMxRSxJQUFHO29CQUFDLE1BQU0sSUFBSWlELFVBQVU7Z0JBQThDO2dCQUFDLElBQUdqRCxFQUFFYSxNQUFNLEtBQUcsR0FBRTtvQkFBQyxPQUFPZSxPQUFPb0MsS0FBSyxDQUFDO2dCQUFFO2dCQUFDLElBQUkzRDtnQkFBRSxJQUFHSixNQUFJMkMsV0FBVTtvQkFBQzNDLElBQUU7b0JBQUUsSUFBSUksSUFBRSxHQUFFQSxJQUFFTCxFQUFFYSxNQUFNLEVBQUMsRUFBRVIsRUFBRTt3QkFBQ0osS0FBR0QsQ0FBQyxDQUFDSyxFQUFFLENBQUNRLE1BQU07b0JBQUE7Z0JBQUM7Z0JBQUMsSUFBSVAsSUFBRXNCLE9BQU9zQixXQUFXLENBQUNqRDtnQkFBRyxJQUFJTSxJQUFFO2dCQUFFLElBQUlGLElBQUUsR0FBRUEsSUFBRUwsRUFBRWEsTUFBTSxFQUFDLEVBQUVSLEVBQUU7b0JBQUMsSUFBSUssSUFBRVYsQ0FBQyxDQUFDSyxFQUFFO29CQUFDLElBQUdvRCxXQUFXL0MsR0FBRUYsYUFBWTt3QkFBQ0UsSUFBRWtCLE9BQU91QixJQUFJLENBQUN6QztvQkFBRTtvQkFBQyxJQUFHLENBQUNrQixPQUFPZSxRQUFRLENBQUNqQyxJQUFHO3dCQUFDLE1BQU0sSUFBSXVDLFVBQVU7b0JBQThDO29CQUFDdkMsRUFBRTZELElBQUksQ0FBQ2pFLEdBQUVDO29CQUFHQSxLQUFHRyxFQUFFRyxNQUFNO2dCQUFBO2dCQUFDLE9BQU9QO1lBQUM7WUFBRSxTQUFTSixXQUFXRixDQUFDLEVBQUNDLENBQUM7Z0JBQUUsSUFBRzJCLE9BQU9lLFFBQVEsQ0FBQzNDLElBQUc7b0JBQUMsT0FBT0EsRUFBRWEsTUFBTTtnQkFBQTtnQkFBQyxJQUFHeUMsWUFBWUMsTUFBTSxDQUFDdkQsTUFBSXlELFdBQVd6RCxHQUFFc0QsY0FBYTtvQkFBQyxPQUFPdEQsRUFBRUUsVUFBVTtnQkFBQTtnQkFBQyxJQUFHLE9BQU9GLE1BQUksVUFBUztvQkFBQyxNQUFNLElBQUlpRCxVQUFVLCtFQUE2RSxtQkFBaUIsT0FBT2pEO2dCQUFFO2dCQUFDLElBQUlLLElBQUVMLEVBQUVhLE1BQU07Z0JBQUMsSUFBSVAsSUFBRStFLFVBQVV4RSxNQUFNLEdBQUMsS0FBR3dFLFNBQVMsQ0FBQyxFQUFFLEtBQUc7Z0JBQUssSUFBRyxDQUFDL0UsS0FBR0QsTUFBSSxHQUFFLE9BQU87Z0JBQUUsSUFBSUUsSUFBRTtnQkFBTSxPQUFPO29CQUFDLE9BQU9OO3dCQUFHLEtBQUk7d0JBQVEsS0FBSTt3QkFBUyxLQUFJOzRCQUFTLE9BQU9JO3dCQUFFLEtBQUk7d0JBQU8sS0FBSTs0QkFBUSxPQUFPaUYsWUFBWXRGLEdBQUdhLE1BQU07d0JBQUMsS0FBSTt3QkFBTyxLQUFJO3dCQUFRLEtBQUk7d0JBQVUsS0FBSTs0QkFBVyxPQUFPUixJQUFFO3dCQUFFLEtBQUk7NEJBQU0sT0FBT0EsTUFBSTt3QkFBRSxLQUFJOzRCQUFTLE9BQU9rRixjQUFjdkYsR0FBR2EsTUFBTTt3QkFBQzs0QkFBUSxJQUFHTixHQUFFO2dDQUFDLE9BQU9ELElBQUUsQ0FBQyxJQUFFZ0YsWUFBWXRGLEdBQUdhLE1BQU07NEJBQUE7NEJBQUNaLElBQUUsQ0FBQyxLQUFHQSxDQUFBQSxFQUFHa0YsV0FBVzs0QkFBRzVFLElBQUU7b0JBQUk7Z0JBQUM7WUFBQztZQUFDcUIsT0FBTzFCLFVBQVUsR0FBQ0E7WUFBVyxTQUFTc0YsYUFBYXhGLENBQUMsRUFBQ0MsQ0FBQyxFQUFDSSxDQUFDO2dCQUFFLElBQUlDLElBQUU7Z0JBQU0sSUFBR0wsTUFBSTJDLGFBQVczQyxJQUFFLEdBQUU7b0JBQUNBLElBQUU7Z0JBQUM7Z0JBQUMsSUFBR0EsSUFBRSxJQUFJLENBQUNZLE1BQU0sRUFBQztvQkFBQyxPQUFNO2dCQUFFO2dCQUFDLElBQUdSLE1BQUl1QyxhQUFXdkMsSUFBRSxJQUFJLENBQUNRLE1BQU0sRUFBQztvQkFBQ1IsSUFBRSxJQUFJLENBQUNRLE1BQU07Z0JBQUE7Z0JBQUMsSUFBR1IsS0FBRyxHQUFFO29CQUFDLE9BQU07Z0JBQUU7Z0JBQUNBLE9BQUs7Z0JBQUVKLE9BQUs7Z0JBQUUsSUFBR0ksS0FBR0osR0FBRTtvQkFBQyxPQUFNO2dCQUFFO2dCQUFDLElBQUcsQ0FBQ0QsR0FBRUEsSUFBRTtnQkFBTyxNQUFNLEtBQUs7b0JBQUMsT0FBT0E7d0JBQUcsS0FBSTs0QkFBTSxPQUFPeUYsU0FBUyxJQUFJLEVBQUN4RixHQUFFSTt3QkFBRyxLQUFJO3dCQUFPLEtBQUk7NEJBQVEsT0FBT3FGLFVBQVUsSUFBSSxFQUFDekYsR0FBRUk7d0JBQUcsS0FBSTs0QkFBUSxPQUFPc0YsV0FBVyxJQUFJLEVBQUMxRixHQUFFSTt3QkFBRyxLQUFJO3dCQUFTLEtBQUk7NEJBQVMsT0FBT3VGLFlBQVksSUFBSSxFQUFDM0YsR0FBRUk7d0JBQUcsS0FBSTs0QkFBUyxPQUFPd0YsWUFBWSxJQUFJLEVBQUM1RixHQUFFSTt3QkFBRyxLQUFJO3dCQUFPLEtBQUk7d0JBQVEsS0FBSTt3QkFBVSxLQUFJOzRCQUFXLE9BQU95RixhQUFhLElBQUksRUFBQzdGLEdBQUVJO3dCQUFHOzRCQUFRLElBQUdDLEdBQUUsTUFBTSxJQUFJMkMsVUFBVSx1QkFBcUJqRDs0QkFBR0EsSUFBRSxDQUFDQSxJQUFFLEVBQUMsRUFBR21GLFdBQVc7NEJBQUc3RSxJQUFFO29CQUFJO2dCQUFDO1lBQUM7WUFBQ3NCLE9BQU9XLFNBQVMsQ0FBQ3NDLFNBQVMsR0FBQztZQUFLLFNBQVNrQixLQUFLL0YsQ0FBQyxFQUFDQyxDQUFDLEVBQUNJLENBQUM7Z0JBQUUsSUFBSUMsSUFBRU4sQ0FBQyxDQUFDQyxFQUFFO2dCQUFDRCxDQUFDLENBQUNDLEVBQUUsR0FBQ0QsQ0FBQyxDQUFDSyxFQUFFO2dCQUFDTCxDQUFDLENBQUNLLEVBQUUsR0FBQ0M7WUFBQztZQUFDc0IsT0FBT1csU0FBUyxDQUFDeUQsTUFBTSxHQUFDLFNBQVNBO2dCQUFTLElBQUloRyxJQUFFLElBQUksQ0FBQ2EsTUFBTTtnQkFBQyxJQUFHYixJQUFFLE1BQUksR0FBRTtvQkFBQyxNQUFNLElBQUlnRCxXQUFXO2dCQUE0QztnQkFBQyxJQUFJLElBQUkvQyxJQUFFLEdBQUVBLElBQUVELEdBQUVDLEtBQUcsRUFBRTtvQkFBQzhGLEtBQUssSUFBSSxFQUFDOUYsR0FBRUEsSUFBRTtnQkFBRTtnQkFBQyxPQUFPLElBQUk7WUFBQTtZQUFFMkIsT0FBT1csU0FBUyxDQUFDMEQsTUFBTSxHQUFDLFNBQVNBO2dCQUFTLElBQUlqRyxJQUFFLElBQUksQ0FBQ2EsTUFBTTtnQkFBQyxJQUFHYixJQUFFLE1BQUksR0FBRTtvQkFBQyxNQUFNLElBQUlnRCxXQUFXO2dCQUE0QztnQkFBQyxJQUFJLElBQUkvQyxJQUFFLEdBQUVBLElBQUVELEdBQUVDLEtBQUcsRUFBRTtvQkFBQzhGLEtBQUssSUFBSSxFQUFDOUYsR0FBRUEsSUFBRTtvQkFBRzhGLEtBQUssSUFBSSxFQUFDOUYsSUFBRSxHQUFFQSxJQUFFO2dCQUFFO2dCQUFDLE9BQU8sSUFBSTtZQUFBO1lBQUUyQixPQUFPVyxTQUFTLENBQUMyRCxNQUFNLEdBQUMsU0FBU0E7Z0JBQVMsSUFBSWxHLElBQUUsSUFBSSxDQUFDYSxNQUFNO2dCQUFDLElBQUdiLElBQUUsTUFBSSxHQUFFO29CQUFDLE1BQU0sSUFBSWdELFdBQVc7Z0JBQTRDO2dCQUFDLElBQUksSUFBSS9DLElBQUUsR0FBRUEsSUFBRUQsR0FBRUMsS0FBRyxFQUFFO29CQUFDOEYsS0FBSyxJQUFJLEVBQUM5RixHQUFFQSxJQUFFO29CQUFHOEYsS0FBSyxJQUFJLEVBQUM5RixJQUFFLEdBQUVBLElBQUU7b0JBQUc4RixLQUFLLElBQUksRUFBQzlGLElBQUUsR0FBRUEsSUFBRTtvQkFBRzhGLEtBQUssSUFBSSxFQUFDOUYsSUFBRSxHQUFFQSxJQUFFO2dCQUFFO2dCQUFDLE9BQU8sSUFBSTtZQUFBO1lBQUUyQixPQUFPVyxTQUFTLENBQUNxQyxRQUFRLEdBQUMsU0FBU0E7Z0JBQVcsSUFBSTVFLElBQUUsSUFBSSxDQUFDYSxNQUFNO2dCQUFDLElBQUdiLE1BQUksR0FBRSxPQUFNO2dCQUFHLElBQUdxRixVQUFVeEUsTUFBTSxLQUFHLEdBQUUsT0FBTzZFLFVBQVUsSUFBSSxFQUFDLEdBQUUxRjtnQkFBRyxPQUFPd0YsYUFBYVcsS0FBSyxDQUFDLElBQUksRUFBQ2Q7WUFBVTtZQUFFekQsT0FBT1csU0FBUyxDQUFDNkQsY0FBYyxHQUFDeEUsT0FBT1csU0FBUyxDQUFDcUMsUUFBUTtZQUFDaEQsT0FBT1csU0FBUyxDQUFDOEQsTUFBTSxHQUFDLFNBQVNBLE9BQU9yRyxDQUFDO2dCQUFFLElBQUcsQ0FBQzRCLE9BQU9lLFFBQVEsQ0FBQzNDLElBQUcsTUFBTSxJQUFJaUQsVUFBVTtnQkFBNkIsSUFBRyxJQUFJLEtBQUdqRCxHQUFFLE9BQU87Z0JBQUssT0FBTzRCLE9BQU9rRCxPQUFPLENBQUMsSUFBSSxFQUFDOUUsT0FBSztZQUFDO1lBQUU0QixPQUFPVyxTQUFTLENBQUMrRCxPQUFPLEdBQUMsU0FBU0E7Z0JBQVUsSUFBSXRHLElBQUU7Z0JBQUcsSUFBSUssSUFBRUosRUFBRTZCLGlCQUFpQjtnQkFBQzlCLElBQUUsSUFBSSxDQUFDNEUsUUFBUSxDQUFDLE9BQU0sR0FBRXZFLEdBQUdrRyxPQUFPLENBQUMsV0FBVSxPQUFPQyxJQUFJO2dCQUFHLElBQUcsSUFBSSxDQUFDM0YsTUFBTSxHQUFDUixHQUFFTCxLQUFHO2dCQUFRLE9BQU0sYUFBV0EsSUFBRTtZQUFHO1lBQUUsSUFBR1UsR0FBRTtnQkFBQ2tCLE9BQU9XLFNBQVMsQ0FBQzdCLEVBQUUsR0FBQ2tCLE9BQU9XLFNBQVMsQ0FBQytELE9BQU87WUFBQTtZQUFDMUUsT0FBT1csU0FBUyxDQUFDdUMsT0FBTyxHQUFDLFNBQVNBLFFBQVE5RSxDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQyxFQUFDQyxDQUFDLEVBQUNDLENBQUM7Z0JBQUUsSUFBR2tELFdBQVd6RCxHQUFFUSxhQUFZO29CQUFDUixJQUFFNEIsT0FBT3VCLElBQUksQ0FBQ25ELEdBQUVBLEVBQUUrRSxNQUFNLEVBQUMvRSxFQUFFRSxVQUFVO2dCQUFDO2dCQUFDLElBQUcsQ0FBQzBCLE9BQU9lLFFBQVEsQ0FBQzNDLElBQUc7b0JBQUMsTUFBTSxJQUFJaUQsVUFBVSxxRUFBbUUsbUJBQWlCLE9BQU9qRDtnQkFBRTtnQkFBQyxJQUFHQyxNQUFJMkMsV0FBVTtvQkFBQzNDLElBQUU7Z0JBQUM7Z0JBQUMsSUFBR0ksTUFBSXVDLFdBQVU7b0JBQUN2QyxJQUFFTCxJQUFFQSxFQUFFYSxNQUFNLEdBQUM7Z0JBQUM7Z0JBQUMsSUFBR1AsTUFBSXNDLFdBQVU7b0JBQUN0QyxJQUFFO2dCQUFDO2dCQUFDLElBQUdDLE1BQUlxQyxXQUFVO29CQUFDckMsSUFBRSxJQUFJLENBQUNNLE1BQU07Z0JBQUE7Z0JBQUMsSUFBR1osSUFBRSxLQUFHSSxJQUFFTCxFQUFFYSxNQUFNLElBQUVQLElBQUUsS0FBR0MsSUFBRSxJQUFJLENBQUNNLE1BQU0sRUFBQztvQkFBQyxNQUFNLElBQUltQyxXQUFXO2dCQUFxQjtnQkFBQyxJQUFHMUMsS0FBR0MsS0FBR04sS0FBR0ksR0FBRTtvQkFBQyxPQUFPO2dCQUFDO2dCQUFDLElBQUdDLEtBQUdDLEdBQUU7b0JBQUMsT0FBTSxDQUFDO2dCQUFDO2dCQUFDLElBQUdOLEtBQUdJLEdBQUU7b0JBQUMsT0FBTztnQkFBQztnQkFBQ0osT0FBSztnQkFBRUksT0FBSztnQkFBRUMsT0FBSztnQkFBRUMsT0FBSztnQkFBRSxJQUFHLElBQUksS0FBR1AsR0FBRSxPQUFPO2dCQUFFLElBQUlVLElBQUVILElBQUVEO2dCQUFFLElBQUlLLElBQUVOLElBQUVKO2dCQUFFLElBQUlXLElBQUVvRSxLQUFLQyxHQUFHLENBQUN2RSxHQUFFQztnQkFBRyxJQUFJUSxJQUFFLElBQUksQ0FBQ21ELEtBQUssQ0FBQ2hFLEdBQUVDO2dCQUFHLElBQUlhLElBQUVwQixFQUFFc0UsS0FBSyxDQUFDckUsR0FBRUk7Z0JBQUcsSUFBSSxJQUFJZ0IsSUFBRSxHQUFFQSxJQUFFVCxHQUFFLEVBQUVTLEVBQUU7b0JBQUMsSUFBR0YsQ0FBQyxDQUFDRSxFQUFFLEtBQUdELENBQUMsQ0FBQ0MsRUFBRSxFQUFDO3dCQUFDWCxJQUFFUyxDQUFDLENBQUNFLEVBQUU7d0JBQUNWLElBQUVTLENBQUMsQ0FBQ0MsRUFBRTt3QkFBQztvQkFBSztnQkFBQztnQkFBQyxJQUFHWCxJQUFFQyxHQUFFLE9BQU0sQ0FBQztnQkFBRSxJQUFHQSxJQUFFRCxHQUFFLE9BQU87Z0JBQUUsT0FBTztZQUFDO1lBQUUsU0FBUytGLHFCQUFxQnpHLENBQUMsRUFBQ0MsQ0FBQyxFQUFDSSxDQUFDLEVBQUNDLENBQUMsRUFBQ0MsQ0FBQztnQkFBRSxJQUFHUCxFQUFFYSxNQUFNLEtBQUcsR0FBRSxPQUFNLENBQUM7Z0JBQUUsSUFBRyxPQUFPUixNQUFJLFVBQVM7b0JBQUNDLElBQUVEO29CQUFFQSxJQUFFO2dCQUFDLE9BQU0sSUFBR0EsSUFBRSxZQUFXO29CQUFDQSxJQUFFO2dCQUFVLE9BQU0sSUFBR0EsSUFBRSxDQUFDLFlBQVc7b0JBQUNBLElBQUUsQ0FBQztnQkFBVTtnQkFBQ0EsSUFBRSxDQUFDQTtnQkFBRSxJQUFHbUUsWUFBWW5FLElBQUc7b0JBQUNBLElBQUVFLElBQUUsSUFBRVAsRUFBRWEsTUFBTSxHQUFDO2dCQUFDO2dCQUFDLElBQUdSLElBQUUsR0FBRUEsSUFBRUwsRUFBRWEsTUFBTSxHQUFDUjtnQkFBRSxJQUFHQSxLQUFHTCxFQUFFYSxNQUFNLEVBQUM7b0JBQUMsSUFBR04sR0FBRSxPQUFNLENBQUM7eUJBQU9GLElBQUVMLEVBQUVhLE1BQU0sR0FBQztnQkFBQyxPQUFNLElBQUdSLElBQUUsR0FBRTtvQkFBQyxJQUFHRSxHQUFFRixJQUFFO3lCQUFPLE9BQU0sQ0FBQztnQkFBQztnQkFBQyxJQUFHLE9BQU9KLE1BQUksVUFBUztvQkFBQ0EsSUFBRTJCLE9BQU91QixJQUFJLENBQUNsRCxHQUFFSztnQkFBRTtnQkFBQyxJQUFHc0IsT0FBT2UsUUFBUSxDQUFDMUMsSUFBRztvQkFBQyxJQUFHQSxFQUFFWSxNQUFNLEtBQUcsR0FBRTt3QkFBQyxPQUFNLENBQUM7b0JBQUM7b0JBQUMsT0FBTzZGLGFBQWExRyxHQUFFQyxHQUFFSSxHQUFFQyxHQUFFQztnQkFBRSxPQUFNLElBQUcsT0FBT04sTUFBSSxVQUFTO29CQUFDQSxJQUFFQSxJQUFFO29CQUFJLElBQUcsT0FBT08sV0FBVytCLFNBQVMsQ0FBQ3RCLE9BQU8sS0FBRyxZQUFXO3dCQUFDLElBQUdWLEdBQUU7NEJBQUMsT0FBT0MsV0FBVytCLFNBQVMsQ0FBQ3RCLE9BQU8sQ0FBQzBGLElBQUksQ0FBQzNHLEdBQUVDLEdBQUVJO3dCQUFFLE9BQUs7NEJBQUMsT0FBT0csV0FBVytCLFNBQVMsQ0FBQ3FFLFdBQVcsQ0FBQ0QsSUFBSSxDQUFDM0csR0FBRUMsR0FBRUk7d0JBQUU7b0JBQUM7b0JBQUMsT0FBT3FHLGFBQWExRyxHQUFFO3dCQUFDQztxQkFBRSxFQUFDSSxHQUFFQyxHQUFFQztnQkFBRTtnQkFBQyxNQUFNLElBQUkwQyxVQUFVO1lBQXVDO1lBQUMsU0FBU3lELGFBQWExRyxDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQyxFQUFDQyxDQUFDLEVBQUNDLENBQUM7Z0JBQUUsSUFBSUcsSUFBRTtnQkFBRSxJQUFJQyxJQUFFWCxFQUFFYSxNQUFNO2dCQUFDLElBQUlELElBQUVYLEVBQUVZLE1BQU07Z0JBQUMsSUFBR1AsTUFBSXNDLFdBQVU7b0JBQUN0QyxJQUFFNEUsT0FBTzVFLEdBQUc2RSxXQUFXO29CQUFHLElBQUc3RSxNQUFJLFVBQVFBLE1BQUksV0FBU0EsTUFBSSxhQUFXQSxNQUFJLFlBQVc7d0JBQUMsSUFBR04sRUFBRWEsTUFBTSxHQUFDLEtBQUdaLEVBQUVZLE1BQU0sR0FBQyxHQUFFOzRCQUFDLE9BQU0sQ0FBQzt3QkFBQzt3QkFBQ0gsSUFBRTt3QkFBRUMsS0FBRzt3QkFBRUMsS0FBRzt3QkFBRVAsS0FBRztvQkFBQztnQkFBQztnQkFBQyxTQUFTd0csS0FBSzdHLENBQUMsRUFBQ0MsQ0FBQztvQkFBRSxJQUFHUyxNQUFJLEdBQUU7d0JBQUMsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO29CQUFBLE9BQUs7d0JBQUMsT0FBT0QsRUFBRThHLFlBQVksQ0FBQzdHLElBQUVTO29CQUFFO2dCQUFDO2dCQUFDLElBQUlTO2dCQUFFLElBQUdaLEdBQUU7b0JBQUMsSUFBSWEsSUFBRSxDQUFDO29CQUFFLElBQUlELElBQUVkLEdBQUVjLElBQUVSLEdBQUVRLElBQUk7d0JBQUMsSUFBRzBGLEtBQUs3RyxHQUFFbUIsT0FBSzBGLEtBQUs1RyxHQUFFbUIsTUFBSSxDQUFDLElBQUUsSUFBRUQsSUFBRUMsSUFBRzs0QkFBQyxJQUFHQSxNQUFJLENBQUMsR0FBRUEsSUFBRUQ7NEJBQUUsSUFBR0EsSUFBRUMsSUFBRSxNQUFJUixHQUFFLE9BQU9RLElBQUVWO3dCQUFDLE9BQUs7NEJBQUMsSUFBR1UsTUFBSSxDQUFDLEdBQUVELEtBQUdBLElBQUVDOzRCQUFFQSxJQUFFLENBQUM7d0JBQUM7b0JBQUM7Z0JBQUMsT0FBSztvQkFBQyxJQUFHZixJQUFFTyxJQUFFRCxHQUFFTixJQUFFTSxJQUFFQztvQkFBRSxJQUFJTyxJQUFFZCxHQUFFYyxLQUFHLEdBQUVBLElBQUk7d0JBQUMsSUFBSUUsSUFBRTt3QkFBSyxJQUFJLElBQUkwRixJQUFFLEdBQUVBLElBQUVuRyxHQUFFbUcsSUFBSTs0QkFBQyxJQUFHRixLQUFLN0csR0FBRW1CLElBQUU0RixPQUFLRixLQUFLNUcsR0FBRThHLElBQUc7Z0NBQUMxRixJQUFFO2dDQUFNOzRCQUFLO3dCQUFDO3dCQUFDLElBQUdBLEdBQUUsT0FBT0Y7b0JBQUM7Z0JBQUM7Z0JBQUMsT0FBTSxDQUFDO1lBQUM7WUFBQ1MsT0FBT1csU0FBUyxDQUFDeUUsUUFBUSxHQUFDLFNBQVNBLFNBQVNoSCxDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQztnQkFBRSxPQUFPLElBQUksQ0FBQ1ksT0FBTyxDQUFDakIsR0FBRUMsR0FBRUksT0FBSyxDQUFDO1lBQUM7WUFBRXVCLE9BQU9XLFNBQVMsQ0FBQ3RCLE9BQU8sR0FBQyxTQUFTQSxRQUFRakIsQ0FBQyxFQUFDQyxDQUFDLEVBQUNJLENBQUM7Z0JBQUUsT0FBT29HLHFCQUFxQixJQUFJLEVBQUN6RyxHQUFFQyxHQUFFSSxHQUFFO1lBQUs7WUFBRXVCLE9BQU9XLFNBQVMsQ0FBQ3FFLFdBQVcsR0FBQyxTQUFTQSxZQUFZNUcsQ0FBQyxFQUFDQyxDQUFDLEVBQUNJLENBQUM7Z0JBQUUsT0FBT29HLHFCQUFxQixJQUFJLEVBQUN6RyxHQUFFQyxHQUFFSSxHQUFFO1lBQU07WUFBRSxTQUFTNEcsU0FBU2pILENBQUMsRUFBQ0MsQ0FBQyxFQUFDSSxDQUFDLEVBQUNDLENBQUM7Z0JBQUVELElBQUU2RyxPQUFPN0csTUFBSTtnQkFBRSxJQUFJRSxJQUFFUCxFQUFFYSxNQUFNLEdBQUNSO2dCQUFFLElBQUcsQ0FBQ0MsR0FBRTtvQkFBQ0EsSUFBRUM7Z0JBQUMsT0FBSztvQkFBQ0QsSUFBRTRHLE9BQU81RztvQkFBRyxJQUFHQSxJQUFFQyxHQUFFO3dCQUFDRCxJQUFFQztvQkFBQztnQkFBQztnQkFBQyxJQUFJRyxJQUFFVCxFQUFFWSxNQUFNO2dCQUFDLElBQUdQLElBQUVJLElBQUUsR0FBRTtvQkFBQ0osSUFBRUksSUFBRTtnQkFBQztnQkFBQyxJQUFJLElBQUlDLElBQUUsR0FBRUEsSUFBRUwsR0FBRSxFQUFFSyxFQUFFO29CQUFDLElBQUlDLElBQUV1RyxTQUFTbEgsRUFBRW1ILE1BQU0sQ0FBQ3pHLElBQUUsR0FBRSxJQUFHO29CQUFJLElBQUc2RCxZQUFZNUQsSUFBRyxPQUFPRDtvQkFBRVgsQ0FBQyxDQUFDSyxJQUFFTSxFQUFFLEdBQUNDO2dCQUFDO2dCQUFDLE9BQU9EO1lBQUM7WUFBQyxTQUFTMEcsVUFBVXJILENBQUMsRUFBQ0MsQ0FBQyxFQUFDSSxDQUFDLEVBQUNDLENBQUM7Z0JBQUUsT0FBT2dILFdBQVdoQyxZQUFZckYsR0FBRUQsRUFBRWEsTUFBTSxHQUFDUixJQUFHTCxHQUFFSyxHQUFFQztZQUFFO1lBQUMsU0FBU2lILFdBQVd2SCxDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQyxFQUFDQyxDQUFDO2dCQUFFLE9BQU9nSCxXQUFXRSxhQUFhdkgsSUFBR0QsR0FBRUssR0FBRUM7WUFBRTtZQUFDLFNBQVNtSCxZQUFZekgsQ0FBQyxFQUFDQyxDQUFDLEVBQUNJLENBQUMsRUFBQ0MsQ0FBQztnQkFBRSxPQUFPaUgsV0FBV3ZILEdBQUVDLEdBQUVJLEdBQUVDO1lBQUU7WUFBQyxTQUFTb0gsWUFBWTFILENBQUMsRUFBQ0MsQ0FBQyxFQUFDSSxDQUFDLEVBQUNDLENBQUM7Z0JBQUUsT0FBT2dILFdBQVcvQixjQUFjdEYsSUFBR0QsR0FBRUssR0FBRUM7WUFBRTtZQUFDLFNBQVNxSCxVQUFVM0gsQ0FBQyxFQUFDQyxDQUFDLEVBQUNJLENBQUMsRUFBQ0MsQ0FBQztnQkFBRSxPQUFPZ0gsV0FBV00sZUFBZTNILEdBQUVELEVBQUVhLE1BQU0sR0FBQ1IsSUFBR0wsR0FBRUssR0FBRUM7WUFBRTtZQUFDc0IsT0FBT1csU0FBUyxDQUFDOEIsS0FBSyxHQUFDLFNBQVNBLE1BQU1yRSxDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQyxFQUFDQyxDQUFDO2dCQUFFLElBQUdMLE1BQUkyQyxXQUFVO29CQUFDdEMsSUFBRTtvQkFBT0QsSUFBRSxJQUFJLENBQUNRLE1BQU07b0JBQUNaLElBQUU7Z0JBQUMsT0FBTSxJQUFHSSxNQUFJdUMsYUFBVyxPQUFPM0MsTUFBSSxVQUFTO29CQUFDSyxJQUFFTDtvQkFBRUksSUFBRSxJQUFJLENBQUNRLE1BQU07b0JBQUNaLElBQUU7Z0JBQUMsT0FBTSxJQUFHNEgsU0FBUzVILElBQUc7b0JBQUNBLElBQUVBLE1BQUk7b0JBQUUsSUFBRzRILFNBQVN4SCxJQUFHO3dCQUFDQSxJQUFFQSxNQUFJO3dCQUFFLElBQUdDLE1BQUlzQyxXQUFVdEMsSUFBRTtvQkFBTSxPQUFLO3dCQUFDQSxJQUFFRDt3QkFBRUEsSUFBRXVDO29CQUFTO2dCQUFDLE9BQUs7b0JBQUMsTUFBTSxJQUFJNUIsTUFBTTtnQkFBMEU7Z0JBQUMsSUFBSVQsSUFBRSxJQUFJLENBQUNNLE1BQU0sR0FBQ1o7Z0JBQUUsSUFBR0ksTUFBSXVDLGFBQVd2QyxJQUFFRSxHQUFFRixJQUFFRTtnQkFBRSxJQUFHUCxFQUFFYSxNQUFNLEdBQUMsS0FBSVIsQ0FBQUEsSUFBRSxLQUFHSixJQUFFLE1BQUlBLElBQUUsSUFBSSxDQUFDWSxNQUFNLEVBQUM7b0JBQUMsTUFBTSxJQUFJbUMsV0FBVztnQkFBeUM7Z0JBQUMsSUFBRyxDQUFDMUMsR0FBRUEsSUFBRTtnQkFBTyxJQUFJSSxJQUFFO2dCQUFNLE9BQU87b0JBQUMsT0FBT0o7d0JBQUcsS0FBSTs0QkFBTSxPQUFPMkcsU0FBUyxJQUFJLEVBQUNqSCxHQUFFQyxHQUFFSTt3QkFBRyxLQUFJO3dCQUFPLEtBQUk7NEJBQVEsT0FBT2dILFVBQVUsSUFBSSxFQUFDckgsR0FBRUMsR0FBRUk7d0JBQUcsS0FBSTs0QkFBUSxPQUFPa0gsV0FBVyxJQUFJLEVBQUN2SCxHQUFFQyxHQUFFSTt3QkFBRyxLQUFJO3dCQUFTLEtBQUk7NEJBQVMsT0FBT29ILFlBQVksSUFBSSxFQUFDekgsR0FBRUMsR0FBRUk7d0JBQUcsS0FBSTs0QkFBUyxPQUFPcUgsWUFBWSxJQUFJLEVBQUMxSCxHQUFFQyxHQUFFSTt3QkFBRyxLQUFJO3dCQUFPLEtBQUk7d0JBQVEsS0FBSTt3QkFBVSxLQUFJOzRCQUFXLE9BQU9zSCxVQUFVLElBQUksRUFBQzNILEdBQUVDLEdBQUVJO3dCQUFHOzRCQUFRLElBQUdLLEdBQUUsTUFBTSxJQUFJdUMsVUFBVSx1QkFBcUIzQzs0QkFBR0EsSUFBRSxDQUFDLEtBQUdBLENBQUFBLEVBQUc2RSxXQUFXOzRCQUFHekUsSUFBRTtvQkFBSTtnQkFBQztZQUFDO1lBQUVrQixPQUFPVyxTQUFTLENBQUN1RixNQUFNLEdBQUMsU0FBU0E7Z0JBQVMsT0FBTTtvQkFBQ3JELE1BQUs7b0JBQVNFLE1BQUtsRSxNQUFNOEIsU0FBUyxDQUFDK0IsS0FBSyxDQUFDcUMsSUFBSSxDQUFDLElBQUksQ0FBQ29CLElBQUksSUFBRSxJQUFJLEVBQUM7Z0JBQUU7WUFBQztZQUFFLFNBQVNsQyxZQUFZN0YsQ0FBQyxFQUFDQyxDQUFDLEVBQUNJLENBQUM7Z0JBQUUsSUFBR0osTUFBSSxLQUFHSSxNQUFJTCxFQUFFYSxNQUFNLEVBQUM7b0JBQUMsT0FBT1AsRUFBRUYsYUFBYSxDQUFDSjtnQkFBRSxPQUFLO29CQUFDLE9BQU9NLEVBQUVGLGFBQWEsQ0FBQ0osRUFBRXNFLEtBQUssQ0FBQ3JFLEdBQUVJO2dCQUFHO1lBQUM7WUFBQyxTQUFTcUYsVUFBVTFGLENBQUMsRUFBQ0MsQ0FBQyxFQUFDSSxDQUFDO2dCQUFFQSxJQUFFMkUsS0FBS0MsR0FBRyxDQUFDakYsRUFBRWEsTUFBTSxFQUFDUjtnQkFBRyxJQUFJQyxJQUFFLEVBQUU7Z0JBQUMsSUFBSUMsSUFBRU47Z0JBQUUsTUFBTU0sSUFBRUYsRUFBRTtvQkFBQyxJQUFJSyxJQUFFVixDQUFDLENBQUNPLEVBQUU7b0JBQUMsSUFBSUksSUFBRTtvQkFBSyxJQUFJQyxJQUFFRixJQUFFLE1BQUksSUFBRUEsSUFBRSxNQUFJLElBQUVBLElBQUUsTUFBSSxJQUFFO29CQUFFLElBQUdILElBQUVLLEtBQUdQLEdBQUU7d0JBQUMsSUFBSWMsR0FBRUMsR0FBRUMsR0FBRTBGO3dCQUFFLE9BQU9uRzs0QkFBRyxLQUFLO2dDQUFFLElBQUdGLElBQUUsS0FBSTtvQ0FBQ0MsSUFBRUQ7Z0NBQUM7Z0NBQUM7NEJBQU0sS0FBSztnQ0FBRVMsSUFBRW5CLENBQUMsQ0FBQ08sSUFBRSxFQUFFO2dDQUFDLElBQUcsQ0FBQ1ksSUFBRSxHQUFFLE1BQUssS0FBSTtvQ0FBQzRGLElBQUUsQ0FBQ3JHLElBQUUsRUFBQyxLQUFJLElBQUVTLElBQUU7b0NBQUcsSUFBRzRGLElBQUUsS0FBSTt3Q0FBQ3BHLElBQUVvRztvQ0FBQztnQ0FBQztnQ0FBQzs0QkFBTSxLQUFLO2dDQUFFNUYsSUFBRW5CLENBQUMsQ0FBQ08sSUFBRSxFQUFFO2dDQUFDYSxJQUFFcEIsQ0FBQyxDQUFDTyxJQUFFLEVBQUU7Z0NBQUMsSUFBRyxDQUFDWSxJQUFFLEdBQUUsTUFBSyxPQUFLLENBQUNDLElBQUUsR0FBRSxNQUFLLEtBQUk7b0NBQUMyRixJQUFFLENBQUNyRyxJQUFFLEVBQUMsS0FBSSxLQUFHLENBQUNTLElBQUUsRUFBQyxLQUFJLElBQUVDLElBQUU7b0NBQUcsSUFBRzJGLElBQUUsUUFBT0EsQ0FBQUEsSUFBRSxTQUFPQSxJQUFFLEtBQUksR0FBRzt3Q0FBQ3BHLElBQUVvRztvQ0FBQztnQ0FBQztnQ0FBQzs0QkFBTSxLQUFLO2dDQUFFNUYsSUFBRW5CLENBQUMsQ0FBQ08sSUFBRSxFQUFFO2dDQUFDYSxJQUFFcEIsQ0FBQyxDQUFDTyxJQUFFLEVBQUU7Z0NBQUNjLElBQUVyQixDQUFDLENBQUNPLElBQUUsRUFBRTtnQ0FBQyxJQUFHLENBQUNZLElBQUUsR0FBRSxNQUFLLE9BQUssQ0FBQ0MsSUFBRSxHQUFFLE1BQUssT0FBSyxDQUFDQyxJQUFFLEdBQUUsTUFBSyxLQUFJO29DQUFDMEYsSUFBRSxDQUFDckcsSUFBRSxFQUFDLEtBQUksS0FBRyxDQUFDUyxJQUFFLEVBQUMsS0FBSSxLQUFHLENBQUNDLElBQUUsRUFBQyxLQUFJLElBQUVDLElBQUU7b0NBQUcsSUFBRzBGLElBQUUsU0FBT0EsSUFBRSxTQUFRO3dDQUFDcEcsSUFBRW9HO29DQUFDO2dDQUFDO3dCQUFDO29CQUFDO29CQUFDLElBQUdwRyxNQUFJLE1BQUs7d0JBQUNBLElBQUU7d0JBQU1DLElBQUU7b0JBQUMsT0FBTSxJQUFHRCxJQUFFLE9BQU07d0JBQUNBLEtBQUc7d0JBQU1MLEVBQUVrQixJQUFJLENBQUNiLE1BQUksS0FBRyxPQUFLO3dCQUFPQSxJQUFFLFFBQU1BLElBQUU7b0JBQUk7b0JBQUNMLEVBQUVrQixJQUFJLENBQUNiO29CQUFHSixLQUFHSztnQkFBQztnQkFBQyxPQUFPb0gsc0JBQXNCMUg7WUFBRTtZQUFDLElBQUlNLElBQUU7WUFBSyxTQUFTb0gsc0JBQXNCaEksQ0FBQztnQkFBRSxJQUFJQyxJQUFFRCxFQUFFYSxNQUFNO2dCQUFDLElBQUdaLEtBQUdXLEdBQUU7b0JBQUMsT0FBT3NFLE9BQU8rQyxZQUFZLENBQUM5QixLQUFLLENBQUNqQixRQUFPbEY7Z0JBQUU7Z0JBQUMsSUFBSUssSUFBRTtnQkFBRyxJQUFJQyxJQUFFO2dCQUFFLE1BQU1BLElBQUVMLEVBQUU7b0JBQUNJLEtBQUc2RSxPQUFPK0MsWUFBWSxDQUFDOUIsS0FBSyxDQUFDakIsUUFBT2xGLEVBQUVzRSxLQUFLLENBQUNoRSxHQUFFQSxLQUFHTTtnQkFBRztnQkFBQyxPQUFPUDtZQUFDO1lBQUMsU0FBU3NGLFdBQVczRixDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQztnQkFBRSxJQUFJQyxJQUFFO2dCQUFHRCxJQUFFMkUsS0FBS0MsR0FBRyxDQUFDakYsRUFBRWEsTUFBTSxFQUFDUjtnQkFBRyxJQUFJLElBQUlFLElBQUVOLEdBQUVNLElBQUVGLEdBQUUsRUFBRUUsRUFBRTtvQkFBQ0QsS0FBRzRFLE9BQU8rQyxZQUFZLENBQUNqSSxDQUFDLENBQUNPLEVBQUUsR0FBQztnQkFBSTtnQkFBQyxPQUFPRDtZQUFDO1lBQUMsU0FBU3NGLFlBQVk1RixDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQztnQkFBRSxJQUFJQyxJQUFFO2dCQUFHRCxJQUFFMkUsS0FBS0MsR0FBRyxDQUFDakYsRUFBRWEsTUFBTSxFQUFDUjtnQkFBRyxJQUFJLElBQUlFLElBQUVOLEdBQUVNLElBQUVGLEdBQUUsRUFBRUUsRUFBRTtvQkFBQ0QsS0FBRzRFLE9BQU8rQyxZQUFZLENBQUNqSSxDQUFDLENBQUNPLEVBQUU7Z0JBQUM7Z0JBQUMsT0FBT0Q7WUFBQztZQUFDLFNBQVNtRixTQUFTekYsQ0FBQyxFQUFDQyxDQUFDLEVBQUNJLENBQUM7Z0JBQUUsSUFBSUMsSUFBRU4sRUFBRWEsTUFBTTtnQkFBQyxJQUFHLENBQUNaLEtBQUdBLElBQUUsR0FBRUEsSUFBRTtnQkFBRSxJQUFHLENBQUNJLEtBQUdBLElBQUUsS0FBR0EsSUFBRUMsR0FBRUQsSUFBRUM7Z0JBQUUsSUFBSUMsSUFBRTtnQkFBRyxJQUFJLElBQUlHLElBQUVULEdBQUVTLElBQUVMLEdBQUUsRUFBRUssRUFBRTtvQkFBQ0gsS0FBR2EsQ0FBQyxDQUFDcEIsQ0FBQyxDQUFDVSxFQUFFLENBQUM7Z0JBQUE7Z0JBQUMsT0FBT0g7WUFBQztZQUFDLFNBQVN1RixhQUFhOUYsQ0FBQyxFQUFDQyxDQUFDLEVBQUNJLENBQUM7Z0JBQUUsSUFBSUMsSUFBRU4sRUFBRXNFLEtBQUssQ0FBQ3JFLEdBQUVJO2dCQUFHLElBQUlFLElBQUU7Z0JBQUcsSUFBSSxJQUFJRyxJQUFFLEdBQUVBLElBQUVKLEVBQUVPLE1BQU0sRUFBQ0gsS0FBRyxFQUFFO29CQUFDSCxLQUFHMkUsT0FBTytDLFlBQVksQ0FBQzNILENBQUMsQ0FBQ0ksRUFBRSxHQUFDSixDQUFDLENBQUNJLElBQUUsRUFBRSxHQUFDO2dCQUFJO2dCQUFDLE9BQU9IO1lBQUM7WUFBQ3FCLE9BQU9XLFNBQVMsQ0FBQytCLEtBQUssR0FBQyxTQUFTQSxNQUFNdEUsQ0FBQyxFQUFDQyxDQUFDO2dCQUFFLElBQUlJLElBQUUsSUFBSSxDQUFDUSxNQUFNO2dCQUFDYixJQUFFLENBQUMsQ0FBQ0E7Z0JBQUVDLElBQUVBLE1BQUkyQyxZQUFVdkMsSUFBRSxDQUFDLENBQUNKO2dCQUFFLElBQUdELElBQUUsR0FBRTtvQkFBQ0EsS0FBR0s7b0JBQUUsSUFBR0wsSUFBRSxHQUFFQSxJQUFFO2dCQUFDLE9BQU0sSUFBR0EsSUFBRUssR0FBRTtvQkFBQ0wsSUFBRUs7Z0JBQUM7Z0JBQUMsSUFBR0osSUFBRSxHQUFFO29CQUFDQSxLQUFHSTtvQkFBRSxJQUFHSixJQUFFLEdBQUVBLElBQUU7Z0JBQUMsT0FBTSxJQUFHQSxJQUFFSSxHQUFFO29CQUFDSixJQUFFSTtnQkFBQztnQkFBQyxJQUFHSixJQUFFRCxHQUFFQyxJQUFFRDtnQkFBRSxJQUFJTSxJQUFFLElBQUksQ0FBQzRILFFBQVEsQ0FBQ2xJLEdBQUVDO2dCQUFHb0MsT0FBT0MsY0FBYyxDQUFDaEMsR0FBRXNCLE9BQU9XLFNBQVM7Z0JBQUUsT0FBT2pDO1lBQUM7WUFBRSxTQUFTNkgsWUFBWW5JLENBQUMsRUFBQ0MsQ0FBQyxFQUFDSSxDQUFDO2dCQUFFLElBQUdMLElBQUUsTUFBSSxLQUFHQSxJQUFFLEdBQUUsTUFBTSxJQUFJZ0QsV0FBVztnQkFBc0IsSUFBR2hELElBQUVDLElBQUVJLEdBQUUsTUFBTSxJQUFJMkMsV0FBVztZQUF3QztZQUFDcEIsT0FBT1csU0FBUyxDQUFDNkYsVUFBVSxHQUFDLFNBQVNBLFdBQVdwSSxDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQztnQkFBRUwsSUFBRUEsTUFBSTtnQkFBRUMsSUFBRUEsTUFBSTtnQkFBRSxJQUFHLENBQUNJLEdBQUU4SCxZQUFZbkksR0FBRUMsR0FBRSxJQUFJLENBQUNZLE1BQU07Z0JBQUUsSUFBSVAsSUFBRSxJQUFJLENBQUNOLEVBQUU7Z0JBQUMsSUFBSU8sSUFBRTtnQkFBRSxJQUFJRyxJQUFFO2dCQUFFLE1BQU0sRUFBRUEsSUFBRVQsS0FBSU0sQ0FBQUEsS0FBRyxHQUFFLEVBQUc7b0JBQUNELEtBQUcsSUFBSSxDQUFDTixJQUFFVSxFQUFFLEdBQUNIO2dCQUFDO2dCQUFDLE9BQU9EO1lBQUM7WUFBRXNCLE9BQU9XLFNBQVMsQ0FBQzhGLFVBQVUsR0FBQyxTQUFTQSxXQUFXckksQ0FBQyxFQUFDQyxDQUFDLEVBQUNJLENBQUM7Z0JBQUVMLElBQUVBLE1BQUk7Z0JBQUVDLElBQUVBLE1BQUk7Z0JBQUUsSUFBRyxDQUFDSSxHQUFFO29CQUFDOEgsWUFBWW5JLEdBQUVDLEdBQUUsSUFBSSxDQUFDWSxNQUFNO2dCQUFDO2dCQUFDLElBQUlQLElBQUUsSUFBSSxDQUFDTixJQUFFLEVBQUVDLEVBQUU7Z0JBQUMsSUFBSU0sSUFBRTtnQkFBRSxNQUFNTixJQUFFLEtBQUlNLENBQUFBLEtBQUcsR0FBRSxFQUFHO29CQUFDRCxLQUFHLElBQUksQ0FBQ04sSUFBRSxFQUFFQyxFQUFFLEdBQUNNO2dCQUFDO2dCQUFDLE9BQU9EO1lBQUM7WUFBRXNCLE9BQU9XLFNBQVMsQ0FBQytGLFNBQVMsR0FBQyxTQUFTQSxVQUFVdEksQ0FBQyxFQUFDQyxDQUFDO2dCQUFFRCxJQUFFQSxNQUFJO2dCQUFFLElBQUcsQ0FBQ0MsR0FBRWtJLFlBQVluSSxHQUFFLEdBQUUsSUFBSSxDQUFDYSxNQUFNO2dCQUFFLE9BQU8sSUFBSSxDQUFDYixFQUFFO1lBQUE7WUFBRTRCLE9BQU9XLFNBQVMsQ0FBQ2dHLFlBQVksR0FBQyxTQUFTQSxhQUFhdkksQ0FBQyxFQUFDQyxDQUFDO2dCQUFFRCxJQUFFQSxNQUFJO2dCQUFFLElBQUcsQ0FBQ0MsR0FBRWtJLFlBQVluSSxHQUFFLEdBQUUsSUFBSSxDQUFDYSxNQUFNO2dCQUFFLE9BQU8sSUFBSSxDQUFDYixFQUFFLEdBQUMsSUFBSSxDQUFDQSxJQUFFLEVBQUUsSUFBRTtZQUFDO1lBQUU0QixPQUFPVyxTQUFTLENBQUN1RSxZQUFZLEdBQUMsU0FBU0EsYUFBYTlHLENBQUMsRUFBQ0MsQ0FBQztnQkFBRUQsSUFBRUEsTUFBSTtnQkFBRSxJQUFHLENBQUNDLEdBQUVrSSxZQUFZbkksR0FBRSxHQUFFLElBQUksQ0FBQ2EsTUFBTTtnQkFBRSxPQUFPLElBQUksQ0FBQ2IsRUFBRSxJQUFFLElBQUUsSUFBSSxDQUFDQSxJQUFFLEVBQUU7WUFBQTtZQUFFNEIsT0FBT1csU0FBUyxDQUFDaUcsWUFBWSxHQUFDLFNBQVNBLGFBQWF4SSxDQUFDLEVBQUNDLENBQUM7Z0JBQUVELElBQUVBLE1BQUk7Z0JBQUUsSUFBRyxDQUFDQyxHQUFFa0ksWUFBWW5JLEdBQUUsR0FBRSxJQUFJLENBQUNhLE1BQU07Z0JBQUUsT0FBTSxDQUFDLElBQUksQ0FBQ2IsRUFBRSxHQUFDLElBQUksQ0FBQ0EsSUFBRSxFQUFFLElBQUUsSUFBRSxJQUFJLENBQUNBLElBQUUsRUFBRSxJQUFFLEVBQUMsSUFBRyxJQUFJLENBQUNBLElBQUUsRUFBRSxHQUFDO1lBQVE7WUFBRTRCLE9BQU9XLFNBQVMsQ0FBQ2tHLFlBQVksR0FBQyxTQUFTQSxhQUFhekksQ0FBQyxFQUFDQyxDQUFDO2dCQUFFRCxJQUFFQSxNQUFJO2dCQUFFLElBQUcsQ0FBQ0MsR0FBRWtJLFlBQVluSSxHQUFFLEdBQUUsSUFBSSxDQUFDYSxNQUFNO2dCQUFFLE9BQU8sSUFBSSxDQUFDYixFQUFFLEdBQUMsV0FBVSxLQUFJLENBQUNBLElBQUUsRUFBRSxJQUFFLEtBQUcsSUFBSSxDQUFDQSxJQUFFLEVBQUUsSUFBRSxJQUFFLElBQUksQ0FBQ0EsSUFBRSxFQUFFO1lBQUM7WUFBRTRCLE9BQU9XLFNBQVMsQ0FBQ21HLFNBQVMsR0FBQyxTQUFTQSxVQUFVMUksQ0FBQyxFQUFDQyxDQUFDLEVBQUNJLENBQUM7Z0JBQUVMLElBQUVBLE1BQUk7Z0JBQUVDLElBQUVBLE1BQUk7Z0JBQUUsSUFBRyxDQUFDSSxHQUFFOEgsWUFBWW5JLEdBQUVDLEdBQUUsSUFBSSxDQUFDWSxNQUFNO2dCQUFFLElBQUlQLElBQUUsSUFBSSxDQUFDTixFQUFFO2dCQUFDLElBQUlPLElBQUU7Z0JBQUUsSUFBSUcsSUFBRTtnQkFBRSxNQUFNLEVBQUVBLElBQUVULEtBQUlNLENBQUFBLEtBQUcsR0FBRSxFQUFHO29CQUFDRCxLQUFHLElBQUksQ0FBQ04sSUFBRVUsRUFBRSxHQUFDSDtnQkFBQztnQkFBQ0EsS0FBRztnQkFBSSxJQUFHRCxLQUFHQyxHQUFFRCxLQUFHMEUsS0FBSzJELEdBQUcsQ0FBQyxHQUFFLElBQUUxSTtnQkFBRyxPQUFPSztZQUFDO1lBQUVzQixPQUFPVyxTQUFTLENBQUNxRyxTQUFTLEdBQUMsU0FBU0EsVUFBVTVJLENBQUMsRUFBQ0MsQ0FBQyxFQUFDSSxDQUFDO2dCQUFFTCxJQUFFQSxNQUFJO2dCQUFFQyxJQUFFQSxNQUFJO2dCQUFFLElBQUcsQ0FBQ0ksR0FBRThILFlBQVluSSxHQUFFQyxHQUFFLElBQUksQ0FBQ1ksTUFBTTtnQkFBRSxJQUFJUCxJQUFFTDtnQkFBRSxJQUFJTSxJQUFFO2dCQUFFLElBQUlHLElBQUUsSUFBSSxDQUFDVixJQUFFLEVBQUVNLEVBQUU7Z0JBQUMsTUFBTUEsSUFBRSxLQUFJQyxDQUFBQSxLQUFHLEdBQUUsRUFBRztvQkFBQ0csS0FBRyxJQUFJLENBQUNWLElBQUUsRUFBRU0sRUFBRSxHQUFDQztnQkFBQztnQkFBQ0EsS0FBRztnQkFBSSxJQUFHRyxLQUFHSCxHQUFFRyxLQUFHc0UsS0FBSzJELEdBQUcsQ0FBQyxHQUFFLElBQUUxSTtnQkFBRyxPQUFPUztZQUFDO1lBQUVrQixPQUFPVyxTQUFTLENBQUNzRyxRQUFRLEdBQUMsU0FBU0EsU0FBUzdJLENBQUMsRUFBQ0MsQ0FBQztnQkFBRUQsSUFBRUEsTUFBSTtnQkFBRSxJQUFHLENBQUNDLEdBQUVrSSxZQUFZbkksR0FBRSxHQUFFLElBQUksQ0FBQ2EsTUFBTTtnQkFBRSxJQUFHLENBQUUsS0FBSSxDQUFDYixFQUFFLEdBQUMsR0FBRSxHQUFHLE9BQU8sSUFBSSxDQUFDQSxFQUFFO2dCQUFDLE9BQU0sQ0FBQyxNQUFJLElBQUksQ0FBQ0EsRUFBRSxHQUFDLEtBQUcsQ0FBQztZQUFDO1lBQUU0QixPQUFPVyxTQUFTLENBQUN1RyxXQUFXLEdBQUMsU0FBU0EsWUFBWTlJLENBQUMsRUFBQ0MsQ0FBQztnQkFBRUQsSUFBRUEsTUFBSTtnQkFBRSxJQUFHLENBQUNDLEdBQUVrSSxZQUFZbkksR0FBRSxHQUFFLElBQUksQ0FBQ2EsTUFBTTtnQkFBRSxJQUFJUixJQUFFLElBQUksQ0FBQ0wsRUFBRSxHQUFDLElBQUksQ0FBQ0EsSUFBRSxFQUFFLElBQUU7Z0JBQUUsT0FBT0ssSUFBRSxRQUFNQSxJQUFFLGFBQVdBO1lBQUM7WUFBRXVCLE9BQU9XLFNBQVMsQ0FBQ3dHLFdBQVcsR0FBQyxTQUFTQSxZQUFZL0ksQ0FBQyxFQUFDQyxDQUFDO2dCQUFFRCxJQUFFQSxNQUFJO2dCQUFFLElBQUcsQ0FBQ0MsR0FBRWtJLFlBQVluSSxHQUFFLEdBQUUsSUFBSSxDQUFDYSxNQUFNO2dCQUFFLElBQUlSLElBQUUsSUFBSSxDQUFDTCxJQUFFLEVBQUUsR0FBQyxJQUFJLENBQUNBLEVBQUUsSUFBRTtnQkFBRSxPQUFPSyxJQUFFLFFBQU1BLElBQUUsYUFBV0E7WUFBQztZQUFFdUIsT0FBT1csU0FBUyxDQUFDeUcsV0FBVyxHQUFDLFNBQVNBLFlBQVloSixDQUFDLEVBQUNDLENBQUM7Z0JBQUVELElBQUVBLE1BQUk7Z0JBQUUsSUFBRyxDQUFDQyxHQUFFa0ksWUFBWW5JLEdBQUUsR0FBRSxJQUFJLENBQUNhLE1BQU07Z0JBQUUsT0FBTyxJQUFJLENBQUNiLEVBQUUsR0FBQyxJQUFJLENBQUNBLElBQUUsRUFBRSxJQUFFLElBQUUsSUFBSSxDQUFDQSxJQUFFLEVBQUUsSUFBRSxLQUFHLElBQUksQ0FBQ0EsSUFBRSxFQUFFLElBQUU7WUFBRTtZQUFFNEIsT0FBT1csU0FBUyxDQUFDMEcsV0FBVyxHQUFDLFNBQVNBLFlBQVlqSixDQUFDLEVBQUNDLENBQUM7Z0JBQUVELElBQUVBLE1BQUk7Z0JBQUUsSUFBRyxDQUFDQyxHQUFFa0ksWUFBWW5JLEdBQUUsR0FBRSxJQUFJLENBQUNhLE1BQU07Z0JBQUUsT0FBTyxJQUFJLENBQUNiLEVBQUUsSUFBRSxLQUFHLElBQUksQ0FBQ0EsSUFBRSxFQUFFLElBQUUsS0FBRyxJQUFJLENBQUNBLElBQUUsRUFBRSxJQUFFLElBQUUsSUFBSSxDQUFDQSxJQUFFLEVBQUU7WUFBQTtZQUFFNEIsT0FBT1csU0FBUyxDQUFDMkcsV0FBVyxHQUFDLFNBQVNBLFlBQVlsSixDQUFDLEVBQUNDLENBQUM7Z0JBQUVELElBQUVBLE1BQUk7Z0JBQUUsSUFBRyxDQUFDQyxHQUFFa0ksWUFBWW5JLEdBQUUsR0FBRSxJQUFJLENBQUNhLE1BQU07Z0JBQUUsT0FBT04sRUFBRXNHLElBQUksQ0FBQyxJQUFJLEVBQUM3RyxHQUFFLE1BQUssSUFBRztZQUFFO1lBQUU0QixPQUFPVyxTQUFTLENBQUM0RyxXQUFXLEdBQUMsU0FBU0EsWUFBWW5KLENBQUMsRUFBQ0MsQ0FBQztnQkFBRUQsSUFBRUEsTUFBSTtnQkFBRSxJQUFHLENBQUNDLEdBQUVrSSxZQUFZbkksR0FBRSxHQUFFLElBQUksQ0FBQ2EsTUFBTTtnQkFBRSxPQUFPTixFQUFFc0csSUFBSSxDQUFDLElBQUksRUFBQzdHLEdBQUUsT0FBTSxJQUFHO1lBQUU7WUFBRTRCLE9BQU9XLFNBQVMsQ0FBQzZHLFlBQVksR0FBQyxTQUFTQSxhQUFhcEosQ0FBQyxFQUFDQyxDQUFDO2dCQUFFRCxJQUFFQSxNQUFJO2dCQUFFLElBQUcsQ0FBQ0MsR0FBRWtJLFlBQVluSSxHQUFFLEdBQUUsSUFBSSxDQUFDYSxNQUFNO2dCQUFFLE9BQU9OLEVBQUVzRyxJQUFJLENBQUMsSUFBSSxFQUFDN0csR0FBRSxNQUFLLElBQUc7WUFBRTtZQUFFNEIsT0FBT1csU0FBUyxDQUFDOEcsWUFBWSxHQUFDLFNBQVNBLGFBQWFySixDQUFDLEVBQUNDLENBQUM7Z0JBQUVELElBQUVBLE1BQUk7Z0JBQUUsSUFBRyxDQUFDQyxHQUFFa0ksWUFBWW5JLEdBQUUsR0FBRSxJQUFJLENBQUNhLE1BQU07Z0JBQUUsT0FBT04sRUFBRXNHLElBQUksQ0FBQyxJQUFJLEVBQUM3RyxHQUFFLE9BQU0sSUFBRztZQUFFO1lBQUUsU0FBU3NKLFNBQVN0SixDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQyxFQUFDQyxDQUFDLEVBQUNDLENBQUMsRUFBQ0csQ0FBQztnQkFBRSxJQUFHLENBQUNrQixPQUFPZSxRQUFRLENBQUMzQyxJQUFHLE1BQU0sSUFBSWlELFVBQVU7Z0JBQStDLElBQUdoRCxJQUFFTSxLQUFHTixJQUFFUyxHQUFFLE1BQU0sSUFBSXNDLFdBQVc7Z0JBQXFDLElBQUczQyxJQUFFQyxJQUFFTixFQUFFYSxNQUFNLEVBQUMsTUFBTSxJQUFJbUMsV0FBVztZQUFxQjtZQUFDcEIsT0FBT1csU0FBUyxDQUFDZ0gsV0FBVyxHQUFDLFNBQVNBLFlBQVl2SixDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQyxFQUFDQyxDQUFDO2dCQUFFTixJQUFFLENBQUNBO2dCQUFFQyxJQUFFQSxNQUFJO2dCQUFFSSxJQUFFQSxNQUFJO2dCQUFFLElBQUcsQ0FBQ0MsR0FBRTtvQkFBQyxJQUFJQyxJQUFFeUUsS0FBSzJELEdBQUcsQ0FBQyxHQUFFLElBQUV0SSxLQUFHO29CQUFFaUosU0FBUyxJQUFJLEVBQUN0SixHQUFFQyxHQUFFSSxHQUFFRSxHQUFFO2dCQUFFO2dCQUFDLElBQUlHLElBQUU7Z0JBQUUsSUFBSUMsSUFBRTtnQkFBRSxJQUFJLENBQUNWLEVBQUUsR0FBQ0QsSUFBRTtnQkFBSSxNQUFNLEVBQUVXLElBQUVOLEtBQUlLLENBQUFBLEtBQUcsR0FBRSxFQUFHO29CQUFDLElBQUksQ0FBQ1QsSUFBRVUsRUFBRSxHQUFDWCxJQUFFVSxJQUFFO2dCQUFHO2dCQUFDLE9BQU9ULElBQUVJO1lBQUM7WUFBRXVCLE9BQU9XLFNBQVMsQ0FBQ2lILFdBQVcsR0FBQyxTQUFTQSxZQUFZeEosQ0FBQyxFQUFDQyxDQUFDLEVBQUNJLENBQUMsRUFBQ0MsQ0FBQztnQkFBRU4sSUFBRSxDQUFDQTtnQkFBRUMsSUFBRUEsTUFBSTtnQkFBRUksSUFBRUEsTUFBSTtnQkFBRSxJQUFHLENBQUNDLEdBQUU7b0JBQUMsSUFBSUMsSUFBRXlFLEtBQUsyRCxHQUFHLENBQUMsR0FBRSxJQUFFdEksS0FBRztvQkFBRWlKLFNBQVMsSUFBSSxFQUFDdEosR0FBRUMsR0FBRUksR0FBRUUsR0FBRTtnQkFBRTtnQkFBQyxJQUFJRyxJQUFFTCxJQUFFO2dCQUFFLElBQUlNLElBQUU7Z0JBQUUsSUFBSSxDQUFDVixJQUFFUyxFQUFFLEdBQUNWLElBQUU7Z0JBQUksTUFBTSxFQUFFVSxLQUFHLEtBQUlDLENBQUFBLEtBQUcsR0FBRSxFQUFHO29CQUFDLElBQUksQ0FBQ1YsSUFBRVMsRUFBRSxHQUFDVixJQUFFVyxJQUFFO2dCQUFHO2dCQUFDLE9BQU9WLElBQUVJO1lBQUM7WUFBRXVCLE9BQU9XLFNBQVMsQ0FBQ2tILFVBQVUsR0FBQyxTQUFTQSxXQUFXekosQ0FBQyxFQUFDQyxDQUFDLEVBQUNJLENBQUM7Z0JBQUVMLElBQUUsQ0FBQ0E7Z0JBQUVDLElBQUVBLE1BQUk7Z0JBQUUsSUFBRyxDQUFDSSxHQUFFaUosU0FBUyxJQUFJLEVBQUN0SixHQUFFQyxHQUFFLEdBQUUsS0FBSTtnQkFBRyxJQUFJLENBQUNBLEVBQUUsR0FBQ0QsSUFBRTtnQkFBSSxPQUFPQyxJQUFFO1lBQUM7WUFBRTJCLE9BQU9XLFNBQVMsQ0FBQ21ILGFBQWEsR0FBQyxTQUFTQSxjQUFjMUosQ0FBQyxFQUFDQyxDQUFDLEVBQUNJLENBQUM7Z0JBQUVMLElBQUUsQ0FBQ0E7Z0JBQUVDLElBQUVBLE1BQUk7Z0JBQUUsSUFBRyxDQUFDSSxHQUFFaUosU0FBUyxJQUFJLEVBQUN0SixHQUFFQyxHQUFFLEdBQUUsT0FBTTtnQkFBRyxJQUFJLENBQUNBLEVBQUUsR0FBQ0QsSUFBRTtnQkFBSSxJQUFJLENBQUNDLElBQUUsRUFBRSxHQUFDRCxNQUFJO2dCQUFFLE9BQU9DLElBQUU7WUFBQztZQUFFMkIsT0FBT1csU0FBUyxDQUFDb0gsYUFBYSxHQUFDLFNBQVNBLGNBQWMzSixDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQztnQkFBRUwsSUFBRSxDQUFDQTtnQkFBRUMsSUFBRUEsTUFBSTtnQkFBRSxJQUFHLENBQUNJLEdBQUVpSixTQUFTLElBQUksRUFBQ3RKLEdBQUVDLEdBQUUsR0FBRSxPQUFNO2dCQUFHLElBQUksQ0FBQ0EsRUFBRSxHQUFDRCxNQUFJO2dCQUFFLElBQUksQ0FBQ0MsSUFBRSxFQUFFLEdBQUNELElBQUU7Z0JBQUksT0FBT0MsSUFBRTtZQUFDO1lBQUUyQixPQUFPVyxTQUFTLENBQUNxSCxhQUFhLEdBQUMsU0FBU0EsY0FBYzVKLENBQUMsRUFBQ0MsQ0FBQyxFQUFDSSxDQUFDO2dCQUFFTCxJQUFFLENBQUNBO2dCQUFFQyxJQUFFQSxNQUFJO2dCQUFFLElBQUcsQ0FBQ0ksR0FBRWlKLFNBQVMsSUFBSSxFQUFDdEosR0FBRUMsR0FBRSxHQUFFLFlBQVc7Z0JBQUcsSUFBSSxDQUFDQSxJQUFFLEVBQUUsR0FBQ0QsTUFBSTtnQkFBRyxJQUFJLENBQUNDLElBQUUsRUFBRSxHQUFDRCxNQUFJO2dCQUFHLElBQUksQ0FBQ0MsSUFBRSxFQUFFLEdBQUNELE1BQUk7Z0JBQUUsSUFBSSxDQUFDQyxFQUFFLEdBQUNELElBQUU7Z0JBQUksT0FBT0MsSUFBRTtZQUFDO1lBQUUyQixPQUFPVyxTQUFTLENBQUNzSCxhQUFhLEdBQUMsU0FBU0EsY0FBYzdKLENBQUMsRUFBQ0MsQ0FBQyxFQUFDSSxDQUFDO2dCQUFFTCxJQUFFLENBQUNBO2dCQUFFQyxJQUFFQSxNQUFJO2dCQUFFLElBQUcsQ0FBQ0ksR0FBRWlKLFNBQVMsSUFBSSxFQUFDdEosR0FBRUMsR0FBRSxHQUFFLFlBQVc7Z0JBQUcsSUFBSSxDQUFDQSxFQUFFLEdBQUNELE1BQUk7Z0JBQUcsSUFBSSxDQUFDQyxJQUFFLEVBQUUsR0FBQ0QsTUFBSTtnQkFBRyxJQUFJLENBQUNDLElBQUUsRUFBRSxHQUFDRCxNQUFJO2dCQUFFLElBQUksQ0FBQ0MsSUFBRSxFQUFFLEdBQUNELElBQUU7Z0JBQUksT0FBT0MsSUFBRTtZQUFDO1lBQUUyQixPQUFPVyxTQUFTLENBQUN1SCxVQUFVLEdBQUMsU0FBU0EsV0FBVzlKLENBQUMsRUFBQ0MsQ0FBQyxFQUFDSSxDQUFDLEVBQUNDLENBQUM7Z0JBQUVOLElBQUUsQ0FBQ0E7Z0JBQUVDLElBQUVBLE1BQUk7Z0JBQUUsSUFBRyxDQUFDSyxHQUFFO29CQUFDLElBQUlDLElBQUV5RSxLQUFLMkQsR0FBRyxDQUFDLEdBQUUsSUFBRXRJLElBQUU7b0JBQUdpSixTQUFTLElBQUksRUFBQ3RKLEdBQUVDLEdBQUVJLEdBQUVFLElBQUUsR0FBRSxDQUFDQTtnQkFBRTtnQkFBQyxJQUFJRyxJQUFFO2dCQUFFLElBQUlDLElBQUU7Z0JBQUUsSUFBSUMsSUFBRTtnQkFBRSxJQUFJLENBQUNYLEVBQUUsR0FBQ0QsSUFBRTtnQkFBSSxNQUFNLEVBQUVVLElBQUVMLEtBQUlNLENBQUFBLEtBQUcsR0FBRSxFQUFHO29CQUFDLElBQUdYLElBQUUsS0FBR1ksTUFBSSxLQUFHLElBQUksQ0FBQ1gsSUFBRVMsSUFBRSxFQUFFLEtBQUcsR0FBRTt3QkFBQ0UsSUFBRTtvQkFBQztvQkFBQyxJQUFJLENBQUNYLElBQUVTLEVBQUUsR0FBQyxDQUFDVixJQUFFVyxLQUFHLEtBQUdDLElBQUU7Z0JBQUc7Z0JBQUMsT0FBT1gsSUFBRUk7WUFBQztZQUFFdUIsT0FBT1csU0FBUyxDQUFDd0gsVUFBVSxHQUFDLFNBQVNBLFdBQVcvSixDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQyxFQUFDQyxDQUFDO2dCQUFFTixJQUFFLENBQUNBO2dCQUFFQyxJQUFFQSxNQUFJO2dCQUFFLElBQUcsQ0FBQ0ssR0FBRTtvQkFBQyxJQUFJQyxJQUFFeUUsS0FBSzJELEdBQUcsQ0FBQyxHQUFFLElBQUV0SSxJQUFFO29CQUFHaUosU0FBUyxJQUFJLEVBQUN0SixHQUFFQyxHQUFFSSxHQUFFRSxJQUFFLEdBQUUsQ0FBQ0E7Z0JBQUU7Z0JBQUMsSUFBSUcsSUFBRUwsSUFBRTtnQkFBRSxJQUFJTSxJQUFFO2dCQUFFLElBQUlDLElBQUU7Z0JBQUUsSUFBSSxDQUFDWCxJQUFFUyxFQUFFLEdBQUNWLElBQUU7Z0JBQUksTUFBTSxFQUFFVSxLQUFHLEtBQUlDLENBQUFBLEtBQUcsR0FBRSxFQUFHO29CQUFDLElBQUdYLElBQUUsS0FBR1ksTUFBSSxLQUFHLElBQUksQ0FBQ1gsSUFBRVMsSUFBRSxFQUFFLEtBQUcsR0FBRTt3QkFBQ0UsSUFBRTtvQkFBQztvQkFBQyxJQUFJLENBQUNYLElBQUVTLEVBQUUsR0FBQyxDQUFDVixJQUFFVyxLQUFHLEtBQUdDLElBQUU7Z0JBQUc7Z0JBQUMsT0FBT1gsSUFBRUk7WUFBQztZQUFFdUIsT0FBT1csU0FBUyxDQUFDeUgsU0FBUyxHQUFDLFNBQVNBLFVBQVVoSyxDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQztnQkFBRUwsSUFBRSxDQUFDQTtnQkFBRUMsSUFBRUEsTUFBSTtnQkFBRSxJQUFHLENBQUNJLEdBQUVpSixTQUFTLElBQUksRUFBQ3RKLEdBQUVDLEdBQUUsR0FBRSxLQUFJLENBQUM7Z0JBQUssSUFBR0QsSUFBRSxHQUFFQSxJQUFFLE1BQUlBLElBQUU7Z0JBQUUsSUFBSSxDQUFDQyxFQUFFLEdBQUNELElBQUU7Z0JBQUksT0FBT0MsSUFBRTtZQUFDO1lBQUUyQixPQUFPVyxTQUFTLENBQUMwSCxZQUFZLEdBQUMsU0FBU0EsYUFBYWpLLENBQUMsRUFBQ0MsQ0FBQyxFQUFDSSxDQUFDO2dCQUFFTCxJQUFFLENBQUNBO2dCQUFFQyxJQUFFQSxNQUFJO2dCQUFFLElBQUcsQ0FBQ0ksR0FBRWlKLFNBQVMsSUFBSSxFQUFDdEosR0FBRUMsR0FBRSxHQUFFLE9BQU0sQ0FBQztnQkFBTyxJQUFJLENBQUNBLEVBQUUsR0FBQ0QsSUFBRTtnQkFBSSxJQUFJLENBQUNDLElBQUUsRUFBRSxHQUFDRCxNQUFJO2dCQUFFLE9BQU9DLElBQUU7WUFBQztZQUFFMkIsT0FBT1csU0FBUyxDQUFDMkgsWUFBWSxHQUFDLFNBQVNBLGFBQWFsSyxDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQztnQkFBRUwsSUFBRSxDQUFDQTtnQkFBRUMsSUFBRUEsTUFBSTtnQkFBRSxJQUFHLENBQUNJLEdBQUVpSixTQUFTLElBQUksRUFBQ3RKLEdBQUVDLEdBQUUsR0FBRSxPQUFNLENBQUM7Z0JBQU8sSUFBSSxDQUFDQSxFQUFFLEdBQUNELE1BQUk7Z0JBQUUsSUFBSSxDQUFDQyxJQUFFLEVBQUUsR0FBQ0QsSUFBRTtnQkFBSSxPQUFPQyxJQUFFO1lBQUM7WUFBRTJCLE9BQU9XLFNBQVMsQ0FBQzRILFlBQVksR0FBQyxTQUFTQSxhQUFhbkssQ0FBQyxFQUFDQyxDQUFDLEVBQUNJLENBQUM7Z0JBQUVMLElBQUUsQ0FBQ0E7Z0JBQUVDLElBQUVBLE1BQUk7Z0JBQUUsSUFBRyxDQUFDSSxHQUFFaUosU0FBUyxJQUFJLEVBQUN0SixHQUFFQyxHQUFFLEdBQUUsWUFBVyxDQUFDO2dCQUFZLElBQUksQ0FBQ0EsRUFBRSxHQUFDRCxJQUFFO2dCQUFJLElBQUksQ0FBQ0MsSUFBRSxFQUFFLEdBQUNELE1BQUk7Z0JBQUUsSUFBSSxDQUFDQyxJQUFFLEVBQUUsR0FBQ0QsTUFBSTtnQkFBRyxJQUFJLENBQUNDLElBQUUsRUFBRSxHQUFDRCxNQUFJO2dCQUFHLE9BQU9DLElBQUU7WUFBQztZQUFFMkIsT0FBT1csU0FBUyxDQUFDNkgsWUFBWSxHQUFDLFNBQVNBLGFBQWFwSyxDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQztnQkFBRUwsSUFBRSxDQUFDQTtnQkFBRUMsSUFBRUEsTUFBSTtnQkFBRSxJQUFHLENBQUNJLEdBQUVpSixTQUFTLElBQUksRUFBQ3RKLEdBQUVDLEdBQUUsR0FBRSxZQUFXLENBQUM7Z0JBQVksSUFBR0QsSUFBRSxHQUFFQSxJQUFFLGFBQVdBLElBQUU7Z0JBQUUsSUFBSSxDQUFDQyxFQUFFLEdBQUNELE1BQUk7Z0JBQUcsSUFBSSxDQUFDQyxJQUFFLEVBQUUsR0FBQ0QsTUFBSTtnQkFBRyxJQUFJLENBQUNDLElBQUUsRUFBRSxHQUFDRCxNQUFJO2dCQUFFLElBQUksQ0FBQ0MsSUFBRSxFQUFFLEdBQUNELElBQUU7Z0JBQUksT0FBT0MsSUFBRTtZQUFDO1lBQUUsU0FBU29LLGFBQWFySyxDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQyxFQUFDQyxDQUFDLEVBQUNDLENBQUMsRUFBQ0csQ0FBQztnQkFBRSxJQUFHTCxJQUFFQyxJQUFFTixFQUFFYSxNQUFNLEVBQUMsTUFBTSxJQUFJbUMsV0FBVztnQkFBc0IsSUFBRzNDLElBQUUsR0FBRSxNQUFNLElBQUkyQyxXQUFXO1lBQXFCO1lBQUMsU0FBU3NILFdBQVd0SyxDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQyxFQUFDQyxDQUFDLEVBQUNJLENBQUM7Z0JBQUVULElBQUUsQ0FBQ0E7Z0JBQUVJLElBQUVBLE1BQUk7Z0JBQUUsSUFBRyxDQUFDSyxHQUFFO29CQUFDMkosYUFBYXJLLEdBQUVDLEdBQUVJLEdBQUUsR0FBRSxzQkFBcUIsQ0FBQztnQkFBcUI7Z0JBQUNFLEVBQUU4RCxLQUFLLENBQUNyRSxHQUFFQyxHQUFFSSxHQUFFQyxHQUFFLElBQUc7Z0JBQUcsT0FBT0QsSUFBRTtZQUFDO1lBQUN1QixPQUFPVyxTQUFTLENBQUNnSSxZQUFZLEdBQUMsU0FBU0EsYUFBYXZLLENBQUMsRUFBQ0MsQ0FBQyxFQUFDSSxDQUFDO2dCQUFFLE9BQU9pSyxXQUFXLElBQUksRUFBQ3RLLEdBQUVDLEdBQUUsTUFBS0k7WUFBRTtZQUFFdUIsT0FBT1csU0FBUyxDQUFDaUksWUFBWSxHQUFDLFNBQVNBLGFBQWF4SyxDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQztnQkFBRSxPQUFPaUssV0FBVyxJQUFJLEVBQUN0SyxHQUFFQyxHQUFFLE9BQU1JO1lBQUU7WUFBRSxTQUFTb0ssWUFBWXpLLENBQUMsRUFBQ0MsQ0FBQyxFQUFDSSxDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQztnQkFBRVQsSUFBRSxDQUFDQTtnQkFBRUksSUFBRUEsTUFBSTtnQkFBRSxJQUFHLENBQUNLLEdBQUU7b0JBQUMySixhQUFhckssR0FBRUMsR0FBRUksR0FBRSxHQUFFLHVCQUFzQixDQUFDO2dCQUFzQjtnQkFBQ0UsRUFBRThELEtBQUssQ0FBQ3JFLEdBQUVDLEdBQUVJLEdBQUVDLEdBQUUsSUFBRztnQkFBRyxPQUFPRCxJQUFFO1lBQUM7WUFBQ3VCLE9BQU9XLFNBQVMsQ0FBQ21JLGFBQWEsR0FBQyxTQUFTQSxjQUFjMUssQ0FBQyxFQUFDQyxDQUFDLEVBQUNJLENBQUM7Z0JBQUUsT0FBT29LLFlBQVksSUFBSSxFQUFDekssR0FBRUMsR0FBRSxNQUFLSTtZQUFFO1lBQUV1QixPQUFPVyxTQUFTLENBQUNvSSxhQUFhLEdBQUMsU0FBU0EsY0FBYzNLLENBQUMsRUFBQ0MsQ0FBQyxFQUFDSSxDQUFDO2dCQUFFLE9BQU9vSyxZQUFZLElBQUksRUFBQ3pLLEdBQUVDLEdBQUUsT0FBTUk7WUFBRTtZQUFFdUIsT0FBT1csU0FBUyxDQUFDZ0MsSUFBSSxHQUFDLFNBQVNBLEtBQUt2RSxDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQyxFQUFDQyxDQUFDO2dCQUFFLElBQUcsQ0FBQ3NCLE9BQU9lLFFBQVEsQ0FBQzNDLElBQUcsTUFBTSxJQUFJaUQsVUFBVTtnQkFBK0IsSUFBRyxDQUFDNUMsR0FBRUEsSUFBRTtnQkFBRSxJQUFHLENBQUNDLEtBQUdBLE1BQUksR0FBRUEsSUFBRSxJQUFJLENBQUNPLE1BQU07Z0JBQUMsSUFBR1osS0FBR0QsRUFBRWEsTUFBTSxFQUFDWixJQUFFRCxFQUFFYSxNQUFNO2dCQUFDLElBQUcsQ0FBQ1osR0FBRUEsSUFBRTtnQkFBRSxJQUFHSyxJQUFFLEtBQUdBLElBQUVELEdBQUVDLElBQUVEO2dCQUFFLElBQUdDLE1BQUlELEdBQUUsT0FBTztnQkFBRSxJQUFHTCxFQUFFYSxNQUFNLEtBQUcsS0FBRyxJQUFJLENBQUNBLE1BQU0sS0FBRyxHQUFFLE9BQU87Z0JBQUUsSUFBR1osSUFBRSxHQUFFO29CQUFDLE1BQU0sSUFBSStDLFdBQVc7Z0JBQTRCO2dCQUFDLElBQUczQyxJQUFFLEtBQUdBLEtBQUcsSUFBSSxDQUFDUSxNQUFNLEVBQUMsTUFBTSxJQUFJbUMsV0FBVztnQkFBc0IsSUFBRzFDLElBQUUsR0FBRSxNQUFNLElBQUkwQyxXQUFXO2dCQUEyQixJQUFHMUMsSUFBRSxJQUFJLENBQUNPLE1BQU0sRUFBQ1AsSUFBRSxJQUFJLENBQUNPLE1BQU07Z0JBQUMsSUFBR2IsRUFBRWEsTUFBTSxHQUFDWixJQUFFSyxJQUFFRCxHQUFFO29CQUFDQyxJQUFFTixFQUFFYSxNQUFNLEdBQUNaLElBQUVJO2dCQUFDO2dCQUFDLElBQUlFLElBQUVELElBQUVEO2dCQUFFLElBQUcsSUFBSSxLQUFHTCxLQUFHLE9BQU9RLFdBQVcrQixTQUFTLENBQUNxSSxVQUFVLEtBQUcsWUFBVztvQkFBQyxJQUFJLENBQUNBLFVBQVUsQ0FBQzNLLEdBQUVJLEdBQUVDO2dCQUFFLE9BQU0sSUFBRyxJQUFJLEtBQUdOLEtBQUdLLElBQUVKLEtBQUdBLElBQUVLLEdBQUU7b0JBQUMsSUFBSSxJQUFJSSxJQUFFSCxJQUFFLEdBQUVHLEtBQUcsR0FBRSxFQUFFQSxFQUFFO3dCQUFDVixDQUFDLENBQUNVLElBQUVULEVBQUUsR0FBQyxJQUFJLENBQUNTLElBQUVMLEVBQUU7b0JBQUE7Z0JBQUMsT0FBSztvQkFBQ0csV0FBVytCLFNBQVMsQ0FBQ3NJLEdBQUcsQ0FBQ2xFLElBQUksQ0FBQzNHLEdBQUUsSUFBSSxDQUFDa0ksUUFBUSxDQUFDN0gsR0FBRUMsSUFBR0w7Z0JBQUU7Z0JBQUMsT0FBT007WUFBQztZQUFFcUIsT0FBT1csU0FBUyxDQUFDMEIsSUFBSSxHQUFDLFNBQVNBLEtBQUtqRSxDQUFDLEVBQUNDLENBQUMsRUFBQ0ksQ0FBQyxFQUFDQyxDQUFDO2dCQUFFLElBQUcsT0FBT04sTUFBSSxVQUFTO29CQUFDLElBQUcsT0FBT0MsTUFBSSxVQUFTO3dCQUFDSyxJQUFFTDt3QkFBRUEsSUFBRTt3QkFBRUksSUFBRSxJQUFJLENBQUNRLE1BQU07b0JBQUEsT0FBTSxJQUFHLE9BQU9SLE1BQUksVUFBUzt3QkFBQ0MsSUFBRUQ7d0JBQUVBLElBQUUsSUFBSSxDQUFDUSxNQUFNO29CQUFBO29CQUFDLElBQUdQLE1BQUlzQyxhQUFXLE9BQU90QyxNQUFJLFVBQVM7d0JBQUMsTUFBTSxJQUFJMkMsVUFBVTtvQkFBNEI7b0JBQUMsSUFBRyxPQUFPM0MsTUFBSSxZQUFVLENBQUNzQixPQUFPd0MsVUFBVSxDQUFDOUQsSUFBRzt3QkFBQyxNQUFNLElBQUkyQyxVQUFVLHVCQUFxQjNDO29CQUFFO29CQUFDLElBQUdOLEVBQUVhLE1BQU0sS0FBRyxHQUFFO3dCQUFDLElBQUlOLElBQUVQLEVBQUVjLFVBQVUsQ0FBQzt3QkFBRyxJQUFHUixNQUFJLFVBQVFDLElBQUUsT0FBS0QsTUFBSSxVQUFTOzRCQUFDTixJQUFFTzt3QkFBQztvQkFBQztnQkFBQyxPQUFNLElBQUcsT0FBT1AsTUFBSSxVQUFTO29CQUFDQSxJQUFFQSxJQUFFO2dCQUFHLE9BQU0sSUFBRyxPQUFPQSxNQUFJLFdBQVU7b0JBQUNBLElBQUVrSCxPQUFPbEg7Z0JBQUU7Z0JBQUMsSUFBR0MsSUFBRSxLQUFHLElBQUksQ0FBQ1ksTUFBTSxHQUFDWixLQUFHLElBQUksQ0FBQ1ksTUFBTSxHQUFDUixHQUFFO29CQUFDLE1BQU0sSUFBSTJDLFdBQVc7Z0JBQXFCO2dCQUFDLElBQUczQyxLQUFHSixHQUFFO29CQUFDLE9BQU8sSUFBSTtnQkFBQTtnQkFBQ0EsSUFBRUEsTUFBSTtnQkFBRUksSUFBRUEsTUFBSXVDLFlBQVUsSUFBSSxDQUFDL0IsTUFBTSxHQUFDUixNQUFJO2dCQUFFLElBQUcsQ0FBQ0wsR0FBRUEsSUFBRTtnQkFBRSxJQUFJVTtnQkFBRSxJQUFHLE9BQU9WLE1BQUksVUFBUztvQkFBQyxJQUFJVSxJQUFFVCxHQUFFUyxJQUFFTCxHQUFFLEVBQUVLLEVBQUU7d0JBQUMsSUFBSSxDQUFDQSxFQUFFLEdBQUNWO29CQUFDO2dCQUFDLE9BQUs7b0JBQUMsSUFBSVcsSUFBRWlCLE9BQU9lLFFBQVEsQ0FBQzNDLEtBQUdBLElBQUU0QixPQUFPdUIsSUFBSSxDQUFDbkQsR0FBRU07b0JBQUcsSUFBSU0sSUFBRUQsRUFBRUUsTUFBTTtvQkFBQyxJQUFHRCxNQUFJLEdBQUU7d0JBQUMsTUFBTSxJQUFJcUMsVUFBVSxnQkFBY2pELElBQUU7b0JBQW9DO29CQUFDLElBQUlVLElBQUUsR0FBRUEsSUFBRUwsSUFBRUosR0FBRSxFQUFFUyxFQUFFO3dCQUFDLElBQUksQ0FBQ0EsSUFBRVQsRUFBRSxHQUFDVSxDQUFDLENBQUNELElBQUVFLEVBQUU7b0JBQUE7Z0JBQUM7Z0JBQUMsT0FBTyxJQUFJO1lBQUE7WUFBRSxJQUFJTyxJQUFFO1lBQW9CLFNBQVMySixZQUFZOUssQ0FBQztnQkFBRUEsSUFBRUEsRUFBRStLLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFBQy9LLElBQUVBLEVBQUV3RyxJQUFJLEdBQUdELE9BQU8sQ0FBQ3BGLEdBQUU7Z0JBQUksSUFBR25CLEVBQUVhLE1BQU0sR0FBQyxHQUFFLE9BQU07Z0JBQUcsTUFBTWIsRUFBRWEsTUFBTSxHQUFDLE1BQUksRUFBRTtvQkFBQ2IsSUFBRUEsSUFBRTtnQkFBRztnQkFBQyxPQUFPQTtZQUFDO1lBQUMsU0FBU3NGLFlBQVl0RixDQUFDLEVBQUNDLENBQUM7Z0JBQUVBLElBQUVBLEtBQUcrSztnQkFBUyxJQUFJM0s7Z0JBQUUsSUFBSUMsSUFBRU4sRUFBRWEsTUFBTTtnQkFBQyxJQUFJTixJQUFFO2dCQUFLLElBQUlHLElBQUUsRUFBRTtnQkFBQyxJQUFJLElBQUlDLElBQUUsR0FBRUEsSUFBRUwsR0FBRSxFQUFFSyxFQUFFO29CQUFDTixJQUFFTCxFQUFFYyxVQUFVLENBQUNIO29CQUFHLElBQUdOLElBQUUsU0FBT0EsSUFBRSxPQUFNO3dCQUFDLElBQUcsQ0FBQ0UsR0FBRTs0QkFBQyxJQUFHRixJQUFFLE9BQU07Z0NBQUMsSUFBRyxDQUFDSixLQUFHLEtBQUcsQ0FBQyxHQUFFUyxFQUFFYyxJQUFJLENBQUMsS0FBSSxLQUFJO2dDQUFLOzRCQUFRLE9BQU0sSUFBR2IsSUFBRSxNQUFJTCxHQUFFO2dDQUFDLElBQUcsQ0FBQ0wsS0FBRyxLQUFHLENBQUMsR0FBRVMsRUFBRWMsSUFBSSxDQUFDLEtBQUksS0FBSTtnQ0FBSzs0QkFBUTs0QkFBQ2pCLElBQUVGOzRCQUFFO3dCQUFRO3dCQUFDLElBQUdBLElBQUUsT0FBTTs0QkFBQyxJQUFHLENBQUNKLEtBQUcsS0FBRyxDQUFDLEdBQUVTLEVBQUVjLElBQUksQ0FBQyxLQUFJLEtBQUk7NEJBQUtqQixJQUFFRjs0QkFBRTt3QkFBUTt3QkFBQ0EsSUFBRSxDQUFDRSxJQUFFLFNBQU8sS0FBR0YsSUFBRSxLQUFJLElBQUc7b0JBQUssT0FBTSxJQUFHRSxHQUFFO3dCQUFDLElBQUcsQ0FBQ04sS0FBRyxLQUFHLENBQUMsR0FBRVMsRUFBRWMsSUFBSSxDQUFDLEtBQUksS0FBSTtvQkFBSTtvQkFBQ2pCLElBQUU7b0JBQUssSUFBR0YsSUFBRSxLQUFJO3dCQUFDLElBQUcsQ0FBQ0osS0FBRyxLQUFHLEdBQUU7d0JBQU1TLEVBQUVjLElBQUksQ0FBQ25CO29CQUFFLE9BQU0sSUFBR0EsSUFBRSxNQUFLO3dCQUFDLElBQUcsQ0FBQ0osS0FBRyxLQUFHLEdBQUU7d0JBQU1TLEVBQUVjLElBQUksQ0FBQ25CLEtBQUcsSUFBRSxLQUFJQSxJQUFFLEtBQUc7b0JBQUksT0FBTSxJQUFHQSxJQUFFLE9BQU07d0JBQUMsSUFBRyxDQUFDSixLQUFHLEtBQUcsR0FBRTt3QkFBTVMsRUFBRWMsSUFBSSxDQUFDbkIsS0FBRyxLQUFHLEtBQUlBLEtBQUcsSUFBRSxLQUFHLEtBQUlBLElBQUUsS0FBRztvQkFBSSxPQUFNLElBQUdBLElBQUUsU0FBUTt3QkFBQyxJQUFHLENBQUNKLEtBQUcsS0FBRyxHQUFFO3dCQUFNUyxFQUFFYyxJQUFJLENBQUNuQixLQUFHLEtBQUcsS0FBSUEsS0FBRyxLQUFHLEtBQUcsS0FBSUEsS0FBRyxJQUFFLEtBQUcsS0FBSUEsSUFBRSxLQUFHO29CQUFJLE9BQUs7d0JBQUMsTUFBTSxJQUFJVyxNQUFNO29CQUFxQjtnQkFBQztnQkFBQyxPQUFPTjtZQUFDO1lBQUMsU0FBUzhHLGFBQWF4SCxDQUFDO2dCQUFFLElBQUlDLElBQUUsRUFBRTtnQkFBQyxJQUFJLElBQUlJLElBQUUsR0FBRUEsSUFBRUwsRUFBRWEsTUFBTSxFQUFDLEVBQUVSLEVBQUU7b0JBQUNKLEVBQUV1QixJQUFJLENBQUN4QixFQUFFYyxVQUFVLENBQUNULEtBQUc7Z0JBQUk7Z0JBQUMsT0FBT0o7WUFBQztZQUFDLFNBQVMySCxlQUFlNUgsQ0FBQyxFQUFDQyxDQUFDO2dCQUFFLElBQUlJLEdBQUVDLEdBQUVDO2dCQUFFLElBQUlHLElBQUUsRUFBRTtnQkFBQyxJQUFJLElBQUlDLElBQUUsR0FBRUEsSUFBRVgsRUFBRWEsTUFBTSxFQUFDLEVBQUVGLEVBQUU7b0JBQUMsSUFBRyxDQUFDVixLQUFHLEtBQUcsR0FBRTtvQkFBTUksSUFBRUwsRUFBRWMsVUFBVSxDQUFDSDtvQkFBR0wsSUFBRUQsS0FBRztvQkFBRUUsSUFBRUYsSUFBRTtvQkFBSUssRUFBRWMsSUFBSSxDQUFDakI7b0JBQUdHLEVBQUVjLElBQUksQ0FBQ2xCO2dCQUFFO2dCQUFDLE9BQU9JO1lBQUM7WUFBQyxTQUFTNkUsY0FBY3ZGLENBQUM7Z0JBQUUsT0FBT00sRUFBRUgsV0FBVyxDQUFDMkssWUFBWTlLO1lBQUc7WUFBQyxTQUFTc0gsV0FBV3RILENBQUMsRUFBQ0MsQ0FBQyxFQUFDSSxDQUFDLEVBQUNDLENBQUM7Z0JBQUUsSUFBSSxJQUFJQyxJQUFFLEdBQUVBLElBQUVELEdBQUUsRUFBRUMsRUFBRTtvQkFBQyxJQUFHQSxJQUFFRixLQUFHSixFQUFFWSxNQUFNLElBQUVOLEtBQUdQLEVBQUVhLE1BQU0sRUFBQztvQkFBTVosQ0FBQyxDQUFDTSxJQUFFRixFQUFFLEdBQUNMLENBQUMsQ0FBQ08sRUFBRTtnQkFBQTtnQkFBQyxPQUFPQTtZQUFDO1lBQUMsU0FBU2tELFdBQVd6RCxDQUFDLEVBQUNDLENBQUM7Z0JBQUUsT0FBT0QsYUFBYUMsS0FBR0QsS0FBRyxRQUFNQSxFQUFFaUwsV0FBVyxJQUFFLFFBQU1qTCxFQUFFaUwsV0FBVyxDQUFDQyxJQUFJLElBQUUsUUFBTWxMLEVBQUVpTCxXQUFXLENBQUNDLElBQUksS0FBR2pMLEVBQUVpTCxJQUFJO1lBQUE7WUFBQyxTQUFTMUcsWUFBWXhFLENBQUM7Z0JBQUUsT0FBT0EsTUFBSUE7WUFBQztZQUFDLElBQUlvQixJQUFFO2dCQUFXLElBQUlwQixJQUFFO2dCQUFtQixJQUFJQyxJQUFFLElBQUlRLE1BQU07Z0JBQUssSUFBSSxJQUFJSixJQUFFLEdBQUVBLElBQUUsSUFBRyxFQUFFQSxFQUFFO29CQUFDLElBQUlDLElBQUVELElBQUU7b0JBQUcsSUFBSSxJQUFJRSxJQUFFLEdBQUVBLElBQUUsSUFBRyxFQUFFQSxFQUFFO3dCQUFDTixDQUFDLENBQUNLLElBQUVDLEVBQUUsR0FBQ1AsQ0FBQyxDQUFDSyxFQUFFLEdBQUNMLENBQUMsQ0FBQ08sRUFBRTtvQkFBQTtnQkFBQztnQkFBQyxPQUFPTjtZQUFDO1FBQUc7UUFBRSxLQUFJLFNBQVNELENBQUMsRUFBQ0MsQ0FBQztZQUMxeXZCLHVGQUF1RixHQUN2RkEsRUFBRTRHLElBQUksR0FBQyxTQUFTN0csQ0FBQyxFQUFDQyxDQUFDLEVBQUNJLENBQUMsRUFBQ0MsQ0FBQyxFQUFDQyxDQUFDO2dCQUFFLElBQUlHLEdBQUVDO2dCQUFFLElBQUlDLElBQUVMLElBQUUsSUFBRUQsSUFBRTtnQkFBRSxJQUFJYSxJQUFFLENBQUMsS0FBR1AsQ0FBQUEsSUFBRztnQkFBRSxJQUFJUSxJQUFFRCxLQUFHO2dCQUFFLElBQUlFLElBQUUsQ0FBQztnQkFBRSxJQUFJMEYsSUFBRTFHLElBQUVFLElBQUUsSUFBRTtnQkFBRSxJQUFJNEssSUFBRTlLLElBQUUsQ0FBQyxJQUFFO2dCQUFFLElBQUkrSyxJQUFFcEwsQ0FBQyxDQUFDQyxJQUFFOEcsRUFBRTtnQkFBQ0EsS0FBR29FO2dCQUFFekssSUFBRTBLLElBQUUsQ0FBQyxLQUFHLENBQUMvSixDQUFBQSxJQUFHO2dCQUFFK0osTUFBSSxDQUFDL0o7Z0JBQUVBLEtBQUdUO2dCQUFFLE1BQUtTLElBQUUsR0FBRVgsSUFBRUEsSUFBRSxNQUFJVixDQUFDLENBQUNDLElBQUU4RyxFQUFFLEVBQUNBLEtBQUdvRSxHQUFFOUosS0FBRyxFQUFFLENBQUM7Z0JBQUNWLElBQUVELElBQUUsQ0FBQyxLQUFHLENBQUNXLENBQUFBLElBQUc7Z0JBQUVYLE1BQUksQ0FBQ1c7Z0JBQUVBLEtBQUdmO2dCQUFFLE1BQUtlLElBQUUsR0FBRVYsSUFBRUEsSUFBRSxNQUFJWCxDQUFDLENBQUNDLElBQUU4RyxFQUFFLEVBQUNBLEtBQUdvRSxHQUFFOUosS0FBRyxFQUFFLENBQUM7Z0JBQUMsSUFBR1gsTUFBSSxHQUFFO29CQUFDQSxJQUFFLElBQUVVO2dCQUFDLE9BQU0sSUFBR1YsTUFBSVMsR0FBRTtvQkFBQyxPQUFPUixJQUFFMEssTUFBSSxDQUFDRCxJQUFFLENBQUMsSUFBRSxLQUFHSjtnQkFBUSxPQUFLO29CQUFDckssSUFBRUEsSUFBRXFFLEtBQUsyRCxHQUFHLENBQUMsR0FBRXJJO29CQUFHSSxJQUFFQSxJQUFFVTtnQkFBQztnQkFBQyxPQUFNLENBQUNnSyxJQUFFLENBQUMsSUFBRSxLQUFHekssSUFBRXFFLEtBQUsyRCxHQUFHLENBQUMsR0FBRWpJLElBQUVKO1lBQUU7WUFBRUwsRUFBRW9FLEtBQUssR0FBQyxTQUFTckUsQ0FBQyxFQUFDQyxDQUFDLEVBQUNJLENBQUMsRUFBQ0MsQ0FBQyxFQUFDQyxDQUFDLEVBQUNHLENBQUM7Z0JBQUUsSUFBSUMsR0FBRUMsR0FBRU87Z0JBQUUsSUFBSUMsSUFBRVYsSUFBRSxJQUFFSCxJQUFFO2dCQUFFLElBQUljLElBQUUsQ0FBQyxLQUFHRCxDQUFBQSxJQUFHO2dCQUFFLElBQUkyRixJQUFFMUYsS0FBRztnQkFBRSxJQUFJOEosSUFBRTVLLE1BQUksS0FBR3lFLEtBQUsyRCxHQUFHLENBQUMsR0FBRSxDQUFDLE1BQUkzRCxLQUFLMkQsR0FBRyxDQUFDLEdBQUUsQ0FBQyxNQUFJO2dCQUFFLElBQUl5QyxJQUFFOUssSUFBRSxJQUFFSSxJQUFFO2dCQUFFLElBQUk0SyxJQUFFaEwsSUFBRSxJQUFFLENBQUM7Z0JBQUUsSUFBSWlMLElBQUV0TCxJQUFFLEtBQUdBLE1BQUksS0FBRyxJQUFFQSxJQUFFLElBQUUsSUFBRTtnQkFBRUEsSUFBRStFLEtBQUt3RyxHQUFHLENBQUN2TDtnQkFBRyxJQUFHd0wsTUFBTXhMLE1BQUlBLE1BQUkrSyxVQUFTO29CQUFDcEssSUFBRTZLLE1BQU14TCxLQUFHLElBQUU7b0JBQUVVLElBQUVVO2dCQUFDLE9BQUs7b0JBQUNWLElBQUVxRSxLQUFLMEcsS0FBSyxDQUFDMUcsS0FBSzJHLEdBQUcsQ0FBQzFMLEtBQUcrRSxLQUFLNEcsR0FBRztvQkFBRSxJQUFHM0wsSUFBR2tCLENBQUFBLElBQUU2RCxLQUFLMkQsR0FBRyxDQUFDLEdBQUUsQ0FBQ2hJLEVBQUMsSUFBRyxHQUFFO3dCQUFDQTt3QkFBSVEsS0FBRztvQkFBQztvQkFBQyxJQUFHUixJQUFFb0csS0FBRyxHQUFFO3dCQUFDOUcsS0FBR2tMLElBQUVoSztvQkFBQyxPQUFLO3dCQUFDbEIsS0FBR2tMLElBQUVuRyxLQUFLMkQsR0FBRyxDQUFDLEdBQUUsSUFBRTVCO29CQUFFO29CQUFDLElBQUc5RyxJQUFFa0IsS0FBRyxHQUFFO3dCQUFDUjt3QkFBSVEsS0FBRztvQkFBQztvQkFBQyxJQUFHUixJQUFFb0csS0FBRzFGLEdBQUU7d0JBQUNULElBQUU7d0JBQUVELElBQUVVO29CQUFDLE9BQU0sSUFBR1YsSUFBRW9HLEtBQUcsR0FBRTt3QkFBQ25HLElBQUUsQ0FBQ1gsSUFBRWtCLElBQUUsS0FBRzZELEtBQUsyRCxHQUFHLENBQUMsR0FBRXBJO3dCQUFHSSxJQUFFQSxJQUFFb0c7b0JBQUMsT0FBSzt3QkFBQ25HLElBQUVYLElBQUUrRSxLQUFLMkQsR0FBRyxDQUFDLEdBQUU1QixJQUFFLEtBQUcvQixLQUFLMkQsR0FBRyxDQUFDLEdBQUVwSTt3QkFBR0ksSUFBRTtvQkFBQztnQkFBQztnQkFBQyxNQUFLSixLQUFHLEdBQUVQLENBQUMsQ0FBQ0ssSUFBRStLLEVBQUUsR0FBQ3hLLElBQUUsS0FBSXdLLEtBQUdFLEdBQUUxSyxLQUFHLEtBQUlMLEtBQUcsRUFBRSxDQUFDO2dCQUFDSSxJQUFFQSxLQUFHSixJQUFFSztnQkFBRVEsS0FBR2I7Z0JBQUUsTUFBS2EsSUFBRSxHQUFFcEIsQ0FBQyxDQUFDSyxJQUFFK0ssRUFBRSxHQUFDekssSUFBRSxLQUFJeUssS0FBR0UsR0FBRTNLLEtBQUcsS0FBSVMsS0FBRyxFQUFFLENBQUM7Z0JBQUNwQixDQUFDLENBQUNLLElBQUUrSyxJQUFFRSxFQUFFLElBQUVDLElBQUU7WUFBRztRQUFDO0lBQUM7SUFBRSxJQUFJdEwsSUFBRSxDQUFDO0lBQUUsU0FBUzRMLG9CQUFvQnhMLENBQUM7UUFBRSxJQUFJQyxJQUFFTCxDQUFDLENBQUNJLEVBQUU7UUFBQyxJQUFHQyxNQUFJc0MsV0FBVTtZQUFDLE9BQU90QyxFQUFFd0wsT0FBTztRQUFBO1FBQUMsSUFBSXZMLElBQUVOLENBQUMsQ0FBQ0ksRUFBRSxHQUFDO1lBQUN5TCxTQUFRLENBQUM7UUFBQztRQUFFLElBQUlwTCxJQUFFO1FBQUssSUFBRztZQUFDVixDQUFDLENBQUNLLEVBQUUsQ0FBQ0UsR0FBRUEsRUFBRXVMLE9BQU8sRUFBQ0Q7WUFBcUJuTCxJQUFFO1FBQUssU0FBUTtZQUFDLElBQUdBLEdBQUUsT0FBT1QsQ0FBQyxDQUFDSSxFQUFFO1FBQUE7UUFBQyxPQUFPRSxFQUFFdUwsT0FBTztJQUFBO0lBQUMsSUFBRyxPQUFPRCx3QkFBc0IsYUFBWUEsb0JBQW9CRSxFQUFFLEdBQUNDLFNBQVNBLEdBQUM7SUFBSSxJQUFJM0wsSUFBRXdMLG9CQUFvQjtJQUFJSSxPQUFPSCxPQUFPLEdBQUN6TDtBQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvYnVmZmVyL2luZGV4LmpzPzM3NzYiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIGU9ezY3NTpmdW5jdGlvbihlLHIpe1widXNlIHN0cmljdFwiO3IuYnl0ZUxlbmd0aD1ieXRlTGVuZ3RoO3IudG9CeXRlQXJyYXk9dG9CeXRlQXJyYXk7ci5mcm9tQnl0ZUFycmF5PWZyb21CeXRlQXJyYXk7dmFyIHQ9W107dmFyIGY9W107dmFyIG49dHlwZW9mIFVpbnQ4QXJyYXkhPT1cInVuZGVmaW5lZFwiP1VpbnQ4QXJyYXk6QXJyYXk7dmFyIGk9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7Zm9yKHZhciBvPTAsdT1pLmxlbmd0aDtvPHU7KytvKXt0W29dPWlbb107ZltpLmNoYXJDb2RlQXQobyldPW99ZltcIi1cIi5jaGFyQ29kZUF0KDApXT02MjtmW1wiX1wiLmNoYXJDb2RlQXQoMCldPTYzO2Z1bmN0aW9uIGdldExlbnMoZSl7dmFyIHI9ZS5sZW5ndGg7aWYociU0PjApe3Rocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDRcIil9dmFyIHQ9ZS5pbmRleE9mKFwiPVwiKTtpZih0PT09LTEpdD1yO3ZhciBmPXQ9PT1yPzA6NC10JTQ7cmV0dXJuW3QsZl19ZnVuY3Rpb24gYnl0ZUxlbmd0aChlKXt2YXIgcj1nZXRMZW5zKGUpO3ZhciB0PXJbMF07dmFyIGY9clsxXTtyZXR1cm4odCtmKSozLzQtZn1mdW5jdGlvbiBfYnl0ZUxlbmd0aChlLHIsdCl7cmV0dXJuKHIrdCkqMy80LXR9ZnVuY3Rpb24gdG9CeXRlQXJyYXkoZSl7dmFyIHI7dmFyIHQ9Z2V0TGVucyhlKTt2YXIgaT10WzBdO3ZhciBvPXRbMV07dmFyIHU9bmV3IG4oX2J5dGVMZW5ndGgoZSxpLG8pKTt2YXIgYT0wO3ZhciBzPW8+MD9pLTQ6aTt2YXIgaDtmb3IoaD0wO2g8cztoKz00KXtyPWZbZS5jaGFyQ29kZUF0KGgpXTw8MTh8ZltlLmNoYXJDb2RlQXQoaCsxKV08PDEyfGZbZS5jaGFyQ29kZUF0KGgrMildPDw2fGZbZS5jaGFyQ29kZUF0KGgrMyldO3VbYSsrXT1yPj4xNiYyNTU7dVthKytdPXI+PjgmMjU1O3VbYSsrXT1yJjI1NX1pZihvPT09Mil7cj1mW2UuY2hhckNvZGVBdChoKV08PDJ8ZltlLmNoYXJDb2RlQXQoaCsxKV0+PjQ7dVthKytdPXImMjU1fWlmKG89PT0xKXtyPWZbZS5jaGFyQ29kZUF0KGgpXTw8MTB8ZltlLmNoYXJDb2RlQXQoaCsxKV08PDR8ZltlLmNoYXJDb2RlQXQoaCsyKV0+PjI7dVthKytdPXI+PjgmMjU1O3VbYSsrXT1yJjI1NX1yZXR1cm4gdX1mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQoZSl7cmV0dXJuIHRbZT4+MTgmNjNdK3RbZT4+MTImNjNdK3RbZT4+NiY2M10rdFtlJjYzXX1mdW5jdGlvbiBlbmNvZGVDaHVuayhlLHIsdCl7dmFyIGY7dmFyIG49W107Zm9yKHZhciBpPXI7aTx0O2krPTMpe2Y9KGVbaV08PDE2JjE2NzExNjgwKSsoZVtpKzFdPDw4JjY1MjgwKSsoZVtpKzJdJjI1NSk7bi5wdXNoKHRyaXBsZXRUb0Jhc2U2NChmKSl9cmV0dXJuIG4uam9pbihcIlwiKX1mdW5jdGlvbiBmcm9tQnl0ZUFycmF5KGUpe3ZhciByO3ZhciBmPWUubGVuZ3RoO3ZhciBuPWYlMzt2YXIgaT1bXTt2YXIgbz0xNjM4Mztmb3IodmFyIHU9MCxhPWYtbjt1PGE7dSs9byl7aS5wdXNoKGVuY29kZUNodW5rKGUsdSx1K28+YT9hOnUrbykpfWlmKG49PT0xKXtyPWVbZi0xXTtpLnB1c2godFtyPj4yXSt0W3I8PDQmNjNdK1wiPT1cIil9ZWxzZSBpZihuPT09Mil7cj0oZVtmLTJdPDw4KStlW2YtMV07aS5wdXNoKHRbcj4+MTBdK3Rbcj4+NCY2M10rdFtyPDwyJjYzXStcIj1cIil9cmV0dXJuIGkuam9pbihcIlwiKX19LDcyOmZ1bmN0aW9uKGUscix0KXtcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL3ZhciBmPXQoNjc1KTt2YXIgbj10KDc4Myk7dmFyIGk9dHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFN5bWJvbC5mb3I9PT1cImZ1bmN0aW9uXCI/U3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpOm51bGw7ci5CdWZmZXI9QnVmZmVyO3IuU2xvd0J1ZmZlcj1TbG93QnVmZmVyO3IuSU5TUEVDVF9NQVhfQllURVM9NTA7dmFyIG89MjE0NzQ4MzY0NztyLmtNYXhMZW5ndGg9bztCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVD10eXBlZEFycmF5U3VwcG9ydCgpO2lmKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCYmdHlwZW9mIGNvbnNvbGUhPT1cInVuZGVmaW5lZFwiJiZ0eXBlb2YgY29uc29sZS5lcnJvcj09PVwiZnVuY3Rpb25cIil7Y29uc29sZS5lcnJvcihcIlRoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSBcIitcImBidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuXCIpfWZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0KCl7dHJ5e3ZhciBlPW5ldyBVaW50OEFycmF5KDEpO3ZhciByPXtmb286ZnVuY3Rpb24oKXtyZXR1cm4gNDJ9fTtPYmplY3Quc2V0UHJvdG90eXBlT2YocixVaW50OEFycmF5LnByb3RvdHlwZSk7T2JqZWN0LnNldFByb3RvdHlwZU9mKGUscik7cmV0dXJuIGUuZm9vKCk9PT00Mn1jYXRjaChlKXtyZXR1cm4gZmFsc2V9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLFwicGFyZW50XCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtpZighQnVmZmVyLmlzQnVmZmVyKHRoaXMpKXJldHVybiB1bmRlZmluZWQ7cmV0dXJuIHRoaXMuYnVmZmVyfX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLFwib2Zmc2V0XCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtpZighQnVmZmVyLmlzQnVmZmVyKHRoaXMpKXJldHVybiB1bmRlZmluZWQ7cmV0dXJuIHRoaXMuYnl0ZU9mZnNldH19KTtmdW5jdGlvbiBjcmVhdGVCdWZmZXIoZSl7aWYoZT5vKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJytlKydcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKX12YXIgcj1uZXcgVWludDhBcnJheShlKTtPYmplY3Quc2V0UHJvdG90eXBlT2YocixCdWZmZXIucHJvdG90eXBlKTtyZXR1cm4gcn1mdW5jdGlvbiBCdWZmZXIoZSxyLHQpe2lmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7aWYodHlwZW9mIHI9PT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcicpfXJldHVybiBhbGxvY1Vuc2FmZShlKX1yZXR1cm4gZnJvbShlLHIsdCl9QnVmZmVyLnBvb2xTaXplPTgxOTI7ZnVuY3Rpb24gZnJvbShlLHIsdCl7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtyZXR1cm4gZnJvbVN0cmluZyhlLHIpfWlmKEFycmF5QnVmZmVyLmlzVmlldyhlKSl7cmV0dXJuIGZyb21BcnJheUxpa2UoZSl9aWYoZT09bnVsbCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIFwiK1wib3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfWlmKGlzSW5zdGFuY2UoZSxBcnJheUJ1ZmZlcil8fGUmJmlzSW5zdGFuY2UoZS5idWZmZXIsQXJyYXlCdWZmZXIpKXtyZXR1cm4gZnJvbUFycmF5QnVmZmVyKGUscix0KX1pZih0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiJiYoaXNJbnN0YW5jZShlLFNoYXJlZEFycmF5QnVmZmVyKXx8ZSYmaXNJbnN0YW5jZShlLmJ1ZmZlcixTaGFyZWRBcnJheUJ1ZmZlcikpKXtyZXR1cm4gZnJvbUFycmF5QnVmZmVyKGUscix0KX1pZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyl9dmFyIGY9ZS52YWx1ZU9mJiZlLnZhbHVlT2YoKTtpZihmIT1udWxsJiZmIT09ZSl7cmV0dXJuIEJ1ZmZlci5mcm9tKGYscix0KX12YXIgbj1mcm9tT2JqZWN0KGUpO2lmKG4pcmV0dXJuIG47aWYodHlwZW9mIFN5bWJvbCE9PVwidW5kZWZpbmVkXCImJlN5bWJvbC50b1ByaW1pdGl2ZSE9bnVsbCYmdHlwZW9mIGVbU3ltYm9sLnRvUHJpbWl0aXZlXT09PVwiZnVuY3Rpb25cIil7cmV0dXJuIEJ1ZmZlci5mcm9tKGVbU3ltYm9sLnRvUHJpbWl0aXZlXShcInN0cmluZ1wiKSxyLHQpfXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBcIitcIm9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX1CdWZmZXIuZnJvbT1mdW5jdGlvbihlLHIsdCl7cmV0dXJuIGZyb20oZSxyLHQpfTtPYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSxVaW50OEFycmF5LnByb3RvdHlwZSk7T2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlcixVaW50OEFycmF5KTtmdW5jdGlvbiBhc3NlcnRTaXplKGUpe2lmKHR5cGVvZiBlIT09XCJudW1iZXJcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpfWVsc2UgaWYoZTwwKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJytlKydcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKX19ZnVuY3Rpb24gYWxsb2MoZSxyLHQpe2Fzc2VydFNpemUoZSk7aWYoZTw9MCl7cmV0dXJuIGNyZWF0ZUJ1ZmZlcihlKX1pZihyIT09dW5kZWZpbmVkKXtyZXR1cm4gdHlwZW9mIHQ9PT1cInN0cmluZ1wiP2NyZWF0ZUJ1ZmZlcihlKS5maWxsKHIsdCk6Y3JlYXRlQnVmZmVyKGUpLmZpbGwocil9cmV0dXJuIGNyZWF0ZUJ1ZmZlcihlKX1CdWZmZXIuYWxsb2M9ZnVuY3Rpb24oZSxyLHQpe3JldHVybiBhbGxvYyhlLHIsdCl9O2Z1bmN0aW9uIGFsbG9jVW5zYWZlKGUpe2Fzc2VydFNpemUoZSk7cmV0dXJuIGNyZWF0ZUJ1ZmZlcihlPDA/MDpjaGVja2VkKGUpfDApfUJ1ZmZlci5hbGxvY1Vuc2FmZT1mdW5jdGlvbihlKXtyZXR1cm4gYWxsb2NVbnNhZmUoZSl9O0J1ZmZlci5hbGxvY1Vuc2FmZVNsb3c9ZnVuY3Rpb24oZSl7cmV0dXJuIGFsbG9jVW5zYWZlKGUpfTtmdW5jdGlvbiBmcm9tU3RyaW5nKGUscil7aWYodHlwZW9mIHIhPT1cInN0cmluZ1wifHxyPT09XCJcIil7cj1cInV0ZjhcIn1pZighQnVmZmVyLmlzRW5jb2Rpbmcocikpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIityKX12YXIgdD1ieXRlTGVuZ3RoKGUscil8MDt2YXIgZj1jcmVhdGVCdWZmZXIodCk7dmFyIG49Zi53cml0ZShlLHIpO2lmKG4hPT10KXtmPWYuc2xpY2UoMCxuKX1yZXR1cm4gZn1mdW5jdGlvbiBmcm9tQXJyYXlMaWtlKGUpe3ZhciByPWUubGVuZ3RoPDA/MDpjaGVja2VkKGUubGVuZ3RoKXwwO3ZhciB0PWNyZWF0ZUJ1ZmZlcihyKTtmb3IodmFyIGY9MDtmPHI7Zis9MSl7dFtmXT1lW2ZdJjI1NX1yZXR1cm4gdH1mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIoZSxyLHQpe2lmKHI8MHx8ZS5ieXRlTGVuZ3RoPHIpe3Rocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpfWlmKGUuYnl0ZUxlbmd0aDxyKyh0fHwwKSl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyl9dmFyIGY7aWYocj09PXVuZGVmaW5lZCYmdD09PXVuZGVmaW5lZCl7Zj1uZXcgVWludDhBcnJheShlKX1lbHNlIGlmKHQ9PT11bmRlZmluZWQpe2Y9bmV3IFVpbnQ4QXJyYXkoZSxyKX1lbHNle2Y9bmV3IFVpbnQ4QXJyYXkoZSxyLHQpfU9iamVjdC5zZXRQcm90b3R5cGVPZihmLEJ1ZmZlci5wcm90b3R5cGUpO3JldHVybiBmfWZ1bmN0aW9uIGZyb21PYmplY3QoZSl7aWYoQnVmZmVyLmlzQnVmZmVyKGUpKXt2YXIgcj1jaGVja2VkKGUubGVuZ3RoKXwwO3ZhciB0PWNyZWF0ZUJ1ZmZlcihyKTtpZih0Lmxlbmd0aD09PTApe3JldHVybiB0fWUuY29weSh0LDAsMCxyKTtyZXR1cm4gdH1pZihlLmxlbmd0aCE9PXVuZGVmaW5lZCl7aWYodHlwZW9mIGUubGVuZ3RoIT09XCJudW1iZXJcInx8bnVtYmVySXNOYU4oZS5sZW5ndGgpKXtyZXR1cm4gY3JlYXRlQnVmZmVyKDApfXJldHVybiBmcm9tQXJyYXlMaWtlKGUpfWlmKGUudHlwZT09PVwiQnVmZmVyXCImJkFycmF5LmlzQXJyYXkoZS5kYXRhKSl7cmV0dXJuIGZyb21BcnJheUxpa2UoZS5kYXRhKX19ZnVuY3Rpb24gY2hlY2tlZChlKXtpZihlPj1vKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gXCIrXCJzaXplOiAweFwiK28udG9TdHJpbmcoMTYpK1wiIGJ5dGVzXCIpfXJldHVybiBlfDB9ZnVuY3Rpb24gU2xvd0J1ZmZlcihlKXtpZigrZSE9ZSl7ZT0wfXJldHVybiBCdWZmZXIuYWxsb2MoK2UpfUJ1ZmZlci5pc0J1ZmZlcj1mdW5jdGlvbiBpc0J1ZmZlcihlKXtyZXR1cm4gZSE9bnVsbCYmZS5faXNCdWZmZXI9PT10cnVlJiZlIT09QnVmZmVyLnByb3RvdHlwZX07QnVmZmVyLmNvbXBhcmU9ZnVuY3Rpb24gY29tcGFyZShlLHIpe2lmKGlzSW5zdGFuY2UoZSxVaW50OEFycmF5KSllPUJ1ZmZlci5mcm9tKGUsZS5vZmZzZXQsZS5ieXRlTGVuZ3RoKTtpZihpc0luc3RhbmNlKHIsVWludDhBcnJheSkpcj1CdWZmZXIuZnJvbShyLHIub2Zmc2V0LHIuYnl0ZUxlbmd0aCk7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKXx8IUJ1ZmZlci5pc0J1ZmZlcihyKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheScpfWlmKGU9PT1yKXJldHVybiAwO3ZhciB0PWUubGVuZ3RoO3ZhciBmPXIubGVuZ3RoO2Zvcih2YXIgbj0wLGk9TWF0aC5taW4odCxmKTtuPGk7KytuKXtpZihlW25dIT09cltuXSl7dD1lW25dO2Y9cltuXTticmVha319aWYodDxmKXJldHVybi0xO2lmKGY8dClyZXR1cm4gMTtyZXR1cm4gMH07QnVmZmVyLmlzRW5jb2Rpbmc9ZnVuY3Rpb24gaXNFbmNvZGluZyhlKXtzd2l0Y2goU3RyaW5nKGUpLnRvTG93ZXJDYXNlKCkpe2Nhc2VcImhleFwiOmNhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOmNhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6Y2FzZVwiYmFzZTY0XCI6Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHRydWU7ZGVmYXVsdDpyZXR1cm4gZmFsc2V9fTtCdWZmZXIuY29uY2F0PWZ1bmN0aW9uIGNvbmNhdChlLHIpe2lmKCFBcnJheS5pc0FycmF5KGUpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKX1pZihlLmxlbmd0aD09PTApe3JldHVybiBCdWZmZXIuYWxsb2MoMCl9dmFyIHQ7aWYocj09PXVuZGVmaW5lZCl7cj0wO2Zvcih0PTA7dDxlLmxlbmd0aDsrK3Qpe3IrPWVbdF0ubGVuZ3RofX12YXIgZj1CdWZmZXIuYWxsb2NVbnNhZmUocik7dmFyIG49MDtmb3IodD0wO3Q8ZS5sZW5ndGg7Kyt0KXt2YXIgaT1lW3RdO2lmKGlzSW5zdGFuY2UoaSxVaW50OEFycmF5KSl7aT1CdWZmZXIuZnJvbShpKX1pZighQnVmZmVyLmlzQnVmZmVyKGkpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKX1pLmNvcHkoZixuKTtuKz1pLmxlbmd0aH1yZXR1cm4gZn07ZnVuY3Rpb24gYnl0ZUxlbmd0aChlLHIpe2lmKEJ1ZmZlci5pc0J1ZmZlcihlKSl7cmV0dXJuIGUubGVuZ3RofWlmKEFycmF5QnVmZmVyLmlzVmlldyhlKXx8aXNJbnN0YW5jZShlLEFycmF5QnVmZmVyKSl7cmV0dXJuIGUuYnl0ZUxlbmd0aH1pZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnK1wiUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9dmFyIHQ9ZS5sZW5ndGg7dmFyIGY9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl09PT10cnVlO2lmKCFmJiZ0PT09MClyZXR1cm4gMDt2YXIgbj1mYWxzZTtmb3IoOzspe3N3aXRjaChyKXtjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiB0O2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiB1dGY4VG9CeXRlcyhlKS5sZW5ndGg7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHQqMjtjYXNlXCJoZXhcIjpyZXR1cm4gdD4+PjE7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGJhc2U2NFRvQnl0ZXMoZSkubGVuZ3RoO2RlZmF1bHQ6aWYobil7cmV0dXJuIGY/LTE6dXRmOFRvQnl0ZXMoZSkubGVuZ3RofXI9KFwiXCIrcikudG9Mb3dlckNhc2UoKTtuPXRydWV9fX1CdWZmZXIuYnl0ZUxlbmd0aD1ieXRlTGVuZ3RoO2Z1bmN0aW9uIHNsb3dUb1N0cmluZyhlLHIsdCl7dmFyIGY9ZmFsc2U7aWYocj09PXVuZGVmaW5lZHx8cjwwKXtyPTB9aWYocj50aGlzLmxlbmd0aCl7cmV0dXJuXCJcIn1pZih0PT09dW5kZWZpbmVkfHx0PnRoaXMubGVuZ3RoKXt0PXRoaXMubGVuZ3RofWlmKHQ8PTApe3JldHVyblwiXCJ9dD4+Pj0wO3I+Pj49MDtpZih0PD1yKXtyZXR1cm5cIlwifWlmKCFlKWU9XCJ1dGY4XCI7d2hpbGUodHJ1ZSl7c3dpdGNoKGUpe2Nhc2VcImhleFwiOnJldHVybiBoZXhTbGljZSh0aGlzLHIsdCk7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHV0ZjhTbGljZSh0aGlzLHIsdCk7Y2FzZVwiYXNjaWlcIjpyZXR1cm4gYXNjaWlTbGljZSh0aGlzLHIsdCk7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIGxhdGluMVNsaWNlKHRoaXMscix0KTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gYmFzZTY0U2xpY2UodGhpcyxyLHQpO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB1dGYxNmxlU2xpY2UodGhpcyxyLHQpO2RlZmF1bHQ6aWYoZil0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZSk7ZT0oZStcIlwiKS50b0xvd2VyQ2FzZSgpO2Y9dHJ1ZX19fUJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyPXRydWU7ZnVuY3Rpb24gc3dhcChlLHIsdCl7dmFyIGY9ZVtyXTtlW3JdPWVbdF07ZVt0XT1mfUJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2PWZ1bmN0aW9uIHN3YXAxNigpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGUlMiE9PTApe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHNcIil9Zm9yKHZhciByPTA7cjxlO3IrPTIpe3N3YXAodGhpcyxyLHIrMSl9cmV0dXJuIHRoaXN9O0J1ZmZlci5wcm90b3R5cGUuc3dhcDMyPWZ1bmN0aW9uIHN3YXAzMigpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGUlNCE9PTApe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHNcIil9Zm9yKHZhciByPTA7cjxlO3IrPTQpe3N3YXAodGhpcyxyLHIrMyk7c3dhcCh0aGlzLHIrMSxyKzIpfXJldHVybiB0aGlzfTtCdWZmZXIucHJvdG90eXBlLnN3YXA2ND1mdW5jdGlvbiBzd2FwNjQoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTghPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz04KXtzd2FwKHRoaXMscixyKzcpO3N3YXAodGhpcyxyKzEscis2KTtzd2FwKHRoaXMscisyLHIrNSk7c3dhcCh0aGlzLHIrMyxyKzQpfXJldHVybiB0aGlzfTtCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uIHRvU3RyaW5nKCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZT09PTApcmV0dXJuXCJcIjtpZihhcmd1bWVudHMubGVuZ3RoPT09MClyZXR1cm4gdXRmOFNsaWNlKHRoaXMsMCxlKTtyZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07QnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZz1CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nO0J1ZmZlci5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uIGVxdWFscyhlKXtpZighQnVmZmVyLmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyXCIpO2lmKHRoaXM9PT1lKXJldHVybiB0cnVlO3JldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLGUpPT09MH07QnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0PWZ1bmN0aW9uIGluc3BlY3QoKXt2YXIgZT1cIlwiO3ZhciB0PXIuSU5TUEVDVF9NQVhfQllURVM7ZT10aGlzLnRvU3RyaW5nKFwiaGV4XCIsMCx0KS5yZXBsYWNlKC8oLnsyfSkvZyxcIiQxIFwiKS50cmltKCk7aWYodGhpcy5sZW5ndGg+dCllKz1cIiAuLi4gXCI7cmV0dXJuXCI8QnVmZmVyIFwiK2UrXCI+XCJ9O2lmKGkpe0J1ZmZlci5wcm90b3R5cGVbaV09QnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0fUJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZT1mdW5jdGlvbiBjb21wYXJlKGUscix0LGYsbil7aWYoaXNJbnN0YW5jZShlLFVpbnQ4QXJyYXkpKXtlPUJ1ZmZlci5mcm9tKGUsZS5vZmZzZXQsZS5ieXRlTGVuZ3RoKX1pZighQnVmZmVyLmlzQnVmZmVyKGUpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnK1wiUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9aWYocj09PXVuZGVmaW5lZCl7cj0wfWlmKHQ9PT11bmRlZmluZWQpe3Q9ZT9lLmxlbmd0aDowfWlmKGY9PT11bmRlZmluZWQpe2Y9MH1pZihuPT09dW5kZWZpbmVkKXtuPXRoaXMubGVuZ3RofWlmKHI8MHx8dD5lLmxlbmd0aHx8ZjwwfHxuPnRoaXMubGVuZ3RoKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByYW5nZSBpbmRleFwiKX1pZihmPj1uJiZyPj10KXtyZXR1cm4gMH1pZihmPj1uKXtyZXR1cm4tMX1pZihyPj10KXtyZXR1cm4gMX1yPj4+PTA7dD4+Pj0wO2Y+Pj49MDtuPj4+PTA7aWYodGhpcz09PWUpcmV0dXJuIDA7dmFyIGk9bi1mO3ZhciBvPXQtcjt2YXIgdT1NYXRoLm1pbihpLG8pO3ZhciBhPXRoaXMuc2xpY2UoZixuKTt2YXIgcz1lLnNsaWNlKHIsdCk7Zm9yKHZhciBoPTA7aDx1OysraCl7aWYoYVtoXSE9PXNbaF0pe2k9YVtoXTtvPXNbaF07YnJlYWt9fWlmKGk8bylyZXR1cm4tMTtpZihvPGkpcmV0dXJuIDE7cmV0dXJuIDB9O2Z1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mKGUscix0LGYsbil7aWYoZS5sZW5ndGg9PT0wKXJldHVybi0xO2lmKHR5cGVvZiB0PT09XCJzdHJpbmdcIil7Zj10O3Q9MH1lbHNlIGlmKHQ+MjE0NzQ4MzY0Nyl7dD0yMTQ3NDgzNjQ3fWVsc2UgaWYodDwtMjE0NzQ4MzY0OCl7dD0tMjE0NzQ4MzY0OH10PSt0O2lmKG51bWJlcklzTmFOKHQpKXt0PW4/MDplLmxlbmd0aC0xfWlmKHQ8MCl0PWUubGVuZ3RoK3Q7aWYodD49ZS5sZW5ndGgpe2lmKG4pcmV0dXJuLTE7ZWxzZSB0PWUubGVuZ3RoLTF9ZWxzZSBpZih0PDApe2lmKG4pdD0wO2Vsc2UgcmV0dXJuLTF9aWYodHlwZW9mIHI9PT1cInN0cmluZ1wiKXtyPUJ1ZmZlci5mcm9tKHIsZil9aWYoQnVmZmVyLmlzQnVmZmVyKHIpKXtpZihyLmxlbmd0aD09PTApe3JldHVybi0xfXJldHVybiBhcnJheUluZGV4T2YoZSxyLHQsZixuKX1lbHNlIGlmKHR5cGVvZiByPT09XCJudW1iZXJcIil7cj1yJjI1NTtpZih0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZj09PVwiZnVuY3Rpb25cIil7aWYobil7cmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChlLHIsdCl9ZWxzZXtyZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChlLHIsdCl9fXJldHVybiBhcnJheUluZGV4T2YoZSxbcl0sdCxmLG4pfXRocm93IG5ldyBUeXBlRXJyb3IoXCJ2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXJcIil9ZnVuY3Rpb24gYXJyYXlJbmRleE9mKGUscix0LGYsbil7dmFyIGk9MTt2YXIgbz1lLmxlbmd0aDt2YXIgdT1yLmxlbmd0aDtpZihmIT09dW5kZWZpbmVkKXtmPVN0cmluZyhmKS50b0xvd2VyQ2FzZSgpO2lmKGY9PT1cInVjczJcInx8Zj09PVwidWNzLTJcInx8Zj09PVwidXRmMTZsZVwifHxmPT09XCJ1dGYtMTZsZVwiKXtpZihlLmxlbmd0aDwyfHxyLmxlbmd0aDwyKXtyZXR1cm4tMX1pPTI7by89Mjt1Lz0yO3QvPTJ9fWZ1bmN0aW9uIHJlYWQoZSxyKXtpZihpPT09MSl7cmV0dXJuIGVbcl19ZWxzZXtyZXR1cm4gZS5yZWFkVUludDE2QkUocippKX19dmFyIGE7aWYobil7dmFyIHM9LTE7Zm9yKGE9dDthPG87YSsrKXtpZihyZWFkKGUsYSk9PT1yZWFkKHIscz09PS0xPzA6YS1zKSl7aWYocz09PS0xKXM9YTtpZihhLXMrMT09PXUpcmV0dXJuIHMqaX1lbHNle2lmKHMhPT0tMSlhLT1hLXM7cz0tMX19fWVsc2V7aWYodCt1Pm8pdD1vLXU7Zm9yKGE9dDthPj0wO2EtLSl7dmFyIGg9dHJ1ZTtmb3IodmFyIGM9MDtjPHU7YysrKXtpZihyZWFkKGUsYStjKSE9PXJlYWQocixjKSl7aD1mYWxzZTticmVha319aWYoaClyZXR1cm4gYX19cmV0dXJuLTF9QnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcz1mdW5jdGlvbiBpbmNsdWRlcyhlLHIsdCl7cmV0dXJuIHRoaXMuaW5kZXhPZihlLHIsdCkhPT0tMX07QnVmZmVyLnByb3RvdHlwZS5pbmRleE9mPWZ1bmN0aW9uIGluZGV4T2YoZSxyLHQpe3JldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLGUscix0LHRydWUpfTtCdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mPWZ1bmN0aW9uIGxhc3RJbmRleE9mKGUscix0KXtyZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcyxlLHIsdCxmYWxzZSl9O2Z1bmN0aW9uIGhleFdyaXRlKGUscix0LGYpe3Q9TnVtYmVyKHQpfHwwO3ZhciBuPWUubGVuZ3RoLXQ7aWYoIWYpe2Y9bn1lbHNle2Y9TnVtYmVyKGYpO2lmKGY+bil7Zj1ufX12YXIgaT1yLmxlbmd0aDtpZihmPmkvMil7Zj1pLzJ9Zm9yKHZhciBvPTA7bzxmOysrbyl7dmFyIHU9cGFyc2VJbnQoci5zdWJzdHIobyoyLDIpLDE2KTtpZihudW1iZXJJc05hTih1KSlyZXR1cm4gbztlW3Qrb109dX1yZXR1cm4gb31mdW5jdGlvbiB1dGY4V3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMocixlLmxlbmd0aC10KSxlLHQsZil9ZnVuY3Rpb24gYXNjaWlXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMociksZSx0LGYpfWZ1bmN0aW9uIGxhdGluMVdyaXRlKGUscix0LGYpe3JldHVybiBhc2NpaVdyaXRlKGUscix0LGYpfWZ1bmN0aW9uIGJhc2U2NFdyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMociksZSx0LGYpfWZ1bmN0aW9uIHVjczJXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhyLGUubGVuZ3RoLXQpLGUsdCxmKX1CdWZmZXIucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uIHdyaXRlKGUscix0LGYpe2lmKHI9PT11bmRlZmluZWQpe2Y9XCJ1dGY4XCI7dD10aGlzLmxlbmd0aDtyPTB9ZWxzZSBpZih0PT09dW5kZWZpbmVkJiZ0eXBlb2Ygcj09PVwic3RyaW5nXCIpe2Y9cjt0PXRoaXMubGVuZ3RoO3I9MH1lbHNlIGlmKGlzRmluaXRlKHIpKXtyPXI+Pj4wO2lmKGlzRmluaXRlKHQpKXt0PXQ+Pj4wO2lmKGY9PT11bmRlZmluZWQpZj1cInV0ZjhcIn1lbHNle2Y9dDt0PXVuZGVmaW5lZH19ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZFwiKX12YXIgbj10aGlzLmxlbmd0aC1yO2lmKHQ9PT11bmRlZmluZWR8fHQ+bil0PW47aWYoZS5sZW5ndGg+MCYmKHQ8MHx8cjwwKXx8cj50aGlzLmxlbmd0aCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kc1wiKX1pZighZilmPVwidXRmOFwiO3ZhciBpPWZhbHNlO2Zvcig7Oyl7c3dpdGNoKGYpe2Nhc2VcImhleFwiOnJldHVybiBoZXhXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gdXRmOFdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcImFzY2lpXCI6cmV0dXJuIGFzY2lpV3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcImJhc2U2NFwiOnJldHVybiBiYXNlNjRXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdWNzMldyaXRlKHRoaXMsZSxyLHQpO2RlZmF1bHQ6aWYoaSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZik7Zj0oXCJcIitmKS50b0xvd2VyQ2FzZSgpO2k9dHJ1ZX19fTtCdWZmZXIucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbiB0b0pTT04oKXtyZXR1cm57dHlwZTpcIkJ1ZmZlclwiLGRhdGE6QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyfHx0aGlzLDApfX07ZnVuY3Rpb24gYmFzZTY0U2xpY2UoZSxyLHQpe2lmKHI9PT0wJiZ0PT09ZS5sZW5ndGgpe3JldHVybiBmLmZyb21CeXRlQXJyYXkoZSl9ZWxzZXtyZXR1cm4gZi5mcm9tQnl0ZUFycmF5KGUuc2xpY2Uocix0KSl9fWZ1bmN0aW9uIHV0ZjhTbGljZShlLHIsdCl7dD1NYXRoLm1pbihlLmxlbmd0aCx0KTt2YXIgZj1bXTt2YXIgbj1yO3doaWxlKG48dCl7dmFyIGk9ZVtuXTt2YXIgbz1udWxsO3ZhciB1PWk+MjM5PzQ6aT4yMjM/MzppPjE5MT8yOjE7aWYobit1PD10KXt2YXIgYSxzLGgsYztzd2l0Y2godSl7Y2FzZSAxOmlmKGk8MTI4KXtvPWl9YnJlYWs7Y2FzZSAyOmE9ZVtuKzFdO2lmKChhJjE5Mik9PT0xMjgpe2M9KGkmMzEpPDw2fGEmNjM7aWYoYz4xMjcpe289Y319YnJlYWs7Y2FzZSAzOmE9ZVtuKzFdO3M9ZVtuKzJdO2lmKChhJjE5Mik9PT0xMjgmJihzJjE5Mik9PT0xMjgpe2M9KGkmMTUpPDwxMnwoYSY2Myk8PDZ8cyY2MztpZihjPjIwNDcmJihjPDU1Mjk2fHxjPjU3MzQzKSl7bz1jfX1icmVhaztjYXNlIDQ6YT1lW24rMV07cz1lW24rMl07aD1lW24rM107aWYoKGEmMTkyKT09PTEyOCYmKHMmMTkyKT09PTEyOCYmKGgmMTkyKT09PTEyOCl7Yz0oaSYxNSk8PDE4fChhJjYzKTw8MTJ8KHMmNjMpPDw2fGgmNjM7aWYoYz42NTUzNSYmYzwxMTE0MTEyKXtvPWN9fX19aWYobz09PW51bGwpe289NjU1MzM7dT0xfWVsc2UgaWYobz42NTUzNSl7by09NjU1MzY7Zi5wdXNoKG8+Pj4xMCYxMDIzfDU1Mjk2KTtvPTU2MzIwfG8mMTAyM31mLnB1c2gobyk7bis9dX1yZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KGYpfXZhciB1PTQwOTY7ZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5KGUpe3ZhciByPWUubGVuZ3RoO2lmKHI8PXUpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxlKX12YXIgdD1cIlwiO3ZhciBmPTA7d2hpbGUoZjxyKXt0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxlLnNsaWNlKGYsZis9dSkpfXJldHVybiB0fWZ1bmN0aW9uIGFzY2lpU2xpY2UoZSxyLHQpe3ZhciBmPVwiXCI7dD1NYXRoLm1pbihlLmxlbmd0aCx0KTtmb3IodmFyIG49cjtuPHQ7KytuKXtmKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbbl0mMTI3KX1yZXR1cm4gZn1mdW5jdGlvbiBsYXRpbjFTbGljZShlLHIsdCl7dmFyIGY9XCJcIjt0PU1hdGgubWluKGUubGVuZ3RoLHQpO2Zvcih2YXIgbj1yO248dDsrK24pe2YrPVN0cmluZy5mcm9tQ2hhckNvZGUoZVtuXSl9cmV0dXJuIGZ9ZnVuY3Rpb24gaGV4U2xpY2UoZSxyLHQpe3ZhciBmPWUubGVuZ3RoO2lmKCFyfHxyPDApcj0wO2lmKCF0fHx0PDB8fHQ+Zil0PWY7dmFyIG49XCJcIjtmb3IodmFyIGk9cjtpPHQ7KytpKXtuKz1zW2VbaV1dfXJldHVybiBufWZ1bmN0aW9uIHV0ZjE2bGVTbGljZShlLHIsdCl7dmFyIGY9ZS5zbGljZShyLHQpO3ZhciBuPVwiXCI7Zm9yKHZhciBpPTA7aTxmLmxlbmd0aDtpKz0yKXtuKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGZbaV0rZltpKzFdKjI1Nil9cmV0dXJuIG59QnVmZmVyLnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbiBzbGljZShlLHIpe3ZhciB0PXRoaXMubGVuZ3RoO2U9fn5lO3I9cj09PXVuZGVmaW5lZD90On5+cjtpZihlPDApe2UrPXQ7aWYoZTwwKWU9MH1lbHNlIGlmKGU+dCl7ZT10fWlmKHI8MCl7cis9dDtpZihyPDApcj0wfWVsc2UgaWYocj50KXtyPXR9aWYocjxlKXI9ZTt2YXIgZj10aGlzLnN1YmFycmF5KGUscik7T2JqZWN0LnNldFByb3RvdHlwZU9mKGYsQnVmZmVyLnByb3RvdHlwZSk7cmV0dXJuIGZ9O2Z1bmN0aW9uIGNoZWNrT2Zmc2V0KGUscix0KXtpZihlJTEhPT0wfHxlPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvZmZzZXQgaXMgbm90IHVpbnRcIik7aWYoZStyPnQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpfUJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRT1mdW5jdGlvbiByZWFkVUludExFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj10aGlzW2VdO3ZhciBuPTE7dmFyIGk9MDt3aGlsZSgrK2k8ciYmKG4qPTI1Nikpe2YrPXRoaXNbZStpXSpufXJldHVybiBmfTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkU9ZnVuY3Rpb24gcmVhZFVJbnRCRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KXtjaGVja09mZnNldChlLHIsdGhpcy5sZW5ndGgpfXZhciBmPXRoaXNbZSstLXJdO3ZhciBuPTE7d2hpbGUocj4wJiYobio9MjU2KSl7Zis9dGhpc1tlKy0tcl0qbn1yZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDg9ZnVuY3Rpb24gcmVhZFVJbnQ4KGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDEsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRT1mdW5jdGlvbiByZWFkVUludDE2TEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMix0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV18dGhpc1tlKzFdPDw4fTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRT1mdW5jdGlvbiByZWFkVUludDE2QkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMix0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV08PDh8dGhpc1tlKzFdfTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRT1mdW5jdGlvbiByZWFkVUludDMyTEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuKHRoaXNbZV18dGhpc1tlKzFdPDw4fHRoaXNbZSsyXTw8MTYpK3RoaXNbZSszXSoxNjc3NzIxNn07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkU9ZnVuY3Rpb24gcmVhZFVJbnQzMkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdKjE2Nzc3MjE2Kyh0aGlzW2UrMV08PDE2fHRoaXNbZSsyXTw8OHx0aGlzW2UrM10pfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRT1mdW5jdGlvbiByZWFkSW50TEUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCljaGVja09mZnNldChlLHIsdGhpcy5sZW5ndGgpO3ZhciBmPXRoaXNbZV07dmFyIG49MTt2YXIgaT0wO3doaWxlKCsraTxyJiYobio9MjU2KSl7Zis9dGhpc1tlK2ldKm59bio9MTI4O2lmKGY+PW4pZi09TWF0aC5wb3coMiw4KnIpO3JldHVybiBmfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRT1mdW5jdGlvbiByZWFkSW50QkUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCljaGVja09mZnNldChlLHIsdGhpcy5sZW5ndGgpO3ZhciBmPXI7dmFyIG49MTt2YXIgaT10aGlzW2UrLS1mXTt3aGlsZShmPjAmJihuKj0yNTYpKXtpKz10aGlzW2UrLS1mXSpufW4qPTEyODtpZihpPj1uKWktPU1hdGgucG93KDIsOCpyKTtyZXR1cm4gaX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OD1mdW5jdGlvbiByZWFkSW50OChlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwxLHRoaXMubGVuZ3RoKTtpZighKHRoaXNbZV0mMTI4KSlyZXR1cm4gdGhpc1tlXTtyZXR1cm4oMjU1LXRoaXNbZV0rMSkqLTF9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEU9ZnVuY3Rpb24gcmVhZEludDE2TEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMix0aGlzLmxlbmd0aCk7dmFyIHQ9dGhpc1tlXXx0aGlzW2UrMV08PDg7cmV0dXJuIHQmMzI3Njg/dHw0Mjk0OTAxNzYwOnR9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkU9ZnVuY3Rpb24gcmVhZEludDE2QkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMix0aGlzLmxlbmd0aCk7dmFyIHQ9dGhpc1tlKzFdfHRoaXNbZV08PDg7cmV0dXJuIHQmMzI3Njg/dHw0Mjk0OTAxNzYwOnR9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEU9ZnVuY3Rpb24gcmVhZEludDMyTEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV18dGhpc1tlKzFdPDw4fHRoaXNbZSsyXTw8MTZ8dGhpc1tlKzNdPDwyNH07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRT1mdW5jdGlvbiByZWFkSW50MzJCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXTw8MjR8dGhpc1tlKzFdPDwxNnx0aGlzW2UrMl08PDh8dGhpc1tlKzNdfTtCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFPWZ1bmN0aW9uIHJlYWRGbG9hdExFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLHRydWUsMjMsNCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkU9ZnVuY3Rpb24gcmVhZEZsb2F0QkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsZmFsc2UsMjMsNCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFPWZ1bmN0aW9uIHJlYWREb3VibGVMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw4LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSx0cnVlLDUyLDgpfTtCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRT1mdW5jdGlvbiByZWFkRG91YmxlQkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsOCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsZmFsc2UsNTIsOCl9O2Z1bmN0aW9uIGNoZWNrSW50KGUscix0LGYsbixpKXtpZighQnVmZmVyLmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO2lmKHI+bnx8cjxpKXRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpO2lmKHQrZj5lLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFPWZ1bmN0aW9uIHdyaXRlVUludExFKGUscix0LGYpe2U9K2U7cj1yPj4+MDt0PXQ+Pj4wO2lmKCFmKXt2YXIgbj1NYXRoLnBvdygyLDgqdCktMTtjaGVja0ludCh0aGlzLGUscix0LG4sMCl9dmFyIGk9MTt2YXIgbz0wO3RoaXNbcl09ZSYyNTU7d2hpbGUoKytvPHQmJihpKj0yNTYpKXt0aGlzW3Irb109ZS9pJjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFPWZ1bmN0aW9uIHdyaXRlVUludEJFKGUscix0LGYpe2U9K2U7cj1yPj4+MDt0PXQ+Pj4wO2lmKCFmKXt2YXIgbj1NYXRoLnBvdygyLDgqdCktMTtjaGVja0ludCh0aGlzLGUscix0LG4sMCl9dmFyIGk9dC0xO3ZhciBvPTE7dGhpc1tyK2ldPWUmMjU1O3doaWxlKC0taT49MCYmKG8qPTI1Nikpe3RoaXNbcitpXT1lL28mMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OD1mdW5jdGlvbiB3cml0ZVVJbnQ4KGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMSwyNTUsMCk7dGhpc1tyXT1lJjI1NTtyZXR1cm4gcisxfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEU9ZnVuY3Rpb24gd3JpdGVVSW50MTZMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDIsNjU1MzUsMCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFPWZ1bmN0aW9uIHdyaXRlVUludDE2QkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDY1NTM1LDApO3RoaXNbcl09ZT4+Pjg7dGhpc1tyKzFdPWUmMjU1O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRT1mdW5jdGlvbiB3cml0ZVVJbnQzMkxFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsNCw0Mjk0OTY3Mjk1LDApO3RoaXNbciszXT1lPj4+MjQ7dGhpc1tyKzJdPWU+Pj4xNjt0aGlzW3IrMV09ZT4+Pjg7dGhpc1tyXT1lJjI1NTtyZXR1cm4gcis0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkU9ZnVuY3Rpb24gd3JpdGVVSW50MzJCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsNDI5NDk2NzI5NSwwKTt0aGlzW3JdPWU+Pj4yNDt0aGlzW3IrMV09ZT4+PjE2O3RoaXNbcisyXT1lPj4+ODt0aGlzW3IrM109ZSYyNTU7cmV0dXJuIHIrNH07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFPWZ1bmN0aW9uIHdyaXRlSW50TEUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO2lmKCFmKXt2YXIgbj1NYXRoLnBvdygyLDgqdC0xKTtjaGVja0ludCh0aGlzLGUscix0LG4tMSwtbil9dmFyIGk9MDt2YXIgbz0xO3ZhciB1PTA7dGhpc1tyXT1lJjI1NTt3aGlsZSgrK2k8dCYmKG8qPTI1Nikpe2lmKGU8MCYmdT09PTAmJnRoaXNbcitpLTFdIT09MCl7dT0xfXRoaXNbcitpXT0oZS9vPj4wKS11JjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkU9ZnVuY3Rpb24gd3JpdGVJbnRCRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0LTEpO2NoZWNrSW50KHRoaXMsZSxyLHQsbi0xLC1uKX12YXIgaT10LTE7dmFyIG89MTt2YXIgdT0wO3RoaXNbcitpXT1lJjI1NTt3aGlsZSgtLWk+PTAmJihvKj0yNTYpKXtpZihlPDAmJnU9PT0wJiZ0aGlzW3IraSsxXSE9PTApe3U9MX10aGlzW3IraV09KGUvbz4+MCktdSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDg9ZnVuY3Rpb24gd3JpdGVJbnQ4KGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMSwxMjcsLTEyOCk7aWYoZTwwKWU9MjU1K2UrMTt0aGlzW3JdPWUmMjU1O3JldHVybiByKzF9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFPWZ1bmN0aW9uIHdyaXRlSW50MTZMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDIsMzI3NjcsLTMyNzY4KTt0aGlzW3JdPWUmMjU1O3RoaXNbcisxXT1lPj4+ODtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRT1mdW5jdGlvbiB3cml0ZUludDE2QkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDMyNzY3LC0zMjc2OCk7dGhpc1tyXT1lPj4+ODt0aGlzW3IrMV09ZSYyNTU7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEU9ZnVuY3Rpb24gd3JpdGVJbnQzMkxFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KTt0aGlzW3JdPWUmMjU1O3RoaXNbcisxXT1lPj4+ODt0aGlzW3IrMl09ZT4+PjE2O3RoaXNbciszXT1lPj4+MjQ7cmV0dXJuIHIrNH07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkU9ZnVuY3Rpb24gd3JpdGVJbnQzMkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KTtpZihlPDApZT00Mjk0OTY3Mjk1K2UrMTt0aGlzW3JdPWU+Pj4yNDt0aGlzW3IrMV09ZT4+PjE2O3RoaXNbcisyXT1lPj4+ODt0aGlzW3IrM109ZSYyNTU7cmV0dXJuIHIrNH07ZnVuY3Rpb24gY2hlY2tJRUVFNzU0KGUscix0LGYsbixpKXtpZih0K2Y+ZS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7aWYodDwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpfWZ1bmN0aW9uIHdyaXRlRmxvYXQoZSxyLHQsZixpKXtyPStyO3Q9dD4+PjA7aWYoIWkpe2NoZWNrSUVFRTc1NChlLHIsdCw0LDM0MDI4MjM0NjYzODUyODg2ZTIyLC0zNDAyODIzNDY2Mzg1Mjg4NmUyMil9bi53cml0ZShlLHIsdCxmLDIzLDQpO3JldHVybiB0KzR9QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEU9ZnVuY3Rpb24gd3JpdGVGbG9hdExFKGUscix0KXtyZXR1cm4gd3JpdGVGbG9hdCh0aGlzLGUscix0cnVlLHQpfTtCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRT1mdW5jdGlvbiB3cml0ZUZsb2F0QkUoZSxyLHQpe3JldHVybiB3cml0ZUZsb2F0KHRoaXMsZSxyLGZhbHNlLHQpfTtmdW5jdGlvbiB3cml0ZURvdWJsZShlLHIsdCxmLGkpe3I9K3I7dD10Pj4+MDtpZighaSl7Y2hlY2tJRUVFNzU0KGUscix0LDgsMTc5NzY5MzEzNDg2MjMxNTdlMjkyLC0xNzk3NjkzMTM0ODYyMzE1N2UyOTIpfW4ud3JpdGUoZSxyLHQsZiw1Miw4KTtyZXR1cm4gdCs4fUJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRT1mdW5jdGlvbiB3cml0ZURvdWJsZUxFKGUscix0KXtyZXR1cm4gd3JpdGVEb3VibGUodGhpcyxlLHIsdHJ1ZSx0KX07QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFPWZ1bmN0aW9uIHdyaXRlRG91YmxlQkUoZSxyLHQpe3JldHVybiB3cml0ZURvdWJsZSh0aGlzLGUscixmYWxzZSx0KX07QnVmZmVyLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uIGNvcHkoZSxyLHQsZil7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyXCIpO2lmKCF0KXQ9MDtpZighZiYmZiE9PTApZj10aGlzLmxlbmd0aDtpZihyPj1lLmxlbmd0aClyPWUubGVuZ3RoO2lmKCFyKXI9MDtpZihmPjAmJmY8dClmPXQ7aWYoZj09PXQpcmV0dXJuIDA7aWYoZS5sZW5ndGg9PT0wfHx0aGlzLmxlbmd0aD09PTApcmV0dXJuIDA7aWYocjwwKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInRhcmdldFN0YXJ0IG91dCBvZiBib3VuZHNcIil9aWYodDwwfHx0Pj10aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtpZihmPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzb3VyY2VFbmQgb3V0IG9mIGJvdW5kc1wiKTtpZihmPnRoaXMubGVuZ3RoKWY9dGhpcy5sZW5ndGg7aWYoZS5sZW5ndGgtcjxmLXQpe2Y9ZS5sZW5ndGgtcit0fXZhciBuPWYtdDtpZih0aGlzPT09ZSYmdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW49PT1cImZ1bmN0aW9uXCIpe3RoaXMuY29weVdpdGhpbihyLHQsZil9ZWxzZSBpZih0aGlzPT09ZSYmdDxyJiZyPGYpe2Zvcih2YXIgaT1uLTE7aT49MDstLWkpe2VbaStyXT10aGlzW2krdF19fWVsc2V7VWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoZSx0aGlzLnN1YmFycmF5KHQsZikscil9cmV0dXJuIG59O0J1ZmZlci5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbiBmaWxsKGUscix0LGYpe2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7aWYodHlwZW9mIHI9PT1cInN0cmluZ1wiKXtmPXI7cj0wO3Q9dGhpcy5sZW5ndGh9ZWxzZSBpZih0eXBlb2YgdD09PVwic3RyaW5nXCIpe2Y9dDt0PXRoaXMubGVuZ3RofWlmKGYhPT11bmRlZmluZWQmJnR5cGVvZiBmIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcImVuY29kaW5nIG11c3QgYmUgYSBzdHJpbmdcIil9aWYodHlwZW9mIGY9PT1cInN0cmluZ1wiJiYhQnVmZmVyLmlzRW5jb2RpbmcoZikpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitmKX1pZihlLmxlbmd0aD09PTEpe3ZhciBuPWUuY2hhckNvZGVBdCgwKTtpZihmPT09XCJ1dGY4XCImJm48MTI4fHxmPT09XCJsYXRpbjFcIil7ZT1ufX19ZWxzZSBpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe2U9ZSYyNTV9ZWxzZSBpZih0eXBlb2YgZT09PVwiYm9vbGVhblwiKXtlPU51bWJlcihlKX1pZihyPDB8fHRoaXMubGVuZ3RoPHJ8fHRoaXMubGVuZ3RoPHQpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiT3V0IG9mIHJhbmdlIGluZGV4XCIpfWlmKHQ8PXIpe3JldHVybiB0aGlzfXI9cj4+PjA7dD10PT09dW5kZWZpbmVkP3RoaXMubGVuZ3RoOnQ+Pj4wO2lmKCFlKWU9MDt2YXIgaTtpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe2ZvcihpPXI7aTx0OysraSl7dGhpc1tpXT1lfX1lbHNle3ZhciBvPUJ1ZmZlci5pc0J1ZmZlcihlKT9lOkJ1ZmZlci5mcm9tKGUsZik7dmFyIHU9by5sZW5ndGg7aWYodT09PTApe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJyl9Zm9yKGk9MDtpPHQtcjsrK2kpe3RoaXNbaStyXT1vW2kldV19fXJldHVybiB0aGlzfTt2YXIgYT0vW14rLzAtOUEtWmEtei1fXS9nO2Z1bmN0aW9uIGJhc2U2NGNsZWFuKGUpe2U9ZS5zcGxpdChcIj1cIilbMF07ZT1lLnRyaW0oKS5yZXBsYWNlKGEsXCJcIik7aWYoZS5sZW5ndGg8MilyZXR1cm5cIlwiO3doaWxlKGUubGVuZ3RoJTQhPT0wKXtlPWUrXCI9XCJ9cmV0dXJuIGV9ZnVuY3Rpb24gdXRmOFRvQnl0ZXMoZSxyKXtyPXJ8fEluZmluaXR5O3ZhciB0O3ZhciBmPWUubGVuZ3RoO3ZhciBuPW51bGw7dmFyIGk9W107Zm9yKHZhciBvPTA7bzxmOysrbyl7dD1lLmNoYXJDb2RlQXQobyk7aWYodD41NTI5NSYmdDw1NzM0NCl7aWYoIW4pe2lmKHQ+NTYzMTkpe2lmKChyLT0zKT4tMSlpLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfWVsc2UgaWYobysxPT09Zil7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSk7Y29udGludWV9bj10O2NvbnRpbnVlfWlmKHQ8NTYzMjApe2lmKChyLT0zKT4tMSlpLnB1c2goMjM5LDE5MSwxODkpO249dDtjb250aW51ZX10PShuLTU1Mjk2PDwxMHx0LTU2MzIwKSs2NTUzNn1lbHNlIGlmKG4pe2lmKChyLT0zKT4tMSlpLnB1c2goMjM5LDE5MSwxODkpfW49bnVsbDtpZih0PDEyOCl7aWYoKHItPTEpPDApYnJlYWs7aS5wdXNoKHQpfWVsc2UgaWYodDwyMDQ4KXtpZigoci09Mik8MClicmVhaztpLnB1c2godD4+NnwxOTIsdCY2M3wxMjgpfWVsc2UgaWYodDw2NTUzNil7aWYoKHItPTMpPDApYnJlYWs7aS5wdXNoKHQ+PjEyfDIyNCx0Pj42JjYzfDEyOCx0JjYzfDEyOCl9ZWxzZSBpZih0PDExMTQxMTIpe2lmKChyLT00KTwwKWJyZWFrO2kucHVzaCh0Pj4xOHwyNDAsdD4+MTImNjN8MTI4LHQ+PjYmNjN8MTI4LHQmNjN8MTI4KX1lbHNle3Rocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29kZSBwb2ludFwiKX19cmV0dXJuIGl9ZnVuY3Rpb24gYXNjaWlUb0J5dGVzKGUpe3ZhciByPVtdO2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7Kyt0KXtyLnB1c2goZS5jaGFyQ29kZUF0KHQpJjI1NSl9cmV0dXJuIHJ9ZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMoZSxyKXt2YXIgdCxmLG47dmFyIGk9W107Zm9yKHZhciBvPTA7bzxlLmxlbmd0aDsrK28pe2lmKChyLT0yKTwwKWJyZWFrO3Q9ZS5jaGFyQ29kZUF0KG8pO2Y9dD4+ODtuPXQlMjU2O2kucHVzaChuKTtpLnB1c2goZil9cmV0dXJuIGl9ZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyhlKXtyZXR1cm4gZi50b0J5dGVBcnJheShiYXNlNjRjbGVhbihlKSl9ZnVuY3Rpb24gYmxpdEJ1ZmZlcihlLHIsdCxmKXtmb3IodmFyIG49MDtuPGY7KytuKXtpZihuK3Q+PXIubGVuZ3RofHxuPj1lLmxlbmd0aClicmVhaztyW24rdF09ZVtuXX1yZXR1cm4gbn1mdW5jdGlvbiBpc0luc3RhbmNlKGUscil7cmV0dXJuIGUgaW5zdGFuY2VvZiByfHxlIT1udWxsJiZlLmNvbnN0cnVjdG9yIT1udWxsJiZlLmNvbnN0cnVjdG9yLm5hbWUhPW51bGwmJmUuY29uc3RydWN0b3IubmFtZT09PXIubmFtZX1mdW5jdGlvbiBudW1iZXJJc05hTihlKXtyZXR1cm4gZSE9PWV9dmFyIHM9ZnVuY3Rpb24oKXt2YXIgZT1cIjAxMjM0NTY3ODlhYmNkZWZcIjt2YXIgcj1uZXcgQXJyYXkoMjU2KTtmb3IodmFyIHQ9MDt0PDE2OysrdCl7dmFyIGY9dCoxNjtmb3IodmFyIG49MDtuPDE2Oysrbil7cltmK25dPWVbdF0rZVtuXX19cmV0dXJuIHJ9KCl9LDc4MzpmdW5jdGlvbihlLHIpe1xuLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbnIucmVhZD1mdW5jdGlvbihlLHIsdCxmLG4pe3ZhciBpLG87dmFyIHU9bio4LWYtMTt2YXIgYT0oMTw8dSktMTt2YXIgcz1hPj4xO3ZhciBoPS03O3ZhciBjPXQ/bi0xOjA7dmFyIGw9dD8tMToxO3ZhciBwPWVbcitjXTtjKz1sO2k9cCYoMTw8LWgpLTE7cD4+PS1oO2grPXU7Zm9yKDtoPjA7aT1pKjI1NitlW3IrY10sYys9bCxoLT04KXt9bz1pJigxPDwtaCktMTtpPj49LWg7aCs9Zjtmb3IoO2g+MDtvPW8qMjU2K2VbcitjXSxjKz1sLGgtPTgpe31pZihpPT09MCl7aT0xLXN9ZWxzZSBpZihpPT09YSl7cmV0dXJuIG8/TmFOOihwPy0xOjEpKkluZmluaXR5fWVsc2V7bz1vK01hdGgucG93KDIsZik7aT1pLXN9cmV0dXJuKHA/LTE6MSkqbypNYXRoLnBvdygyLGktZil9O3Iud3JpdGU9ZnVuY3Rpb24oZSxyLHQsZixuLGkpe3ZhciBvLHUsYTt2YXIgcz1pKjgtbi0xO3ZhciBoPSgxPDxzKS0xO3ZhciBjPWg+PjE7dmFyIGw9bj09PTIzP01hdGgucG93KDIsLTI0KS1NYXRoLnBvdygyLC03Nyk6MDt2YXIgcD1mPzA6aS0xO3ZhciB5PWY/MTotMTt2YXIgZz1yPDB8fHI9PT0wJiYxL3I8MD8xOjA7cj1NYXRoLmFicyhyKTtpZihpc05hTihyKXx8cj09PUluZmluaXR5KXt1PWlzTmFOKHIpPzE6MDtvPWh9ZWxzZXtvPU1hdGguZmxvb3IoTWF0aC5sb2cocikvTWF0aC5MTjIpO2lmKHIqKGE9TWF0aC5wb3coMiwtbykpPDEpe28tLTthKj0yfWlmKG8rYz49MSl7cis9bC9hfWVsc2V7cis9bCpNYXRoLnBvdygyLDEtYyl9aWYociphPj0yKXtvKys7YS89Mn1pZihvK2M+PWgpe3U9MDtvPWh9ZWxzZSBpZihvK2M+PTEpe3U9KHIqYS0xKSpNYXRoLnBvdygyLG4pO289bytjfWVsc2V7dT1yKk1hdGgucG93KDIsYy0xKSpNYXRoLnBvdygyLG4pO289MH19Zm9yKDtuPj04O2VbdCtwXT11JjI1NSxwKz15LHUvPTI1NixuLT04KXt9bz1vPDxufHU7cys9bjtmb3IoO3M+MDtlW3QrcF09byYyNTUscCs9eSxvLz0yNTYscy09OCl7fWVbdCtwLXldfD1nKjEyOH19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBmPXJbdF07aWYoZiE9PXVuZGVmaW5lZCl7cmV0dXJuIGYuZXhwb3J0c312YXIgbj1yW3RdPXtleHBvcnRzOnt9fTt2YXIgaT10cnVlO3RyeXtlW3RdKG4sbi5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2k9ZmFsc2V9ZmluYWxseXtpZihpKWRlbGV0ZSByW3RdfXJldHVybiBuLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNzIpO21vZHVsZS5leHBvcnRzPXR9KSgpOyJdLCJuYW1lcyI6WyJlIiwiciIsImJ5dGVMZW5ndGgiLCJ0b0J5dGVBcnJheSIsImZyb21CeXRlQXJyYXkiLCJ0IiwiZiIsIm4iLCJVaW50OEFycmF5IiwiQXJyYXkiLCJpIiwibyIsInUiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiZ2V0TGVucyIsIkVycm9yIiwiaW5kZXhPZiIsIl9ieXRlTGVuZ3RoIiwiYSIsInMiLCJoIiwidHJpcGxldFRvQmFzZTY0IiwiZW5jb2RlQ2h1bmsiLCJwdXNoIiwiam9pbiIsIlN5bWJvbCIsImZvciIsIkJ1ZmZlciIsIlNsb3dCdWZmZXIiLCJJTlNQRUNUX01BWF9CWVRFUyIsImtNYXhMZW5ndGgiLCJUWVBFRF9BUlJBWV9TVVBQT1JUIiwidHlwZWRBcnJheVN1cHBvcnQiLCJjb25zb2xlIiwiZXJyb3IiLCJmb28iLCJPYmplY3QiLCJzZXRQcm90b3R5cGVPZiIsInByb3RvdHlwZSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsImlzQnVmZmVyIiwidW5kZWZpbmVkIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImNyZWF0ZUJ1ZmZlciIsIlJhbmdlRXJyb3IiLCJUeXBlRXJyb3IiLCJhbGxvY1Vuc2FmZSIsImZyb20iLCJwb29sU2l6ZSIsImZyb21TdHJpbmciLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImZyb21BcnJheUxpa2UiLCJpc0luc3RhbmNlIiwiZnJvbUFycmF5QnVmZmVyIiwiU2hhcmVkQXJyYXlCdWZmZXIiLCJ2YWx1ZU9mIiwiZnJvbU9iamVjdCIsInRvUHJpbWl0aXZlIiwiYXNzZXJ0U2l6ZSIsImFsbG9jIiwiZmlsbCIsImNoZWNrZWQiLCJhbGxvY1Vuc2FmZVNsb3ciLCJpc0VuY29kaW5nIiwid3JpdGUiLCJzbGljZSIsImNvcHkiLCJudW1iZXJJc05hTiIsInR5cGUiLCJpc0FycmF5IiwiZGF0YSIsInRvU3RyaW5nIiwiX2lzQnVmZmVyIiwiY29tcGFyZSIsIm9mZnNldCIsIk1hdGgiLCJtaW4iLCJTdHJpbmciLCJ0b0xvd2VyQ2FzZSIsImNvbmNhdCIsImFyZ3VtZW50cyIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwiYXBwbHkiLCJ0b0xvY2FsZVN0cmluZyIsImVxdWFscyIsImluc3BlY3QiLCJyZXBsYWNlIiwidHJpbSIsImJpZGlyZWN0aW9uYWxJbmRleE9mIiwiYXJyYXlJbmRleE9mIiwiY2FsbCIsImxhc3RJbmRleE9mIiwicmVhZCIsInJlYWRVSW50MTZCRSIsImMiLCJpbmNsdWRlcyIsImhleFdyaXRlIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJzdWJzdHIiLCJ1dGY4V3JpdGUiLCJibGl0QnVmZmVyIiwiYXNjaWlXcml0ZSIsImFzY2lpVG9CeXRlcyIsImxhdGluMVdyaXRlIiwiYmFzZTY0V3JpdGUiLCJ1Y3MyV3JpdGUiLCJ1dGYxNmxlVG9CeXRlcyIsImlzRmluaXRlIiwidG9KU09OIiwiX2FyciIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsImZyb21DaGFyQ29kZSIsInN1YmFycmF5IiwiY2hlY2tPZmZzZXQiLCJyZWFkVUludExFIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInBvdyIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIndyaXRlVUludEJFIiwid3JpdGVVSW50OCIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVJbnQxNkJFIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwid3JpdGVJbnRCRSIsIndyaXRlSW50OCIsIndyaXRlSW50MTZMRSIsIndyaXRlSW50MTZCRSIsIndyaXRlSW50MzJMRSIsIndyaXRlSW50MzJCRSIsImNoZWNrSUVFRTc1NCIsIndyaXRlRmxvYXQiLCJ3cml0ZUZsb2F0TEUiLCJ3cml0ZUZsb2F0QkUiLCJ3cml0ZURvdWJsZSIsIndyaXRlRG91YmxlTEUiLCJ3cml0ZURvdWJsZUJFIiwiY29weVdpdGhpbiIsInNldCIsImJhc2U2NGNsZWFuIiwic3BsaXQiLCJJbmZpbml0eSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImwiLCJwIiwiTmFOIiwieSIsImciLCJhYnMiLCJpc05hTiIsImZsb29yIiwibG9nIiwiTE4yIiwiX19uY2N3cGNrX3JlcXVpcmVfXyIsImV4cG9ydHMiLCJhYiIsIl9fZGlybmFtZSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/micromatch/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/micromatch/index.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n(()=>{\n    \"use strict\";\n    var e = {\n        333: (e, t, r)=>{\n            const n = r(137);\n            const u = r(179);\n            const s = r(13);\n            const o = r(719);\n            const braces = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                let r = [];\n                if (Array.isArray(e)) {\n                    for (let n of e){\n                        let e = braces.create(n, t);\n                        if (Array.isArray(e)) {\n                            r.push(...e);\n                        } else {\n                            r.push(e);\n                        }\n                    }\n                } else {\n                    r = [].concat(braces.create(e, t));\n                }\n                if (t && t.expand === true && t.nodupes === true) {\n                    r = [\n                        ...new Set(r)\n                    ];\n                }\n                return r;\n            };\n            braces.parse = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                return o(e, t);\n            };\n            braces.stringify = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                if (typeof e === \"string\") {\n                    return n(braces.parse(e, t), t);\n                }\n                return n(e, t);\n            };\n            braces.compile = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                if (typeof e === \"string\") {\n                    e = braces.parse(e, t);\n                }\n                return u(e, t);\n            };\n            braces.expand = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                if (typeof e === \"string\") {\n                    e = braces.parse(e, t);\n                }\n                let r = s(e, t);\n                if (t.noempty === true) {\n                    r = r.filter(Boolean);\n                }\n                if (t.nodupes === true) {\n                    r = [\n                        ...new Set(r)\n                    ];\n                }\n                return r;\n            };\n            braces.create = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                if (e === \"\" || e.length < 3) {\n                    return [\n                        e\n                    ];\n                }\n                return t.expand !== true ? braces.compile(e, t) : braces.expand(e, t);\n            };\n            e.exports = braces;\n        },\n        179: (e, t, r)=>{\n            const n = r(783);\n            const u = r(617);\n            const compile = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                let walk = function(e) {\n                    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                    let s = u.isInvalidBrace(r);\n                    let o = e.invalid === true && t.escapeInvalid === true;\n                    let i = s === true || o === true;\n                    let a = t.escapeInvalid === true ? \"\\\\\" : \"\";\n                    let l = \"\";\n                    if (e.isOpen === true) {\n                        return a + e.value;\n                    }\n                    if (e.isClose === true) {\n                        return a + e.value;\n                    }\n                    if (e.type === \"open\") {\n                        return i ? a + e.value : \"(\";\n                    }\n                    if (e.type === \"close\") {\n                        return i ? a + e.value : \")\";\n                    }\n                    if (e.type === \"comma\") {\n                        return e.prev.type === \"comma\" ? \"\" : i ? e.value : \"|\";\n                    }\n                    if (e.value) {\n                        return e.value;\n                    }\n                    if (e.nodes && e.ranges > 0) {\n                        let r = u.reduce(e.nodes);\n                        let s = n(...r, {\n                            ...t,\n                            wrap: false,\n                            toRegex: true\n                        });\n                        if (s.length !== 0) {\n                            return r.length > 1 && s.length > 1 ? \"(\".concat(s, \")\") : s;\n                        }\n                    }\n                    if (e.nodes) {\n                        for (let t of e.nodes){\n                            l += walk(t, e);\n                        }\n                    }\n                    return l;\n                };\n                return walk(e);\n            };\n            e.exports = compile;\n        },\n        457: (e)=>{\n            e.exports = {\n                MAX_LENGTH: 1024 * 64,\n                CHAR_0: \"0\",\n                CHAR_9: \"9\",\n                CHAR_UPPERCASE_A: \"A\",\n                CHAR_LOWERCASE_A: \"a\",\n                CHAR_UPPERCASE_Z: \"Z\",\n                CHAR_LOWERCASE_Z: \"z\",\n                CHAR_LEFT_PARENTHESES: \"(\",\n                CHAR_RIGHT_PARENTHESES: \")\",\n                CHAR_ASTERISK: \"*\",\n                CHAR_AMPERSAND: \"&\",\n                CHAR_AT: \"@\",\n                CHAR_BACKSLASH: \"\\\\\",\n                CHAR_BACKTICK: \"`\",\n                CHAR_CARRIAGE_RETURN: \"\\r\",\n                CHAR_CIRCUMFLEX_ACCENT: \"^\",\n                CHAR_COLON: \":\",\n                CHAR_COMMA: \",\",\n                CHAR_DOLLAR: \"$\",\n                CHAR_DOT: \".\",\n                CHAR_DOUBLE_QUOTE: '\"',\n                CHAR_EQUAL: \"=\",\n                CHAR_EXCLAMATION_MARK: \"!\",\n                CHAR_FORM_FEED: \"\\f\",\n                CHAR_FORWARD_SLASH: \"/\",\n                CHAR_HASH: \"#\",\n                CHAR_HYPHEN_MINUS: \"-\",\n                CHAR_LEFT_ANGLE_BRACKET: \"<\",\n                CHAR_LEFT_CURLY_BRACE: \"{\",\n                CHAR_LEFT_SQUARE_BRACKET: \"[\",\n                CHAR_LINE_FEED: \"\\n\",\n                CHAR_NO_BREAK_SPACE: \"\\xa0\",\n                CHAR_PERCENT: \"%\",\n                CHAR_PLUS: \"+\",\n                CHAR_QUESTION_MARK: \"?\",\n                CHAR_RIGHT_ANGLE_BRACKET: \">\",\n                CHAR_RIGHT_CURLY_BRACE: \"}\",\n                CHAR_RIGHT_SQUARE_BRACKET: \"]\",\n                CHAR_SEMICOLON: \";\",\n                CHAR_SINGLE_QUOTE: \"'\",\n                CHAR_SPACE: \" \",\n                CHAR_TAB: \"\t\",\n                CHAR_UNDERSCORE: \"_\",\n                CHAR_VERTICAL_LINE: \"|\",\n                CHAR_ZERO_WIDTH_NOBREAK_SPACE: \"\\uFEFF\"\n            };\n        },\n        13: (e, t, r)=>{\n            const n = r(783);\n            const u = r(137);\n            const s = r(617);\n            const append = function() {\n                let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\", r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n                let n = [];\n                e = [].concat(e);\n                t = [].concat(t);\n                if (!t.length) return e;\n                if (!e.length) {\n                    return r ? s.flatten(t).map((e)=>\"{\".concat(e, \"}\")) : t;\n                }\n                for (let u of e){\n                    if (Array.isArray(u)) {\n                        for (let e of u){\n                            n.push(append(e, t, r));\n                        }\n                    } else {\n                        for (let e of t){\n                            if (r === true && typeof e === \"string\") e = \"{\".concat(e, \"}\");\n                            n.push(Array.isArray(e) ? append(u, e, r) : u + e);\n                        }\n                    }\n                }\n                return s.flatten(n);\n            };\n            const expand = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                let r = t.rangeLimit === void 0 ? 1e3 : t.rangeLimit;\n                let walk = function(e) {\n                    let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                    e.queue = [];\n                    let i = o;\n                    let a = o.queue;\n                    while(i.type !== \"brace\" && i.type !== \"root\" && i.parent){\n                        i = i.parent;\n                        a = i.queue;\n                    }\n                    if (e.invalid || e.dollar) {\n                        a.push(append(a.pop(), u(e, t)));\n                        return;\n                    }\n                    if (e.type === \"brace\" && e.invalid !== true && e.nodes.length === 2) {\n                        a.push(append(a.pop(), [\n                            \"{}\"\n                        ]));\n                        return;\n                    }\n                    if (e.nodes && e.ranges > 0) {\n                        let o = s.reduce(e.nodes);\n                        if (s.exceedsLimit(...o, t.step, r)) {\n                            throw new RangeError(\"expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.\");\n                        }\n                        let i = n(...o, t);\n                        if (i.length === 0) {\n                            i = u(e, t);\n                        }\n                        a.push(append(a.pop(), i));\n                        e.nodes = [];\n                        return;\n                    }\n                    let l = s.encloseBrace(e);\n                    let c = e.queue;\n                    let p = e;\n                    while(p.type !== \"brace\" && p.type !== \"root\" && p.parent){\n                        p = p.parent;\n                        c = p.queue;\n                    }\n                    for(let t = 0; t < e.nodes.length; t++){\n                        let r = e.nodes[t];\n                        if (r.type === \"comma\" && e.type === \"brace\") {\n                            if (t === 1) c.push(\"\");\n                            c.push(\"\");\n                            continue;\n                        }\n                        if (r.type === \"close\") {\n                            a.push(append(a.pop(), c, l));\n                            continue;\n                        }\n                        if (r.value && r.type !== \"open\") {\n                            c.push(append(c.pop(), r.value));\n                            continue;\n                        }\n                        if (r.nodes) {\n                            walk(r, e);\n                        }\n                    }\n                    return c;\n                };\n                return s.flatten(walk(e));\n            };\n            e.exports = expand;\n        },\n        719: (e, t, r)=>{\n            const n = r(137);\n            const { MAX_LENGTH: u, CHAR_BACKSLASH: s, CHAR_BACKTICK: o, CHAR_COMMA: i, CHAR_DOT: a, CHAR_LEFT_PARENTHESES: l, CHAR_RIGHT_PARENTHESES: c, CHAR_LEFT_CURLY_BRACE: p, CHAR_RIGHT_CURLY_BRACE: f, CHAR_LEFT_SQUARE_BRACKET: A, CHAR_RIGHT_SQUARE_BRACKET: R, CHAR_DOUBLE_QUOTE: _, CHAR_SINGLE_QUOTE: h, CHAR_NO_BREAK_SPACE: g, CHAR_ZERO_WIDTH_NOBREAK_SPACE: E } = r(457);\n            const parse = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                if (typeof e !== \"string\") {\n                    throw new TypeError(\"Expected a string\");\n                }\n                let r = t || {};\n                let C = typeof r.maxLength === \"number\" ? Math.min(u, r.maxLength) : u;\n                if (e.length > C) {\n                    throw new SyntaxError(\"Input length (\".concat(e.length, \"), exceeds max characters (\").concat(C, \")\"));\n                }\n                let y = {\n                    type: \"root\",\n                    input: e,\n                    nodes: []\n                };\n                let d = [\n                    y\n                ];\n                let x = y;\n                let b = y;\n                let S = 0;\n                let H = e.length;\n                let v = 0;\n                let $ = 0;\n                let m;\n                let T = {};\n                const advance = ()=>e[v++];\n                const push = (e)=>{\n                    if (e.type === \"text\" && b.type === \"dot\") {\n                        b.type = \"text\";\n                    }\n                    if (b && b.type === \"text\" && e.type === \"text\") {\n                        b.value += e.value;\n                        return;\n                    }\n                    x.nodes.push(e);\n                    e.parent = x;\n                    e.prev = b;\n                    b = e;\n                    return e;\n                };\n                push({\n                    type: \"bos\"\n                });\n                while(v < H){\n                    x = d[d.length - 1];\n                    m = advance();\n                    if (m === E || m === g) {\n                        continue;\n                    }\n                    if (m === s) {\n                        push({\n                            type: \"text\",\n                            value: (t.keepEscaping ? m : \"\") + advance()\n                        });\n                        continue;\n                    }\n                    if (m === R) {\n                        push({\n                            type: \"text\",\n                            value: \"\\\\\" + m\n                        });\n                        continue;\n                    }\n                    if (m === A) {\n                        S++;\n                        let e = true;\n                        let t;\n                        while(v < H && (t = advance())){\n                            m += t;\n                            if (t === A) {\n                                S++;\n                                continue;\n                            }\n                            if (t === s) {\n                                m += advance();\n                                continue;\n                            }\n                            if (t === R) {\n                                S--;\n                                if (S === 0) {\n                                    break;\n                                }\n                            }\n                        }\n                        push({\n                            type: \"text\",\n                            value: m\n                        });\n                        continue;\n                    }\n                    if (m === l) {\n                        x = push({\n                            type: \"paren\",\n                            nodes: []\n                        });\n                        d.push(x);\n                        push({\n                            type: \"text\",\n                            value: m\n                        });\n                        continue;\n                    }\n                    if (m === c) {\n                        if (x.type !== \"paren\") {\n                            push({\n                                type: \"text\",\n                                value: m\n                            });\n                            continue;\n                        }\n                        x = d.pop();\n                        push({\n                            type: \"text\",\n                            value: m\n                        });\n                        x = d[d.length - 1];\n                        continue;\n                    }\n                    if (m === _ || m === h || m === o) {\n                        let e = m;\n                        let r;\n                        if (t.keepQuotes !== true) {\n                            m = \"\";\n                        }\n                        while(v < H && (r = advance())){\n                            if (r === s) {\n                                m += r + advance();\n                                continue;\n                            }\n                            if (r === e) {\n                                if (t.keepQuotes === true) m += r;\n                                break;\n                            }\n                            m += r;\n                        }\n                        push({\n                            type: \"text\",\n                            value: m\n                        });\n                        continue;\n                    }\n                    if (m === p) {\n                        $++;\n                        let e = b.value && b.value.slice(-1) === \"$\" || x.dollar === true;\n                        let t = {\n                            type: \"brace\",\n                            open: true,\n                            close: false,\n                            dollar: e,\n                            depth: $,\n                            commas: 0,\n                            ranges: 0,\n                            nodes: []\n                        };\n                        x = push(t);\n                        d.push(x);\n                        push({\n                            type: \"open\",\n                            value: m\n                        });\n                        continue;\n                    }\n                    if (m === f) {\n                        if (x.type !== \"brace\") {\n                            push({\n                                type: \"text\",\n                                value: m\n                            });\n                            continue;\n                        }\n                        let e = \"close\";\n                        x = d.pop();\n                        x.close = true;\n                        push({\n                            type: e,\n                            value: m\n                        });\n                        $--;\n                        x = d[d.length - 1];\n                        continue;\n                    }\n                    if (m === i && $ > 0) {\n                        if (x.ranges > 0) {\n                            x.ranges = 0;\n                            let e = x.nodes.shift();\n                            x.nodes = [\n                                e,\n                                {\n                                    type: \"text\",\n                                    value: n(x)\n                                }\n                            ];\n                        }\n                        push({\n                            type: \"comma\",\n                            value: m\n                        });\n                        x.commas++;\n                        continue;\n                    }\n                    if (m === a && $ > 0 && x.commas === 0) {\n                        let e = x.nodes;\n                        if ($ === 0 || e.length === 0) {\n                            push({\n                                type: \"text\",\n                                value: m\n                            });\n                            continue;\n                        }\n                        if (b.type === \"dot\") {\n                            x.range = [];\n                            b.value += m;\n                            b.type = \"range\";\n                            if (x.nodes.length !== 3 && x.nodes.length !== 5) {\n                                x.invalid = true;\n                                x.ranges = 0;\n                                b.type = \"text\";\n                                continue;\n                            }\n                            x.ranges++;\n                            x.args = [];\n                            continue;\n                        }\n                        if (b.type === \"range\") {\n                            e.pop();\n                            let t = e[e.length - 1];\n                            t.value += b.value + m;\n                            b = t;\n                            x.ranges--;\n                            continue;\n                        }\n                        push({\n                            type: \"dot\",\n                            value: m\n                        });\n                        continue;\n                    }\n                    push({\n                        type: \"text\",\n                        value: m\n                    });\n                }\n                do {\n                    x = d.pop();\n                    if (x.type !== \"root\") {\n                        x.nodes.forEach((e)=>{\n                            if (!e.nodes) {\n                                if (e.type === \"open\") e.isOpen = true;\n                                if (e.type === \"close\") e.isClose = true;\n                                if (!e.nodes) e.type = \"text\";\n                                e.invalid = true;\n                            }\n                        });\n                        let e = d[d.length - 1];\n                        let t = e.nodes.indexOf(x);\n                        e.nodes.splice(t, 1, ...x.nodes);\n                    }\n                }while (d.length > 0);\n                push({\n                    type: \"eos\"\n                });\n                return y;\n            };\n            e.exports = parse;\n        },\n        137: (e, t, r)=>{\n            const n = r(617);\n            e.exports = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                let stringify = function(e) {\n                    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                    let u = t.escapeInvalid && n.isInvalidBrace(r);\n                    let s = e.invalid === true && t.escapeInvalid === true;\n                    let o = \"\";\n                    if (e.value) {\n                        if ((u || s) && n.isOpenOrClose(e)) {\n                            return \"\\\\\" + e.value;\n                        }\n                        return e.value;\n                    }\n                    if (e.value) {\n                        return e.value;\n                    }\n                    if (e.nodes) {\n                        for (let t of e.nodes){\n                            o += stringify(t);\n                        }\n                    }\n                    return o;\n                };\n                return stringify(e);\n            };\n        },\n        617: (e, t)=>{\n            t.isInteger = (e)=>{\n                if (typeof e === \"number\") {\n                    return Number.isInteger(e);\n                }\n                if (typeof e === \"string\" && e.trim() !== \"\") {\n                    return Number.isInteger(Number(e));\n                }\n                return false;\n            };\n            t.find = (e, t)=>e.nodes.find((e)=>e.type === t);\n            t.exceedsLimit = function(e, r) {\n                let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, u = arguments.length > 3 ? arguments[3] : void 0;\n                if (u === false) return false;\n                if (!t.isInteger(e) || !t.isInteger(r)) return false;\n                return (Number(r) - Number(e)) / Number(n) >= u;\n            };\n            t.escapeNode = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = arguments.length > 2 ? arguments[2] : void 0;\n                let n = e.nodes[t];\n                if (!n) return;\n                if (r && n.type === r || n.type === \"open\" || n.type === \"close\") {\n                    if (n.escaped !== true) {\n                        n.value = \"\\\\\" + n.value;\n                        n.escaped = true;\n                    }\n                }\n            };\n            t.encloseBrace = (e)=>{\n                if (e.type !== \"brace\") return false;\n                if (e.commas >> 0 + e.ranges >> 0 === 0) {\n                    e.invalid = true;\n                    return true;\n                }\n                return false;\n            };\n            t.isInvalidBrace = (e)=>{\n                if (e.type !== \"brace\") return false;\n                if (e.invalid === true || e.dollar) return true;\n                if (e.commas >> 0 + e.ranges >> 0 === 0) {\n                    e.invalid = true;\n                    return true;\n                }\n                if (e.open !== true || e.close !== true) {\n                    e.invalid = true;\n                    return true;\n                }\n                return false;\n            };\n            t.isOpenOrClose = (e)=>{\n                if (e.type === \"open\" || e.type === \"close\") {\n                    return true;\n                }\n                return e.open === true || e.close === true;\n            };\n            t.reduce = (e)=>e.reduce((e, t)=>{\n                    if (t.type === \"text\") e.push(t.value);\n                    if (t.type === \"range\") t.type = \"text\";\n                    return e;\n                }, []);\n            t.flatten = function() {\n                for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n                    e[_key] = arguments[_key];\n                }\n                const t = [];\n                const flat = (e)=>{\n                    for(let r = 0; r < e.length; r++){\n                        let n = e[r];\n                        Array.isArray(n) ? flat(n, t) : n !== void 0 && t.push(n);\n                    }\n                    return t;\n                };\n                flat(e);\n                return t;\n            };\n        },\n        783: (e, t, r)=>{\n            /*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */ const n = r(837);\n            const u = r(492);\n            const isObject = (e)=>e !== null && typeof e === \"object\" && !Array.isArray(e);\n            const transform = (e)=>(t)=>e === true ? Number(t) : String(t);\n            const isValidValue = (e)=>typeof e === \"number\" || typeof e === \"string\" && e !== \"\";\n            const isNumber = (e)=>Number.isInteger(+e);\n            const zeros = (e)=>{\n                let t = \"\".concat(e);\n                let r = -1;\n                if (t[0] === \"-\") t = t.slice(1);\n                if (t === \"0\") return false;\n                while(t[++r] === \"0\");\n                return r > 0;\n            };\n            const stringify = (e, t, r)=>{\n                if (typeof e === \"string\" || typeof t === \"string\") {\n                    return true;\n                }\n                return r.stringify === true;\n            };\n            const pad = (e, t, r)=>{\n                if (t > 0) {\n                    let r = e[0] === \"-\" ? \"-\" : \"\";\n                    if (r) e = e.slice(1);\n                    e = r + e.padStart(r ? t - 1 : t, \"0\");\n                }\n                if (r === false) {\n                    return String(e);\n                }\n                return e;\n            };\n            const toMaxLen = (e, t)=>{\n                let r = e[0] === \"-\" ? \"-\" : \"\";\n                if (r) {\n                    e = e.slice(1);\n                    t--;\n                }\n                while(e.length < t)e = \"0\" + e;\n                return r ? \"-\" + e : e;\n            };\n            const toSequence = (e, t)=>{\n                e.negatives.sort((e, t)=>e < t ? -1 : e > t ? 1 : 0);\n                e.positives.sort((e, t)=>e < t ? -1 : e > t ? 1 : 0);\n                let r = t.capture ? \"\" : \"?:\";\n                let n = \"\";\n                let u = \"\";\n                let s;\n                if (e.positives.length) {\n                    n = e.positives.join(\"|\");\n                }\n                if (e.negatives.length) {\n                    u = \"-(\".concat(r).concat(e.negatives.join(\"|\"), \")\");\n                }\n                if (n && u) {\n                    s = \"\".concat(n, \"|\").concat(u);\n                } else {\n                    s = n || u;\n                }\n                if (t.wrap) {\n                    return \"(\".concat(r).concat(s, \")\");\n                }\n                return s;\n            };\n            const toRange = (e, t, r, n)=>{\n                if (r) {\n                    return u(e, t, {\n                        wrap: false,\n                        ...n\n                    });\n                }\n                let s = String.fromCharCode(e);\n                if (e === t) return s;\n                let o = String.fromCharCode(t);\n                return \"[\".concat(s, \"-\").concat(o, \"]\");\n            };\n            const toRegex = (e, t, r)=>{\n                if (Array.isArray(e)) {\n                    let t = r.wrap === true;\n                    let n = r.capture ? \"\" : \"?:\";\n                    return t ? \"(\".concat(n).concat(e.join(\"|\"), \")\") : e.join(\"|\");\n                }\n                return u(e, t, r);\n            };\n            const rangeError = function() {\n                for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n                    e[_key] = arguments[_key];\n                }\n                return new RangeError(\"Invalid range arguments: \" + n.inspect(...e));\n            };\n            const invalidRange = (e, t, r)=>{\n                if (r.strictRanges === true) throw rangeError([\n                    e,\n                    t\n                ]);\n                return [];\n            };\n            const invalidStep = (e, t)=>{\n                if (t.strictRanges === true) {\n                    throw new TypeError('Expected step \"'.concat(e, '\" to be a number'));\n                }\n                return [];\n            };\n            const fillNumbers = function(e, t) {\n                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n                let u = Number(e);\n                let s = Number(t);\n                if (!Number.isInteger(u) || !Number.isInteger(s)) {\n                    if (n.strictRanges === true) throw rangeError([\n                        e,\n                        t\n                    ]);\n                    return [];\n                }\n                if (u === 0) u = 0;\n                if (s === 0) s = 0;\n                let o = u > s;\n                let i = String(e);\n                let a = String(t);\n                let l = String(r);\n                r = Math.max(Math.abs(r), 1);\n                let c = zeros(i) || zeros(a) || zeros(l);\n                let p = c ? Math.max(i.length, a.length, l.length) : 0;\n                let f = c === false && stringify(e, t, n) === false;\n                let A = n.transform || transform(f);\n                if (n.toRegex && r === 1) {\n                    return toRange(toMaxLen(e, p), toMaxLen(t, p), true, n);\n                }\n                let R = {\n                    negatives: [],\n                    positives: []\n                };\n                let push = (e)=>R[e < 0 ? \"negatives\" : \"positives\"].push(Math.abs(e));\n                let _ = [];\n                let h = 0;\n                while(o ? u >= s : u <= s){\n                    if (n.toRegex === true && r > 1) {\n                        push(u);\n                    } else {\n                        _.push(pad(A(u, h), p, f));\n                    }\n                    u = o ? u - r : u + r;\n                    h++;\n                }\n                if (n.toRegex === true) {\n                    return r > 1 ? toSequence(R, n) : toRegex(_, null, {\n                        wrap: false,\n                        ...n\n                    });\n                }\n                return _;\n            };\n            const fillLetters = function(e, t) {\n                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n                if (!isNumber(e) && e.length > 1 || !isNumber(t) && t.length > 1) {\n                    return invalidRange(e, t, n);\n                }\n                let u = n.transform || ((e)=>String.fromCharCode(e));\n                let s = \"\".concat(e).charCodeAt(0);\n                let o = \"\".concat(t).charCodeAt(0);\n                let i = s > o;\n                let a = Math.min(s, o);\n                let l = Math.max(s, o);\n                if (n.toRegex && r === 1) {\n                    return toRange(a, l, false, n);\n                }\n                let c = [];\n                let p = 0;\n                while(i ? s >= o : s <= o){\n                    c.push(u(s, p));\n                    s = i ? s - r : s + r;\n                    p++;\n                }\n                if (n.toRegex === true) {\n                    return toRegex(c, null, {\n                        wrap: false,\n                        options: n\n                    });\n                }\n                return c;\n            };\n            const fill = function(e, t, r) {\n                let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n                if (t == null && isValidValue(e)) {\n                    return [\n                        e\n                    ];\n                }\n                if (!isValidValue(e) || !isValidValue(t)) {\n                    return invalidRange(e, t, n);\n                }\n                if (typeof r === \"function\") {\n                    return fill(e, t, 1, {\n                        transform: r\n                    });\n                }\n                if (isObject(r)) {\n                    return fill(e, t, 0, r);\n                }\n                let u = {\n                    ...n\n                };\n                if (u.capture === true) u.wrap = true;\n                r = r || u.step || 1;\n                if (!isNumber(r)) {\n                    if (r != null && !isObject(r)) return invalidStep(r, u);\n                    return fill(e, t, 1, r);\n                }\n                if (isNumber(e) && isNumber(t)) {\n                    return fillNumbers(e, t, r, u);\n                }\n                return fillLetters(e, t, Math.max(Math.abs(r), 1), u);\n            };\n            e.exports = fill;\n        },\n        357: (e)=>{\n            /*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */ e.exports = function(e) {\n                if (typeof e === \"number\") {\n                    return e - e === 0;\n                }\n                if (typeof e === \"string\" && e.trim() !== \"\") {\n                    return Number.isFinite ? Number.isFinite(+e) : isFinite(+e);\n                }\n                return false;\n            };\n        },\n        971: (e, t, r)=>{\n            const n = r(837);\n            const u = r(333);\n            const s = r(251);\n            const o = r(513);\n            const isEmptyString = (e)=>e === \"\" || e === \"./\";\n            const micromatch = (e, t, r)=>{\n                t = [].concat(t);\n                e = [].concat(e);\n                let n = new Set;\n                let u = new Set;\n                let o = new Set;\n                let i = 0;\n                let onResult = (e)=>{\n                    o.add(e.output);\n                    if (r && r.onResult) {\n                        r.onResult(e);\n                    }\n                };\n                for(let o = 0; o < t.length; o++){\n                    let a = s(String(t[o]), {\n                        ...r,\n                        onResult: onResult\n                    }, true);\n                    let l = a.state.negated || a.state.negatedExtglob;\n                    if (l) i++;\n                    for (let t of e){\n                        let e = a(t, true);\n                        let r = l ? !e.isMatch : e.isMatch;\n                        if (!r) continue;\n                        if (l) {\n                            n.add(e.output);\n                        } else {\n                            n.delete(e.output);\n                            u.add(e.output);\n                        }\n                    }\n                }\n                let a = i === t.length ? [\n                    ...o\n                ] : [\n                    ...u\n                ];\n                let l = a.filter((e)=>!n.has(e));\n                if (r && l.length === 0) {\n                    if (r.failglob === true) {\n                        throw new Error('No matches found for \"'.concat(t.join(\", \"), '\"'));\n                    }\n                    if (r.nonull === true || r.nullglob === true) {\n                        return r.unescape ? t.map((e)=>e.replace(/\\\\/g, \"\")) : t;\n                    }\n                }\n                return l;\n            };\n            micromatch.match = micromatch;\n            micromatch.matcher = (e, t)=>s(e, t);\n            micromatch.isMatch = (e, t, r)=>s(t, r)(e);\n            micromatch.any = micromatch.isMatch;\n            micromatch.not = function(e, t) {\n                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                t = [].concat(t).map(String);\n                let n = new Set;\n                let u = [];\n                let onResult = (e)=>{\n                    if (r.onResult) r.onResult(e);\n                    u.push(e.output);\n                };\n                let s = micromatch(e, t, {\n                    ...r,\n                    onResult: onResult\n                });\n                for (let e of u){\n                    if (!s.includes(e)) {\n                        n.add(e);\n                    }\n                }\n                return [\n                    ...n\n                ];\n            };\n            micromatch.contains = (e, t, r)=>{\n                if (typeof e !== \"string\") {\n                    throw new TypeError('Expected a string: \"'.concat(n.inspect(e), '\"'));\n                }\n                if (Array.isArray(t)) {\n                    return t.some((t)=>micromatch.contains(e, t, r));\n                }\n                if (typeof t === \"string\") {\n                    if (isEmptyString(e) || isEmptyString(t)) {\n                        return false;\n                    }\n                    if (e.includes(t) || e.startsWith(\"./\") && e.slice(2).includes(t)) {\n                        return true;\n                    }\n                }\n                return micromatch.isMatch(e, t, {\n                    ...r,\n                    contains: true\n                });\n            };\n            micromatch.matchKeys = (e, t, r)=>{\n                if (!o.isObject(e)) {\n                    throw new TypeError(\"Expected the first argument to be an object\");\n                }\n                let n = micromatch(Object.keys(e), t, r);\n                let u = {};\n                for (let t of n)u[t] = e[t];\n                return u;\n            };\n            micromatch.some = (e, t, r)=>{\n                let n = [].concat(e);\n                for (let e of [].concat(t)){\n                    let t = s(String(e), r);\n                    if (n.some((e)=>t(e))) {\n                        return true;\n                    }\n                }\n                return false;\n            };\n            micromatch.every = (e, t, r)=>{\n                let n = [].concat(e);\n                for (let e of [].concat(t)){\n                    let t = s(String(e), r);\n                    if (!n.every((e)=>t(e))) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            micromatch.all = (e, t, r)=>{\n                if (typeof e !== \"string\") {\n                    throw new TypeError('Expected a string: \"'.concat(n.inspect(e), '\"'));\n                }\n                return [].concat(t).every((t)=>s(t, r)(e));\n            };\n            micromatch.capture = (e, t, r)=>{\n                let n = o.isWindows(r);\n                let u = s.makeRe(String(e), {\n                    ...r,\n                    capture: true\n                });\n                let i = u.exec(n ? o.toPosixSlashes(t) : t);\n                if (i) {\n                    return i.slice(1).map((e)=>e === void 0 ? \"\" : e);\n                }\n            };\n            micromatch.makeRe = function() {\n                for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n                    e[_key] = arguments[_key];\n                }\n                return s.makeRe(...e);\n            };\n            micromatch.scan = function() {\n                for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n                    e[_key] = arguments[_key];\n                }\n                return s.scan(...e);\n            };\n            micromatch.parse = (e, t)=>{\n                let r = [];\n                for (let n of [].concat(e || [])){\n                    for (let e of u(String(n), t)){\n                        r.push(s.parse(e, t));\n                    }\n                }\n                return r;\n            };\n            micromatch.braces = (e, t)=>{\n                if (typeof e !== \"string\") throw new TypeError(\"Expected a string\");\n                if (t && t.nobrace === true || !/\\{.*\\}/.test(e)) {\n                    return [\n                        e\n                    ];\n                }\n                return u(e, t);\n            };\n            micromatch.braceExpand = (e, t)=>{\n                if (typeof e !== \"string\") throw new TypeError(\"Expected a string\");\n                return micromatch.braces(e, {\n                    ...t,\n                    expand: true\n                });\n            };\n            e.exports = micromatch;\n        },\n        251: (e, t, r)=>{\n            e.exports = r(683);\n        },\n        356: (e, t, r)=>{\n            const n = r(17);\n            const u = \"\\\\\\\\/\";\n            const s = \"[^\".concat(u, \"]\");\n            const o = \"\\\\.\";\n            const i = \"\\\\+\";\n            const a = \"\\\\?\";\n            const l = \"\\\\/\";\n            const c = \"(?=.)\";\n            const p = \"[^/]\";\n            const f = \"(?:\".concat(l, \"|$)\");\n            const A = \"(?:^|\".concat(l, \")\");\n            const R = \"\".concat(o, \"{1,2}\").concat(f);\n            const _ = \"(?!\".concat(o, \")\");\n            const h = \"(?!\".concat(A).concat(R, \")\");\n            const g = \"(?!\".concat(o, \"{0,1}\").concat(f, \")\");\n            const E = \"(?!\".concat(R, \")\");\n            const C = \"[^.\".concat(l, \"]\");\n            const y = \"\".concat(p, \"*?\");\n            const d = {\n                DOT_LITERAL: o,\n                PLUS_LITERAL: i,\n                QMARK_LITERAL: a,\n                SLASH_LITERAL: l,\n                ONE_CHAR: c,\n                QMARK: p,\n                END_ANCHOR: f,\n                DOTS_SLASH: R,\n                NO_DOT: _,\n                NO_DOTS: h,\n                NO_DOT_SLASH: g,\n                NO_DOTS_SLASH: E,\n                QMARK_NO_DOT: C,\n                STAR: y,\n                START_ANCHOR: A\n            };\n            const x = {\n                ...d,\n                SLASH_LITERAL: \"[\".concat(u, \"]\"),\n                QMARK: s,\n                STAR: \"\".concat(s, \"*?\"),\n                DOTS_SLASH: \"\".concat(o, \"{1,2}(?:[\").concat(u, \"]|$)\"),\n                NO_DOT: \"(?!\".concat(o, \")\"),\n                NO_DOTS: \"(?!(?:^|[\".concat(u, \"])\").concat(o, \"{1,2}(?:[\").concat(u, \"]|$))\"),\n                NO_DOT_SLASH: \"(?!\".concat(o, \"{0,1}(?:[\").concat(u, \"]|$))\"),\n                NO_DOTS_SLASH: \"(?!\".concat(o, \"{1,2}(?:[\").concat(u, \"]|$))\"),\n                QMARK_NO_DOT: \"[^.\".concat(u, \"]\"),\n                START_ANCHOR: \"(?:^|[\".concat(u, \"])\"),\n                END_ANCHOR: \"(?:[\".concat(u, \"]|$)\")\n            };\n            const b = {\n                alnum: \"a-zA-Z0-9\",\n                alpha: \"a-zA-Z\",\n                ascii: \"\\\\x00-\\\\x7F\",\n                blank: \" \\\\t\",\n                cntrl: \"\\\\x00-\\\\x1F\\\\x7F\",\n                digit: \"0-9\",\n                graph: \"\\\\x21-\\\\x7E\",\n                lower: \"a-z\",\n                print: \"\\\\x20-\\\\x7E \",\n                punct: \"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",\n                space: \" \\\\t\\\\r\\\\n\\\\v\\\\f\",\n                upper: \"A-Z\",\n                word: \"A-Za-z0-9_\",\n                xdigit: \"A-Fa-f0-9\"\n            };\n            e.exports = {\n                MAX_LENGTH: 1024 * 64,\n                POSIX_REGEX_SOURCE: b,\n                REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n                REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n                REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n                REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n                REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n                REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n                REPLACEMENTS: {\n                    \"***\": \"*\",\n                    \"**/**\": \"**\",\n                    \"**/**/**\": \"**\"\n                },\n                CHAR_0: 48,\n                CHAR_9: 57,\n                CHAR_UPPERCASE_A: 65,\n                CHAR_LOWERCASE_A: 97,\n                CHAR_UPPERCASE_Z: 90,\n                CHAR_LOWERCASE_Z: 122,\n                CHAR_LEFT_PARENTHESES: 40,\n                CHAR_RIGHT_PARENTHESES: 41,\n                CHAR_ASTERISK: 42,\n                CHAR_AMPERSAND: 38,\n                CHAR_AT: 64,\n                CHAR_BACKWARD_SLASH: 92,\n                CHAR_CARRIAGE_RETURN: 13,\n                CHAR_CIRCUMFLEX_ACCENT: 94,\n                CHAR_COLON: 58,\n                CHAR_COMMA: 44,\n                CHAR_DOT: 46,\n                CHAR_DOUBLE_QUOTE: 34,\n                CHAR_EQUAL: 61,\n                CHAR_EXCLAMATION_MARK: 33,\n                CHAR_FORM_FEED: 12,\n                CHAR_FORWARD_SLASH: 47,\n                CHAR_GRAVE_ACCENT: 96,\n                CHAR_HASH: 35,\n                CHAR_HYPHEN_MINUS: 45,\n                CHAR_LEFT_ANGLE_BRACKET: 60,\n                CHAR_LEFT_CURLY_BRACE: 123,\n                CHAR_LEFT_SQUARE_BRACKET: 91,\n                CHAR_LINE_FEED: 10,\n                CHAR_NO_BREAK_SPACE: 160,\n                CHAR_PERCENT: 37,\n                CHAR_PLUS: 43,\n                CHAR_QUESTION_MARK: 63,\n                CHAR_RIGHT_ANGLE_BRACKET: 62,\n                CHAR_RIGHT_CURLY_BRACE: 125,\n                CHAR_RIGHT_SQUARE_BRACKET: 93,\n                CHAR_SEMICOLON: 59,\n                CHAR_SINGLE_QUOTE: 39,\n                CHAR_SPACE: 32,\n                CHAR_TAB: 9,\n                CHAR_UNDERSCORE: 95,\n                CHAR_VERTICAL_LINE: 124,\n                CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,\n                SEP: n.sep,\n                extglobChars (e) {\n                    return {\n                        \"!\": {\n                            type: \"negate\",\n                            open: \"(?:(?!(?:\",\n                            close: \"))\".concat(e.STAR, \")\")\n                        },\n                        \"?\": {\n                            type: \"qmark\",\n                            open: \"(?:\",\n                            close: \")?\"\n                        },\n                        \"+\": {\n                            type: \"plus\",\n                            open: \"(?:\",\n                            close: \")+\"\n                        },\n                        \"*\": {\n                            type: \"star\",\n                            open: \"(?:\",\n                            close: \")*\"\n                        },\n                        \"@\": {\n                            type: \"at\",\n                            open: \"(?:\",\n                            close: \")\"\n                        }\n                    };\n                },\n                globChars (e) {\n                    return e === true ? x : d;\n                }\n            };\n        },\n        754: (e, t, r)=>{\n            const n = r(356);\n            const u = r(513);\n            const { MAX_LENGTH: s, POSIX_REGEX_SOURCE: o, REGEX_NON_SPECIAL_CHARS: i, REGEX_SPECIAL_CHARS_BACKREF: a, REPLACEMENTS: l } = n;\n            const expandRange = (e, t)=>{\n                if (typeof t.expandRange === \"function\") {\n                    return t.expandRange(...e, t);\n                }\n                e.sort();\n                const r = \"[\".concat(e.join(\"-\"), \"]\");\n                try {\n                    new RegExp(r);\n                } catch (t) {\n                    return e.map((e)=>u.escapeRegex(e)).join(\"..\");\n                }\n                return r;\n            };\n            const syntaxError = (e, t)=>\"Missing \".concat(e, ': \"').concat(t, '\" - use \"\\\\\\\\').concat(t, '\" to match literal characters');\n            const parse = (e, t)=>{\n                if (typeof e !== \"string\") {\n                    throw new TypeError(\"Expected a string\");\n                }\n                e = l[e] || e;\n                const r = {\n                    ...t\n                };\n                const c = typeof r.maxLength === \"number\" ? Math.min(s, r.maxLength) : s;\n                let p = e.length;\n                if (p > c) {\n                    throw new SyntaxError(\"Input length: \".concat(p, \", exceeds maximum allowed length: \").concat(c));\n                }\n                const f = {\n                    type: \"bos\",\n                    value: \"\",\n                    output: r.prepend || \"\"\n                };\n                const A = [\n                    f\n                ];\n                const R = r.capture ? \"\" : \"?:\";\n                const _ = u.isWindows(t);\n                const h = n.globChars(_);\n                const g = n.extglobChars(h);\n                const { DOT_LITERAL: E, PLUS_LITERAL: C, SLASH_LITERAL: y, ONE_CHAR: d, DOTS_SLASH: x, NO_DOT: b, NO_DOT_SLASH: S, NO_DOTS_SLASH: H, QMARK: v, QMARK_NO_DOT: $, STAR: m, START_ANCHOR: T } = h;\n                const globstar = (e)=>\"(\".concat(R, \"(?:(?!\").concat(T).concat(e.dot ? x : E, \").)*?)\");\n                const L = r.dot ? \"\" : b;\n                const O = r.dot ? v : $;\n                let w = r.bash === true ? globstar(r) : m;\n                if (r.capture) {\n                    w = \"(\".concat(w, \")\");\n                }\n                if (typeof r.noext === \"boolean\") {\n                    r.noextglob = r.noext;\n                }\n                const N = {\n                    input: e,\n                    index: -1,\n                    start: 0,\n                    dot: r.dot === true,\n                    consumed: \"\",\n                    output: \"\",\n                    prefix: \"\",\n                    backtrack: false,\n                    negated: false,\n                    brackets: 0,\n                    braces: 0,\n                    parens: 0,\n                    quotes: 0,\n                    globstar: false,\n                    tokens: A\n                };\n                e = u.removePrefix(e, N);\n                p = e.length;\n                const k = [];\n                const I = [];\n                const M = [];\n                let P = f;\n                let B;\n                const eos = ()=>N.index === p - 1;\n                const G = N.peek = function() {\n                    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;\n                    return e[N.index + t];\n                };\n                const D = N.advance = ()=>e[++N.index];\n                const remaining = ()=>e.slice(N.index + 1);\n                const consume = function() {\n                    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n                    N.consumed += e;\n                    N.index += t;\n                };\n                const append = (e)=>{\n                    N.output += e.output != null ? e.output : e.value;\n                    consume(e.value);\n                };\n                const negate = ()=>{\n                    let e = 1;\n                    while(G() === \"!\" && (G(2) !== \"(\" || G(3) === \"?\")){\n                        D();\n                        N.start++;\n                        e++;\n                    }\n                    if (e % 2 === 0) {\n                        return false;\n                    }\n                    N.negated = true;\n                    N.start++;\n                    return true;\n                };\n                const increment = (e)=>{\n                    N[e]++;\n                    M.push(e);\n                };\n                const decrement = (e)=>{\n                    N[e]--;\n                    M.pop();\n                };\n                const push = (e)=>{\n                    if (P.type === \"globstar\") {\n                        const t = N.braces > 0 && (e.type === \"comma\" || e.type === \"brace\");\n                        const r = e.extglob === true || k.length && (e.type === \"pipe\" || e.type === \"paren\");\n                        if (e.type !== \"slash\" && e.type !== \"paren\" && !t && !r) {\n                            N.output = N.output.slice(0, -P.output.length);\n                            P.type = \"star\";\n                            P.value = \"*\";\n                            P.output = w;\n                            N.output += P.output;\n                        }\n                    }\n                    if (k.length && e.type !== \"paren\" && !g[e.value]) {\n                        k[k.length - 1].inner += e.value;\n                    }\n                    if (e.value || e.output) append(e);\n                    if (P && P.type === \"text\" && e.type === \"text\") {\n                        P.value += e.value;\n                        P.output = (P.output || \"\") + e.value;\n                        return;\n                    }\n                    e.prev = P;\n                    A.push(e);\n                    P = e;\n                };\n                const extglobOpen = (e, t)=>{\n                    const n = {\n                        ...g[t],\n                        conditions: 1,\n                        inner: \"\"\n                    };\n                    n.prev = P;\n                    n.parens = N.parens;\n                    n.output = N.output;\n                    const u = (r.capture ? \"(\" : \"\") + n.open;\n                    increment(\"parens\");\n                    push({\n                        type: e,\n                        value: t,\n                        output: N.output ? \"\" : d\n                    });\n                    push({\n                        type: \"paren\",\n                        extglob: true,\n                        value: D(),\n                        output: u\n                    });\n                    k.push(n);\n                };\n                const extglobClose = (e)=>{\n                    let t = e.close + (r.capture ? \")\" : \"\");\n                    if (e.type === \"negate\") {\n                        let n = w;\n                        if (e.inner && e.inner.length > 1 && e.inner.includes(\"/\")) {\n                            n = globstar(r);\n                        }\n                        if (n !== w || eos() || /^\\)+$/.test(remaining())) {\n                            t = e.close = \")$))\".concat(n);\n                        }\n                        if (e.prev.type === \"bos\") {\n                            N.negatedExtglob = true;\n                        }\n                    }\n                    push({\n                        type: \"paren\",\n                        extglob: true,\n                        value: B,\n                        output: t\n                    });\n                    decrement(\"parens\");\n                };\n                if (r.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(e)) {\n                    let n = false;\n                    let s = e.replace(a, (e, t, r, u, s, o)=>{\n                        if (u === \"\\\\\") {\n                            n = true;\n                            return e;\n                        }\n                        if (u === \"?\") {\n                            if (t) {\n                                return t + u + (s ? v.repeat(s.length) : \"\");\n                            }\n                            if (o === 0) {\n                                return O + (s ? v.repeat(s.length) : \"\");\n                            }\n                            return v.repeat(r.length);\n                        }\n                        if (u === \".\") {\n                            return E.repeat(r.length);\n                        }\n                        if (u === \"*\") {\n                            if (t) {\n                                return t + u + (s ? w : \"\");\n                            }\n                            return w;\n                        }\n                        return t ? e : \"\\\\\".concat(e);\n                    });\n                    if (n === true) {\n                        if (r.unescape === true) {\n                            s = s.replace(/\\\\/g, \"\");\n                        } else {\n                            s = s.replace(/\\\\+/g, (e)=>e.length % 2 === 0 ? \"\\\\\\\\\" : e ? \"\\\\\" : \"\");\n                        }\n                    }\n                    if (s === e && r.contains === true) {\n                        N.output = e;\n                        return N;\n                    }\n                    N.output = u.wrapOutput(s, N, t);\n                    return N;\n                }\n                while(!eos()){\n                    B = D();\n                    if (B === \"\\x00\") {\n                        continue;\n                    }\n                    if (B === \"\\\\\") {\n                        const e = G();\n                        if (e === \"/\" && r.bash !== true) {\n                            continue;\n                        }\n                        if (e === \".\" || e === \";\") {\n                            continue;\n                        }\n                        if (!e) {\n                            B += \"\\\\\";\n                            push({\n                                type: \"text\",\n                                value: B\n                            });\n                            continue;\n                        }\n                        const t = /^\\\\+/.exec(remaining());\n                        let n = 0;\n                        if (t && t[0].length > 2) {\n                            n = t[0].length;\n                            N.index += n;\n                            if (n % 2 !== 0) {\n                                B += \"\\\\\";\n                            }\n                        }\n                        if (r.unescape === true) {\n                            B = D() || \"\";\n                        } else {\n                            B += D() || \"\";\n                        }\n                        if (N.brackets === 0) {\n                            push({\n                                type: \"text\",\n                                value: B\n                            });\n                            continue;\n                        }\n                    }\n                    if (N.brackets > 0 && (B !== \"]\" || P.value === \"[\" || P.value === \"[^\")) {\n                        if (r.posix !== false && B === \":\") {\n                            const e = P.value.slice(1);\n                            if (e.includes(\"[\")) {\n                                P.posix = true;\n                                if (e.includes(\":\")) {\n                                    const e = P.value.lastIndexOf(\"[\");\n                                    const t = P.value.slice(0, e);\n                                    const r = P.value.slice(e + 2);\n                                    const n = o[r];\n                                    if (n) {\n                                        P.value = t + n;\n                                        N.backtrack = true;\n                                        D();\n                                        if (!f.output && A.indexOf(P) === 1) {\n                                            f.output = d;\n                                        }\n                                        continue;\n                                    }\n                                }\n                            }\n                        }\n                        if (B === \"[\" && G() !== \":\" || B === \"-\" && G() === \"]\") {\n                            B = \"\\\\\".concat(B);\n                        }\n                        if (B === \"]\" && (P.value === \"[\" || P.value === \"[^\")) {\n                            B = \"\\\\\".concat(B);\n                        }\n                        if (r.posix === true && B === \"!\" && P.value === \"[\") {\n                            B = \"^\";\n                        }\n                        P.value += B;\n                        append({\n                            value: B\n                        });\n                        continue;\n                    }\n                    if (N.quotes === 1 && B !== '\"') {\n                        B = u.escapeRegex(B);\n                        P.value += B;\n                        append({\n                            value: B\n                        });\n                        continue;\n                    }\n                    if (B === '\"') {\n                        N.quotes = N.quotes === 1 ? 0 : 1;\n                        if (r.keepQuotes === true) {\n                            push({\n                                type: \"text\",\n                                value: B\n                            });\n                        }\n                        continue;\n                    }\n                    if (B === \"(\") {\n                        increment(\"parens\");\n                        push({\n                            type: \"paren\",\n                            value: B\n                        });\n                        continue;\n                    }\n                    if (B === \")\") {\n                        if (N.parens === 0 && r.strictBrackets === true) {\n                            throw new SyntaxError(syntaxError(\"opening\", \"(\"));\n                        }\n                        const e = k[k.length - 1];\n                        if (e && N.parens === e.parens + 1) {\n                            extglobClose(k.pop());\n                            continue;\n                        }\n                        push({\n                            type: \"paren\",\n                            value: B,\n                            output: N.parens ? \")\" : \"\\\\)\"\n                        });\n                        decrement(\"parens\");\n                        continue;\n                    }\n                    if (B === \"[\") {\n                        if (r.nobracket === true || !remaining().includes(\"]\")) {\n                            if (r.nobracket !== true && r.strictBrackets === true) {\n                                throw new SyntaxError(syntaxError(\"closing\", \"]\"));\n                            }\n                            B = \"\\\\\".concat(B);\n                        } else {\n                            increment(\"brackets\");\n                        }\n                        push({\n                            type: \"bracket\",\n                            value: B\n                        });\n                        continue;\n                    }\n                    if (B === \"]\") {\n                        if (r.nobracket === true || P && P.type === \"bracket\" && P.value.length === 1) {\n                            push({\n                                type: \"text\",\n                                value: B,\n                                output: \"\\\\\".concat(B)\n                            });\n                            continue;\n                        }\n                        if (N.brackets === 0) {\n                            if (r.strictBrackets === true) {\n                                throw new SyntaxError(syntaxError(\"opening\", \"[\"));\n                            }\n                            push({\n                                type: \"text\",\n                                value: B,\n                                output: \"\\\\\".concat(B)\n                            });\n                            continue;\n                        }\n                        decrement(\"brackets\");\n                        const e = P.value.slice(1);\n                        if (P.posix !== true && e[0] === \"^\" && !e.includes(\"/\")) {\n                            B = \"/\".concat(B);\n                        }\n                        P.value += B;\n                        append({\n                            value: B\n                        });\n                        if (r.literalBrackets === false || u.hasRegexChars(e)) {\n                            continue;\n                        }\n                        const t = u.escapeRegex(P.value);\n                        N.output = N.output.slice(0, -P.value.length);\n                        if (r.literalBrackets === true) {\n                            N.output += t;\n                            P.value = t;\n                            continue;\n                        }\n                        P.value = \"(\".concat(R).concat(t, \"|\").concat(P.value, \")\");\n                        N.output += P.value;\n                        continue;\n                    }\n                    if (B === \"{\" && r.nobrace !== true) {\n                        increment(\"braces\");\n                        const e = {\n                            type: \"brace\",\n                            value: B,\n                            output: \"(\",\n                            outputIndex: N.output.length,\n                            tokensIndex: N.tokens.length\n                        };\n                        I.push(e);\n                        push(e);\n                        continue;\n                    }\n                    if (B === \"}\") {\n                        const e = I[I.length - 1];\n                        if (r.nobrace === true || !e) {\n                            push({\n                                type: \"text\",\n                                value: B,\n                                output: B\n                            });\n                            continue;\n                        }\n                        let t = \")\";\n                        if (e.dots === true) {\n                            const e = A.slice();\n                            const n = [];\n                            for(let t = e.length - 1; t >= 0; t--){\n                                A.pop();\n                                if (e[t].type === \"brace\") {\n                                    break;\n                                }\n                                if (e[t].type !== \"dots\") {\n                                    n.unshift(e[t].value);\n                                }\n                            }\n                            t = expandRange(n, r);\n                            N.backtrack = true;\n                        }\n                        if (e.comma !== true && e.dots !== true) {\n                            const r = N.output.slice(0, e.outputIndex);\n                            const n = N.tokens.slice(e.tokensIndex);\n                            e.value = e.output = \"\\\\{\";\n                            B = t = \"\\\\}\";\n                            N.output = r;\n                            for (const e of n){\n                                N.output += e.output || e.value;\n                            }\n                        }\n                        push({\n                            type: \"brace\",\n                            value: B,\n                            output: t\n                        });\n                        decrement(\"braces\");\n                        I.pop();\n                        continue;\n                    }\n                    if (B === \"|\") {\n                        if (k.length > 0) {\n                            k[k.length - 1].conditions++;\n                        }\n                        push({\n                            type: \"text\",\n                            value: B\n                        });\n                        continue;\n                    }\n                    if (B === \",\") {\n                        let e = B;\n                        const t = I[I.length - 1];\n                        if (t && M[M.length - 1] === \"braces\") {\n                            t.comma = true;\n                            e = \"|\";\n                        }\n                        push({\n                            type: \"comma\",\n                            value: B,\n                            output: e\n                        });\n                        continue;\n                    }\n                    if (B === \"/\") {\n                        if (P.type === \"dot\" && N.index === N.start + 1) {\n                            N.start = N.index + 1;\n                            N.consumed = \"\";\n                            N.output = \"\";\n                            A.pop();\n                            P = f;\n                            continue;\n                        }\n                        push({\n                            type: \"slash\",\n                            value: B,\n                            output: y\n                        });\n                        continue;\n                    }\n                    if (B === \".\") {\n                        if (N.braces > 0 && P.type === \"dot\") {\n                            if (P.value === \".\") P.output = E;\n                            const e = I[I.length - 1];\n                            P.type = \"dots\";\n                            P.output += B;\n                            P.value += B;\n                            e.dots = true;\n                            continue;\n                        }\n                        if (N.braces + N.parens === 0 && P.type !== \"bos\" && P.type !== \"slash\") {\n                            push({\n                                type: \"text\",\n                                value: B,\n                                output: E\n                            });\n                            continue;\n                        }\n                        push({\n                            type: \"dot\",\n                            value: B,\n                            output: E\n                        });\n                        continue;\n                    }\n                    if (B === \"?\") {\n                        const e = P && P.value === \"(\";\n                        if (!e && r.noextglob !== true && G() === \"(\" && G(2) !== \"?\") {\n                            extglobOpen(\"qmark\", B);\n                            continue;\n                        }\n                        if (P && P.type === \"paren\") {\n                            const e = G();\n                            let t = B;\n                            if (e === \"<\" && !u.supportsLookbehinds()) {\n                                throw new Error(\"Node.js v10 or higher is required for regex lookbehinds\");\n                            }\n                            if (P.value === \"(\" && !/[!=<:]/.test(e) || e === \"<\" && !/<([!=]|\\w+>)/.test(remaining())) {\n                                t = \"\\\\\".concat(B);\n                            }\n                            push({\n                                type: \"text\",\n                                value: B,\n                                output: t\n                            });\n                            continue;\n                        }\n                        if (r.dot !== true && (P.type === \"slash\" || P.type === \"bos\")) {\n                            push({\n                                type: \"qmark\",\n                                value: B,\n                                output: $\n                            });\n                            continue;\n                        }\n                        push({\n                            type: \"qmark\",\n                            value: B,\n                            output: v\n                        });\n                        continue;\n                    }\n                    if (B === \"!\") {\n                        if (r.noextglob !== true && G() === \"(\") {\n                            if (G(2) !== \"?\" || !/[!=<:]/.test(G(3))) {\n                                extglobOpen(\"negate\", B);\n                                continue;\n                            }\n                        }\n                        if (r.nonegate !== true && N.index === 0) {\n                            negate();\n                            continue;\n                        }\n                    }\n                    if (B === \"+\") {\n                        if (r.noextglob !== true && G() === \"(\" && G(2) !== \"?\") {\n                            extglobOpen(\"plus\", B);\n                            continue;\n                        }\n                        if (P && P.value === \"(\" || r.regex === false) {\n                            push({\n                                type: \"plus\",\n                                value: B,\n                                output: C\n                            });\n                            continue;\n                        }\n                        if (P && (P.type === \"bracket\" || P.type === \"paren\" || P.type === \"brace\") || N.parens > 0) {\n                            push({\n                                type: \"plus\",\n                                value: B\n                            });\n                            continue;\n                        }\n                        push({\n                            type: \"plus\",\n                            value: C\n                        });\n                        continue;\n                    }\n                    if (B === \"@\") {\n                        if (r.noextglob !== true && G() === \"(\" && G(2) !== \"?\") {\n                            push({\n                                type: \"at\",\n                                extglob: true,\n                                value: B,\n                                output: \"\"\n                            });\n                            continue;\n                        }\n                        push({\n                            type: \"text\",\n                            value: B\n                        });\n                        continue;\n                    }\n                    if (B !== \"*\") {\n                        if (B === \"$\" || B === \"^\") {\n                            B = \"\\\\\".concat(B);\n                        }\n                        const e = i.exec(remaining());\n                        if (e) {\n                            B += e[0];\n                            N.index += e[0].length;\n                        }\n                        push({\n                            type: \"text\",\n                            value: B\n                        });\n                        continue;\n                    }\n                    if (P && (P.type === \"globstar\" || P.star === true)) {\n                        P.type = \"star\";\n                        P.star = true;\n                        P.value += B;\n                        P.output = w;\n                        N.backtrack = true;\n                        N.globstar = true;\n                        consume(B);\n                        continue;\n                    }\n                    let t = remaining();\n                    if (r.noextglob !== true && /^\\([^?]/.test(t)) {\n                        extglobOpen(\"star\", B);\n                        continue;\n                    }\n                    if (P.type === \"star\") {\n                        if (r.noglobstar === true) {\n                            consume(B);\n                            continue;\n                        }\n                        const n = P.prev;\n                        const u = n.prev;\n                        const s = n.type === \"slash\" || n.type === \"bos\";\n                        const o = u && (u.type === \"star\" || u.type === \"globstar\");\n                        if (r.bash === true && (!s || t[0] && t[0] !== \"/\")) {\n                            push({\n                                type: \"star\",\n                                value: B,\n                                output: \"\"\n                            });\n                            continue;\n                        }\n                        const i = N.braces > 0 && (n.type === \"comma\" || n.type === \"brace\");\n                        const a = k.length && (n.type === \"pipe\" || n.type === \"paren\");\n                        if (!s && n.type !== \"paren\" && !i && !a) {\n                            push({\n                                type: \"star\",\n                                value: B,\n                                output: \"\"\n                            });\n                            continue;\n                        }\n                        while(t.slice(0, 3) === \"/**\"){\n                            const r = e[N.index + 4];\n                            if (r && r !== \"/\") {\n                                break;\n                            }\n                            t = t.slice(3);\n                            consume(\"/**\", 3);\n                        }\n                        if (n.type === \"bos\" && eos()) {\n                            P.type = \"globstar\";\n                            P.value += B;\n                            P.output = globstar(r);\n                            N.output = P.output;\n                            N.globstar = true;\n                            consume(B);\n                            continue;\n                        }\n                        if (n.type === \"slash\" && n.prev.type !== \"bos\" && !o && eos()) {\n                            N.output = N.output.slice(0, -(n.output + P.output).length);\n                            n.output = \"(?:\".concat(n.output);\n                            P.type = \"globstar\";\n                            P.output = globstar(r) + (r.strictSlashes ? \")\" : \"|$)\");\n                            P.value += B;\n                            N.globstar = true;\n                            N.output += n.output + P.output;\n                            consume(B);\n                            continue;\n                        }\n                        if (n.type === \"slash\" && n.prev.type !== \"bos\" && t[0] === \"/\") {\n                            const e = t[1] !== void 0 ? \"|$\" : \"\";\n                            N.output = N.output.slice(0, -(n.output + P.output).length);\n                            n.output = \"(?:\".concat(n.output);\n                            P.type = \"globstar\";\n                            P.output = \"\".concat(globstar(r)).concat(y, \"|\").concat(y).concat(e, \")\");\n                            P.value += B;\n                            N.output += n.output + P.output;\n                            N.globstar = true;\n                            consume(B + D());\n                            push({\n                                type: \"slash\",\n                                value: \"/\",\n                                output: \"\"\n                            });\n                            continue;\n                        }\n                        if (n.type === \"bos\" && t[0] === \"/\") {\n                            P.type = \"globstar\";\n                            P.value += B;\n                            P.output = \"(?:^|\".concat(y, \"|\").concat(globstar(r)).concat(y, \")\");\n                            N.output = P.output;\n                            N.globstar = true;\n                            consume(B + D());\n                            push({\n                                type: \"slash\",\n                                value: \"/\",\n                                output: \"\"\n                            });\n                            continue;\n                        }\n                        N.output = N.output.slice(0, -P.output.length);\n                        P.type = \"globstar\";\n                        P.output = globstar(r);\n                        P.value += B;\n                        N.output += P.output;\n                        N.globstar = true;\n                        consume(B);\n                        continue;\n                    }\n                    const n = {\n                        type: \"star\",\n                        value: B,\n                        output: w\n                    };\n                    if (r.bash === true) {\n                        n.output = \".*?\";\n                        if (P.type === \"bos\" || P.type === \"slash\") {\n                            n.output = L + n.output;\n                        }\n                        push(n);\n                        continue;\n                    }\n                    if (P && (P.type === \"bracket\" || P.type === \"paren\") && r.regex === true) {\n                        n.output = B;\n                        push(n);\n                        continue;\n                    }\n                    if (N.index === N.start || P.type === \"slash\" || P.type === \"dot\") {\n                        if (P.type === \"dot\") {\n                            N.output += S;\n                            P.output += S;\n                        } else if (r.dot === true) {\n                            N.output += H;\n                            P.output += H;\n                        } else {\n                            N.output += L;\n                            P.output += L;\n                        }\n                        if (G() !== \"*\") {\n                            N.output += d;\n                            P.output += d;\n                        }\n                    }\n                    push(n);\n                }\n                while(N.brackets > 0){\n                    if (r.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \"]\"));\n                    N.output = u.escapeLast(N.output, \"[\");\n                    decrement(\"brackets\");\n                }\n                while(N.parens > 0){\n                    if (r.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \")\"));\n                    N.output = u.escapeLast(N.output, \"(\");\n                    decrement(\"parens\");\n                }\n                while(N.braces > 0){\n                    if (r.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \"}\"));\n                    N.output = u.escapeLast(N.output, \"{\");\n                    decrement(\"braces\");\n                }\n                if (r.strictSlashes !== true && (P.type === \"star\" || P.type === \"bracket\")) {\n                    push({\n                        type: \"maybe_slash\",\n                        value: \"\",\n                        output: \"\".concat(y, \"?\")\n                    });\n                }\n                if (N.backtrack === true) {\n                    N.output = \"\";\n                    for (const e of N.tokens){\n                        N.output += e.output != null ? e.output : e.value;\n                        if (e.suffix) {\n                            N.output += e.suffix;\n                        }\n                    }\n                }\n                return N;\n            };\n            parse.fastpaths = (e, t)=>{\n                const r = {\n                    ...t\n                };\n                const o = typeof r.maxLength === \"number\" ? Math.min(s, r.maxLength) : s;\n                const i = e.length;\n                if (i > o) {\n                    throw new SyntaxError(\"Input length: \".concat(i, \", exceeds maximum allowed length: \").concat(o));\n                }\n                e = l[e] || e;\n                const a = u.isWindows(t);\n                const { DOT_LITERAL: c, SLASH_LITERAL: p, ONE_CHAR: f, DOTS_SLASH: A, NO_DOT: R, NO_DOTS: _, NO_DOTS_SLASH: h, STAR: g, START_ANCHOR: E } = n.globChars(a);\n                const C = r.dot ? _ : R;\n                const y = r.dot ? h : R;\n                const d = r.capture ? \"\" : \"?:\";\n                const x = {\n                    negated: false,\n                    prefix: \"\"\n                };\n                let b = r.bash === true ? \".*?\" : g;\n                if (r.capture) {\n                    b = \"(\".concat(b, \")\");\n                }\n                const globstar = (e)=>{\n                    if (e.noglobstar === true) return b;\n                    return \"(\".concat(d, \"(?:(?!\").concat(E).concat(e.dot ? A : c, \").)*?)\");\n                };\n                const create = (e)=>{\n                    switch(e){\n                        case \"*\":\n                            return \"\".concat(C).concat(f).concat(b);\n                        case \".*\":\n                            return \"\".concat(c).concat(f).concat(b);\n                        case \"*.*\":\n                            return \"\".concat(C).concat(b).concat(c).concat(f).concat(b);\n                        case \"*/*\":\n                            return \"\".concat(C).concat(b).concat(p).concat(f).concat(y).concat(b);\n                        case \"**\":\n                            return C + globstar(r);\n                        case \"**/*\":\n                            return \"(?:\".concat(C).concat(globstar(r)).concat(p, \")?\").concat(y).concat(f).concat(b);\n                        case \"**/*.*\":\n                            return \"(?:\".concat(C).concat(globstar(r)).concat(p, \")?\").concat(y).concat(b).concat(c).concat(f).concat(b);\n                        case \"**/.*\":\n                            return \"(?:\".concat(C).concat(globstar(r)).concat(p, \")?\").concat(c).concat(f).concat(b);\n                        default:\n                            {\n                                const t = /^(.*?)\\.(\\w+)$/.exec(e);\n                                if (!t) return;\n                                const r = create(t[1]);\n                                if (!r) return;\n                                return r + c + t[2];\n                            }\n                    }\n                };\n                const S = u.removePrefix(e, x);\n                let H = create(S);\n                if (H && r.strictSlashes !== true) {\n                    H += \"\".concat(p, \"?\");\n                }\n                return H;\n            };\n            e.exports = parse;\n        },\n        683: (e, t, r)=>{\n            const n = r(17);\n            const u = r(700);\n            const s = r(754);\n            const o = r(513);\n            const i = r(356);\n            const isObject = (e)=>e && typeof e === \"object\" && !Array.isArray(e);\n            const picomatch = function(e, t) {\n                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n                if (Array.isArray(e)) {\n                    const n = e.map((e)=>picomatch(e, t, r));\n                    const arrayMatcher = (e)=>{\n                        for (const t of n){\n                            const r = t(e);\n                            if (r) return r;\n                        }\n                        return false;\n                    };\n                    return arrayMatcher;\n                }\n                const n = isObject(e) && e.tokens && e.input;\n                if (e === \"\" || typeof e !== \"string\" && !n) {\n                    throw new TypeError(\"Expected pattern to be a non-empty string\");\n                }\n                const u = t || {};\n                const s = o.isWindows(t);\n                const i = n ? picomatch.compileRe(e, t) : picomatch.makeRe(e, t, false, true);\n                const a = i.state;\n                delete i.state;\n                let isIgnored = ()=>false;\n                if (u.ignore) {\n                    const e = {\n                        ...t,\n                        ignore: null,\n                        onMatch: null,\n                        onResult: null\n                    };\n                    isIgnored = picomatch(u.ignore, e, r);\n                }\n                const matcher = function(r) {\n                    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n                    const { isMatch: o, match: l, output: c } = picomatch.test(r, i, t, {\n                        glob: e,\n                        posix: s\n                    });\n                    const p = {\n                        glob: e,\n                        state: a,\n                        regex: i,\n                        posix: s,\n                        input: r,\n                        output: c,\n                        match: l,\n                        isMatch: o\n                    };\n                    if (typeof u.onResult === \"function\") {\n                        u.onResult(p);\n                    }\n                    if (o === false) {\n                        p.isMatch = false;\n                        return n ? p : false;\n                    }\n                    if (isIgnored(r)) {\n                        if (typeof u.onIgnore === \"function\") {\n                            u.onIgnore(p);\n                        }\n                        p.isMatch = false;\n                        return n ? p : false;\n                    }\n                    if (typeof u.onMatch === \"function\") {\n                        u.onMatch(p);\n                    }\n                    return n ? p : true;\n                };\n                if (r) {\n                    matcher.state = a;\n                }\n                return matcher;\n            };\n            picomatch.test = function(e, t, r) {\n                let { glob: n, posix: u } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n                if (typeof e !== \"string\") {\n                    throw new TypeError(\"Expected input to be a string\");\n                }\n                if (e === \"\") {\n                    return {\n                        isMatch: false,\n                        output: \"\"\n                    };\n                }\n                const s = r || {};\n                const i = s.format || (u ? o.toPosixSlashes : null);\n                let a = e === n;\n                let l = a && i ? i(e) : e;\n                if (a === false) {\n                    l = i ? i(e) : e;\n                    a = l === n;\n                }\n                if (a === false || s.capture === true) {\n                    if (s.matchBase === true || s.basename === true) {\n                        a = picomatch.matchBase(e, t, r, u);\n                    } else {\n                        a = t.exec(l);\n                    }\n                }\n                return {\n                    isMatch: Boolean(a),\n                    match: a,\n                    output: l\n                };\n            };\n            picomatch.matchBase = function(e, t, r) {\n                let u = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : o.isWindows(r);\n                const s = t instanceof RegExp ? t : picomatch.makeRe(t, r);\n                return s.test(n.basename(e));\n            };\n            picomatch.isMatch = (e, t, r)=>picomatch(t, r)(e);\n            picomatch.parse = (e, t)=>{\n                if (Array.isArray(e)) return e.map((e)=>picomatch.parse(e, t));\n                return s(e, {\n                    ...t,\n                    fastpaths: false\n                });\n            };\n            picomatch.scan = (e, t)=>u(e, t);\n            picomatch.compileRe = function(e, t) {\n                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n                if (r === true) {\n                    return e.output;\n                }\n                const u = t || {};\n                const s = u.contains ? \"\" : \"^\";\n                const o = u.contains ? \"\" : \"$\";\n                let i = \"\".concat(s, \"(?:\").concat(e.output, \")\").concat(o);\n                if (e && e.negated === true) {\n                    i = \"^(?!\".concat(i, \").*$\");\n                }\n                const a = picomatch.toRegex(i, t);\n                if (n === true) {\n                    a.state = e;\n                }\n                return a;\n            };\n            picomatch.makeRe = function(e, t) {\n                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n                if (!e || typeof e !== \"string\") {\n                    throw new TypeError(\"Expected a non-empty string\");\n                }\n                const u = t || {};\n                let o = {\n                    negated: false,\n                    fastpaths: true\n                };\n                let i = \"\";\n                let a;\n                if (e.startsWith(\"./\")) {\n                    e = e.slice(2);\n                    i = o.prefix = \"./\";\n                }\n                if (u.fastpaths !== false && (e[0] === \".\" || e[0] === \"*\")) {\n                    a = s.fastpaths(e, t);\n                }\n                if (a === undefined) {\n                    o = s(e, t);\n                    o.prefix = i + (o.prefix || \"\");\n                } else {\n                    o.output = a;\n                }\n                return picomatch.compileRe(o, t, r, n);\n            };\n            picomatch.toRegex = (e, t)=>{\n                try {\n                    const r = t || {};\n                    return new RegExp(e, r.flags || (r.nocase ? \"i\" : \"\"));\n                } catch (e) {\n                    if (t && t.debug === true) throw e;\n                    return /$^/;\n                }\n            };\n            picomatch.constants = i;\n            e.exports = picomatch;\n        },\n        700: (e, t, r)=>{\n            const n = r(513);\n            const { CHAR_ASTERISK: u, CHAR_AT: s, CHAR_BACKWARD_SLASH: o, CHAR_COMMA: i, CHAR_DOT: a, CHAR_EXCLAMATION_MARK: l, CHAR_FORWARD_SLASH: c, CHAR_LEFT_CURLY_BRACE: p, CHAR_LEFT_PARENTHESES: f, CHAR_LEFT_SQUARE_BRACKET: A, CHAR_PLUS: R, CHAR_QUESTION_MARK: _, CHAR_RIGHT_CURLY_BRACE: h, CHAR_RIGHT_PARENTHESES: g, CHAR_RIGHT_SQUARE_BRACKET: E } = r(356);\n            const isPathSeparator = (e)=>e === c || e === o;\n            const depth = (e)=>{\n                if (e.isPrefix !== true) {\n                    e.depth = e.isGlobstar ? Infinity : 1;\n                }\n            };\n            const scan = (e, t)=>{\n                const r = t || {};\n                const C = e.length - 1;\n                const y = r.parts === true || r.scanToEnd === true;\n                const d = [];\n                const x = [];\n                const b = [];\n                let S = e;\n                let H = -1;\n                let v = 0;\n                let $ = 0;\n                let m = false;\n                let T = false;\n                let L = false;\n                let O = false;\n                let w = false;\n                let N = false;\n                let k = false;\n                let I = false;\n                let M = false;\n                let P = 0;\n                let B;\n                let G;\n                let D = {\n                    value: \"\",\n                    depth: 0,\n                    isGlob: false\n                };\n                const eos = ()=>H >= C;\n                const peek = ()=>S.charCodeAt(H + 1);\n                const advance = ()=>{\n                    B = G;\n                    return S.charCodeAt(++H);\n                };\n                while(H < C){\n                    G = advance();\n                    let e;\n                    if (G === o) {\n                        k = D.backslashes = true;\n                        G = advance();\n                        if (G === p) {\n                            N = true;\n                        }\n                        continue;\n                    }\n                    if (N === true || G === p) {\n                        P++;\n                        while(eos() !== true && (G = advance())){\n                            if (G === o) {\n                                k = D.backslashes = true;\n                                advance();\n                                continue;\n                            }\n                            if (G === p) {\n                                P++;\n                                continue;\n                            }\n                            if (N !== true && G === a && (G = advance()) === a) {\n                                m = D.isBrace = true;\n                                L = D.isGlob = true;\n                                M = true;\n                                if (y === true) {\n                                    continue;\n                                }\n                                break;\n                            }\n                            if (N !== true && G === i) {\n                                m = D.isBrace = true;\n                                L = D.isGlob = true;\n                                M = true;\n                                if (y === true) {\n                                    continue;\n                                }\n                                break;\n                            }\n                            if (G === h) {\n                                P--;\n                                if (P === 0) {\n                                    N = false;\n                                    m = D.isBrace = true;\n                                    M = true;\n                                    break;\n                                }\n                            }\n                        }\n                        if (y === true) {\n                            continue;\n                        }\n                        break;\n                    }\n                    if (G === c) {\n                        d.push(H);\n                        x.push(D);\n                        D = {\n                            value: \"\",\n                            depth: 0,\n                            isGlob: false\n                        };\n                        if (M === true) continue;\n                        if (B === a && H === v + 1) {\n                            v += 2;\n                            continue;\n                        }\n                        $ = H + 1;\n                        continue;\n                    }\n                    if (r.noext !== true) {\n                        const e = G === R || G === s || G === u || G === _ || G === l;\n                        if (e === true && peek() === f) {\n                            L = D.isGlob = true;\n                            O = D.isExtglob = true;\n                            M = true;\n                            if (y === true) {\n                                while(eos() !== true && (G = advance())){\n                                    if (G === o) {\n                                        k = D.backslashes = true;\n                                        G = advance();\n                                        continue;\n                                    }\n                                    if (G === g) {\n                                        L = D.isGlob = true;\n                                        M = true;\n                                        break;\n                                    }\n                                }\n                                continue;\n                            }\n                            break;\n                        }\n                    }\n                    if (G === u) {\n                        if (B === u) w = D.isGlobstar = true;\n                        L = D.isGlob = true;\n                        M = true;\n                        if (y === true) {\n                            continue;\n                        }\n                        break;\n                    }\n                    if (G === _) {\n                        L = D.isGlob = true;\n                        M = true;\n                        if (y === true) {\n                            continue;\n                        }\n                        break;\n                    }\n                    if (G === A) {\n                        while(eos() !== true && (e = advance())){\n                            if (e === o) {\n                                k = D.backslashes = true;\n                                advance();\n                                continue;\n                            }\n                            if (e === E) {\n                                T = D.isBracket = true;\n                                L = D.isGlob = true;\n                                M = true;\n                                break;\n                            }\n                        }\n                        if (y === true) {\n                            continue;\n                        }\n                        break;\n                    }\n                    if (r.nonegate !== true && G === l && H === v) {\n                        I = D.negated = true;\n                        v++;\n                        continue;\n                    }\n                    if (r.noparen !== true && G === f) {\n                        L = D.isGlob = true;\n                        if (y === true) {\n                            while(eos() !== true && (G = advance())){\n                                if (G === f) {\n                                    k = D.backslashes = true;\n                                    G = advance();\n                                    continue;\n                                }\n                                if (G === g) {\n                                    M = true;\n                                    break;\n                                }\n                            }\n                            continue;\n                        }\n                        break;\n                    }\n                    if (L === true) {\n                        M = true;\n                        if (y === true) {\n                            continue;\n                        }\n                        break;\n                    }\n                }\n                if (r.noext === true) {\n                    O = false;\n                    L = false;\n                }\n                let U = S;\n                let K = \"\";\n                let F = \"\";\n                if (v > 0) {\n                    K = S.slice(0, v);\n                    S = S.slice(v);\n                    $ -= v;\n                }\n                if (U && L === true && $ > 0) {\n                    U = S.slice(0, $);\n                    F = S.slice($);\n                } else if (L === true) {\n                    U = \"\";\n                    F = S;\n                } else {\n                    U = S;\n                }\n                if (U && U !== \"\" && U !== \"/\" && U !== S) {\n                    if (isPathSeparator(U.charCodeAt(U.length - 1))) {\n                        U = U.slice(0, -1);\n                    }\n                }\n                if (r.unescape === true) {\n                    if (F) F = n.removeBackslashes(F);\n                    if (U && k === true) {\n                        U = n.removeBackslashes(U);\n                    }\n                }\n                const Q = {\n                    prefix: K,\n                    input: e,\n                    start: v,\n                    base: U,\n                    glob: F,\n                    isBrace: m,\n                    isBracket: T,\n                    isGlob: L,\n                    isExtglob: O,\n                    isGlobstar: w,\n                    negated: I\n                };\n                if (r.tokens === true) {\n                    Q.maxDepth = 0;\n                    if (!isPathSeparator(G)) {\n                        x.push(D);\n                    }\n                    Q.tokens = x;\n                }\n                if (r.parts === true || r.tokens === true) {\n                    let t;\n                    for(let n = 0; n < d.length; n++){\n                        const u = t ? t + 1 : v;\n                        const s = d[n];\n                        const o = e.slice(u, s);\n                        if (r.tokens) {\n                            if (n === 0 && v !== 0) {\n                                x[n].isPrefix = true;\n                                x[n].value = K;\n                            } else {\n                                x[n].value = o;\n                            }\n                            depth(x[n]);\n                            Q.maxDepth += x[n].depth;\n                        }\n                        if (n !== 0 || o !== \"\") {\n                            b.push(o);\n                        }\n                        t = s;\n                    }\n                    if (t && t + 1 < e.length) {\n                        const n = e.slice(t + 1);\n                        b.push(n);\n                        if (r.tokens) {\n                            x[x.length - 1].value = n;\n                            depth(x[x.length - 1]);\n                            Q.maxDepth += x[x.length - 1].depth;\n                        }\n                    }\n                    Q.slashes = d;\n                    Q.parts = b;\n                }\n                return Q;\n            };\n            e.exports = scan;\n        },\n        513: (e, t, r)=>{\n            const n = r(17);\n            const u = process.platform === \"win32\";\n            const { REGEX_BACKSLASH: s, REGEX_REMOVE_BACKSLASH: o, REGEX_SPECIAL_CHARS: i, REGEX_SPECIAL_CHARS_GLOBAL: a } = r(356);\n            t.isObject = (e)=>e !== null && typeof e === \"object\" && !Array.isArray(e);\n            t.hasRegexChars = (e)=>i.test(e);\n            t.isRegexChar = (e)=>e.length === 1 && t.hasRegexChars(e);\n            t.escapeRegex = (e)=>e.replace(a, \"\\\\$1\");\n            t.toPosixSlashes = (e)=>e.replace(s, \"/\");\n            t.removeBackslashes = (e)=>e.replace(o, (e)=>e === \"\\\\\" ? \"\" : e);\n            t.supportsLookbehinds = ()=>{\n                const e = process.version.slice(1).split(\".\").map(Number);\n                if (e.length === 3 && e[0] >= 9 || e[0] === 8 && e[1] >= 10) {\n                    return true;\n                }\n                return false;\n            };\n            t.isWindows = (e)=>{\n                if (e && typeof e.windows === \"boolean\") {\n                    return e.windows;\n                }\n                return u === true || n.sep === \"\\\\\";\n            };\n            t.escapeLast = (e, r, n)=>{\n                const u = e.lastIndexOf(r, n);\n                if (u === -1) return e;\n                if (e[u - 1] === \"\\\\\") return t.escapeLast(e, r, u - 1);\n                return \"\".concat(e.slice(0, u), \"\\\\\").concat(e.slice(u));\n            };\n            t.removePrefix = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                let r = e;\n                if (r.startsWith(\"./\")) {\n                    r = r.slice(2);\n                    t.prefix = \"./\";\n                }\n                return r;\n            };\n            t.wrapOutput = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                const n = r.contains ? \"\" : \"^\";\n                const u = r.contains ? \"\" : \"$\";\n                let s = \"\".concat(n, \"(?:\").concat(e, \")\").concat(u);\n                if (t.negated === true) {\n                    s = \"(?:^(?!\".concat(s, \").*$)\");\n                }\n                return s;\n            };\n        },\n        492: (e, t, r)=>{\n            /*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */ const n = r(357);\n            const toRegexRange = (e, t, r)=>{\n                if (n(e) === false) {\n                    throw new TypeError(\"toRegexRange: expected the first argument to be a number\");\n                }\n                if (t === void 0 || e === t) {\n                    return String(e);\n                }\n                if (n(t) === false) {\n                    throw new TypeError(\"toRegexRange: expected the second argument to be a number.\");\n                }\n                let u = {\n                    relaxZeros: true,\n                    ...r\n                };\n                if (typeof u.strictZeros === \"boolean\") {\n                    u.relaxZeros = u.strictZeros === false;\n                }\n                let s = String(u.relaxZeros);\n                let o = String(u.shorthand);\n                let i = String(u.capture);\n                let a = String(u.wrap);\n                let l = e + \":\" + t + \"=\" + s + o + i + a;\n                if (toRegexRange.cache.hasOwnProperty(l)) {\n                    return toRegexRange.cache[l].result;\n                }\n                let c = Math.min(e, t);\n                let p = Math.max(e, t);\n                if (Math.abs(c - p) === 1) {\n                    let r = e + \"|\" + t;\n                    if (u.capture) {\n                        return \"(\".concat(r, \")\");\n                    }\n                    if (u.wrap === false) {\n                        return r;\n                    }\n                    return \"(?:\".concat(r, \")\");\n                }\n                let f = hasPadding(e) || hasPadding(t);\n                let A = {\n                    min: e,\n                    max: t,\n                    a: c,\n                    b: p\n                };\n                let R = [];\n                let _ = [];\n                if (f) {\n                    A.isPadded = f;\n                    A.maxLen = String(A.max).length;\n                }\n                if (c < 0) {\n                    let e = p < 0 ? Math.abs(p) : 1;\n                    _ = splitToPatterns(e, Math.abs(c), A, u);\n                    c = A.a = 0;\n                }\n                if (p >= 0) {\n                    R = splitToPatterns(c, p, A, u);\n                }\n                A.negatives = _;\n                A.positives = R;\n                A.result = collatePatterns(_, R, u);\n                if (u.capture === true) {\n                    A.result = \"(\".concat(A.result, \")\");\n                } else if (u.wrap !== false && R.length + _.length > 1) {\n                    A.result = \"(?:\".concat(A.result, \")\");\n                }\n                toRegexRange.cache[l] = A;\n                return A.result;\n            };\n            function collatePatterns(e, t, r) {\n                let n = filterPatterns(e, t, \"-\", false, r) || [];\n                let u = filterPatterns(t, e, \"\", false, r) || [];\n                let s = filterPatterns(e, t, \"-?\", true, r) || [];\n                let o = n.concat(s).concat(u);\n                return o.join(\"|\");\n            }\n            function splitToRanges(e, t) {\n                let r = 1;\n                let n = 1;\n                let u = countNines(e, r);\n                let s = new Set([\n                    t\n                ]);\n                while(e <= u && u <= t){\n                    s.add(u);\n                    r += 1;\n                    u = countNines(e, r);\n                }\n                u = countZeros(t + 1, n) - 1;\n                while(e < u && u <= t){\n                    s.add(u);\n                    n += 1;\n                    u = countZeros(t + 1, n) - 1;\n                }\n                s = [\n                    ...s\n                ];\n                s.sort(compare);\n                return s;\n            }\n            function rangeToPattern(e, t, r) {\n                if (e === t) {\n                    return {\n                        pattern: e,\n                        count: [],\n                        digits: 0\n                    };\n                }\n                let n = zip(e, t);\n                let u = n.length;\n                let s = \"\";\n                let o = 0;\n                for(let e = 0; e < u; e++){\n                    let [t, u] = n[e];\n                    if (t === u) {\n                        s += t;\n                    } else if (t !== \"0\" || u !== \"9\") {\n                        s += toCharacterClass(t, u, r);\n                    } else {\n                        o++;\n                    }\n                }\n                if (o) {\n                    s += r.shorthand === true ? \"\\\\d\" : \"[0-9]\";\n                }\n                return {\n                    pattern: s,\n                    count: [\n                        o\n                    ],\n                    digits: u\n                };\n            }\n            function splitToPatterns(e, t, r, n) {\n                let u = splitToRanges(e, t);\n                let s = [];\n                let o = e;\n                let i;\n                for(let e = 0; e < u.length; e++){\n                    let t = u[e];\n                    let a = rangeToPattern(String(o), String(t), n);\n                    let l = \"\";\n                    if (!r.isPadded && i && i.pattern === a.pattern) {\n                        if (i.count.length > 1) {\n                            i.count.pop();\n                        }\n                        i.count.push(a.count[0]);\n                        i.string = i.pattern + toQuantifier(i.count);\n                        o = t + 1;\n                        continue;\n                    }\n                    if (r.isPadded) {\n                        l = padZeros(t, r, n);\n                    }\n                    a.string = l + a.pattern + toQuantifier(a.count);\n                    s.push(a);\n                    o = t + 1;\n                    i = a;\n                }\n                return s;\n            }\n            function filterPatterns(e, t, r, n, u) {\n                let s = [];\n                for (let u of e){\n                    let { string: e } = u;\n                    if (!n && !contains(t, \"string\", e)) {\n                        s.push(r + e);\n                    }\n                    if (n && contains(t, \"string\", e)) {\n                        s.push(r + e);\n                    }\n                }\n                return s;\n            }\n            function zip(e, t) {\n                let r = [];\n                for(let n = 0; n < e.length; n++)r.push([\n                    e[n],\n                    t[n]\n                ]);\n                return r;\n            }\n            function compare(e, t) {\n                return e > t ? 1 : t > e ? -1 : 0;\n            }\n            function contains(e, t, r) {\n                return e.some((e)=>e[t] === r);\n            }\n            function countNines(e, t) {\n                return Number(String(e).slice(0, -t) + \"9\".repeat(t));\n            }\n            function countZeros(e, t) {\n                return e - e % Math.pow(10, t);\n            }\n            function toQuantifier(e) {\n                let [t = 0, r = \"\"] = e;\n                if (r || t > 1) {\n                    return \"{\".concat(t + (r ? \",\" + r : \"\"), \"}\");\n                }\n                return \"\";\n            }\n            function toCharacterClass(e, t, r) {\n                return \"[\".concat(e).concat(t - e === 1 ? \"\" : \"-\").concat(t, \"]\");\n            }\n            function hasPadding(e) {\n                return /^-?(0+)\\d/.test(e);\n            }\n            function padZeros(e, t, r) {\n                if (!t.isPadded) {\n                    return e;\n                }\n                let n = Math.abs(t.maxLen - String(e).length);\n                let u = r.relaxZeros !== false;\n                switch(n){\n                    case 0:\n                        return \"\";\n                    case 1:\n                        return u ? \"0?\" : \"0\";\n                    case 2:\n                        return u ? \"0{0,2}\" : \"00\";\n                    default:\n                        {\n                            return u ? \"0{0,\".concat(n, \"}\") : \"0{\".concat(n, \"}\");\n                        }\n                }\n            }\n            toRegexRange.cache = {};\n            toRegexRange.clearCache = ()=>toRegexRange.cache = {};\n            e.exports = toRegexRange;\n        },\n        17: (e)=>{\n            e.exports = __webpack_require__(/*! path */ \"(app-pages-browser)/./node_modules/next/dist/compiled/path-browserify/index.js\");\n        },\n        837: (e)=>{\n            e.exports = __webpack_require__(/*! util */ \"(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js\");\n        }\n    };\n    var t = {};\n    function __nccwpck_require__(r) {\n        var n = t[r];\n        if (n !== undefined) {\n            return n.exports;\n        }\n        var u = t[r] = {\n            exports: {}\n        };\n        var s = true;\n        try {\n            e[r](u, u.exports, __nccwpck_require__);\n            s = false;\n        } finally{\n            if (s) delete t[r];\n        }\n        return u.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var r = __nccwpck_require__(971);\n    module.exports = r;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWljcm9tYXRjaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQztJQUFLO0lBQWEsSUFBSUEsSUFBRTtRQUFDLEtBQUksQ0FBQ0EsR0FBRUMsR0FBRUM7WUFBSyxNQUFNQyxJQUFFRCxFQUFFO1lBQUssTUFBTUUsSUFBRUYsRUFBRTtZQUFLLE1BQU1HLElBQUVILEVBQUU7WUFBSSxNQUFNSSxJQUFFSixFQUFFO1lBQUssTUFBTUssU0FBTyxTQUFDUDtvQkFBRUMscUVBQUUsQ0FBQztnQkFBSyxJQUFJQyxJQUFFLEVBQUU7Z0JBQUMsSUFBR00sTUFBTUMsT0FBTyxDQUFDVCxJQUFHO29CQUFDLEtBQUksSUFBSUcsS0FBS0gsRUFBRTt3QkFBQyxJQUFJQSxJQUFFTyxPQUFPRyxNQUFNLENBQUNQLEdBQUVGO3dCQUFHLElBQUdPLE1BQU1DLE9BQU8sQ0FBQ1QsSUFBRzs0QkFBQ0UsRUFBRVMsSUFBSSxJQUFJWDt3QkFBRSxPQUFLOzRCQUFDRSxFQUFFUyxJQUFJLENBQUNYO3dCQUFFO29CQUFDO2dCQUFDLE9BQUs7b0JBQUNFLElBQUUsRUFBRSxDQUFDVSxNQUFNLENBQUNMLE9BQU9HLE1BQU0sQ0FBQ1YsR0FBRUM7Z0JBQUc7Z0JBQUMsSUFBR0EsS0FBR0EsRUFBRVksTUFBTSxLQUFHLFFBQU1aLEVBQUVhLE9BQU8sS0FBRyxNQUFLO29CQUFDWixJQUFFOzJCQUFJLElBQUlhLElBQUliO3FCQUFHO2dCQUFBO2dCQUFDLE9BQU9BO1lBQUM7WUFBRUssT0FBT1MsS0FBSyxHQUFDLFNBQUNoQjtvQkFBRUMscUVBQUUsQ0FBQzt1QkFBSUssRUFBRU4sR0FBRUM7O1lBQUdNLE9BQU9VLFNBQVMsR0FBQyxTQUFDakI7b0JBQUVDLHFFQUFFLENBQUM7Z0JBQUssSUFBRyxPQUFPRCxNQUFJLFVBQVM7b0JBQUMsT0FBT0csRUFBRUksT0FBT1MsS0FBSyxDQUFDaEIsR0FBRUMs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QUFFO2dCQUFDO1lBQUM7WUFBQ3lXLGFBQWFJLEtBQUssR0FBQyxDQUFDO1lBQUVKLGFBQWEyQixVQUFVLEdBQUMsSUFBSTNCLGFBQWFJLEtBQUssR0FBQyxDQUFDO1lBQUVoWCxFQUFFdUIsT0FBTyxHQUFDcVY7UUFBWTtRQUFFLElBQUc1VyxDQUFBQTtZQUFJQSxFQUFFdUIsT0FBTyxHQUFDaVgsbUJBQU9BLENBQUMsNEZBQU07UUFBQztRQUFFLEtBQUl4WSxDQUFBQTtZQUFJQSxFQUFFdUIsT0FBTyxHQUFDaVgsbUJBQU9BLENBQUMsZ0ZBQU07UUFBQztJQUFDO0lBQUUsSUFBSXZZLElBQUUsQ0FBQztJQUFFLFNBQVN3WSxvQkFBb0J2WSxDQUFDO1FBQUUsSUFBSUMsSUFBRUYsQ0FBQyxDQUFDQyxFQUFFO1FBQUMsSUFBR0MsTUFBSTBVLFdBQVU7WUFBQyxPQUFPMVUsRUFBRW9CLE9BQU87UUFBQTtRQUFDLElBQUluQixJQUFFSCxDQUFDLENBQUNDLEVBQUUsR0FBQztZQUFDcUIsU0FBUSxDQUFDO1FBQUM7UUFBRSxJQUFJbEIsSUFBRTtRQUFLLElBQUc7WUFBQ0wsQ0FBQyxDQUFDRSxFQUFFLENBQUNFLEdBQUVBLEVBQUVtQixPQUFPLEVBQUNrWDtZQUFxQnBZLElBQUU7UUFBSyxTQUFRO1lBQUMsSUFBR0EsR0FBRSxPQUFPSixDQUFDLENBQUNDLEVBQUU7UUFBQTtRQUFDLE9BQU9FLEVBQUVtQixPQUFPO0lBQUE7SUFBQyxJQUFHLE9BQU9rWCx3QkFBc0IsYUFBWUEsb0JBQW9CQyxFQUFFLEdBQUNDLFNBQVNBLEdBQUM7SUFBSSxJQUFJelksSUFBRXVZLG9CQUFvQjtJQUFLRyxPQUFPclgsT0FBTyxHQUFDckI7QUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pY3JvbWF0Y2gvaW5kZXguanM/M2NlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZT17MzMzOihlLHQscik9Pntjb25zdCBuPXIoMTM3KTtjb25zdCB1PXIoMTc5KTtjb25zdCBzPXIoMTMpO2NvbnN0IG89cig3MTkpO2NvbnN0IGJyYWNlcz0oZSx0PXt9KT0+e2xldCByPVtdO2lmKEFycmF5LmlzQXJyYXkoZSkpe2ZvcihsZXQgbiBvZiBlKXtsZXQgZT1icmFjZXMuY3JlYXRlKG4sdCk7aWYoQXJyYXkuaXNBcnJheShlKSl7ci5wdXNoKC4uLmUpfWVsc2V7ci5wdXNoKGUpfX19ZWxzZXtyPVtdLmNvbmNhdChicmFjZXMuY3JlYXRlKGUsdCkpfWlmKHQmJnQuZXhwYW5kPT09dHJ1ZSYmdC5ub2R1cGVzPT09dHJ1ZSl7cj1bLi4ubmV3IFNldChyKV19cmV0dXJuIHJ9O2JyYWNlcy5wYXJzZT0oZSx0PXt9KT0+byhlLHQpO2JyYWNlcy5zdHJpbmdpZnk9KGUsdD17fSk9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe3JldHVybiBuKGJyYWNlcy5wYXJzZShlLHQpLHQpfXJldHVybiBuKGUsdCl9O2JyYWNlcy5jb21waWxlPShlLHQ9e30pPT57aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtlPWJyYWNlcy5wYXJzZShlLHQpfXJldHVybiB1KGUsdCl9O2JyYWNlcy5leHBhbmQ9KGUsdD17fSk9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe2U9YnJhY2VzLnBhcnNlKGUsdCl9bGV0IHI9cyhlLHQpO2lmKHQubm9lbXB0eT09PXRydWUpe3I9ci5maWx0ZXIoQm9vbGVhbil9aWYodC5ub2R1cGVzPT09dHJ1ZSl7cj1bLi4ubmV3IFNldChyKV19cmV0dXJuIHJ9O2JyYWNlcy5jcmVhdGU9KGUsdD17fSk9PntpZihlPT09XCJcInx8ZS5sZW5ndGg8Myl7cmV0dXJuW2VdfXJldHVybiB0LmV4cGFuZCE9PXRydWU/YnJhY2VzLmNvbXBpbGUoZSx0KTpicmFjZXMuZXhwYW5kKGUsdCl9O2UuZXhwb3J0cz1icmFjZXN9LDE3OTooZSx0LHIpPT57Y29uc3Qgbj1yKDc4Myk7Y29uc3QgdT1yKDYxNyk7Y29uc3QgY29tcGlsZT0oZSx0PXt9KT0+e2xldCB3YWxrPShlLHI9e30pPT57bGV0IHM9dS5pc0ludmFsaWRCcmFjZShyKTtsZXQgbz1lLmludmFsaWQ9PT10cnVlJiZ0LmVzY2FwZUludmFsaWQ9PT10cnVlO2xldCBpPXM9PT10cnVlfHxvPT09dHJ1ZTtsZXQgYT10LmVzY2FwZUludmFsaWQ9PT10cnVlP1wiXFxcXFwiOlwiXCI7bGV0IGw9XCJcIjtpZihlLmlzT3Blbj09PXRydWUpe3JldHVybiBhK2UudmFsdWV9aWYoZS5pc0Nsb3NlPT09dHJ1ZSl7cmV0dXJuIGErZS52YWx1ZX1pZihlLnR5cGU9PT1cIm9wZW5cIil7cmV0dXJuIGk/YStlLnZhbHVlOlwiKFwifWlmKGUudHlwZT09PVwiY2xvc2VcIil7cmV0dXJuIGk/YStlLnZhbHVlOlwiKVwifWlmKGUudHlwZT09PVwiY29tbWFcIil7cmV0dXJuIGUucHJldi50eXBlPT09XCJjb21tYVwiP1wiXCI6aT9lLnZhbHVlOlwifFwifWlmKGUudmFsdWUpe3JldHVybiBlLnZhbHVlfWlmKGUubm9kZXMmJmUucmFuZ2VzPjApe2xldCByPXUucmVkdWNlKGUubm9kZXMpO2xldCBzPW4oLi4ucix7Li4udCx3cmFwOmZhbHNlLHRvUmVnZXg6dHJ1ZX0pO2lmKHMubGVuZ3RoIT09MCl7cmV0dXJuIHIubGVuZ3RoPjEmJnMubGVuZ3RoPjE/YCgke3N9KWA6c319aWYoZS5ub2Rlcyl7Zm9yKGxldCB0IG9mIGUubm9kZXMpe2wrPXdhbGsodCxlKX19cmV0dXJuIGx9O3JldHVybiB3YWxrKGUpfTtlLmV4cG9ydHM9Y29tcGlsZX0sNDU3OmU9PntlLmV4cG9ydHM9e01BWF9MRU5HVEg6MTAyNCo2NCxDSEFSXzA6XCIwXCIsQ0hBUl85OlwiOVwiLENIQVJfVVBQRVJDQVNFX0E6XCJBXCIsQ0hBUl9MT1dFUkNBU0VfQTpcImFcIixDSEFSX1VQUEVSQ0FTRV9aOlwiWlwiLENIQVJfTE9XRVJDQVNFX1o6XCJ6XCIsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOlwiKFwiLENIQVJfUklHSFRfUEFSRU5USEVTRVM6XCIpXCIsQ0hBUl9BU1RFUklTSzpcIipcIixDSEFSX0FNUEVSU0FORDpcIiZcIixDSEFSX0FUOlwiQFwiLENIQVJfQkFDS1NMQVNIOlwiXFxcXFwiLENIQVJfQkFDS1RJQ0s6XCJgXCIsQ0hBUl9DQVJSSUFHRV9SRVRVUk46XCJcXHJcIixDSEFSX0NJUkNVTUZMRVhfQUNDRU5UOlwiXlwiLENIQVJfQ09MT046XCI6XCIsQ0hBUl9DT01NQTpcIixcIixDSEFSX0RPTExBUjpcIiRcIixDSEFSX0RPVDpcIi5cIixDSEFSX0RPVUJMRV9RVU9URTonXCInLENIQVJfRVFVQUw6XCI9XCIsQ0hBUl9FWENMQU1BVElPTl9NQVJLOlwiIVwiLENIQVJfRk9STV9GRUVEOlwiXFxmXCIsQ0hBUl9GT1JXQVJEX1NMQVNIOlwiL1wiLENIQVJfSEFTSDpcIiNcIixDSEFSX0hZUEhFTl9NSU5VUzpcIi1cIixDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDpcIjxcIixDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6XCJ7XCIsQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOlwiW1wiLENIQVJfTElORV9GRUVEOlwiXFxuXCIsQ0hBUl9OT19CUkVBS19TUEFDRTpcIsKgXCIsQ0hBUl9QRVJDRU5UOlwiJVwiLENIQVJfUExVUzpcIitcIixDSEFSX1FVRVNUSU9OX01BUks6XCI/XCIsQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUOlwiPlwiLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6XCJ9XCIsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpcIl1cIixDSEFSX1NFTUlDT0xPTjpcIjtcIixDSEFSX1NJTkdMRV9RVU9URTpcIidcIixDSEFSX1NQQUNFOlwiIFwiLENIQVJfVEFCOlwiXFx0XCIsQ0hBUl9VTkRFUlNDT1JFOlwiX1wiLENIQVJfVkVSVElDQUxfTElORTpcInxcIixDSEFSX1pFUk9fV0lEVEhfTk9CUkVBS19TUEFDRTpcIlxcdWZlZmZcIn19LDEzOihlLHQscik9Pntjb25zdCBuPXIoNzgzKTtjb25zdCB1PXIoMTM3KTtjb25zdCBzPXIoNjE3KTtjb25zdCBhcHBlbmQ9KGU9XCJcIix0PVwiXCIscj1mYWxzZSk9PntsZXQgbj1bXTtlPVtdLmNvbmNhdChlKTt0PVtdLmNvbmNhdCh0KTtpZighdC5sZW5ndGgpcmV0dXJuIGU7aWYoIWUubGVuZ3RoKXtyZXR1cm4gcj9zLmZsYXR0ZW4odCkubWFwKChlPT5geyR7ZX19YCkpOnR9Zm9yKGxldCB1IG9mIGUpe2lmKEFycmF5LmlzQXJyYXkodSkpe2ZvcihsZXQgZSBvZiB1KXtuLnB1c2goYXBwZW5kKGUsdCxyKSl9fWVsc2V7Zm9yKGxldCBlIG9mIHQpe2lmKHI9PT10cnVlJiZ0eXBlb2YgZT09PVwic3RyaW5nXCIpZT1geyR7ZX19YDtuLnB1c2goQXJyYXkuaXNBcnJheShlKT9hcHBlbmQodSxlLHIpOnUrZSl9fX1yZXR1cm4gcy5mbGF0dGVuKG4pfTtjb25zdCBleHBhbmQ9KGUsdD17fSk9PntsZXQgcj10LnJhbmdlTGltaXQ9PT12b2lkIDA/MWUzOnQucmFuZ2VMaW1pdDtsZXQgd2Fsaz0oZSxvPXt9KT0+e2UucXVldWU9W107bGV0IGk9bztsZXQgYT1vLnF1ZXVlO3doaWxlKGkudHlwZSE9PVwiYnJhY2VcIiYmaS50eXBlIT09XCJyb290XCImJmkucGFyZW50KXtpPWkucGFyZW50O2E9aS5xdWV1ZX1pZihlLmludmFsaWR8fGUuZG9sbGFyKXthLnB1c2goYXBwZW5kKGEucG9wKCksdShlLHQpKSk7cmV0dXJufWlmKGUudHlwZT09PVwiYnJhY2VcIiYmZS5pbnZhbGlkIT09dHJ1ZSYmZS5ub2Rlcy5sZW5ndGg9PT0yKXthLnB1c2goYXBwZW5kKGEucG9wKCksW1wie31cIl0pKTtyZXR1cm59aWYoZS5ub2RlcyYmZS5yYW5nZXM+MCl7bGV0IG89cy5yZWR1Y2UoZS5ub2Rlcyk7aWYocy5leGNlZWRzTGltaXQoLi4ubyx0LnN0ZXAscikpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiZXhwYW5kZWQgYXJyYXkgbGVuZ3RoIGV4Y2VlZHMgcmFuZ2UgbGltaXQuIFVzZSBvcHRpb25zLnJhbmdlTGltaXQgdG8gaW5jcmVhc2Ugb3IgZGlzYWJsZSB0aGUgbGltaXQuXCIpfWxldCBpPW4oLi4ubyx0KTtpZihpLmxlbmd0aD09PTApe2k9dShlLHQpfWEucHVzaChhcHBlbmQoYS5wb3AoKSxpKSk7ZS5ub2Rlcz1bXTtyZXR1cm59bGV0IGw9cy5lbmNsb3NlQnJhY2UoZSk7bGV0IGM9ZS5xdWV1ZTtsZXQgcD1lO3doaWxlKHAudHlwZSE9PVwiYnJhY2VcIiYmcC50eXBlIT09XCJyb290XCImJnAucGFyZW50KXtwPXAucGFyZW50O2M9cC5xdWV1ZX1mb3IobGV0IHQ9MDt0PGUubm9kZXMubGVuZ3RoO3QrKyl7bGV0IHI9ZS5ub2Rlc1t0XTtpZihyLnR5cGU9PT1cImNvbW1hXCImJmUudHlwZT09PVwiYnJhY2VcIil7aWYodD09PTEpYy5wdXNoKFwiXCIpO2MucHVzaChcIlwiKTtjb250aW51ZX1pZihyLnR5cGU9PT1cImNsb3NlXCIpe2EucHVzaChhcHBlbmQoYS5wb3AoKSxjLGwpKTtjb250aW51ZX1pZihyLnZhbHVlJiZyLnR5cGUhPT1cIm9wZW5cIil7Yy5wdXNoKGFwcGVuZChjLnBvcCgpLHIudmFsdWUpKTtjb250aW51ZX1pZihyLm5vZGVzKXt3YWxrKHIsZSl9fXJldHVybiBjfTtyZXR1cm4gcy5mbGF0dGVuKHdhbGsoZSkpfTtlLmV4cG9ydHM9ZXhwYW5kfSw3MTk6KGUsdCxyKT0+e2NvbnN0IG49cigxMzcpO2NvbnN0e01BWF9MRU5HVEg6dSxDSEFSX0JBQ0tTTEFTSDpzLENIQVJfQkFDS1RJQ0s6byxDSEFSX0NPTU1BOmksQ0hBUl9ET1Q6YSxDSEFSX0xFRlRfUEFSRU5USEVTRVM6bCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmMsQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOnAsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRTpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6UixDSEFSX0RPVUJMRV9RVU9URTpfLENIQVJfU0lOR0xFX1FVT1RFOmgsQ0hBUl9OT19CUkVBS19TUEFDRTpnLENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOkV9PXIoNDU3KTtjb25zdCBwYXJzZT0oZSx0PXt9KT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgc3RyaW5nXCIpfWxldCByPXR8fHt9O2xldCBDPXR5cGVvZiByLm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4odSxyLm1heExlbmd0aCk6dTtpZihlLmxlbmd0aD5DKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aCAoJHtlLmxlbmd0aH0pLCBleGNlZWRzIG1heCBjaGFyYWN0ZXJzICgke0N9KWApfWxldCB5PXt0eXBlOlwicm9vdFwiLGlucHV0OmUsbm9kZXM6W119O2xldCBkPVt5XTtsZXQgeD15O2xldCBiPXk7bGV0IFM9MDtsZXQgSD1lLmxlbmd0aDtsZXQgdj0wO2xldCAkPTA7bGV0IG07bGV0IFQ9e307Y29uc3QgYWR2YW5jZT0oKT0+ZVt2KytdO2NvbnN0IHB1c2g9ZT0+e2lmKGUudHlwZT09PVwidGV4dFwiJiZiLnR5cGU9PT1cImRvdFwiKXtiLnR5cGU9XCJ0ZXh0XCJ9aWYoYiYmYi50eXBlPT09XCJ0ZXh0XCImJmUudHlwZT09PVwidGV4dFwiKXtiLnZhbHVlKz1lLnZhbHVlO3JldHVybn14Lm5vZGVzLnB1c2goZSk7ZS5wYXJlbnQ9eDtlLnByZXY9YjtiPWU7cmV0dXJuIGV9O3B1c2goe3R5cGU6XCJib3NcIn0pO3doaWxlKHY8SCl7eD1kW2QubGVuZ3RoLTFdO209YWR2YW5jZSgpO2lmKG09PT1FfHxtPT09Zyl7Y29udGludWV9aWYobT09PXMpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6KHQua2VlcEVzY2FwaW5nP206XCJcIikrYWR2YW5jZSgpfSk7Y29udGludWV9aWYobT09PVIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6XCJcXFxcXCIrbX0pO2NvbnRpbnVlfWlmKG09PT1BKXtTKys7bGV0IGU9dHJ1ZTtsZXQgdDt3aGlsZSh2PEgmJih0PWFkdmFuY2UoKSkpe20rPXQ7aWYodD09PUEpe1MrKztjb250aW51ZX1pZih0PT09cyl7bSs9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKHQ9PT1SKXtTLS07aWYoUz09PTApe2JyZWFrfX19cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PWwpe3g9cHVzaCh7dHlwZTpcInBhcmVuXCIsbm9kZXM6W119KTtkLnB1c2goeCk7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PWMpe2lmKHgudHlwZSE9PVwicGFyZW5cIil7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9eD1kLnBvcCgpO3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pO3g9ZFtkLmxlbmd0aC0xXTtjb250aW51ZX1pZihtPT09X3x8bT09PWh8fG09PT1vKXtsZXQgZT1tO2xldCByO2lmKHQua2VlcFF1b3RlcyE9PXRydWUpe209XCJcIn13aGlsZSh2PEgmJihyPWFkdmFuY2UoKSkpe2lmKHI9PT1zKXttKz1yK2FkdmFuY2UoKTtjb250aW51ZX1pZihyPT09ZSl7aWYodC5rZWVwUXVvdGVzPT09dHJ1ZSltKz1yO2JyZWFrfW0rPXJ9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PXApeyQrKztsZXQgZT1iLnZhbHVlJiZiLnZhbHVlLnNsaWNlKC0xKT09PVwiJFwifHx4LmRvbGxhcj09PXRydWU7bGV0IHQ9e3R5cGU6XCJicmFjZVwiLG9wZW46dHJ1ZSxjbG9zZTpmYWxzZSxkb2xsYXI6ZSxkZXB0aDokLGNvbW1hczowLHJhbmdlczowLG5vZGVzOltdfTt4PXB1c2godCk7ZC5wdXNoKHgpO3B1c2goe3R5cGU6XCJvcGVuXCIsdmFsdWU6bX0pO2NvbnRpbnVlfWlmKG09PT1mKXtpZih4LnR5cGUhPT1cImJyYWNlXCIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pO2NvbnRpbnVlfWxldCBlPVwiY2xvc2VcIjt4PWQucG9wKCk7eC5jbG9zZT10cnVlO3B1c2goe3R5cGU6ZSx2YWx1ZTptfSk7JC0tO3g9ZFtkLmxlbmd0aC0xXTtjb250aW51ZX1pZihtPT09aSYmJD4wKXtpZih4LnJhbmdlcz4wKXt4LnJhbmdlcz0wO2xldCBlPXgubm9kZXMuc2hpZnQoKTt4Lm5vZGVzPVtlLHt0eXBlOlwidGV4dFwiLHZhbHVlOm4oeCl9XX1wdXNoKHt0eXBlOlwiY29tbWFcIix2YWx1ZTptfSk7eC5jb21tYXMrKztjb250aW51ZX1pZihtPT09YSYmJD4wJiZ4LmNvbW1hcz09PTApe2xldCBlPXgubm9kZXM7aWYoJD09PTB8fGUubGVuZ3RoPT09MCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYoYi50eXBlPT09XCJkb3RcIil7eC5yYW5nZT1bXTtiLnZhbHVlKz1tO2IudHlwZT1cInJhbmdlXCI7aWYoeC5ub2Rlcy5sZW5ndGghPT0zJiZ4Lm5vZGVzLmxlbmd0aCE9PTUpe3guaW52YWxpZD10cnVlO3gucmFuZ2VzPTA7Yi50eXBlPVwidGV4dFwiO2NvbnRpbnVlfXgucmFuZ2VzKys7eC5hcmdzPVtdO2NvbnRpbnVlfWlmKGIudHlwZT09PVwicmFuZ2VcIil7ZS5wb3AoKTtsZXQgdD1lW2UubGVuZ3RoLTFdO3QudmFsdWUrPWIudmFsdWUrbTtiPXQ7eC5yYW5nZXMtLTtjb250aW51ZX1wdXNoKHt0eXBlOlwiZG90XCIsdmFsdWU6bX0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pfWRve3g9ZC5wb3AoKTtpZih4LnR5cGUhPT1cInJvb3RcIil7eC5ub2Rlcy5mb3JFYWNoKChlPT57aWYoIWUubm9kZXMpe2lmKGUudHlwZT09PVwib3BlblwiKWUuaXNPcGVuPXRydWU7aWYoZS50eXBlPT09XCJjbG9zZVwiKWUuaXNDbG9zZT10cnVlO2lmKCFlLm5vZGVzKWUudHlwZT1cInRleHRcIjtlLmludmFsaWQ9dHJ1ZX19KSk7bGV0IGU9ZFtkLmxlbmd0aC0xXTtsZXQgdD1lLm5vZGVzLmluZGV4T2YoeCk7ZS5ub2Rlcy5zcGxpY2UodCwxLC4uLngubm9kZXMpfX13aGlsZShkLmxlbmd0aD4wKTtwdXNoKHt0eXBlOlwiZW9zXCJ9KTtyZXR1cm4geX07ZS5leHBvcnRzPXBhcnNlfSwxMzc6KGUsdCxyKT0+e2NvbnN0IG49cig2MTcpO2UuZXhwb3J0cz0oZSx0PXt9KT0+e2xldCBzdHJpbmdpZnk9KGUscj17fSk9PntsZXQgdT10LmVzY2FwZUludmFsaWQmJm4uaXNJbnZhbGlkQnJhY2Uocik7bGV0IHM9ZS5pbnZhbGlkPT09dHJ1ZSYmdC5lc2NhcGVJbnZhbGlkPT09dHJ1ZTtsZXQgbz1cIlwiO2lmKGUudmFsdWUpe2lmKCh1fHxzKSYmbi5pc09wZW5PckNsb3NlKGUpKXtyZXR1cm5cIlxcXFxcIitlLnZhbHVlfXJldHVybiBlLnZhbHVlfWlmKGUudmFsdWUpe3JldHVybiBlLnZhbHVlfWlmKGUubm9kZXMpe2ZvcihsZXQgdCBvZiBlLm5vZGVzKXtvKz1zdHJpbmdpZnkodCl9fXJldHVybiBvfTtyZXR1cm4gc3RyaW5naWZ5KGUpfX0sNjE3OihlLHQpPT57dC5pc0ludGVnZXI9ZT0+e2lmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7cmV0dXJuIE51bWJlci5pc0ludGVnZXIoZSl9aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiJiZlLnRyaW0oKSE9PVwiXCIpe3JldHVybiBOdW1iZXIuaXNJbnRlZ2VyKE51bWJlcihlKSl9cmV0dXJuIGZhbHNlfTt0LmZpbmQ9KGUsdCk9PmUubm9kZXMuZmluZCgoZT0+ZS50eXBlPT09dCkpO3QuZXhjZWVkc0xpbWl0PShlLHIsbj0xLHUpPT57aWYodT09PWZhbHNlKXJldHVybiBmYWxzZTtpZighdC5pc0ludGVnZXIoZSl8fCF0LmlzSW50ZWdlcihyKSlyZXR1cm4gZmFsc2U7cmV0dXJuKE51bWJlcihyKS1OdW1iZXIoZSkpL051bWJlcihuKT49dX07dC5lc2NhcGVOb2RlPShlLHQ9MCxyKT0+e2xldCBuPWUubm9kZXNbdF07aWYoIW4pcmV0dXJuO2lmKHImJm4udHlwZT09PXJ8fG4udHlwZT09PVwib3BlblwifHxuLnR5cGU9PT1cImNsb3NlXCIpe2lmKG4uZXNjYXBlZCE9PXRydWUpe24udmFsdWU9XCJcXFxcXCIrbi52YWx1ZTtuLmVzY2FwZWQ9dHJ1ZX19fTt0LmVuY2xvc2VCcmFjZT1lPT57aWYoZS50eXBlIT09XCJicmFjZVwiKXJldHVybiBmYWxzZTtpZihlLmNvbW1hcz4+MCtlLnJhbmdlcz4+MD09PTApe2UuaW52YWxpZD10cnVlO3JldHVybiB0cnVlfXJldHVybiBmYWxzZX07dC5pc0ludmFsaWRCcmFjZT1lPT57aWYoZS50eXBlIT09XCJicmFjZVwiKXJldHVybiBmYWxzZTtpZihlLmludmFsaWQ9PT10cnVlfHxlLmRvbGxhcilyZXR1cm4gdHJ1ZTtpZihlLmNvbW1hcz4+MCtlLnJhbmdlcz4+MD09PTApe2UuaW52YWxpZD10cnVlO3JldHVybiB0cnVlfWlmKGUub3BlbiE9PXRydWV8fGUuY2xvc2UhPT10cnVlKXtlLmludmFsaWQ9dHJ1ZTtyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2V9O3QuaXNPcGVuT3JDbG9zZT1lPT57aWYoZS50eXBlPT09XCJvcGVuXCJ8fGUudHlwZT09PVwiY2xvc2VcIil7cmV0dXJuIHRydWV9cmV0dXJuIGUub3Blbj09PXRydWV8fGUuY2xvc2U9PT10cnVlfTt0LnJlZHVjZT1lPT5lLnJlZHVjZSgoKGUsdCk9PntpZih0LnR5cGU9PT1cInRleHRcIillLnB1c2godC52YWx1ZSk7aWYodC50eXBlPT09XCJyYW5nZVwiKXQudHlwZT1cInRleHRcIjtyZXR1cm4gZX0pLFtdKTt0LmZsYXR0ZW49KC4uLmUpPT57Y29uc3QgdD1bXTtjb25zdCBmbGF0PWU9Pntmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7bGV0IG49ZVtyXTtBcnJheS5pc0FycmF5KG4pP2ZsYXQobix0KTpuIT09dm9pZCAwJiZ0LnB1c2gobil9cmV0dXJuIHR9O2ZsYXQoZSk7cmV0dXJuIHR9fSw3ODM6KGUsdCxyKT0+e1xuLyohXG4gKiBmaWxsLXJhbmdlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9maWxsLXJhbmdlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuY29uc3Qgbj1yKDgzNyk7Y29uc3QgdT1yKDQ5Mik7Y29uc3QgaXNPYmplY3Q9ZT0+ZSE9PW51bGwmJnR5cGVvZiBlPT09XCJvYmplY3RcIiYmIUFycmF5LmlzQXJyYXkoZSk7Y29uc3QgdHJhbnNmb3JtPWU9PnQ9PmU9PT10cnVlP051bWJlcih0KTpTdHJpbmcodCk7Y29uc3QgaXNWYWxpZFZhbHVlPWU9PnR5cGVvZiBlPT09XCJudW1iZXJcInx8dHlwZW9mIGU9PT1cInN0cmluZ1wiJiZlIT09XCJcIjtjb25zdCBpc051bWJlcj1lPT5OdW1iZXIuaXNJbnRlZ2VyKCtlKTtjb25zdCB6ZXJvcz1lPT57bGV0IHQ9YCR7ZX1gO2xldCByPS0xO2lmKHRbMF09PT1cIi1cIil0PXQuc2xpY2UoMSk7aWYodD09PVwiMFwiKXJldHVybiBmYWxzZTt3aGlsZSh0Wysrcl09PT1cIjBcIik7cmV0dXJuIHI+MH07Y29uc3Qgc3RyaW5naWZ5PShlLHQscik9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCJ8fHR5cGVvZiB0PT09XCJzdHJpbmdcIil7cmV0dXJuIHRydWV9cmV0dXJuIHIuc3RyaW5naWZ5PT09dHJ1ZX07Y29uc3QgcGFkPShlLHQscik9PntpZih0PjApe2xldCByPWVbMF09PT1cIi1cIj9cIi1cIjpcIlwiO2lmKHIpZT1lLnNsaWNlKDEpO2U9citlLnBhZFN0YXJ0KHI/dC0xOnQsXCIwXCIpfWlmKHI9PT1mYWxzZSl7cmV0dXJuIFN0cmluZyhlKX1yZXR1cm4gZX07Y29uc3QgdG9NYXhMZW49KGUsdCk9PntsZXQgcj1lWzBdPT09XCItXCI/XCItXCI6XCJcIjtpZihyKXtlPWUuc2xpY2UoMSk7dC0tfXdoaWxlKGUubGVuZ3RoPHQpZT1cIjBcIitlO3JldHVybiByP1wiLVwiK2U6ZX07Y29uc3QgdG9TZXF1ZW5jZT0oZSx0KT0+e2UubmVnYXRpdmVzLnNvcnQoKChlLHQpPT5lPHQ/LTE6ZT50PzE6MCkpO2UucG9zaXRpdmVzLnNvcnQoKChlLHQpPT5lPHQ/LTE6ZT50PzE6MCkpO2xldCByPXQuY2FwdHVyZT9cIlwiOlwiPzpcIjtsZXQgbj1cIlwiO2xldCB1PVwiXCI7bGV0IHM7aWYoZS5wb3NpdGl2ZXMubGVuZ3RoKXtuPWUucG9zaXRpdmVzLmpvaW4oXCJ8XCIpfWlmKGUubmVnYXRpdmVzLmxlbmd0aCl7dT1gLSgke3J9JHtlLm5lZ2F0aXZlcy5qb2luKFwifFwiKX0pYH1pZihuJiZ1KXtzPWAke259fCR7dX1gfWVsc2V7cz1ufHx1fWlmKHQud3JhcCl7cmV0dXJuYCgke3J9JHtzfSlgfXJldHVybiBzfTtjb25zdCB0b1JhbmdlPShlLHQscixuKT0+e2lmKHIpe3JldHVybiB1KGUsdCx7d3JhcDpmYWxzZSwuLi5ufSl9bGV0IHM9U3RyaW5nLmZyb21DaGFyQ29kZShlKTtpZihlPT09dClyZXR1cm4gcztsZXQgbz1TdHJpbmcuZnJvbUNoYXJDb2RlKHQpO3JldHVybmBbJHtzfS0ke299XWB9O2NvbnN0IHRvUmVnZXg9KGUsdCxyKT0+e2lmKEFycmF5LmlzQXJyYXkoZSkpe2xldCB0PXIud3JhcD09PXRydWU7bGV0IG49ci5jYXB0dXJlP1wiXCI6XCI/OlwiO3JldHVybiB0P2AoJHtufSR7ZS5qb2luKFwifFwiKX0pYDplLmpvaW4oXCJ8XCIpfXJldHVybiB1KGUsdCxyKX07Y29uc3QgcmFuZ2VFcnJvcj0oLi4uZSk9Pm5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCByYW5nZSBhcmd1bWVudHM6IFwiK24uaW5zcGVjdCguLi5lKSk7Y29uc3QgaW52YWxpZFJhbmdlPShlLHQscik9PntpZihyLnN0cmljdFJhbmdlcz09PXRydWUpdGhyb3cgcmFuZ2VFcnJvcihbZSx0XSk7cmV0dXJuW119O2NvbnN0IGludmFsaWRTdGVwPShlLHQpPT57aWYodC5zdHJpY3RSYW5nZXM9PT10cnVlKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBzdGVwIFwiJHtlfVwiIHRvIGJlIGEgbnVtYmVyYCl9cmV0dXJuW119O2NvbnN0IGZpbGxOdW1iZXJzPShlLHQscj0xLG49e30pPT57bGV0IHU9TnVtYmVyKGUpO2xldCBzPU51bWJlcih0KTtpZighTnVtYmVyLmlzSW50ZWdlcih1KXx8IU51bWJlci5pc0ludGVnZXIocykpe2lmKG4uc3RyaWN0UmFuZ2VzPT09dHJ1ZSl0aHJvdyByYW5nZUVycm9yKFtlLHRdKTtyZXR1cm5bXX1pZih1PT09MCl1PTA7aWYocz09PTApcz0wO2xldCBvPXU+cztsZXQgaT1TdHJpbmcoZSk7bGV0IGE9U3RyaW5nKHQpO2xldCBsPVN0cmluZyhyKTtyPU1hdGgubWF4KE1hdGguYWJzKHIpLDEpO2xldCBjPXplcm9zKGkpfHx6ZXJvcyhhKXx8emVyb3MobCk7bGV0IHA9Yz9NYXRoLm1heChpLmxlbmd0aCxhLmxlbmd0aCxsLmxlbmd0aCk6MDtsZXQgZj1jPT09ZmFsc2UmJnN0cmluZ2lmeShlLHQsbik9PT1mYWxzZTtsZXQgQT1uLnRyYW5zZm9ybXx8dHJhbnNmb3JtKGYpO2lmKG4udG9SZWdleCYmcj09PTEpe3JldHVybiB0b1JhbmdlKHRvTWF4TGVuKGUscCksdG9NYXhMZW4odCxwKSx0cnVlLG4pfWxldCBSPXtuZWdhdGl2ZXM6W10scG9zaXRpdmVzOltdfTtsZXQgcHVzaD1lPT5SW2U8MD9cIm5lZ2F0aXZlc1wiOlwicG9zaXRpdmVzXCJdLnB1c2goTWF0aC5hYnMoZSkpO2xldCBfPVtdO2xldCBoPTA7d2hpbGUobz91Pj1zOnU8PXMpe2lmKG4udG9SZWdleD09PXRydWUmJnI+MSl7cHVzaCh1KX1lbHNle18ucHVzaChwYWQoQSh1LGgpLHAsZikpfXU9bz91LXI6dStyO2grK31pZihuLnRvUmVnZXg9PT10cnVlKXtyZXR1cm4gcj4xP3RvU2VxdWVuY2UoUixuKTp0b1JlZ2V4KF8sbnVsbCx7d3JhcDpmYWxzZSwuLi5ufSl9cmV0dXJuIF99O2NvbnN0IGZpbGxMZXR0ZXJzPShlLHQscj0xLG49e30pPT57aWYoIWlzTnVtYmVyKGUpJiZlLmxlbmd0aD4xfHwhaXNOdW1iZXIodCkmJnQubGVuZ3RoPjEpe3JldHVybiBpbnZhbGlkUmFuZ2UoZSx0LG4pfWxldCB1PW4udHJhbnNmb3JtfHwoZT0+U3RyaW5nLmZyb21DaGFyQ29kZShlKSk7bGV0IHM9YCR7ZX1gLmNoYXJDb2RlQXQoMCk7bGV0IG89YCR7dH1gLmNoYXJDb2RlQXQoMCk7bGV0IGk9cz5vO2xldCBhPU1hdGgubWluKHMsbyk7bGV0IGw9TWF0aC5tYXgocyxvKTtpZihuLnRvUmVnZXgmJnI9PT0xKXtyZXR1cm4gdG9SYW5nZShhLGwsZmFsc2Usbil9bGV0IGM9W107bGV0IHA9MDt3aGlsZShpP3M+PW86czw9byl7Yy5wdXNoKHUocyxwKSk7cz1pP3MtcjpzK3I7cCsrfWlmKG4udG9SZWdleD09PXRydWUpe3JldHVybiB0b1JlZ2V4KGMsbnVsbCx7d3JhcDpmYWxzZSxvcHRpb25zOm59KX1yZXR1cm4gY307Y29uc3QgZmlsbD0oZSx0LHIsbj17fSk9PntpZih0PT1udWxsJiZpc1ZhbGlkVmFsdWUoZSkpe3JldHVybltlXX1pZighaXNWYWxpZFZhbHVlKGUpfHwhaXNWYWxpZFZhbHVlKHQpKXtyZXR1cm4gaW52YWxpZFJhbmdlKGUsdCxuKX1pZih0eXBlb2Ygcj09PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZpbGwoZSx0LDEse3RyYW5zZm9ybTpyfSl9aWYoaXNPYmplY3Qocikpe3JldHVybiBmaWxsKGUsdCwwLHIpfWxldCB1PXsuLi5ufTtpZih1LmNhcHR1cmU9PT10cnVlKXUud3JhcD10cnVlO3I9cnx8dS5zdGVwfHwxO2lmKCFpc051bWJlcihyKSl7aWYociE9bnVsbCYmIWlzT2JqZWN0KHIpKXJldHVybiBpbnZhbGlkU3RlcChyLHUpO3JldHVybiBmaWxsKGUsdCwxLHIpfWlmKGlzTnVtYmVyKGUpJiZpc051bWJlcih0KSl7cmV0dXJuIGZpbGxOdW1iZXJzKGUsdCxyLHUpfXJldHVybiBmaWxsTGV0dGVycyhlLHQsTWF0aC5tYXgoTWF0aC5hYnMociksMSksdSl9O2UuZXhwb3J0cz1maWxsfSwzNTc6ZT0+e1xuLyohXG4gKiBpcy1udW1iZXIgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLW51bWJlcj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmUuZXhwb3J0cz1mdW5jdGlvbihlKXtpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe3JldHVybiBlLWU9PT0wfWlmKHR5cGVvZiBlPT09XCJzdHJpbmdcIiYmZS50cmltKCkhPT1cIlwiKXtyZXR1cm4gTnVtYmVyLmlzRmluaXRlP051bWJlci5pc0Zpbml0ZSgrZSk6aXNGaW5pdGUoK2UpfXJldHVybiBmYWxzZX19LDk3MTooZSx0LHIpPT57Y29uc3Qgbj1yKDgzNyk7Y29uc3QgdT1yKDMzMyk7Y29uc3Qgcz1yKDI1MSk7Y29uc3Qgbz1yKDUxMyk7Y29uc3QgaXNFbXB0eVN0cmluZz1lPT5lPT09XCJcInx8ZT09PVwiLi9cIjtjb25zdCBtaWNyb21hdGNoPShlLHQscik9Pnt0PVtdLmNvbmNhdCh0KTtlPVtdLmNvbmNhdChlKTtsZXQgbj1uZXcgU2V0O2xldCB1PW5ldyBTZXQ7bGV0IG89bmV3IFNldDtsZXQgaT0wO2xldCBvblJlc3VsdD1lPT57by5hZGQoZS5vdXRwdXQpO2lmKHImJnIub25SZXN1bHQpe3Iub25SZXN1bHQoZSl9fTtmb3IobGV0IG89MDtvPHQubGVuZ3RoO28rKyl7bGV0IGE9cyhTdHJpbmcodFtvXSksey4uLnIsb25SZXN1bHQ6b25SZXN1bHR9LHRydWUpO2xldCBsPWEuc3RhdGUubmVnYXRlZHx8YS5zdGF0ZS5uZWdhdGVkRXh0Z2xvYjtpZihsKWkrKztmb3IobGV0IHQgb2YgZSl7bGV0IGU9YSh0LHRydWUpO2xldCByPWw/IWUuaXNNYXRjaDplLmlzTWF0Y2g7aWYoIXIpY29udGludWU7aWYobCl7bi5hZGQoZS5vdXRwdXQpfWVsc2V7bi5kZWxldGUoZS5vdXRwdXQpO3UuYWRkKGUub3V0cHV0KX19fWxldCBhPWk9PT10Lmxlbmd0aD9bLi4ub106Wy4uLnVdO2xldCBsPWEuZmlsdGVyKChlPT4hbi5oYXMoZSkpKTtpZihyJiZsLmxlbmd0aD09PTApe2lmKHIuZmFpbGdsb2I9PT10cnVlKXt0aHJvdyBuZXcgRXJyb3IoYE5vIG1hdGNoZXMgZm91bmQgZm9yIFwiJHt0LmpvaW4oXCIsIFwiKX1cImApfWlmKHIubm9udWxsPT09dHJ1ZXx8ci5udWxsZ2xvYj09PXRydWUpe3JldHVybiByLnVuZXNjYXBlP3QubWFwKChlPT5lLnJlcGxhY2UoL1xcXFwvZyxcIlwiKSkpOnR9fXJldHVybiBsfTttaWNyb21hdGNoLm1hdGNoPW1pY3JvbWF0Y2g7bWljcm9tYXRjaC5tYXRjaGVyPShlLHQpPT5zKGUsdCk7bWljcm9tYXRjaC5pc01hdGNoPShlLHQscik9PnModCxyKShlKTttaWNyb21hdGNoLmFueT1taWNyb21hdGNoLmlzTWF0Y2g7bWljcm9tYXRjaC5ub3Q9KGUsdCxyPXt9KT0+e3Q9W10uY29uY2F0KHQpLm1hcChTdHJpbmcpO2xldCBuPW5ldyBTZXQ7bGV0IHU9W107bGV0IG9uUmVzdWx0PWU9PntpZihyLm9uUmVzdWx0KXIub25SZXN1bHQoZSk7dS5wdXNoKGUub3V0cHV0KX07bGV0IHM9bWljcm9tYXRjaChlLHQsey4uLnIsb25SZXN1bHQ6b25SZXN1bHR9KTtmb3IobGV0IGUgb2YgdSl7aWYoIXMuaW5jbHVkZXMoZSkpe24uYWRkKGUpfX1yZXR1cm5bLi4ubl19O21pY3JvbWF0Y2guY29udGFpbnM9KGUsdCxyKT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmc6IFwiJHtuLmluc3BlY3QoZSl9XCJgKX1pZihBcnJheS5pc0FycmF5KHQpKXtyZXR1cm4gdC5zb21lKCh0PT5taWNyb21hdGNoLmNvbnRhaW5zKGUsdCxyKSkpfWlmKHR5cGVvZiB0PT09XCJzdHJpbmdcIil7aWYoaXNFbXB0eVN0cmluZyhlKXx8aXNFbXB0eVN0cmluZyh0KSl7cmV0dXJuIGZhbHNlfWlmKGUuaW5jbHVkZXModCl8fGUuc3RhcnRzV2l0aChcIi4vXCIpJiZlLnNsaWNlKDIpLmluY2x1ZGVzKHQpKXtyZXR1cm4gdHJ1ZX19cmV0dXJuIG1pY3JvbWF0Y2guaXNNYXRjaChlLHQsey4uLnIsY29udGFpbnM6dHJ1ZX0pfTttaWNyb21hdGNoLm1hdGNoS2V5cz0oZSx0LHIpPT57aWYoIW8uaXNPYmplY3QoZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0XCIpfWxldCBuPW1pY3JvbWF0Y2goT2JqZWN0LmtleXMoZSksdCxyKTtsZXQgdT17fTtmb3IobGV0IHQgb2Ygbil1W3RdPWVbdF07cmV0dXJuIHV9O21pY3JvbWF0Y2guc29tZT0oZSx0LHIpPT57bGV0IG49W10uY29uY2F0KGUpO2ZvcihsZXQgZSBvZltdLmNvbmNhdCh0KSl7bGV0IHQ9cyhTdHJpbmcoZSkscik7aWYobi5zb21lKChlPT50KGUpKSkpe3JldHVybiB0cnVlfX1yZXR1cm4gZmFsc2V9O21pY3JvbWF0Y2guZXZlcnk9KGUsdCxyKT0+e2xldCBuPVtdLmNvbmNhdChlKTtmb3IobGV0IGUgb2ZbXS5jb25jYXQodCkpe2xldCB0PXMoU3RyaW5nKGUpLHIpO2lmKCFuLmV2ZXJ5KChlPT50KGUpKSkpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9O21pY3JvbWF0Y2guYWxsPShlLHQscik9PntpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGEgc3RyaW5nOiBcIiR7bi5pbnNwZWN0KGUpfVwiYCl9cmV0dXJuW10uY29uY2F0KHQpLmV2ZXJ5KCh0PT5zKHQscikoZSkpKX07bWljcm9tYXRjaC5jYXB0dXJlPShlLHQscik9PntsZXQgbj1vLmlzV2luZG93cyhyKTtsZXQgdT1zLm1ha2VSZShTdHJpbmcoZSksey4uLnIsY2FwdHVyZTp0cnVlfSk7bGV0IGk9dS5leGVjKG4/by50b1Bvc2l4U2xhc2hlcyh0KTp0KTtpZihpKXtyZXR1cm4gaS5zbGljZSgxKS5tYXAoKGU9PmU9PT12b2lkIDA/XCJcIjplKSl9fTttaWNyb21hdGNoLm1ha2VSZT0oLi4uZSk9PnMubWFrZVJlKC4uLmUpO21pY3JvbWF0Y2guc2Nhbj0oLi4uZSk9PnMuc2NhbiguLi5lKTttaWNyb21hdGNoLnBhcnNlPShlLHQpPT57bGV0IHI9W107Zm9yKGxldCBuIG9mW10uY29uY2F0KGV8fFtdKSl7Zm9yKGxldCBlIG9mIHUoU3RyaW5nKG4pLHQpKXtyLnB1c2gocy5wYXJzZShlLHQpKX19cmV0dXJuIHJ9O21pY3JvbWF0Y2guYnJhY2VzPShlLHQpPT57aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKTtpZih0JiZ0Lm5vYnJhY2U9PT10cnVlfHwhL1xcey4qXFx9Ly50ZXN0KGUpKXtyZXR1cm5bZV19cmV0dXJuIHUoZSx0KX07bWljcm9tYXRjaC5icmFjZUV4cGFuZD0oZSx0KT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYSBzdHJpbmdcIik7cmV0dXJuIG1pY3JvbWF0Y2guYnJhY2VzKGUsey4uLnQsZXhwYW5kOnRydWV9KX07ZS5leHBvcnRzPW1pY3JvbWF0Y2h9LDI1MTooZSx0LHIpPT57ZS5leHBvcnRzPXIoNjgzKX0sMzU2OihlLHQscik9Pntjb25zdCBuPXIoMTcpO2NvbnN0IHU9XCJcXFxcXFxcXC9cIjtjb25zdCBzPWBbXiR7dX1dYDtjb25zdCBvPVwiXFxcXC5cIjtjb25zdCBpPVwiXFxcXCtcIjtjb25zdCBhPVwiXFxcXD9cIjtjb25zdCBsPVwiXFxcXC9cIjtjb25zdCBjPVwiKD89LilcIjtjb25zdCBwPVwiW14vXVwiO2NvbnN0IGY9YCg/OiR7bH18JClgO2NvbnN0IEE9YCg/Ol58JHtsfSlgO2NvbnN0IFI9YCR7b317MSwyfSR7Zn1gO2NvbnN0IF89YCg/ISR7b30pYDtjb25zdCBoPWAoPyEke0F9JHtSfSlgO2NvbnN0IGc9YCg/ISR7b317MCwxfSR7Zn0pYDtjb25zdCBFPWAoPyEke1J9KWA7Y29uc3QgQz1gW14uJHtsfV1gO2NvbnN0IHk9YCR7cH0qP2A7Y29uc3QgZD17RE9UX0xJVEVSQUw6byxQTFVTX0xJVEVSQUw6aSxRTUFSS19MSVRFUkFMOmEsU0xBU0hfTElURVJBTDpsLE9ORV9DSEFSOmMsUU1BUks6cCxFTkRfQU5DSE9SOmYsRE9UU19TTEFTSDpSLE5PX0RPVDpfLE5PX0RPVFM6aCxOT19ET1RfU0xBU0g6ZyxOT19ET1RTX1NMQVNIOkUsUU1BUktfTk9fRE9UOkMsU1RBUjp5LFNUQVJUX0FOQ0hPUjpBfTtjb25zdCB4PXsuLi5kLFNMQVNIX0xJVEVSQUw6YFske3V9XWAsUU1BUks6cyxTVEFSOmAke3N9Kj9gLERPVFNfU0xBU0g6YCR7b317MSwyfSg/Olske3V9XXwkKWAsTk9fRE9UOmAoPyEke299KWAsTk9fRE9UUzpgKD8hKD86XnxbJHt1fV0pJHtvfXsxLDJ9KD86WyR7dX1dfCQpKWAsTk9fRE9UX1NMQVNIOmAoPyEke299ezAsMX0oPzpbJHt1fV18JCkpYCxOT19ET1RTX1NMQVNIOmAoPyEke299ezEsMn0oPzpbJHt1fV18JCkpYCxRTUFSS19OT19ET1Q6YFteLiR7dX1dYCxTVEFSVF9BTkNIT1I6YCg/Ol58WyR7dX1dKWAsRU5EX0FOQ0hPUjpgKD86WyR7dX1dfCQpYH07Y29uc3QgYj17YWxudW06XCJhLXpBLVowLTlcIixhbHBoYTpcImEtekEtWlwiLGFzY2lpOlwiXFxcXHgwMC1cXFxceDdGXCIsYmxhbms6XCIgXFxcXHRcIixjbnRybDpcIlxcXFx4MDAtXFxcXHgxRlxcXFx4N0ZcIixkaWdpdDpcIjAtOVwiLGdyYXBoOlwiXFxcXHgyMS1cXFxceDdFXCIsbG93ZXI6XCJhLXpcIixwcmludDpcIlxcXFx4MjAtXFxcXHg3RSBcIixwdW5jdDpcIlxcXFwtIVxcXCIjJCUmJygpXFxcXCorLC4vOjs8PT4/QFtcXFxcXV5fYHt8fX5cIixzcGFjZTpcIiBcXFxcdFxcXFxyXFxcXG5cXFxcdlxcXFxmXCIsdXBwZXI6XCJBLVpcIix3b3JkOlwiQS1aYS16MC05X1wiLHhkaWdpdDpcIkEtRmEtZjAtOVwifTtlLmV4cG9ydHM9e01BWF9MRU5HVEg6MTAyNCo2NCxQT1NJWF9SRUdFWF9TT1VSQ0U6YixSRUdFWF9CQUNLU0xBU0g6L1xcXFwoPyFbKis/XiR7fSh8KVtcXF1dKS9nLFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTOi9eW15AIVtcXF0uLCQqKz9ee30oKXxcXFxcL10rLyxSRUdFWF9TUEVDSUFMX0NIQVJTOi9bLSorPy5eJHt9KHwpW1xcXV0vLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjovKFxcXFw/KSgoXFxXKShcXDMqKSkvZyxSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDovKFstKis/Ll4ke30ofClbXFxdXSkvZyxSRUdFWF9SRU1PVkVfQkFDS1NMQVNIOi8oPzpcXFsuKj9bXlxcXFxdXFxdfFxcXFwoPz0uKSkvZyxSRVBMQUNFTUVOVFM6e1wiKioqXCI6XCIqXCIsXCIqKi8qKlwiOlwiKipcIixcIioqLyoqLyoqXCI6XCIqKlwifSxDSEFSXzA6NDgsQ0hBUl85OjU3LENIQVJfVVBQRVJDQVNFX0E6NjUsQ0hBUl9MT1dFUkNBU0VfQTo5NyxDSEFSX1VQUEVSQ0FTRV9aOjkwLENIQVJfTE9XRVJDQVNFX1o6MTIyLENIQVJfTEVGVF9QQVJFTlRIRVNFUzo0MCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOjQxLENIQVJfQVNURVJJU0s6NDIsQ0hBUl9BTVBFUlNBTkQ6MzgsQ0hBUl9BVDo2NCxDSEFSX0JBQ0tXQVJEX1NMQVNIOjkyLENIQVJfQ0FSUklBR0VfUkVUVVJOOjEzLENIQVJfQ0lSQ1VNRkxFWF9BQ0NFTlQ6OTQsQ0hBUl9DT0xPTjo1OCxDSEFSX0NPTU1BOjQ0LENIQVJfRE9UOjQ2LENIQVJfRE9VQkxFX1FVT1RFOjM0LENIQVJfRVFVQUw6NjEsQ0hBUl9FWENMQU1BVElPTl9NQVJLOjMzLENIQVJfRk9STV9GRUVEOjEyLENIQVJfRk9SV0FSRF9TTEFTSDo0NyxDSEFSX0dSQVZFX0FDQ0VOVDo5NixDSEFSX0hBU0g6MzUsQ0hBUl9IWVBIRU5fTUlOVVM6NDUsQ0hBUl9MRUZUX0FOR0xFX0JSQUNLRVQ6NjAsQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOjEyMyxDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQ6OTEsQ0hBUl9MSU5FX0ZFRUQ6MTAsQ0hBUl9OT19CUkVBS19TUEFDRToxNjAsQ0hBUl9QRVJDRU5UOjM3LENIQVJfUExVUzo0MyxDSEFSX1FVRVNUSU9OX01BUks6NjMsQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUOjYyLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6MTI1LENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6OTMsQ0hBUl9TRU1JQ09MT046NTksQ0hBUl9TSU5HTEVfUVVPVEU6MzksQ0hBUl9TUEFDRTozMixDSEFSX1RBQjo5LENIQVJfVU5ERVJTQ09SRTo5NSxDSEFSX1ZFUlRJQ0FMX0xJTkU6MTI0LENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOjY1Mjc5LFNFUDpuLnNlcCxleHRnbG9iQ2hhcnMoZSl7cmV0dXJue1wiIVwiOnt0eXBlOlwibmVnYXRlXCIsb3BlbjpcIig/Oig/ISg/OlwiLGNsb3NlOmApKSR7ZS5TVEFSfSlgfSxcIj9cIjp7dHlwZTpcInFtYXJrXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKT9cIn0sXCIrXCI6e3R5cGU6XCJwbHVzXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKStcIn0sXCIqXCI6e3R5cGU6XCJzdGFyXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKSpcIn0sXCJAXCI6e3R5cGU6XCJhdFwiLG9wZW46XCIoPzpcIixjbG9zZTpcIilcIn19fSxnbG9iQ2hhcnMoZSl7cmV0dXJuIGU9PT10cnVlP3g6ZH19fSw3NTQ6KGUsdCxyKT0+e2NvbnN0IG49cigzNTYpO2NvbnN0IHU9cig1MTMpO2NvbnN0e01BWF9MRU5HVEg6cyxQT1NJWF9SRUdFWF9TT1VSQ0U6byxSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzppLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjphLFJFUExBQ0VNRU5UUzpsfT1uO2NvbnN0IGV4cGFuZFJhbmdlPShlLHQpPT57aWYodHlwZW9mIHQuZXhwYW5kUmFuZ2U9PT1cImZ1bmN0aW9uXCIpe3JldHVybiB0LmV4cGFuZFJhbmdlKC4uLmUsdCl9ZS5zb3J0KCk7Y29uc3Qgcj1gWyR7ZS5qb2luKFwiLVwiKX1dYDt0cnl7bmV3IFJlZ0V4cChyKX1jYXRjaCh0KXtyZXR1cm4gZS5tYXAoKGU9PnUuZXNjYXBlUmVnZXgoZSkpKS5qb2luKFwiLi5cIil9cmV0dXJuIHJ9O2NvbnN0IHN5bnRheEVycm9yPShlLHQpPT5gTWlzc2luZyAke2V9OiBcIiR7dH1cIiAtIHVzZSBcIlxcXFxcXFxcJHt0fVwiIHRvIG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyc2A7Y29uc3QgcGFyc2U9KGUsdCk9PntpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKX1lPWxbZV18fGU7Y29uc3Qgcj17Li4udH07Y29uc3QgYz10eXBlb2Ygci5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsci5tYXhMZW5ndGgpOnM7bGV0IHA9ZS5sZW5ndGg7aWYocD5jKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtwfSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke2N9YCl9Y29uc3QgZj17dHlwZTpcImJvc1wiLHZhbHVlOlwiXCIsb3V0cHV0OnIucHJlcGVuZHx8XCJcIn07Y29uc3QgQT1bZl07Y29uc3QgUj1yLmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgXz11LmlzV2luZG93cyh0KTtjb25zdCBoPW4uZ2xvYkNoYXJzKF8pO2NvbnN0IGc9bi5leHRnbG9iQ2hhcnMoaCk7Y29uc3R7RE9UX0xJVEVSQUw6RSxQTFVTX0xJVEVSQUw6QyxTTEFTSF9MSVRFUkFMOnksT05FX0NIQVI6ZCxET1RTX1NMQVNIOngsTk9fRE9UOmIsTk9fRE9UX1NMQVNIOlMsTk9fRE9UU19TTEFTSDpILFFNQVJLOnYsUU1BUktfTk9fRE9UOiQsU1RBUjptLFNUQVJUX0FOQ0hPUjpUfT1oO2NvbnN0IGdsb2JzdGFyPWU9PmAoJHtSfSg/Oig/ISR7VH0ke2UuZG90P3g6RX0pLikqPylgO2NvbnN0IEw9ci5kb3Q/XCJcIjpiO2NvbnN0IE89ci5kb3Q/djokO2xldCB3PXIuYmFzaD09PXRydWU/Z2xvYnN0YXIocik6bTtpZihyLmNhcHR1cmUpe3c9YCgke3d9KWB9aWYodHlwZW9mIHIubm9leHQ9PT1cImJvb2xlYW5cIil7ci5ub2V4dGdsb2I9ci5ub2V4dH1jb25zdCBOPXtpbnB1dDplLGluZGV4Oi0xLHN0YXJ0OjAsZG90OnIuZG90PT09dHJ1ZSxjb25zdW1lZDpcIlwiLG91dHB1dDpcIlwiLHByZWZpeDpcIlwiLGJhY2t0cmFjazpmYWxzZSxuZWdhdGVkOmZhbHNlLGJyYWNrZXRzOjAsYnJhY2VzOjAscGFyZW5zOjAscXVvdGVzOjAsZ2xvYnN0YXI6ZmFsc2UsdG9rZW5zOkF9O2U9dS5yZW1vdmVQcmVmaXgoZSxOKTtwPWUubGVuZ3RoO2NvbnN0IGs9W107Y29uc3QgST1bXTtjb25zdCBNPVtdO2xldCBQPWY7bGV0IEI7Y29uc3QgZW9zPSgpPT5OLmluZGV4PT09cC0xO2NvbnN0IEc9Ti5wZWVrPSh0PTEpPT5lW04uaW5kZXgrdF07Y29uc3QgRD1OLmFkdmFuY2U9KCk9PmVbKytOLmluZGV4XTtjb25zdCByZW1haW5pbmc9KCk9PmUuc2xpY2UoTi5pbmRleCsxKTtjb25zdCBjb25zdW1lPShlPVwiXCIsdD0wKT0+e04uY29uc3VtZWQrPWU7Ti5pbmRleCs9dH07Y29uc3QgYXBwZW5kPWU9PntOLm91dHB1dCs9ZS5vdXRwdXQhPW51bGw/ZS5vdXRwdXQ6ZS52YWx1ZTtjb25zdW1lKGUudmFsdWUpfTtjb25zdCBuZWdhdGU9KCk9PntsZXQgZT0xO3doaWxlKEcoKT09PVwiIVwiJiYoRygyKSE9PVwiKFwifHxHKDMpPT09XCI/XCIpKXtEKCk7Ti5zdGFydCsrO2UrK31pZihlJTI9PT0wKXtyZXR1cm4gZmFsc2V9Ti5uZWdhdGVkPXRydWU7Ti5zdGFydCsrO3JldHVybiB0cnVlfTtjb25zdCBpbmNyZW1lbnQ9ZT0+e05bZV0rKztNLnB1c2goZSl9O2NvbnN0IGRlY3JlbWVudD1lPT57TltlXS0tO00ucG9wKCl9O2NvbnN0IHB1c2g9ZT0+e2lmKFAudHlwZT09PVwiZ2xvYnN0YXJcIil7Y29uc3QgdD1OLmJyYWNlcz4wJiYoZS50eXBlPT09XCJjb21tYVwifHxlLnR5cGU9PT1cImJyYWNlXCIpO2NvbnN0IHI9ZS5leHRnbG9iPT09dHJ1ZXx8ay5sZW5ndGgmJihlLnR5cGU9PT1cInBpcGVcInx8ZS50eXBlPT09XCJwYXJlblwiKTtpZihlLnR5cGUhPT1cInNsYXNoXCImJmUudHlwZSE9PVwicGFyZW5cIiYmIXQmJiFyKXtOLm91dHB1dD1OLm91dHB1dC5zbGljZSgwLC1QLm91dHB1dC5sZW5ndGgpO1AudHlwZT1cInN0YXJcIjtQLnZhbHVlPVwiKlwiO1Aub3V0cHV0PXc7Ti5vdXRwdXQrPVAub3V0cHV0fX1pZihrLmxlbmd0aCYmZS50eXBlIT09XCJwYXJlblwiJiYhZ1tlLnZhbHVlXSl7a1trLmxlbmd0aC0xXS5pbm5lcis9ZS52YWx1ZX1pZihlLnZhbHVlfHxlLm91dHB1dClhcHBlbmQoZSk7aWYoUCYmUC50eXBlPT09XCJ0ZXh0XCImJmUudHlwZT09PVwidGV4dFwiKXtQLnZhbHVlKz1lLnZhbHVlO1Aub3V0cHV0PShQLm91dHB1dHx8XCJcIikrZS52YWx1ZTtyZXR1cm59ZS5wcmV2PVA7QS5wdXNoKGUpO1A9ZX07Y29uc3QgZXh0Z2xvYk9wZW49KGUsdCk9Pntjb25zdCBuPXsuLi5nW3RdLGNvbmRpdGlvbnM6MSxpbm5lcjpcIlwifTtuLnByZXY9UDtuLnBhcmVucz1OLnBhcmVucztuLm91dHB1dD1OLm91dHB1dDtjb25zdCB1PShyLmNhcHR1cmU/XCIoXCI6XCJcIikrbi5vcGVuO2luY3JlbWVudChcInBhcmVuc1wiKTtwdXNoKHt0eXBlOmUsdmFsdWU6dCxvdXRwdXQ6Ti5vdXRwdXQ/XCJcIjpkfSk7cHVzaCh7dHlwZTpcInBhcmVuXCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkQoKSxvdXRwdXQ6dX0pO2sucHVzaChuKX07Y29uc3QgZXh0Z2xvYkNsb3NlPWU9PntsZXQgdD1lLmNsb3NlKyhyLmNhcHR1cmU/XCIpXCI6XCJcIik7aWYoZS50eXBlPT09XCJuZWdhdGVcIil7bGV0IG49dztpZihlLmlubmVyJiZlLmlubmVyLmxlbmd0aD4xJiZlLmlubmVyLmluY2x1ZGVzKFwiL1wiKSl7bj1nbG9ic3RhcihyKX1pZihuIT09d3x8ZW9zKCl8fC9eXFwpKyQvLnRlc3QocmVtYWluaW5nKCkpKXt0PWUuY2xvc2U9YCkkKSkke259YH1pZihlLnByZXYudHlwZT09PVwiYm9zXCIpe04ubmVnYXRlZEV4dGdsb2I9dHJ1ZX19cHVzaCh7dHlwZTpcInBhcmVuXCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkIsb3V0cHV0OnR9KTtkZWNyZW1lbnQoXCJwYXJlbnNcIil9O2lmKHIuZmFzdHBhdGhzIT09ZmFsc2UmJiEvKF5bKiFdfFsvKClbXFxde31cIl0pLy50ZXN0KGUpKXtsZXQgbj1mYWxzZTtsZXQgcz1lLnJlcGxhY2UoYSwoKGUsdCxyLHUscyxvKT0+e2lmKHU9PT1cIlxcXFxcIil7bj10cnVlO3JldHVybiBlfWlmKHU9PT1cIj9cIil7aWYodCl7cmV0dXJuIHQrdSsocz92LnJlcGVhdChzLmxlbmd0aCk6XCJcIil9aWYobz09PTApe3JldHVybiBPKyhzP3YucmVwZWF0KHMubGVuZ3RoKTpcIlwiKX1yZXR1cm4gdi5yZXBlYXQoci5sZW5ndGgpfWlmKHU9PT1cIi5cIil7cmV0dXJuIEUucmVwZWF0KHIubGVuZ3RoKX1pZih1PT09XCIqXCIpe2lmKHQpe3JldHVybiB0K3UrKHM/dzpcIlwiKX1yZXR1cm4gd31yZXR1cm4gdD9lOmBcXFxcJHtlfWB9KSk7aWYobj09PXRydWUpe2lmKHIudW5lc2NhcGU9PT10cnVlKXtzPXMucmVwbGFjZSgvXFxcXC9nLFwiXCIpfWVsc2V7cz1zLnJlcGxhY2UoL1xcXFwrL2csKGU9PmUubGVuZ3RoJTI9PT0wP1wiXFxcXFxcXFxcIjplP1wiXFxcXFwiOlwiXCIpKX19aWYocz09PWUmJnIuY29udGFpbnM9PT10cnVlKXtOLm91dHB1dD1lO3JldHVybiBOfU4ub3V0cHV0PXUud3JhcE91dHB1dChzLE4sdCk7cmV0dXJuIE59d2hpbGUoIWVvcygpKXtCPUQoKTtpZihCPT09XCJcXDBcIil7Y29udGludWV9aWYoQj09PVwiXFxcXFwiKXtjb25zdCBlPUcoKTtpZihlPT09XCIvXCImJnIuYmFzaCE9PXRydWUpe2NvbnRpbnVlfWlmKGU9PT1cIi5cInx8ZT09PVwiO1wiKXtjb250aW51ZX1pZighZSl7Qis9XCJcXFxcXCI7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCfSk7Y29udGludWV9Y29uc3QgdD0vXlxcXFwrLy5leGVjKHJlbWFpbmluZygpKTtsZXQgbj0wO2lmKHQmJnRbMF0ubGVuZ3RoPjIpe249dFswXS5sZW5ndGg7Ti5pbmRleCs9bjtpZihuJTIhPT0wKXtCKz1cIlxcXFxcIn19aWYoci51bmVzY2FwZT09PXRydWUpe0I9RCgpfHxcIlwifWVsc2V7Qis9RCgpfHxcIlwifWlmKE4uYnJhY2tldHM9PT0wKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkJ9KTtjb250aW51ZX19aWYoTi5icmFja2V0cz4wJiYoQiE9PVwiXVwifHxQLnZhbHVlPT09XCJbXCJ8fFAudmFsdWU9PT1cIlteXCIpKXtpZihyLnBvc2l4IT09ZmFsc2UmJkI9PT1cIjpcIil7Y29uc3QgZT1QLnZhbHVlLnNsaWNlKDEpO2lmKGUuaW5jbHVkZXMoXCJbXCIpKXtQLnBvc2l4PXRydWU7aWYoZS5pbmNsdWRlcyhcIjpcIikpe2NvbnN0IGU9UC52YWx1ZS5sYXN0SW5kZXhPZihcIltcIik7Y29uc3QgdD1QLnZhbHVlLnNsaWNlKDAsZSk7Y29uc3Qgcj1QLnZhbHVlLnNsaWNlKGUrMik7Y29uc3Qgbj1vW3JdO2lmKG4pe1AudmFsdWU9dCtuO04uYmFja3RyYWNrPXRydWU7RCgpO2lmKCFmLm91dHB1dCYmQS5pbmRleE9mKFApPT09MSl7Zi5vdXRwdXQ9ZH1jb250aW51ZX19fX1pZihCPT09XCJbXCImJkcoKSE9PVwiOlwifHxCPT09XCItXCImJkcoKT09PVwiXVwiKXtCPWBcXFxcJHtCfWB9aWYoQj09PVwiXVwiJiYoUC52YWx1ZT09PVwiW1wifHxQLnZhbHVlPT09XCJbXlwiKSl7Qj1gXFxcXCR7Qn1gfWlmKHIucG9zaXg9PT10cnVlJiZCPT09XCIhXCImJlAudmFsdWU9PT1cIltcIil7Qj1cIl5cIn1QLnZhbHVlKz1CO2FwcGVuZCh7dmFsdWU6Qn0pO2NvbnRpbnVlfWlmKE4ucXVvdGVzPT09MSYmQiE9PSdcIicpe0I9dS5lc2NhcGVSZWdleChCKTtQLnZhbHVlKz1CO2FwcGVuZCh7dmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT0nXCInKXtOLnF1b3Rlcz1OLnF1b3Rlcz09PTE/MDoxO2lmKHIua2VlcFF1b3Rlcz09PXRydWUpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pfWNvbnRpbnVlfWlmKEI9PT1cIihcIil7aW5jcmVtZW50KFwicGFyZW5zXCIpO3B1c2goe3R5cGU6XCJwYXJlblwiLHZhbHVlOkJ9KTtjb250aW51ZX1pZihCPT09XCIpXCIpe2lmKE4ucGFyZW5zPT09MCYmci5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcIm9wZW5pbmdcIixcIihcIikpfWNvbnN0IGU9a1trLmxlbmd0aC0xXTtpZihlJiZOLnBhcmVucz09PWUucGFyZW5zKzEpe2V4dGdsb2JDbG9zZShrLnBvcCgpKTtjb250aW51ZX1wdXNoKHt0eXBlOlwicGFyZW5cIix2YWx1ZTpCLG91dHB1dDpOLnBhcmVucz9cIilcIjpcIlxcXFwpXCJ9KTtkZWNyZW1lbnQoXCJwYXJlbnNcIik7Y29udGludWV9aWYoQj09PVwiW1wiKXtpZihyLm5vYnJhY2tldD09PXRydWV8fCFyZW1haW5pbmcoKS5pbmNsdWRlcyhcIl1cIikpe2lmKHIubm9icmFja2V0IT09dHJ1ZSYmci5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIl1cIikpfUI9YFxcXFwke0J9YH1lbHNle2luY3JlbWVudChcImJyYWNrZXRzXCIpfXB1c2goe3R5cGU6XCJicmFja2V0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT1cIl1cIil7aWYoci5ub2JyYWNrZXQ9PT10cnVlfHxQJiZQLnR5cGU9PT1cImJyYWNrZXRcIiYmUC52YWx1ZS5sZW5ndGg9PT0xKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkIsb3V0cHV0OmBcXFxcJHtCfWB9KTtjb250aW51ZX1pZihOLmJyYWNrZXRzPT09MCl7aWYoci5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcIm9wZW5pbmdcIixcIltcIikpfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6QixvdXRwdXQ6YFxcXFwke0J9YH0pO2NvbnRpbnVlfWRlY3JlbWVudChcImJyYWNrZXRzXCIpO2NvbnN0IGU9UC52YWx1ZS5zbGljZSgxKTtpZihQLnBvc2l4IT09dHJ1ZSYmZVswXT09PVwiXlwiJiYhZS5pbmNsdWRlcyhcIi9cIikpe0I9YC8ke0J9YH1QLnZhbHVlKz1CO2FwcGVuZCh7dmFsdWU6Qn0pO2lmKHIubGl0ZXJhbEJyYWNrZXRzPT09ZmFsc2V8fHUuaGFzUmVnZXhDaGFycyhlKSl7Y29udGludWV9Y29uc3QgdD11LmVzY2FwZVJlZ2V4KFAudmFsdWUpO04ub3V0cHV0PU4ub3V0cHV0LnNsaWNlKDAsLVAudmFsdWUubGVuZ3RoKTtpZihyLmxpdGVyYWxCcmFja2V0cz09PXRydWUpe04ub3V0cHV0Kz10O1AudmFsdWU9dDtjb250aW51ZX1QLnZhbHVlPWAoJHtSfSR7dH18JHtQLnZhbHVlfSlgO04ub3V0cHV0Kz1QLnZhbHVlO2NvbnRpbnVlfWlmKEI9PT1cIntcIiYmci5ub2JyYWNlIT09dHJ1ZSl7aW5jcmVtZW50KFwiYnJhY2VzXCIpO2NvbnN0IGU9e3R5cGU6XCJicmFjZVwiLHZhbHVlOkIsb3V0cHV0OlwiKFwiLG91dHB1dEluZGV4Ok4ub3V0cHV0Lmxlbmd0aCx0b2tlbnNJbmRleDpOLnRva2Vucy5sZW5ndGh9O0kucHVzaChlKTtwdXNoKGUpO2NvbnRpbnVlfWlmKEI9PT1cIn1cIil7Y29uc3QgZT1JW0kubGVuZ3RoLTFdO2lmKHIubm9icmFjZT09PXRydWV8fCFlKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkIsb3V0cHV0OkJ9KTtjb250aW51ZX1sZXQgdD1cIilcIjtpZihlLmRvdHM9PT10cnVlKXtjb25zdCBlPUEuc2xpY2UoKTtjb25zdCBuPVtdO2ZvcihsZXQgdD1lLmxlbmd0aC0xO3Q+PTA7dC0tKXtBLnBvcCgpO2lmKGVbdF0udHlwZT09PVwiYnJhY2VcIil7YnJlYWt9aWYoZVt0XS50eXBlIT09XCJkb3RzXCIpe24udW5zaGlmdChlW3RdLnZhbHVlKX19dD1leHBhbmRSYW5nZShuLHIpO04uYmFja3RyYWNrPXRydWV9aWYoZS5jb21tYSE9PXRydWUmJmUuZG90cyE9PXRydWUpe2NvbnN0IHI9Ti5vdXRwdXQuc2xpY2UoMCxlLm91dHB1dEluZGV4KTtjb25zdCBuPU4udG9rZW5zLnNsaWNlKGUudG9rZW5zSW5kZXgpO2UudmFsdWU9ZS5vdXRwdXQ9XCJcXFxce1wiO0I9dD1cIlxcXFx9XCI7Ti5vdXRwdXQ9cjtmb3IoY29uc3QgZSBvZiBuKXtOLm91dHB1dCs9ZS5vdXRwdXR8fGUudmFsdWV9fXB1c2goe3R5cGU6XCJicmFjZVwiLHZhbHVlOkIsb3V0cHV0OnR9KTtkZWNyZW1lbnQoXCJicmFjZXNcIik7SS5wb3AoKTtjb250aW51ZX1pZihCPT09XCJ8XCIpe2lmKGsubGVuZ3RoPjApe2tbay5sZW5ndGgtMV0uY29uZGl0aW9ucysrfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT1cIixcIil7bGV0IGU9Qjtjb25zdCB0PUlbSS5sZW5ndGgtMV07aWYodCYmTVtNLmxlbmd0aC0xXT09PVwiYnJhY2VzXCIpe3QuY29tbWE9dHJ1ZTtlPVwifFwifXB1c2goe3R5cGU6XCJjb21tYVwiLHZhbHVlOkIsb3V0cHV0OmV9KTtjb250aW51ZX1pZihCPT09XCIvXCIpe2lmKFAudHlwZT09PVwiZG90XCImJk4uaW5kZXg9PT1OLnN0YXJ0KzEpe04uc3RhcnQ9Ti5pbmRleCsxO04uY29uc3VtZWQ9XCJcIjtOLm91dHB1dD1cIlwiO0EucG9wKCk7UD1mO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJzbGFzaFwiLHZhbHVlOkIsb3V0cHV0Onl9KTtjb250aW51ZX1pZihCPT09XCIuXCIpe2lmKE4uYnJhY2VzPjAmJlAudHlwZT09PVwiZG90XCIpe2lmKFAudmFsdWU9PT1cIi5cIilQLm91dHB1dD1FO2NvbnN0IGU9SVtJLmxlbmd0aC0xXTtQLnR5cGU9XCJkb3RzXCI7UC5vdXRwdXQrPUI7UC52YWx1ZSs9QjtlLmRvdHM9dHJ1ZTtjb250aW51ZX1pZihOLmJyYWNlcytOLnBhcmVucz09PTAmJlAudHlwZSE9PVwiYm9zXCImJlAudHlwZSE9PVwic2xhc2hcIil7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCLG91dHB1dDpFfSk7Y29udGludWV9cHVzaCh7dHlwZTpcImRvdFwiLHZhbHVlOkIsb3V0cHV0OkV9KTtjb250aW51ZX1pZihCPT09XCI/XCIpe2NvbnN0IGU9UCYmUC52YWx1ZT09PVwiKFwiO2lmKCFlJiZyLm5vZXh0Z2xvYiE9PXRydWUmJkcoKT09PVwiKFwiJiZHKDIpIT09XCI/XCIpe2V4dGdsb2JPcGVuKFwicW1hcmtcIixCKTtjb250aW51ZX1pZihQJiZQLnR5cGU9PT1cInBhcmVuXCIpe2NvbnN0IGU9RygpO2xldCB0PUI7aWYoZT09PVwiPFwiJiYhdS5zdXBwb3J0c0xvb2tiZWhpbmRzKCkpe3Rocm93IG5ldyBFcnJvcihcIk5vZGUuanMgdjEwIG9yIGhpZ2hlciBpcyByZXF1aXJlZCBmb3IgcmVnZXggbG9va2JlaGluZHNcIil9aWYoUC52YWx1ZT09PVwiKFwiJiYhL1shPTw6XS8udGVzdChlKXx8ZT09PVwiPFwiJiYhLzwoWyE9XXxcXHcrPikvLnRlc3QocmVtYWluaW5nKCkpKXt0PWBcXFxcJHtCfWB9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCLG91dHB1dDp0fSk7Y29udGludWV9aWYoci5kb3QhPT10cnVlJiYoUC50eXBlPT09XCJzbGFzaFwifHxQLnR5cGU9PT1cImJvc1wiKSl7cHVzaCh7dHlwZTpcInFtYXJrXCIsdmFsdWU6QixvdXRwdXQ6JH0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJxbWFya1wiLHZhbHVlOkIsb3V0cHV0OnZ9KTtjb250aW51ZX1pZihCPT09XCIhXCIpe2lmKHIubm9leHRnbG9iIT09dHJ1ZSYmRygpPT09XCIoXCIpe2lmKEcoMikhPT1cIj9cInx8IS9bIT08Ol0vLnRlc3QoRygzKSkpe2V4dGdsb2JPcGVuKFwibmVnYXRlXCIsQik7Y29udGludWV9fWlmKHIubm9uZWdhdGUhPT10cnVlJiZOLmluZGV4PT09MCl7bmVnYXRlKCk7Y29udGludWV9fWlmKEI9PT1cIitcIil7aWYoci5ub2V4dGdsb2IhPT10cnVlJiZHKCk9PT1cIihcIiYmRygyKSE9PVwiP1wiKXtleHRnbG9iT3BlbihcInBsdXNcIixCKTtjb250aW51ZX1pZihQJiZQLnZhbHVlPT09XCIoXCJ8fHIucmVnZXg9PT1mYWxzZSl7cHVzaCh7dHlwZTpcInBsdXNcIix2YWx1ZTpCLG91dHB1dDpDfSk7Y29udGludWV9aWYoUCYmKFAudHlwZT09PVwiYnJhY2tldFwifHxQLnR5cGU9PT1cInBhcmVuXCJ8fFAudHlwZT09PVwiYnJhY2VcIil8fE4ucGFyZW5zPjApe3B1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6Qn0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6Q30pO2NvbnRpbnVlfWlmKEI9PT1cIkBcIil7aWYoci5ub2V4dGdsb2IhPT10cnVlJiZHKCk9PT1cIihcIiYmRygyKSE9PVwiP1wiKXtwdXNoKHt0eXBlOlwiYXRcIixleHRnbG9iOnRydWUsdmFsdWU6QixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEIhPT1cIipcIil7aWYoQj09PVwiJFwifHxCPT09XCJeXCIpe0I9YFxcXFwke0J9YH1jb25zdCBlPWkuZXhlYyhyZW1haW5pbmcoKSk7aWYoZSl7Qis9ZVswXTtOLmluZGV4Kz1lWzBdLmxlbmd0aH1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkJ9KTtjb250aW51ZX1pZihQJiYoUC50eXBlPT09XCJnbG9ic3RhclwifHxQLnN0YXI9PT10cnVlKSl7UC50eXBlPVwic3RhclwiO1Auc3Rhcj10cnVlO1AudmFsdWUrPUI7UC5vdXRwdXQ9dztOLmJhY2t0cmFjaz10cnVlO04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIpO2NvbnRpbnVlfWxldCB0PXJlbWFpbmluZygpO2lmKHIubm9leHRnbG9iIT09dHJ1ZSYmL15cXChbXj9dLy50ZXN0KHQpKXtleHRnbG9iT3BlbihcInN0YXJcIixCKTtjb250aW51ZX1pZihQLnR5cGU9PT1cInN0YXJcIil7aWYoci5ub2dsb2JzdGFyPT09dHJ1ZSl7Y29uc3VtZShCKTtjb250aW51ZX1jb25zdCBuPVAucHJldjtjb25zdCB1PW4ucHJldjtjb25zdCBzPW4udHlwZT09PVwic2xhc2hcInx8bi50eXBlPT09XCJib3NcIjtjb25zdCBvPXUmJih1LnR5cGU9PT1cInN0YXJcInx8dS50eXBlPT09XCJnbG9ic3RhclwiKTtpZihyLmJhc2g9PT10cnVlJiYoIXN8fHRbMF0mJnRbMF0hPT1cIi9cIikpe3B1c2goe3R5cGU6XCJzdGFyXCIsdmFsdWU6QixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfWNvbnN0IGk9Ti5icmFjZXM+MCYmKG4udHlwZT09PVwiY29tbWFcInx8bi50eXBlPT09XCJicmFjZVwiKTtjb25zdCBhPWsubGVuZ3RoJiYobi50eXBlPT09XCJwaXBlXCJ8fG4udHlwZT09PVwicGFyZW5cIik7aWYoIXMmJm4udHlwZSE9PVwicGFyZW5cIiYmIWkmJiFhKXtwdXNoKHt0eXBlOlwic3RhclwiLHZhbHVlOkIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX13aGlsZSh0LnNsaWNlKDAsMyk9PT1cIi8qKlwiKXtjb25zdCByPWVbTi5pbmRleCs0XTtpZihyJiZyIT09XCIvXCIpe2JyZWFrfXQ9dC5zbGljZSgzKTtjb25zdW1lKFwiLyoqXCIsMyl9aWYobi50eXBlPT09XCJib3NcIiYmZW9zKCkpe1AudHlwZT1cImdsb2JzdGFyXCI7UC52YWx1ZSs9QjtQLm91dHB1dD1nbG9ic3RhcihyKTtOLm91dHB1dD1QLm91dHB1dDtOLmdsb2JzdGFyPXRydWU7Y29uc3VtZShCKTtjb250aW51ZX1pZihuLnR5cGU9PT1cInNsYXNoXCImJm4ucHJldi50eXBlIT09XCJib3NcIiYmIW8mJmVvcygpKXtOLm91dHB1dD1OLm91dHB1dC5zbGljZSgwLC0obi5vdXRwdXQrUC5vdXRwdXQpLmxlbmd0aCk7bi5vdXRwdXQ9YCg/OiR7bi5vdXRwdXR9YDtQLnR5cGU9XCJnbG9ic3RhclwiO1Aub3V0cHV0PWdsb2JzdGFyKHIpKyhyLnN0cmljdFNsYXNoZXM/XCIpXCI6XCJ8JClcIik7UC52YWx1ZSs9QjtOLmdsb2JzdGFyPXRydWU7Ti5vdXRwdXQrPW4ub3V0cHV0K1Aub3V0cHV0O2NvbnN1bWUoQik7Y29udGludWV9aWYobi50eXBlPT09XCJzbGFzaFwiJiZuLnByZXYudHlwZSE9PVwiYm9zXCImJnRbMF09PT1cIi9cIil7Y29uc3QgZT10WzFdIT09dm9pZCAwP1wifCRcIjpcIlwiO04ub3V0cHV0PU4ub3V0cHV0LnNsaWNlKDAsLShuLm91dHB1dCtQLm91dHB1dCkubGVuZ3RoKTtuLm91dHB1dD1gKD86JHtuLm91dHB1dH1gO1AudHlwZT1cImdsb2JzdGFyXCI7UC5vdXRwdXQ9YCR7Z2xvYnN0YXIocil9JHt5fXwke3l9JHtlfSlgO1AudmFsdWUrPUI7Ti5vdXRwdXQrPW4ub3V0cHV0K1Aub3V0cHV0O04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIrRCgpKTtwdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpcIi9cIixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfWlmKG4udHlwZT09PVwiYm9zXCImJnRbMF09PT1cIi9cIil7UC50eXBlPVwiZ2xvYnN0YXJcIjtQLnZhbHVlKz1CO1Aub3V0cHV0PWAoPzpefCR7eX18JHtnbG9ic3RhcihyKX0ke3l9KWA7Ti5vdXRwdXQ9UC5vdXRwdXQ7Ti5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoQitEKCkpO3B1c2goe3R5cGU6XCJzbGFzaFwiLHZhbHVlOlwiL1wiLG91dHB1dDpcIlwifSk7Y29udGludWV9Ti5vdXRwdXQ9Ti5vdXRwdXQuc2xpY2UoMCwtUC5vdXRwdXQubGVuZ3RoKTtQLnR5cGU9XCJnbG9ic3RhclwiO1Aub3V0cHV0PWdsb2JzdGFyKHIpO1AudmFsdWUrPUI7Ti5vdXRwdXQrPVAub3V0cHV0O04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIpO2NvbnRpbnVlfWNvbnN0IG49e3R5cGU6XCJzdGFyXCIsdmFsdWU6QixvdXRwdXQ6d307aWYoci5iYXNoPT09dHJ1ZSl7bi5vdXRwdXQ9XCIuKj9cIjtpZihQLnR5cGU9PT1cImJvc1wifHxQLnR5cGU9PT1cInNsYXNoXCIpe24ub3V0cHV0PUwrbi5vdXRwdXR9cHVzaChuKTtjb250aW51ZX1pZihQJiYoUC50eXBlPT09XCJicmFja2V0XCJ8fFAudHlwZT09PVwicGFyZW5cIikmJnIucmVnZXg9PT10cnVlKXtuLm91dHB1dD1CO3B1c2gobik7Y29udGludWV9aWYoTi5pbmRleD09PU4uc3RhcnR8fFAudHlwZT09PVwic2xhc2hcInx8UC50eXBlPT09XCJkb3RcIil7aWYoUC50eXBlPT09XCJkb3RcIil7Ti5vdXRwdXQrPVM7UC5vdXRwdXQrPVN9ZWxzZSBpZihyLmRvdD09PXRydWUpe04ub3V0cHV0Kz1IO1Aub3V0cHV0Kz1IfWVsc2V7Ti5vdXRwdXQrPUw7UC5vdXRwdXQrPUx9aWYoRygpIT09XCIqXCIpe04ub3V0cHV0Kz1kO1Aub3V0cHV0Kz1kfX1wdXNoKG4pfXdoaWxlKE4uYnJhY2tldHM+MCl7aWYoci5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiXVwiKSk7Ti5vdXRwdXQ9dS5lc2NhcGVMYXN0KE4ub3V0cHV0LFwiW1wiKTtkZWNyZW1lbnQoXCJicmFja2V0c1wiKX13aGlsZShOLnBhcmVucz4wKXtpZihyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCIpXCIpKTtOLm91dHB1dD11LmVzY2FwZUxhc3QoTi5vdXRwdXQsXCIoXCIpO2RlY3JlbWVudChcInBhcmVuc1wiKX13aGlsZShOLmJyYWNlcz4wKXtpZihyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJ9XCIpKTtOLm91dHB1dD11LmVzY2FwZUxhc3QoTi5vdXRwdXQsXCJ7XCIpO2RlY3JlbWVudChcImJyYWNlc1wiKX1pZihyLnN0cmljdFNsYXNoZXMhPT10cnVlJiYoUC50eXBlPT09XCJzdGFyXCJ8fFAudHlwZT09PVwiYnJhY2tldFwiKSl7cHVzaCh7dHlwZTpcIm1heWJlX3NsYXNoXCIsdmFsdWU6XCJcIixvdXRwdXQ6YCR7eX0/YH0pfWlmKE4uYmFja3RyYWNrPT09dHJ1ZSl7Ti5vdXRwdXQ9XCJcIjtmb3IoY29uc3QgZSBvZiBOLnRva2Vucyl7Ti5vdXRwdXQrPWUub3V0cHV0IT1udWxsP2Uub3V0cHV0OmUudmFsdWU7aWYoZS5zdWZmaXgpe04ub3V0cHV0Kz1lLnN1ZmZpeH19fXJldHVybiBOfTtwYXJzZS5mYXN0cGF0aHM9KGUsdCk9Pntjb25zdCByPXsuLi50fTtjb25zdCBvPXR5cGVvZiByLm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4ocyxyLm1heExlbmd0aCk6cztjb25zdCBpPWUubGVuZ3RoO2lmKGk+byl7dGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnB1dCBsZW5ndGg6ICR7aX0sIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIGxlbmd0aDogJHtvfWApfWU9bFtlXXx8ZTtjb25zdCBhPXUuaXNXaW5kb3dzKHQpO2NvbnN0e0RPVF9MSVRFUkFMOmMsU0xBU0hfTElURVJBTDpwLE9ORV9DSEFSOmYsRE9UU19TTEFTSDpBLE5PX0RPVDpSLE5PX0RPVFM6XyxOT19ET1RTX1NMQVNIOmgsU1RBUjpnLFNUQVJUX0FOQ0hPUjpFfT1uLmdsb2JDaGFycyhhKTtjb25zdCBDPXIuZG90P186Ujtjb25zdCB5PXIuZG90P2g6Ujtjb25zdCBkPXIuY2FwdHVyZT9cIlwiOlwiPzpcIjtjb25zdCB4PXtuZWdhdGVkOmZhbHNlLHByZWZpeDpcIlwifTtsZXQgYj1yLmJhc2g9PT10cnVlP1wiLio/XCI6ZztpZihyLmNhcHR1cmUpe2I9YCgke2J9KWB9Y29uc3QgZ2xvYnN0YXI9ZT0+e2lmKGUubm9nbG9ic3Rhcj09PXRydWUpcmV0dXJuIGI7cmV0dXJuYCgke2R9KD86KD8hJHtFfSR7ZS5kb3Q/QTpjfSkuKSo/KWB9O2NvbnN0IGNyZWF0ZT1lPT57c3dpdGNoKGUpe2Nhc2VcIipcIjpyZXR1cm5gJHtDfSR7Zn0ke2J9YDtjYXNlXCIuKlwiOnJldHVybmAke2N9JHtmfSR7Yn1gO2Nhc2VcIiouKlwiOnJldHVybmAke0N9JHtifSR7Y30ke2Z9JHtifWA7Y2FzZVwiKi8qXCI6cmV0dXJuYCR7Q30ke2J9JHtwfSR7Zn0ke3l9JHtifWA7Y2FzZVwiKipcIjpyZXR1cm4gQytnbG9ic3RhcihyKTtjYXNlXCIqKi8qXCI6cmV0dXJuYCg/OiR7Q30ke2dsb2JzdGFyKHIpfSR7cH0pPyR7eX0ke2Z9JHtifWA7Y2FzZVwiKiovKi4qXCI6cmV0dXJuYCg/OiR7Q30ke2dsb2JzdGFyKHIpfSR7cH0pPyR7eX0ke2J9JHtjfSR7Zn0ke2J9YDtjYXNlXCIqKi8uKlwiOnJldHVybmAoPzoke0N9JHtnbG9ic3RhcihyKX0ke3B9KT8ke2N9JHtmfSR7Yn1gO2RlZmF1bHQ6e2NvbnN0IHQ9L14oLio/KVxcLihcXHcrKSQvLmV4ZWMoZSk7aWYoIXQpcmV0dXJuO2NvbnN0IHI9Y3JlYXRlKHRbMV0pO2lmKCFyKXJldHVybjtyZXR1cm4gcitjK3RbMl19fX07Y29uc3QgUz11LnJlbW92ZVByZWZpeChlLHgpO2xldCBIPWNyZWF0ZShTKTtpZihIJiZyLnN0cmljdFNsYXNoZXMhPT10cnVlKXtIKz1gJHtwfT9gfXJldHVybiBIfTtlLmV4cG9ydHM9cGFyc2V9LDY4MzooZSx0LHIpPT57Y29uc3Qgbj1yKDE3KTtjb25zdCB1PXIoNzAwKTtjb25zdCBzPXIoNzU0KTtjb25zdCBvPXIoNTEzKTtjb25zdCBpPXIoMzU2KTtjb25zdCBpc09iamVjdD1lPT5lJiZ0eXBlb2YgZT09PVwib2JqZWN0XCImJiFBcnJheS5pc0FycmF5KGUpO2NvbnN0IHBpY29tYXRjaD0oZSx0LHI9ZmFsc2UpPT57aWYoQXJyYXkuaXNBcnJheShlKSl7Y29uc3Qgbj1lLm1hcCgoZT0+cGljb21hdGNoKGUsdCxyKSkpO2NvbnN0IGFycmF5TWF0Y2hlcj1lPT57Zm9yKGNvbnN0IHQgb2Ygbil7Y29uc3Qgcj10KGUpO2lmKHIpcmV0dXJuIHJ9cmV0dXJuIGZhbHNlfTtyZXR1cm4gYXJyYXlNYXRjaGVyfWNvbnN0IG49aXNPYmplY3QoZSkmJmUudG9rZW5zJiZlLmlucHV0O2lmKGU9PT1cIlwifHx0eXBlb2YgZSE9PVwic3RyaW5nXCImJiFuKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgcGF0dGVybiB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIil9Y29uc3QgdT10fHx7fTtjb25zdCBzPW8uaXNXaW5kb3dzKHQpO2NvbnN0IGk9bj9waWNvbWF0Y2guY29tcGlsZVJlKGUsdCk6cGljb21hdGNoLm1ha2VSZShlLHQsZmFsc2UsdHJ1ZSk7Y29uc3QgYT1pLnN0YXRlO2RlbGV0ZSBpLnN0YXRlO2xldCBpc0lnbm9yZWQ9KCk9PmZhbHNlO2lmKHUuaWdub3JlKXtjb25zdCBlPXsuLi50LGlnbm9yZTpudWxsLG9uTWF0Y2g6bnVsbCxvblJlc3VsdDpudWxsfTtpc0lnbm9yZWQ9cGljb21hdGNoKHUuaWdub3JlLGUscil9Y29uc3QgbWF0Y2hlcj0ocixuPWZhbHNlKT0+e2NvbnN0e2lzTWF0Y2g6byxtYXRjaDpsLG91dHB1dDpjfT1waWNvbWF0Y2gudGVzdChyLGksdCx7Z2xvYjplLHBvc2l4OnN9KTtjb25zdCBwPXtnbG9iOmUsc3RhdGU6YSxyZWdleDppLHBvc2l4OnMsaW5wdXQ6cixvdXRwdXQ6YyxtYXRjaDpsLGlzTWF0Y2g6b307aWYodHlwZW9mIHUub25SZXN1bHQ9PT1cImZ1bmN0aW9uXCIpe3Uub25SZXN1bHQocCl9aWYobz09PWZhbHNlKXtwLmlzTWF0Y2g9ZmFsc2U7cmV0dXJuIG4/cDpmYWxzZX1pZihpc0lnbm9yZWQocikpe2lmKHR5cGVvZiB1Lm9uSWdub3JlPT09XCJmdW5jdGlvblwiKXt1Lm9uSWdub3JlKHApfXAuaXNNYXRjaD1mYWxzZTtyZXR1cm4gbj9wOmZhbHNlfWlmKHR5cGVvZiB1Lm9uTWF0Y2g9PT1cImZ1bmN0aW9uXCIpe3Uub25NYXRjaChwKX1yZXR1cm4gbj9wOnRydWV9O2lmKHIpe21hdGNoZXIuc3RhdGU9YX1yZXR1cm4gbWF0Y2hlcn07cGljb21hdGNoLnRlc3Q9KGUsdCxyLHtnbG9iOm4scG9zaXg6dX09e30pPT57aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgaW5wdXQgdG8gYmUgYSBzdHJpbmdcIil9aWYoZT09PVwiXCIpe3JldHVybntpc01hdGNoOmZhbHNlLG91dHB1dDpcIlwifX1jb25zdCBzPXJ8fHt9O2NvbnN0IGk9cy5mb3JtYXR8fCh1P28udG9Qb3NpeFNsYXNoZXM6bnVsbCk7bGV0IGE9ZT09PW47bGV0IGw9YSYmaT9pKGUpOmU7aWYoYT09PWZhbHNlKXtsPWk/aShlKTplO2E9bD09PW59aWYoYT09PWZhbHNlfHxzLmNhcHR1cmU9PT10cnVlKXtpZihzLm1hdGNoQmFzZT09PXRydWV8fHMuYmFzZW5hbWU9PT10cnVlKXthPXBpY29tYXRjaC5tYXRjaEJhc2UoZSx0LHIsdSl9ZWxzZXthPXQuZXhlYyhsKX19cmV0dXJue2lzTWF0Y2g6Qm9vbGVhbihhKSxtYXRjaDphLG91dHB1dDpsfX07cGljb21hdGNoLm1hdGNoQmFzZT0oZSx0LHIsdT1vLmlzV2luZG93cyhyKSk9Pntjb25zdCBzPXQgaW5zdGFuY2VvZiBSZWdFeHA/dDpwaWNvbWF0Y2gubWFrZVJlKHQscik7cmV0dXJuIHMudGVzdChuLmJhc2VuYW1lKGUpKX07cGljb21hdGNoLmlzTWF0Y2g9KGUsdCxyKT0+cGljb21hdGNoKHQscikoZSk7cGljb21hdGNoLnBhcnNlPShlLHQpPT57aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZS5tYXAoKGU9PnBpY29tYXRjaC5wYXJzZShlLHQpKSk7cmV0dXJuIHMoZSx7Li4udCxmYXN0cGF0aHM6ZmFsc2V9KX07cGljb21hdGNoLnNjYW49KGUsdCk9PnUoZSx0KTtwaWNvbWF0Y2guY29tcGlsZVJlPShlLHQscj1mYWxzZSxuPWZhbHNlKT0+e2lmKHI9PT10cnVlKXtyZXR1cm4gZS5vdXRwdXR9Y29uc3QgdT10fHx7fTtjb25zdCBzPXUuY29udGFpbnM/XCJcIjpcIl5cIjtjb25zdCBvPXUuY29udGFpbnM/XCJcIjpcIiRcIjtsZXQgaT1gJHtzfSg/OiR7ZS5vdXRwdXR9KSR7b31gO2lmKGUmJmUubmVnYXRlZD09PXRydWUpe2k9YF4oPyEke2l9KS4qJGB9Y29uc3QgYT1waWNvbWF0Y2gudG9SZWdleChpLHQpO2lmKG49PT10cnVlKXthLnN0YXRlPWV9cmV0dXJuIGF9O3BpY29tYXRjaC5tYWtlUmU9KGUsdCxyPWZhbHNlLG49ZmFsc2UpPT57aWYoIWV8fHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgbm9uLWVtcHR5IHN0cmluZ1wiKX1jb25zdCB1PXR8fHt9O2xldCBvPXtuZWdhdGVkOmZhbHNlLGZhc3RwYXRoczp0cnVlfTtsZXQgaT1cIlwiO2xldCBhO2lmKGUuc3RhcnRzV2l0aChcIi4vXCIpKXtlPWUuc2xpY2UoMik7aT1vLnByZWZpeD1cIi4vXCJ9aWYodS5mYXN0cGF0aHMhPT1mYWxzZSYmKGVbMF09PT1cIi5cInx8ZVswXT09PVwiKlwiKSl7YT1zLmZhc3RwYXRocyhlLHQpfWlmKGE9PT11bmRlZmluZWQpe289cyhlLHQpO28ucHJlZml4PWkrKG8ucHJlZml4fHxcIlwiKX1lbHNle28ub3V0cHV0PWF9cmV0dXJuIHBpY29tYXRjaC5jb21waWxlUmUobyx0LHIsbil9O3BpY29tYXRjaC50b1JlZ2V4PShlLHQpPT57dHJ5e2NvbnN0IHI9dHx8e307cmV0dXJuIG5ldyBSZWdFeHAoZSxyLmZsYWdzfHwoci5ub2Nhc2U/XCJpXCI6XCJcIikpfWNhdGNoKGUpe2lmKHQmJnQuZGVidWc9PT10cnVlKXRocm93IGU7cmV0dXJuLyReL319O3BpY29tYXRjaC5jb25zdGFudHM9aTtlLmV4cG9ydHM9cGljb21hdGNofSw3MDA6KGUsdCxyKT0+e2NvbnN0IG49cig1MTMpO2NvbnN0e0NIQVJfQVNURVJJU0s6dSxDSEFSX0FUOnMsQ0hBUl9CQUNLV0FSRF9TTEFTSDpvLENIQVJfQ09NTUE6aSxDSEFSX0RPVDphLENIQVJfRVhDTEFNQVRJT05fTUFSSzpsLENIQVJfRk9SV0FSRF9TTEFTSDpjLENIQVJfTEVGVF9DVVJMWV9CUkFDRTpwLENIQVJfTEVGVF9QQVJFTlRIRVNFUzpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUExVUzpSLENIQVJfUVVFU1RJT05fTUFSSzpfLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6aCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmcsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpFfT1yKDM1Nik7Y29uc3QgaXNQYXRoU2VwYXJhdG9yPWU9PmU9PT1jfHxlPT09bztjb25zdCBkZXB0aD1lPT57aWYoZS5pc1ByZWZpeCE9PXRydWUpe2UuZGVwdGg9ZS5pc0dsb2JzdGFyP0luZmluaXR5OjF9fTtjb25zdCBzY2FuPShlLHQpPT57Y29uc3Qgcj10fHx7fTtjb25zdCBDPWUubGVuZ3RoLTE7Y29uc3QgeT1yLnBhcnRzPT09dHJ1ZXx8ci5zY2FuVG9FbmQ9PT10cnVlO2NvbnN0IGQ9W107Y29uc3QgeD1bXTtjb25zdCBiPVtdO2xldCBTPWU7bGV0IEg9LTE7bGV0IHY9MDtsZXQgJD0wO2xldCBtPWZhbHNlO2xldCBUPWZhbHNlO2xldCBMPWZhbHNlO2xldCBPPWZhbHNlO2xldCB3PWZhbHNlO2xldCBOPWZhbHNlO2xldCBrPWZhbHNlO2xldCBJPWZhbHNlO2xldCBNPWZhbHNlO2xldCBQPTA7bGV0IEI7bGV0IEc7bGV0IEQ9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2NvbnN0IGVvcz0oKT0+SD49Qztjb25zdCBwZWVrPSgpPT5TLmNoYXJDb2RlQXQoSCsxKTtjb25zdCBhZHZhbmNlPSgpPT57Qj1HO3JldHVybiBTLmNoYXJDb2RlQXQoKytIKX07d2hpbGUoSDxDKXtHPWFkdmFuY2UoKTtsZXQgZTtpZihHPT09byl7az1ELmJhY2tzbGFzaGVzPXRydWU7Rz1hZHZhbmNlKCk7aWYoRz09PXApe049dHJ1ZX1jb250aW51ZX1pZihOPT09dHJ1ZXx8Rz09PXApe1ArKzt3aGlsZShlb3MoKSE9PXRydWUmJihHPWFkdmFuY2UoKSkpe2lmKEc9PT1vKXtrPUQuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoRz09PXApe1ArKztjb250aW51ZX1pZihOIT09dHJ1ZSYmRz09PWEmJihHPWFkdmFuY2UoKSk9PT1hKXttPUQuaXNCcmFjZT10cnVlO0w9RC5pc0dsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKE4hPT10cnVlJiZHPT09aSl7bT1ELmlzQnJhY2U9dHJ1ZTtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2lmKHk9PT10cnVlKXtjb250aW51ZX1icmVha31pZihHPT09aCl7UC0tO2lmKFA9PT0wKXtOPWZhbHNlO209RC5pc0JyYWNlPXRydWU7TT10cnVlO2JyZWFrfX19aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKEc9PT1jKXtkLnB1c2goSCk7eC5wdXNoKEQpO0Q9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2lmKE09PT10cnVlKWNvbnRpbnVlO2lmKEI9PT1hJiZIPT09disxKXt2Kz0yO2NvbnRpbnVlfSQ9SCsxO2NvbnRpbnVlfWlmKHIubm9leHQhPT10cnVlKXtjb25zdCBlPUc9PT1SfHxHPT09c3x8Rz09PXV8fEc9PT1ffHxHPT09bDtpZihlPT09dHJ1ZSYmcGVlaygpPT09Zil7TD1ELmlzR2xvYj10cnVlO089RC5pc0V4dGdsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe3doaWxlKGVvcygpIT09dHJ1ZSYmKEc9YWR2YW5jZSgpKSl7aWYoRz09PW8pe2s9RC5iYWNrc2xhc2hlcz10cnVlO0c9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKEc9PT1nKXtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2JyZWFrfX1jb250aW51ZX1icmVha319aWYoRz09PXUpe2lmKEI9PT11KXc9RC5pc0dsb2JzdGFyPXRydWU7TD1ELmlzR2xvYj10cnVlO009dHJ1ZTtpZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoRz09PV8pe0w9RC5pc0dsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKEc9PT1BKXt3aGlsZShlb3MoKSE9PXRydWUmJihlPWFkdmFuY2UoKSkpe2lmKGU9PT1vKXtrPUQuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoZT09PUUpe1Q9RC5pc0JyYWNrZXQ9dHJ1ZTtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2JyZWFrfX1pZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoci5ub25lZ2F0ZSE9PXRydWUmJkc9PT1sJiZIPT09dil7ST1ELm5lZ2F0ZWQ9dHJ1ZTt2Kys7Y29udGludWV9aWYoci5ub3BhcmVuIT09dHJ1ZSYmRz09PWYpe0w9RC5pc0dsb2I9dHJ1ZTtpZih5PT09dHJ1ZSl7d2hpbGUoZW9zKCkhPT10cnVlJiYoRz1hZHZhbmNlKCkpKXtpZihHPT09Zil7az1ELmJhY2tzbGFzaGVzPXRydWU7Rz1hZHZhbmNlKCk7Y29udGludWV9aWYoRz09PWcpe009dHJ1ZTticmVha319Y29udGludWV9YnJlYWt9aWYoTD09PXRydWUpe009dHJ1ZTtpZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9fWlmKHIubm9leHQ9PT10cnVlKXtPPWZhbHNlO0w9ZmFsc2V9bGV0IFU9UztsZXQgSz1cIlwiO2xldCBGPVwiXCI7aWYodj4wKXtLPVMuc2xpY2UoMCx2KTtTPVMuc2xpY2Uodik7JC09dn1pZihVJiZMPT09dHJ1ZSYmJD4wKXtVPVMuc2xpY2UoMCwkKTtGPVMuc2xpY2UoJCl9ZWxzZSBpZihMPT09dHJ1ZSl7VT1cIlwiO0Y9U31lbHNle1U9U31pZihVJiZVIT09XCJcIiYmVSE9PVwiL1wiJiZVIT09Uyl7aWYoaXNQYXRoU2VwYXJhdG9yKFUuY2hhckNvZGVBdChVLmxlbmd0aC0xKSkpe1U9VS5zbGljZSgwLC0xKX19aWYoci51bmVzY2FwZT09PXRydWUpe2lmKEYpRj1uLnJlbW92ZUJhY2tzbGFzaGVzKEYpO2lmKFUmJms9PT10cnVlKXtVPW4ucmVtb3ZlQmFja3NsYXNoZXMoVSl9fWNvbnN0IFE9e3ByZWZpeDpLLGlucHV0OmUsc3RhcnQ6dixiYXNlOlUsZ2xvYjpGLGlzQnJhY2U6bSxpc0JyYWNrZXQ6VCxpc0dsb2I6TCxpc0V4dGdsb2I6Tyxpc0dsb2JzdGFyOncsbmVnYXRlZDpJfTtpZihyLnRva2Vucz09PXRydWUpe1EubWF4RGVwdGg9MDtpZighaXNQYXRoU2VwYXJhdG9yKEcpKXt4LnB1c2goRCl9US50b2tlbnM9eH1pZihyLnBhcnRzPT09dHJ1ZXx8ci50b2tlbnM9PT10cnVlKXtsZXQgdDtmb3IobGV0IG49MDtuPGQubGVuZ3RoO24rKyl7Y29uc3QgdT10P3QrMTp2O2NvbnN0IHM9ZFtuXTtjb25zdCBvPWUuc2xpY2UodSxzKTtpZihyLnRva2Vucyl7aWYobj09PTAmJnYhPT0wKXt4W25dLmlzUHJlZml4PXRydWU7eFtuXS52YWx1ZT1LfWVsc2V7eFtuXS52YWx1ZT1vfWRlcHRoKHhbbl0pO1EubWF4RGVwdGgrPXhbbl0uZGVwdGh9aWYobiE9PTB8fG8hPT1cIlwiKXtiLnB1c2gobyl9dD1zfWlmKHQmJnQrMTxlLmxlbmd0aCl7Y29uc3Qgbj1lLnNsaWNlKHQrMSk7Yi5wdXNoKG4pO2lmKHIudG9rZW5zKXt4W3gubGVuZ3RoLTFdLnZhbHVlPW47ZGVwdGgoeFt4Lmxlbmd0aC0xXSk7US5tYXhEZXB0aCs9eFt4Lmxlbmd0aC0xXS5kZXB0aH19US5zbGFzaGVzPWQ7US5wYXJ0cz1ifXJldHVybiBRfTtlLmV4cG9ydHM9c2Nhbn0sNTEzOihlLHQscik9Pntjb25zdCBuPXIoMTcpO2NvbnN0IHU9cHJvY2Vzcy5wbGF0Zm9ybT09PVwid2luMzJcIjtjb25zdHtSRUdFWF9CQUNLU0xBU0g6cyxSRUdFWF9SRU1PVkVfQkFDS1NMQVNIOm8sUkVHRVhfU1BFQ0lBTF9DSEFSUzppLFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMOmF9PXIoMzU2KTt0LmlzT2JqZWN0PWU9PmUhPT1udWxsJiZ0eXBlb2YgZT09PVwib2JqZWN0XCImJiFBcnJheS5pc0FycmF5KGUpO3QuaGFzUmVnZXhDaGFycz1lPT5pLnRlc3QoZSk7dC5pc1JlZ2V4Q2hhcj1lPT5lLmxlbmd0aD09PTEmJnQuaGFzUmVnZXhDaGFycyhlKTt0LmVzY2FwZVJlZ2V4PWU9PmUucmVwbGFjZShhLFwiXFxcXCQxXCIpO3QudG9Qb3NpeFNsYXNoZXM9ZT0+ZS5yZXBsYWNlKHMsXCIvXCIpO3QucmVtb3ZlQmFja3NsYXNoZXM9ZT0+ZS5yZXBsYWNlKG8sKGU9PmU9PT1cIlxcXFxcIj9cIlwiOmUpKTt0LnN1cHBvcnRzTG9va2JlaGluZHM9KCk9Pntjb25zdCBlPXByb2Nlc3MudmVyc2lvbi5zbGljZSgxKS5zcGxpdChcIi5cIikubWFwKE51bWJlcik7aWYoZS5sZW5ndGg9PT0zJiZlWzBdPj05fHxlWzBdPT09OCYmZVsxXT49MTApe3JldHVybiB0cnVlfXJldHVybiBmYWxzZX07dC5pc1dpbmRvd3M9ZT0+e2lmKGUmJnR5cGVvZiBlLndpbmRvd3M9PT1cImJvb2xlYW5cIil7cmV0dXJuIGUud2luZG93c31yZXR1cm4gdT09PXRydWV8fG4uc2VwPT09XCJcXFxcXCJ9O3QuZXNjYXBlTGFzdD0oZSxyLG4pPT57Y29uc3QgdT1lLmxhc3RJbmRleE9mKHIsbik7aWYodT09PS0xKXJldHVybiBlO2lmKGVbdS0xXT09PVwiXFxcXFwiKXJldHVybiB0LmVzY2FwZUxhc3QoZSxyLHUtMSk7cmV0dXJuYCR7ZS5zbGljZSgwLHUpfVxcXFwke2Uuc2xpY2UodSl9YH07dC5yZW1vdmVQcmVmaXg9KGUsdD17fSk9PntsZXQgcj1lO2lmKHIuc3RhcnRzV2l0aChcIi4vXCIpKXtyPXIuc2xpY2UoMik7dC5wcmVmaXg9XCIuL1wifXJldHVybiByfTt0LndyYXBPdXRwdXQ9KGUsdD17fSxyPXt9KT0+e2NvbnN0IG49ci5jb250YWlucz9cIlwiOlwiXlwiO2NvbnN0IHU9ci5jb250YWlucz9cIlwiOlwiJFwiO2xldCBzPWAke259KD86JHtlfSkke3V9YDtpZih0Lm5lZ2F0ZWQ9PT10cnVlKXtzPWAoPzpeKD8hJHtzfSkuKiQpYH1yZXR1cm4gc319LDQ5MjooZSx0LHIpPT57XG4vKiFcbiAqIHRvLXJlZ2V4LXJhbmdlIDxodHRwczovL2dpdGh1Yi5jb20vbWljcm9tYXRjaC90by1yZWdleC1yYW5nZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmNvbnN0IG49cigzNTcpO2NvbnN0IHRvUmVnZXhSYW5nZT0oZSx0LHIpPT57aWYobihlKT09PWZhbHNlKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwidG9SZWdleFJhbmdlOiBleHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYSBudW1iZXJcIil9aWYodD09PXZvaWQgMHx8ZT09PXQpe3JldHVybiBTdHJpbmcoZSl9aWYobih0KT09PWZhbHNlKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwidG9SZWdleFJhbmdlOiBleHBlY3RlZCB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgbnVtYmVyLlwiKX1sZXQgdT17cmVsYXhaZXJvczp0cnVlLC4uLnJ9O2lmKHR5cGVvZiB1LnN0cmljdFplcm9zPT09XCJib29sZWFuXCIpe3UucmVsYXhaZXJvcz11LnN0cmljdFplcm9zPT09ZmFsc2V9bGV0IHM9U3RyaW5nKHUucmVsYXhaZXJvcyk7bGV0IG89U3RyaW5nKHUuc2hvcnRoYW5kKTtsZXQgaT1TdHJpbmcodS5jYXB0dXJlKTtsZXQgYT1TdHJpbmcodS53cmFwKTtsZXQgbD1lK1wiOlwiK3QrXCI9XCIrcytvK2krYTtpZih0b1JlZ2V4UmFuZ2UuY2FjaGUuaGFzT3duUHJvcGVydHkobCkpe3JldHVybiB0b1JlZ2V4UmFuZ2UuY2FjaGVbbF0ucmVzdWx0fWxldCBjPU1hdGgubWluKGUsdCk7bGV0IHA9TWF0aC5tYXgoZSx0KTtpZihNYXRoLmFicyhjLXApPT09MSl7bGV0IHI9ZStcInxcIit0O2lmKHUuY2FwdHVyZSl7cmV0dXJuYCgke3J9KWB9aWYodS53cmFwPT09ZmFsc2Upe3JldHVybiByfXJldHVybmAoPzoke3J9KWB9bGV0IGY9aGFzUGFkZGluZyhlKXx8aGFzUGFkZGluZyh0KTtsZXQgQT17bWluOmUsbWF4OnQsYTpjLGI6cH07bGV0IFI9W107bGV0IF89W107aWYoZil7QS5pc1BhZGRlZD1mO0EubWF4TGVuPVN0cmluZyhBLm1heCkubGVuZ3RofWlmKGM8MCl7bGV0IGU9cDwwP01hdGguYWJzKHApOjE7Xz1zcGxpdFRvUGF0dGVybnMoZSxNYXRoLmFicyhjKSxBLHUpO2M9QS5hPTB9aWYocD49MCl7Uj1zcGxpdFRvUGF0dGVybnMoYyxwLEEsdSl9QS5uZWdhdGl2ZXM9XztBLnBvc2l0aXZlcz1SO0EucmVzdWx0PWNvbGxhdGVQYXR0ZXJucyhfLFIsdSk7aWYodS5jYXB0dXJlPT09dHJ1ZSl7QS5yZXN1bHQ9YCgke0EucmVzdWx0fSlgfWVsc2UgaWYodS53cmFwIT09ZmFsc2UmJlIubGVuZ3RoK18ubGVuZ3RoPjEpe0EucmVzdWx0PWAoPzoke0EucmVzdWx0fSlgfXRvUmVnZXhSYW5nZS5jYWNoZVtsXT1BO3JldHVybiBBLnJlc3VsdH07ZnVuY3Rpb24gY29sbGF0ZVBhdHRlcm5zKGUsdCxyKXtsZXQgbj1maWx0ZXJQYXR0ZXJucyhlLHQsXCItXCIsZmFsc2Uscil8fFtdO2xldCB1PWZpbHRlclBhdHRlcm5zKHQsZSxcIlwiLGZhbHNlLHIpfHxbXTtsZXQgcz1maWx0ZXJQYXR0ZXJucyhlLHQsXCItP1wiLHRydWUscil8fFtdO2xldCBvPW4uY29uY2F0KHMpLmNvbmNhdCh1KTtyZXR1cm4gby5qb2luKFwifFwiKX1mdW5jdGlvbiBzcGxpdFRvUmFuZ2VzKGUsdCl7bGV0IHI9MTtsZXQgbj0xO2xldCB1PWNvdW50TmluZXMoZSxyKTtsZXQgcz1uZXcgU2V0KFt0XSk7d2hpbGUoZTw9dSYmdTw9dCl7cy5hZGQodSk7cis9MTt1PWNvdW50TmluZXMoZSxyKX11PWNvdW50WmVyb3ModCsxLG4pLTE7d2hpbGUoZTx1JiZ1PD10KXtzLmFkZCh1KTtuKz0xO3U9Y291bnRaZXJvcyh0KzEsbiktMX1zPVsuLi5zXTtzLnNvcnQoY29tcGFyZSk7cmV0dXJuIHN9ZnVuY3Rpb24gcmFuZ2VUb1BhdHRlcm4oZSx0LHIpe2lmKGU9PT10KXtyZXR1cm57cGF0dGVybjplLGNvdW50OltdLGRpZ2l0czowfX1sZXQgbj16aXAoZSx0KTtsZXQgdT1uLmxlbmd0aDtsZXQgcz1cIlwiO2xldCBvPTA7Zm9yKGxldCBlPTA7ZTx1O2UrKyl7bGV0W3QsdV09bltlXTtpZih0PT09dSl7cys9dH1lbHNlIGlmKHQhPT1cIjBcInx8dSE9PVwiOVwiKXtzKz10b0NoYXJhY3RlckNsYXNzKHQsdSxyKX1lbHNle28rK319aWYobyl7cys9ci5zaG9ydGhhbmQ9PT10cnVlP1wiXFxcXGRcIjpcIlswLTldXCJ9cmV0dXJue3BhdHRlcm46cyxjb3VudDpbb10sZGlnaXRzOnV9fWZ1bmN0aW9uIHNwbGl0VG9QYXR0ZXJucyhlLHQscixuKXtsZXQgdT1zcGxpdFRvUmFuZ2VzKGUsdCk7bGV0IHM9W107bGV0IG89ZTtsZXQgaTtmb3IobGV0IGU9MDtlPHUubGVuZ3RoO2UrKyl7bGV0IHQ9dVtlXTtsZXQgYT1yYW5nZVRvUGF0dGVybihTdHJpbmcobyksU3RyaW5nKHQpLG4pO2xldCBsPVwiXCI7aWYoIXIuaXNQYWRkZWQmJmkmJmkucGF0dGVybj09PWEucGF0dGVybil7aWYoaS5jb3VudC5sZW5ndGg+MSl7aS5jb3VudC5wb3AoKX1pLmNvdW50LnB1c2goYS5jb3VudFswXSk7aS5zdHJpbmc9aS5wYXR0ZXJuK3RvUXVhbnRpZmllcihpLmNvdW50KTtvPXQrMTtjb250aW51ZX1pZihyLmlzUGFkZGVkKXtsPXBhZFplcm9zKHQscixuKX1hLnN0cmluZz1sK2EucGF0dGVybit0b1F1YW50aWZpZXIoYS5jb3VudCk7cy5wdXNoKGEpO289dCsxO2k9YX1yZXR1cm4gc31mdW5jdGlvbiBmaWx0ZXJQYXR0ZXJucyhlLHQscixuLHUpe2xldCBzPVtdO2ZvcihsZXQgdSBvZiBlKXtsZXR7c3RyaW5nOmV9PXU7aWYoIW4mJiFjb250YWlucyh0LFwic3RyaW5nXCIsZSkpe3MucHVzaChyK2UpfWlmKG4mJmNvbnRhaW5zKHQsXCJzdHJpbmdcIixlKSl7cy5wdXNoKHIrZSl9fXJldHVybiBzfWZ1bmN0aW9uIHppcChlLHQpe2xldCByPVtdO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXIucHVzaChbZVtuXSx0W25dXSk7cmV0dXJuIHJ9ZnVuY3Rpb24gY29tcGFyZShlLHQpe3JldHVybiBlPnQ/MTp0PmU/LTE6MH1mdW5jdGlvbiBjb250YWlucyhlLHQscil7cmV0dXJuIGUuc29tZSgoZT0+ZVt0XT09PXIpKX1mdW5jdGlvbiBjb3VudE5pbmVzKGUsdCl7cmV0dXJuIE51bWJlcihTdHJpbmcoZSkuc2xpY2UoMCwtdCkrXCI5XCIucmVwZWF0KHQpKX1mdW5jdGlvbiBjb3VudFplcm9zKGUsdCl7cmV0dXJuIGUtZSVNYXRoLnBvdygxMCx0KX1mdW5jdGlvbiB0b1F1YW50aWZpZXIoZSl7bGV0W3Q9MCxyPVwiXCJdPWU7aWYocnx8dD4xKXtyZXR1cm5geyR7dCsocj9cIixcIityOlwiXCIpfX1gfXJldHVyblwiXCJ9ZnVuY3Rpb24gdG9DaGFyYWN0ZXJDbGFzcyhlLHQscil7cmV0dXJuYFske2V9JHt0LWU9PT0xP1wiXCI6XCItXCJ9JHt0fV1gfWZ1bmN0aW9uIGhhc1BhZGRpbmcoZSl7cmV0dXJuL14tPygwKylcXGQvLnRlc3QoZSl9ZnVuY3Rpb24gcGFkWmVyb3MoZSx0LHIpe2lmKCF0LmlzUGFkZGVkKXtyZXR1cm4gZX1sZXQgbj1NYXRoLmFicyh0Lm1heExlbi1TdHJpbmcoZSkubGVuZ3RoKTtsZXQgdT1yLnJlbGF4WmVyb3MhPT1mYWxzZTtzd2l0Y2gobil7Y2FzZSAwOnJldHVyblwiXCI7Y2FzZSAxOnJldHVybiB1P1wiMD9cIjpcIjBcIjtjYXNlIDI6cmV0dXJuIHU/XCIwezAsMn1cIjpcIjAwXCI7ZGVmYXVsdDp7cmV0dXJuIHU/YDB7MCwke259fWA6YDB7JHtufX1gfX19dG9SZWdleFJhbmdlLmNhY2hlPXt9O3RvUmVnZXhSYW5nZS5jbGVhckNhY2hlPSgpPT50b1JlZ2V4UmFuZ2UuY2FjaGU9e307ZS5leHBvcnRzPXRvUmVnZXhSYW5nZX0sMTc6ZT0+e2UuZXhwb3J0cz1yZXF1aXJlKFwicGF0aFwiKX0sODM3OmU9PntlLmV4cG9ydHM9cmVxdWlyZShcInV0aWxcIil9fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgdT10W3JdPXtleHBvcnRzOnt9fTt2YXIgcz10cnVlO3RyeXtlW3JdKHUsdS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO3M9ZmFsc2V9ZmluYWxseXtpZihzKWRlbGV0ZSB0W3JdfXJldHVybiB1LmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oOTcxKTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOlsiZSIsInQiLCJyIiwibiIsInUiLCJzIiwibyIsImJyYWNlcyIsIkFycmF5IiwiaXNBcnJheSIsImNyZWF0ZSIsInB1c2giLCJjb25jYXQiLCJleHBhbmQiLCJub2R1cGVzIiwiU2V0IiwicGFyc2UiLCJzdHJpbmdpZnkiLCJjb21waWxlIiwibm9lbXB0eSIsImZpbHRlciIsIkJvb2xlYW4iLCJsZW5ndGgiLCJleHBvcnRzIiwid2FsayIsImlzSW52YWxpZEJyYWNlIiwiaW52YWxpZCIsImVzY2FwZUludmFsaWQiLCJpIiwiYSIsImwiLCJpc09wZW4iLCJ2YWx1ZSIsImlzQ2xvc2UiLCJ0eXBlIiwicHJldiIsIm5vZGVzIiwicmFuZ2VzIiwicmVkdWNlIiwid3JhcCIsInRvUmVnZXgiLCJNQVhfTEVOR1RIIiwiQ0hBUl8wIiwiQ0hBUl85IiwiQ0hBUl9VUFBFUkNBU0VfQSIsIkNIQVJfTE9XRVJDQVNFX0EiLCJDSEFSX1VQUEVSQ0FTRV9aIiwiQ0hBUl9MT1dFUkNBU0VfWiIsIkNIQVJfTEVGVF9QQVJFTlRIRVNFUyIsIkNIQVJfUklHSFRfUEFSRU5USEVTRVMiLCJDSEFSX0FTVEVSSVNLIiwiQ0hBUl9BTVBFUlNBTkQiLCJDSEFSX0FUIiwiQ0hBUl9CQUNLU0xBU0giLCJDSEFSX0JBQ0tUSUNLIiwiQ0hBUl9DQVJSSUFHRV9SRVRVUk4iLCJDSEFSX0NJUkNVTUZMRVhfQUNDRU5UIiwiQ0hBUl9DT0xPTiIsIkNIQVJfQ09NTUEiLCJDSEFSX0RPTExBUiIsIkNIQVJfRE9UIiwiQ0hBUl9ET1VCTEVfUVVPVEUiLCJDSEFSX0VRVUFMIiwiQ0hBUl9FWENMQU1BVElPTl9NQVJLIiwiQ0hBUl9GT1JNX0ZFRUQiLCJDSEFSX0ZPUldBUkRfU0xBU0giLCJDSEFSX0hBU0giLCJDSEFSX0hZUEhFTl9NSU5VUyIsIkNIQVJfTEVGVF9BTkdMRV9CUkFDS0VUIiwiQ0hBUl9MRUZUX0NVUkxZX0JSQUNFIiwiQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUIiwiQ0hBUl9MSU5FX0ZFRUQiLCJDSEFSX05PX0JSRUFLX1NQQUNFIiwiQ0hBUl9QRVJDRU5UIiwiQ0hBUl9QTFVTIiwiQ0hBUl9RVUVTVElPTl9NQVJLIiwiQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUIiwiQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRSIsIkNIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQiLCJDSEFSX1NFTUlDT0xPTiIsIkNIQVJfU0lOR0xFX1FVT1RFIiwiQ0hBUl9TUEFDRSIsIkNIQVJfVEFCIiwiQ0hBUl9VTkRFUlNDT1JFIiwiQ0hBUl9WRVJUSUNBTF9MSU5FIiwiQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0UiLCJhcHBlbmQiLCJmbGF0dGVuIiwibWFwIiwicmFuZ2VMaW1pdCIsInF1ZXVlIiwicGFyZW50IiwiZG9sbGFyIiwicG9wIiwiZXhjZWVkc0xpbWl0Iiwic3RlcCIsIlJhbmdlRXJyb3IiLCJlbmNsb3NlQnJhY2UiLCJjIiwicCIsImYiLCJBIiwiUiIsIl8iLCJoIiwiZyIsIkUiLCJUeXBlRXJyb3IiLCJDIiwibWF4TGVuZ3RoIiwiTWF0aCIsIm1pbiIsIlN5bnRheEVycm9yIiwieSIsImlucHV0IiwiZCIsIngiLCJiIiwiUyIsIkgiLCJ2IiwiJCIsIm0iLCJUIiwiYWR2YW5jZSIsImtlZXBFc2NhcGluZyIsImtlZXBRdW90ZXMiLCJzbGljZSIsIm9wZW4iLCJjbG9zZSIsImRlcHRoIiwiY29tbWFzIiwic2hpZnQiLCJyYW5nZSIsImFyZ3MiLCJmb3JFYWNoIiwiaW5kZXhPZiIsInNwbGljZSIsImlzT3Blbk9yQ2xvc2UiLCJpc0ludGVnZXIiLCJOdW1iZXIiLCJ0cmltIiwiZmluZCIsImVzY2FwZU5vZGUiLCJlc2NhcGVkIiwiZmxhdCIsImlzT2JqZWN0IiwidHJhbnNmb3JtIiwiU3RyaW5nIiwiaXNWYWxpZFZhbHVlIiwiaXNOdW1iZXIiLCJ6ZXJvcyIsInBhZCIsInBhZFN0YXJ0IiwidG9NYXhMZW4iLCJ0b1NlcXVlbmNlIiwibmVnYXRpdmVzIiwic29ydCIsInBvc2l0aXZlcyIsImNhcHR1cmUiLCJqb2luIiwidG9SYW5nZSIsImZyb21DaGFyQ29kZSIsInJhbmdlRXJyb3IiLCJpbnNwZWN0IiwiaW52YWxpZFJhbmdlIiwic3RyaWN0UmFuZ2VzIiwiaW52YWxpZFN0ZXAiLCJmaWxsTnVtYmVycyIsIm1heCIsImFicyIsImZpbGxMZXR0ZXJzIiwiY2hhckNvZGVBdCIsIm9wdGlvbnMiLCJmaWxsIiwiaXNGaW5pdGUiLCJpc0VtcHR5U3RyaW5nIiwibWljcm9tYXRjaCIsIm9uUmVzdWx0IiwiYWRkIiwib3V0cHV0Iiwic3RhdGUiLCJuZWdhdGVkIiwibmVnYXRlZEV4dGdsb2IiLCJpc01hdGNoIiwiZGVsZXRlIiwiaGFzIiwiZmFpbGdsb2IiLCJFcnJvciIsIm5vbnVsbCIsIm51bGxnbG9iIiwidW5lc2NhcGUiLCJyZXBsYWNlIiwibWF0Y2giLCJtYXRjaGVyIiwiYW55Iiwibm90IiwiaW5jbHVkZXMiLCJjb250YWlucyIsInNvbWUiLCJzdGFydHNXaXRoIiwibWF0Y2hLZXlzIiwiT2JqZWN0Iiwia2V5cyIsImV2ZXJ5IiwiYWxsIiwiaXNXaW5kb3dzIiwibWFrZVJlIiwiZXhlYyIsInRvUG9zaXhTbGFzaGVzIiwic2NhbiIsIm5vYnJhY2UiLCJ0ZXN0IiwiYnJhY2VFeHBhbmQiLCJET1RfTElURVJBTCIsIlBMVVNfTElURVJBTCIsIlFNQVJLX0xJVEVSQUwiLCJTTEFTSF9MSVRFUkFMIiwiT05FX0NIQVIiLCJRTUFSSyIsIkVORF9BTkNIT1IiLCJET1RTX1NMQVNIIiwiTk9fRE9UIiwiTk9fRE9UUyIsIk5PX0RPVF9TTEFTSCIsIk5PX0RPVFNfU0xBU0giLCJRTUFSS19OT19ET1QiLCJTVEFSIiwiU1RBUlRfQU5DSE9SIiwiYWxudW0iLCJhbHBoYSIsImFzY2lpIiwiYmxhbmsiLCJjbnRybCIsImRpZ2l0IiwiZ3JhcGgiLCJsb3dlciIsInByaW50IiwicHVuY3QiLCJzcGFjZSIsInVwcGVyIiwid29yZCIsInhkaWdpdCIsIlBPU0lYX1JFR0VYX1NPVVJDRSIsIlJFR0VYX0JBQ0tTTEFTSCIsIlJFR0VYX05PTl9TUEVDSUFMX0NIQVJTIiwiUkVHRVhfU1BFQ0lBTF9DSEFSUyIsIlJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRiIsIlJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMIiwiUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSCIsIlJFUExBQ0VNRU5UUyIsIkNIQVJfQkFDS1dBUkRfU0xBU0giLCJDSEFSX0dSQVZFX0FDQ0VOVCIsIlNFUCIsInNlcCIsImV4dGdsb2JDaGFycyIsImdsb2JDaGFycyIsImV4cGFuZFJhbmdlIiwiUmVnRXhwIiwiZXNjYXBlUmVnZXgiLCJzeW50YXhFcnJvciIsInByZXBlbmQiLCJnbG9ic3RhciIsImRvdCIsIkwiLCJPIiwidyIsImJhc2giLCJub2V4dCIsIm5vZXh0Z2xvYiIsIk4iLCJpbmRleCIsInN0YXJ0IiwiY29uc3VtZWQiLCJwcmVmaXgiLCJiYWNrdHJhY2siLCJicmFja2V0cyIsInBhcmVucyIsInF1b3RlcyIsInRva2VucyIsInJlbW92ZVByZWZpeCIsImsiLCJJIiwiTSIsIlAiLCJCIiwiZW9zIiwiRyIsInBlZWsiLCJEIiwicmVtYWluaW5nIiwiY29uc3VtZSIsIm5lZ2F0ZSIsImluY3JlbWVudCIsImRlY3JlbWVudCIsImV4dGdsb2IiLCJpbm5lciIsImV4dGdsb2JPcGVuIiwiY29uZGl0aW9ucyIsImV4dGdsb2JDbG9zZSIsImZhc3RwYXRocyIsInJlcGVhdCIsIndyYXBPdXRwdXQiLCJwb3NpeCIsImxhc3RJbmRleE9mIiwic3RyaWN0QnJhY2tldHMiLCJub2JyYWNrZXQiLCJsaXRlcmFsQnJhY2tldHMiLCJoYXNSZWdleENoYXJzIiwib3V0cHV0SW5kZXgiLCJ0b2tlbnNJbmRleCIsImRvdHMiLCJ1bnNoaWZ0IiwiY29tbWEiLCJzdXBwb3J0c0xvb2tiZWhpbmRzIiwibm9uZWdhdGUiLCJyZWdleCIsInN0YXIiLCJub2dsb2JzdGFyIiwic3RyaWN0U2xhc2hlcyIsImVzY2FwZUxhc3QiLCJzdWZmaXgiLCJwaWNvbWF0Y2giLCJhcnJheU1hdGNoZXIiLCJjb21waWxlUmUiLCJpc0lnbm9yZWQiLCJpZ25vcmUiLCJvbk1hdGNoIiwiZ2xvYiIsIm9uSWdub3JlIiwiZm9ybWF0IiwibWF0Y2hCYXNlIiwiYmFzZW5hbWUiLCJ1bmRlZmluZWQiLCJmbGFncyIsIm5vY2FzZSIsImRlYnVnIiwiY29uc3RhbnRzIiwiaXNQYXRoU2VwYXJhdG9yIiwiaXNQcmVmaXgiLCJpc0dsb2JzdGFyIiwiSW5maW5pdHkiLCJwYXJ0cyIsInNjYW5Ub0VuZCIsImlzR2xvYiIsImJhY2tzbGFzaGVzIiwiaXNCcmFjZSIsImlzRXh0Z2xvYiIsImlzQnJhY2tldCIsIm5vcGFyZW4iLCJVIiwiSyIsIkYiLCJyZW1vdmVCYWNrc2xhc2hlcyIsIlEiLCJiYXNlIiwibWF4RGVwdGgiLCJzbGFzaGVzIiwicHJvY2VzcyIsInBsYXRmb3JtIiwiaXNSZWdleENoYXIiLCJ2ZXJzaW9uIiwic3BsaXQiLCJ3aW5kb3dzIiwidG9SZWdleFJhbmdlIiwicmVsYXhaZXJvcyIsInN0cmljdFplcm9zIiwic2hvcnRoYW5kIiwiY2FjaGUiLCJoYXNPd25Qcm9wZXJ0eSIsInJlc3VsdCIsImhhc1BhZGRpbmciLCJpc1BhZGRlZCIsIm1heExlbiIsInNwbGl0VG9QYXR0ZXJucyIsImNvbGxhdGVQYXR0ZXJucyIsImZpbHRlclBhdHRlcm5zIiwic3BsaXRUb1JhbmdlcyIsImNvdW50TmluZXMiLCJjb3VudFplcm9zIiwiY29tcGFyZSIsInJhbmdlVG9QYXR0ZXJuIiwicGF0dGVybiIsImNvdW50IiwiZGlnaXRzIiwiemlwIiwidG9DaGFyYWN0ZXJDbGFzcyIsInN0cmluZyIsInRvUXVhbnRpZmllciIsInBhZFplcm9zIiwicG93IiwiY2xlYXJDYWNoZSIsInJlcXVpcmUiLCJfX25jY3dwY2tfcmVxdWlyZV9fIiwiYWIiLCJfX2Rpcm5hbWUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/micromatch/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/path-browserify/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-browserify/index.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n\n(function() {\n    \"use strict\";\n    var e = {\n        114: function(e) {\n            function assertPath(e) {\n                if (typeof e !== \"string\") {\n                    throw new TypeError(\"Path must be a string. Received \" + JSON.stringify(e));\n                }\n            }\n            function normalizeStringPosix(e, r) {\n                var t = \"\";\n                var i = 0;\n                var n = -1;\n                var a = 0;\n                var f;\n                for(var l = 0; l <= e.length; ++l){\n                    if (l < e.length) f = e.charCodeAt(l);\n                    else if (f === 47) break;\n                    else f = 47;\n                    if (f === 47) {\n                        if (n === l - 1 || a === 1) {} else if (n !== l - 1 && a === 2) {\n                            if (t.length < 2 || i !== 2 || t.charCodeAt(t.length - 1) !== 46 || t.charCodeAt(t.length - 2) !== 46) {\n                                if (t.length > 2) {\n                                    var s = t.lastIndexOf(\"/\");\n                                    if (s !== t.length - 1) {\n                                        if (s === -1) {\n                                            t = \"\";\n                                            i = 0;\n                                        } else {\n                                            t = t.slice(0, s);\n                                            i = t.length - 1 - t.lastIndexOf(\"/\");\n                                        }\n                                        n = l;\n                                        a = 0;\n                                        continue;\n                                    }\n                                } else if (t.length === 2 || t.length === 1) {\n                                    t = \"\";\n                                    i = 0;\n                                    n = l;\n                                    a = 0;\n                                    continue;\n                                }\n                            }\n                            if (r) {\n                                if (t.length > 0) t += \"/..\";\n                                else t = \"..\";\n                                i = 2;\n                            }\n                        } else {\n                            if (t.length > 0) t += \"/\" + e.slice(n + 1, l);\n                            else t = e.slice(n + 1, l);\n                            i = l - n - 1;\n                        }\n                        n = l;\n                        a = 0;\n                    } else if (f === 46 && a !== -1) {\n                        ++a;\n                    } else {\n                        a = -1;\n                    }\n                }\n                return t;\n            }\n            function _format(e, r) {\n                var t = r.dir || r.root;\n                var i = r.base || (r.name || \"\") + (r.ext || \"\");\n                if (!t) {\n                    return i;\n                }\n                if (t === r.root) {\n                    return t + i;\n                }\n                return t + e + i;\n            }\n            var r = {\n                resolve: function resolve() {\n                    var e = \"\";\n                    var r = false;\n                    var t;\n                    for(var i = arguments.length - 1; i >= -1 && !r; i--){\n                        var n;\n                        if (i >= 0) n = arguments[i];\n                        else {\n                            if (t === undefined) t = \"\";\n                            n = t;\n                        }\n                        assertPath(n);\n                        if (n.length === 0) {\n                            continue;\n                        }\n                        e = n + \"/\" + e;\n                        r = n.charCodeAt(0) === 47;\n                    }\n                    e = normalizeStringPosix(e, !r);\n                    if (r) {\n                        if (e.length > 0) return \"/\" + e;\n                        else return \"/\";\n                    } else if (e.length > 0) {\n                        return e;\n                    } else {\n                        return \".\";\n                    }\n                },\n                normalize: function normalize(e) {\n                    assertPath(e);\n                    if (e.length === 0) return \".\";\n                    var r = e.charCodeAt(0) === 47;\n                    var t = e.charCodeAt(e.length - 1) === 47;\n                    e = normalizeStringPosix(e, !r);\n                    if (e.length === 0 && !r) e = \".\";\n                    if (e.length > 0 && t) e += \"/\";\n                    if (r) return \"/\" + e;\n                    return e;\n                },\n                isAbsolute: function isAbsolute(e) {\n                    assertPath(e);\n                    return e.length > 0 && e.charCodeAt(0) === 47;\n                },\n                join: function join() {\n                    if (arguments.length === 0) return \".\";\n                    var e;\n                    for(var t = 0; t < arguments.length; ++t){\n                        var i = arguments[t];\n                        assertPath(i);\n                        if (i.length > 0) {\n                            if (e === undefined) e = i;\n                            else e += \"/\" + i;\n                        }\n                    }\n                    if (e === undefined) return \".\";\n                    return r.normalize(e);\n                },\n                relative: function relative(e, t) {\n                    assertPath(e);\n                    assertPath(t);\n                    if (e === t) return \"\";\n                    e = r.resolve(e);\n                    t = r.resolve(t);\n                    if (e === t) return \"\";\n                    var i = 1;\n                    for(; i < e.length; ++i){\n                        if (e.charCodeAt(i) !== 47) break;\n                    }\n                    var n = e.length;\n                    var a = n - i;\n                    var f = 1;\n                    for(; f < t.length; ++f){\n                        if (t.charCodeAt(f) !== 47) break;\n                    }\n                    var l = t.length;\n                    var s = l - f;\n                    var o = a < s ? a : s;\n                    var u = -1;\n                    var h = 0;\n                    for(; h <= o; ++h){\n                        if (h === o) {\n                            if (s > o) {\n                                if (t.charCodeAt(f + h) === 47) {\n                                    return t.slice(f + h + 1);\n                                } else if (h === 0) {\n                                    return t.slice(f + h);\n                                }\n                            } else if (a > o) {\n                                if (e.charCodeAt(i + h) === 47) {\n                                    u = h;\n                                } else if (h === 0) {\n                                    u = 0;\n                                }\n                            }\n                            break;\n                        }\n                        var c = e.charCodeAt(i + h);\n                        var v = t.charCodeAt(f + h);\n                        if (c !== v) break;\n                        else if (c === 47) u = h;\n                    }\n                    var g = \"\";\n                    for(h = i + u + 1; h <= n; ++h){\n                        if (h === n || e.charCodeAt(h) === 47) {\n                            if (g.length === 0) g += \"..\";\n                            else g += \"/..\";\n                        }\n                    }\n                    if (g.length > 0) return g + t.slice(f + u);\n                    else {\n                        f += u;\n                        if (t.charCodeAt(f) === 47) ++f;\n                        return t.slice(f);\n                    }\n                },\n                _makeLong: function _makeLong(e) {\n                    return e;\n                },\n                dirname: function dirname(e) {\n                    assertPath(e);\n                    if (e.length === 0) return \".\";\n                    var r = e.charCodeAt(0);\n                    var t = r === 47;\n                    var i = -1;\n                    var n = true;\n                    for(var a = e.length - 1; a >= 1; --a){\n                        r = e.charCodeAt(a);\n                        if (r === 47) {\n                            if (!n) {\n                                i = a;\n                                break;\n                            }\n                        } else {\n                            n = false;\n                        }\n                    }\n                    if (i === -1) return t ? \"/\" : \".\";\n                    if (t && i === 1) return \"//\";\n                    return e.slice(0, i);\n                },\n                basename: function basename(e, r) {\n                    if (r !== undefined && typeof r !== \"string\") throw new TypeError('\"ext\" argument must be a string');\n                    assertPath(e);\n                    var t = 0;\n                    var i = -1;\n                    var n = true;\n                    var a;\n                    if (r !== undefined && r.length > 0 && r.length <= e.length) {\n                        if (r.length === e.length && r === e) return \"\";\n                        var f = r.length - 1;\n                        var l = -1;\n                        for(a = e.length - 1; a >= 0; --a){\n                            var s = e.charCodeAt(a);\n                            if (s === 47) {\n                                if (!n) {\n                                    t = a + 1;\n                                    break;\n                                }\n                            } else {\n                                if (l === -1) {\n                                    n = false;\n                                    l = a + 1;\n                                }\n                                if (f >= 0) {\n                                    if (s === r.charCodeAt(f)) {\n                                        if (--f === -1) {\n                                            i = a;\n                                        }\n                                    } else {\n                                        f = -1;\n                                        i = l;\n                                    }\n                                }\n                            }\n                        }\n                        if (t === i) i = l;\n                        else if (i === -1) i = e.length;\n                        return e.slice(t, i);\n                    } else {\n                        for(a = e.length - 1; a >= 0; --a){\n                            if (e.charCodeAt(a) === 47) {\n                                if (!n) {\n                                    t = a + 1;\n                                    break;\n                                }\n                            } else if (i === -1) {\n                                n = false;\n                                i = a + 1;\n                            }\n                        }\n                        if (i === -1) return \"\";\n                        return e.slice(t, i);\n                    }\n                },\n                extname: function extname(e) {\n                    assertPath(e);\n                    var r = -1;\n                    var t = 0;\n                    var i = -1;\n                    var n = true;\n                    var a = 0;\n                    for(var f = e.length - 1; f >= 0; --f){\n                        var l = e.charCodeAt(f);\n                        if (l === 47) {\n                            if (!n) {\n                                t = f + 1;\n                                break;\n                            }\n                            continue;\n                        }\n                        if (i === -1) {\n                            n = false;\n                            i = f + 1;\n                        }\n                        if (l === 46) {\n                            if (r === -1) r = f;\n                            else if (a !== 1) a = 1;\n                        } else if (r !== -1) {\n                            a = -1;\n                        }\n                    }\n                    if (r === -1 || i === -1 || a === 0 || a === 1 && r === i - 1 && r === t + 1) {\n                        return \"\";\n                    }\n                    return e.slice(r, i);\n                },\n                format: function format(e) {\n                    if (e === null || typeof e !== \"object\") {\n                        throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof e);\n                    }\n                    return _format(\"/\", e);\n                },\n                parse: function parse(e) {\n                    assertPath(e);\n                    var r = {\n                        root: \"\",\n                        dir: \"\",\n                        base: \"\",\n                        ext: \"\",\n                        name: \"\"\n                    };\n                    if (e.length === 0) return r;\n                    var t = e.charCodeAt(0);\n                    var i = t === 47;\n                    var n;\n                    if (i) {\n                        r.root = \"/\";\n                        n = 1;\n                    } else {\n                        n = 0;\n                    }\n                    var a = -1;\n                    var f = 0;\n                    var l = -1;\n                    var s = true;\n                    var o = e.length - 1;\n                    var u = 0;\n                    for(; o >= n; --o){\n                        t = e.charCodeAt(o);\n                        if (t === 47) {\n                            if (!s) {\n                                f = o + 1;\n                                break;\n                            }\n                            continue;\n                        }\n                        if (l === -1) {\n                            s = false;\n                            l = o + 1;\n                        }\n                        if (t === 46) {\n                            if (a === -1) a = o;\n                            else if (u !== 1) u = 1;\n                        } else if (a !== -1) {\n                            u = -1;\n                        }\n                    }\n                    if (a === -1 || l === -1 || u === 0 || u === 1 && a === l - 1 && a === f + 1) {\n                        if (l !== -1) {\n                            if (f === 0 && i) r.base = r.name = e.slice(1, l);\n                            else r.base = r.name = e.slice(f, l);\n                        }\n                    } else {\n                        if (f === 0 && i) {\n                            r.name = e.slice(1, a);\n                            r.base = e.slice(1, l);\n                        } else {\n                            r.name = e.slice(f, a);\n                            r.base = e.slice(f, l);\n                        }\n                        r.ext = e.slice(a, l);\n                    }\n                    if (f > 0) r.dir = e.slice(0, f - 1);\n                    else if (i) r.dir = \"/\";\n                    return r;\n                },\n                sep: \"/\",\n                delimiter: \":\",\n                win32: null,\n                posix: null\n            };\n            r.posix = r;\n            e.exports = r;\n        }\n    };\n    var r = {};\n    function __nccwpck_require__(t) {\n        var i = r[t];\n        if (i !== undefined) {\n            return i.exports;\n        }\n        var n = r[t] = {\n            exports: {}\n        };\n        var a = true;\n        try {\n            e[t](n, n.exports, __nccwpck_require__);\n            a = false;\n        } finally{\n            if (a) delete r[t];\n        }\n        return n.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var t = __nccwpck_require__(114);\n    module.exports = t;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUM7SUFBVztJQUFhLElBQUlBLElBQUU7UUFBQyxLQUFJLFNBQVNBLENBQUM7WUFBRSxTQUFTQyxXQUFXRCxDQUFDO2dCQUFFLElBQUcsT0FBT0EsTUFBSSxVQUFTO29CQUFDLE1BQU0sSUFBSUUsVUFBVSxxQ0FBbUNDLEtBQUtDLFNBQVMsQ0FBQ0o7Z0JBQUc7WUFBQztZQUFDLFNBQVNLLHFCQUFxQkwsQ0FBQyxFQUFDTSxDQUFDO2dCQUFFLElBQUlDLElBQUU7Z0JBQUcsSUFBSUMsSUFBRTtnQkFBRSxJQUFJQyxJQUFFLENBQUM7Z0JBQUUsSUFBSUMsSUFBRTtnQkFBRSxJQUFJQztnQkFBRSxJQUFJLElBQUlDLElBQUUsR0FBRUEsS0FBR1osRUFBRWEsTUFBTSxFQUFDLEVBQUVELEVBQUU7b0JBQUMsSUFBR0EsSUFBRVosRUFBRWEsTUFBTSxFQUFDRixJQUFFWCxFQUFFYyxVQUFVLENBQUNGO3lCQUFRLElBQUdELE1BQUksSUFBRzt5QkFBV0EsSUFBRTtvQkFBRyxJQUFHQSxNQUFJLElBQUc7d0JBQUMsSUFBR0YsTUFBSUcsSUFBRSxLQUFHRixNQUFJLEdBQUUsQ0FBQyxPQUFNLElBQUdELE1BQUlHLElBQUUsS0FBR0YsTUFBSSxHQUFFOzRCQUFDLElBQUdILEVBQUVNLE1BQU0sR0FBQyxLQUFHTCxNQUFJLEtBQUdELEVBQUVPLFVBQVUsQ0FBQ1AsRUFBRU0sTUFBTSxHQUFDLE9BQUssTUFBSU4sRUFBRU8sVUFBVSxDQUFDUCxFQUFFTSxNQUFNLEdBQUMsT0FBSyxJQUFHO2dDQUFDLElBQUdOLEVBQUVNLE1BQU0sR0FBQyxHQUFFO29DQUFDLElBQUlFLElBQUVSLEVBQUVTLFdBQVcsQ0FBQztvQ0FBSyxJQUFHRCxNQUFJUixFQUFFTSxNQUFNLEdBQUMsR0FBRTt3Q0FBQyxJQUFHRSxNQUFJ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QUFFK0MsT0FBTyxHQUFDekM7UUFBQztJQUFDO0lBQUUsSUFBSUEsSUFBRSxDQUFDO0lBQUUsU0FBUzBDLG9CQUFvQnpDLENBQUM7UUFBRSxJQUFJQyxJQUFFRixDQUFDLENBQUNDLEVBQUU7UUFBQyxJQUFHQyxNQUFJa0IsV0FBVTtZQUFDLE9BQU9sQixFQUFFdUMsT0FBTztRQUFBO1FBQUMsSUFBSXRDLElBQUVILENBQUMsQ0FBQ0MsRUFBRSxHQUFDO1lBQUN3QyxTQUFRLENBQUM7UUFBQztRQUFFLElBQUlyQyxJQUFFO1FBQUssSUFBRztZQUFDVixDQUFDLENBQUNPLEVBQUUsQ0FBQ0UsR0FBRUEsRUFBRXNDLE9BQU8sRUFBQ0M7WUFBcUJ0QyxJQUFFO1FBQUssU0FBUTtZQUFDLElBQUdBLEdBQUUsT0FBT0osQ0FBQyxDQUFDQyxFQUFFO1FBQUE7UUFBQyxPQUFPRSxFQUFFc0MsT0FBTztJQUFBO0lBQUMsSUFBRyxPQUFPQyx3QkFBc0IsYUFBWUEsb0JBQW9CQyxFQUFFLEdBQUNDLFNBQVNBLEdBQUM7SUFBSSxJQUFJM0MsSUFBRXlDLG9CQUFvQjtJQUFLRyxPQUFPSixPQUFPLEdBQUN4QztBQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzPzNjZDEiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9ezExNDpmdW5jdGlvbihlKXtmdW5jdGlvbiBhc3NlcnRQYXRoKGUpe2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkoZSkpfX1mdW5jdGlvbiBub3JtYWxpemVTdHJpbmdQb3NpeChlLHIpe3ZhciB0PVwiXCI7dmFyIGk9MDt2YXIgbj0tMTt2YXIgYT0wO3ZhciBmO2Zvcih2YXIgbD0wO2w8PWUubGVuZ3RoOysrbCl7aWYobDxlLmxlbmd0aClmPWUuY2hhckNvZGVBdChsKTtlbHNlIGlmKGY9PT00NylicmVhaztlbHNlIGY9NDc7aWYoZj09PTQ3KXtpZihuPT09bC0xfHxhPT09MSl7fWVsc2UgaWYobiE9PWwtMSYmYT09PTIpe2lmKHQubGVuZ3RoPDJ8fGkhPT0yfHx0LmNoYXJDb2RlQXQodC5sZW5ndGgtMSkhPT00Nnx8dC5jaGFyQ29kZUF0KHQubGVuZ3RoLTIpIT09NDYpe2lmKHQubGVuZ3RoPjIpe3ZhciBzPXQubGFzdEluZGV4T2YoXCIvXCIpO2lmKHMhPT10Lmxlbmd0aC0xKXtpZihzPT09LTEpe3Q9XCJcIjtpPTB9ZWxzZXt0PXQuc2xpY2UoMCxzKTtpPXQubGVuZ3RoLTEtdC5sYXN0SW5kZXhPZihcIi9cIil9bj1sO2E9MDtjb250aW51ZX19ZWxzZSBpZih0Lmxlbmd0aD09PTJ8fHQubGVuZ3RoPT09MSl7dD1cIlwiO2k9MDtuPWw7YT0wO2NvbnRpbnVlfX1pZihyKXtpZih0Lmxlbmd0aD4wKXQrPVwiLy4uXCI7ZWxzZSB0PVwiLi5cIjtpPTJ9fWVsc2V7aWYodC5sZW5ndGg+MCl0Kz1cIi9cIitlLnNsaWNlKG4rMSxsKTtlbHNlIHQ9ZS5zbGljZShuKzEsbCk7aT1sLW4tMX1uPWw7YT0wfWVsc2UgaWYoZj09PTQ2JiZhIT09LTEpeysrYX1lbHNle2E9LTF9fXJldHVybiB0fWZ1bmN0aW9uIF9mb3JtYXQoZSxyKXt2YXIgdD1yLmRpcnx8ci5yb290O3ZhciBpPXIuYmFzZXx8KHIubmFtZXx8XCJcIikrKHIuZXh0fHxcIlwiKTtpZighdCl7cmV0dXJuIGl9aWYodD09PXIucm9vdCl7cmV0dXJuIHQraX1yZXR1cm4gdCtlK2l9dmFyIHI9e3Jlc29sdmU6ZnVuY3Rpb24gcmVzb2x2ZSgpe3ZhciBlPVwiXCI7dmFyIHI9ZmFsc2U7dmFyIHQ7Zm9yKHZhciBpPWFyZ3VtZW50cy5sZW5ndGgtMTtpPj0tMSYmIXI7aS0tKXt2YXIgbjtpZihpPj0wKW49YXJndW1lbnRzW2ldO2Vsc2V7aWYodD09PXVuZGVmaW5lZCl0PVwiXCI7bj10fWFzc2VydFBhdGgobik7aWYobi5sZW5ndGg9PT0wKXtjb250aW51ZX1lPW4rXCIvXCIrZTtyPW4uY2hhckNvZGVBdCgwKT09PTQ3fWU9bm9ybWFsaXplU3RyaW5nUG9zaXgoZSwhcik7aWYocil7aWYoZS5sZW5ndGg+MClyZXR1cm5cIi9cIitlO2Vsc2UgcmV0dXJuXCIvXCJ9ZWxzZSBpZihlLmxlbmd0aD4wKXtyZXR1cm4gZX1lbHNle3JldHVyblwiLlwifX0sbm9ybWFsaXplOmZ1bmN0aW9uIG5vcm1hbGl6ZShlKXthc3NlcnRQYXRoKGUpO2lmKGUubGVuZ3RoPT09MClyZXR1cm5cIi5cIjt2YXIgcj1lLmNoYXJDb2RlQXQoMCk9PT00Nzt2YXIgdD1lLmNoYXJDb2RlQXQoZS5sZW5ndGgtMSk9PT00NztlPW5vcm1hbGl6ZVN0cmluZ1Bvc2l4KGUsIXIpO2lmKGUubGVuZ3RoPT09MCYmIXIpZT1cIi5cIjtpZihlLmxlbmd0aD4wJiZ0KWUrPVwiL1wiO2lmKHIpcmV0dXJuXCIvXCIrZTtyZXR1cm4gZX0saXNBYnNvbHV0ZTpmdW5jdGlvbiBpc0Fic29sdXRlKGUpe2Fzc2VydFBhdGgoZSk7cmV0dXJuIGUubGVuZ3RoPjAmJmUuY2hhckNvZGVBdCgwKT09PTQ3fSxqb2luOmZ1bmN0aW9uIGpvaW4oKXtpZihhcmd1bWVudHMubGVuZ3RoPT09MClyZXR1cm5cIi5cIjt2YXIgZTtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7Kyt0KXt2YXIgaT1hcmd1bWVudHNbdF07YXNzZXJ0UGF0aChpKTtpZihpLmxlbmd0aD4wKXtpZihlPT09dW5kZWZpbmVkKWU9aTtlbHNlIGUrPVwiL1wiK2l9fWlmKGU9PT11bmRlZmluZWQpcmV0dXJuXCIuXCI7cmV0dXJuIHIubm9ybWFsaXplKGUpfSxyZWxhdGl2ZTpmdW5jdGlvbiByZWxhdGl2ZShlLHQpe2Fzc2VydFBhdGgoZSk7YXNzZXJ0UGF0aCh0KTtpZihlPT09dClyZXR1cm5cIlwiO2U9ci5yZXNvbHZlKGUpO3Q9ci5yZXNvbHZlKHQpO2lmKGU9PT10KXJldHVyblwiXCI7dmFyIGk9MTtmb3IoO2k8ZS5sZW5ndGg7KytpKXtpZihlLmNoYXJDb2RlQXQoaSkhPT00NylicmVha312YXIgbj1lLmxlbmd0aDt2YXIgYT1uLWk7dmFyIGY9MTtmb3IoO2Y8dC5sZW5ndGg7KytmKXtpZih0LmNoYXJDb2RlQXQoZikhPT00NylicmVha312YXIgbD10Lmxlbmd0aDt2YXIgcz1sLWY7dmFyIG89YTxzP2E6czt2YXIgdT0tMTt2YXIgaD0wO2Zvcig7aDw9bzsrK2gpe2lmKGg9PT1vKXtpZihzPm8pe2lmKHQuY2hhckNvZGVBdChmK2gpPT09NDcpe3JldHVybiB0LnNsaWNlKGYraCsxKX1lbHNlIGlmKGg9PT0wKXtyZXR1cm4gdC5zbGljZShmK2gpfX1lbHNlIGlmKGE+byl7aWYoZS5jaGFyQ29kZUF0KGkraCk9PT00Nyl7dT1ofWVsc2UgaWYoaD09PTApe3U9MH19YnJlYWt9dmFyIGM9ZS5jaGFyQ29kZUF0KGkraCk7dmFyIHY9dC5jaGFyQ29kZUF0KGYraCk7aWYoYyE9PXYpYnJlYWs7ZWxzZSBpZihjPT09NDcpdT1ofXZhciBnPVwiXCI7Zm9yKGg9aSt1KzE7aDw9bjsrK2gpe2lmKGg9PT1ufHxlLmNoYXJDb2RlQXQoaCk9PT00Nyl7aWYoZy5sZW5ndGg9PT0wKWcrPVwiLi5cIjtlbHNlIGcrPVwiLy4uXCJ9fWlmKGcubGVuZ3RoPjApcmV0dXJuIGcrdC5zbGljZShmK3UpO2Vsc2V7Zis9dTtpZih0LmNoYXJDb2RlQXQoZik9PT00NykrK2Y7cmV0dXJuIHQuc2xpY2UoZil9fSxfbWFrZUxvbmc6ZnVuY3Rpb24gX21ha2VMb25nKGUpe3JldHVybiBlfSxkaXJuYW1lOmZ1bmN0aW9uIGRpcm5hbWUoZSl7YXNzZXJ0UGF0aChlKTtpZihlLmxlbmd0aD09PTApcmV0dXJuXCIuXCI7dmFyIHI9ZS5jaGFyQ29kZUF0KDApO3ZhciB0PXI9PT00Nzt2YXIgaT0tMTt2YXIgbj10cnVlO2Zvcih2YXIgYT1lLmxlbmd0aC0xO2E+PTE7LS1hKXtyPWUuY2hhckNvZGVBdChhKTtpZihyPT09NDcpe2lmKCFuKXtpPWE7YnJlYWt9fWVsc2V7bj1mYWxzZX19aWYoaT09PS0xKXJldHVybiB0P1wiL1wiOlwiLlwiO2lmKHQmJmk9PT0xKXJldHVyblwiLy9cIjtyZXR1cm4gZS5zbGljZSgwLGkpfSxiYXNlbmFtZTpmdW5jdGlvbiBiYXNlbmFtZShlLHIpe2lmKHIhPT11bmRlZmluZWQmJnR5cGVvZiByIT09XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKCdcImV4dFwiIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTthc3NlcnRQYXRoKGUpO3ZhciB0PTA7dmFyIGk9LTE7dmFyIG49dHJ1ZTt2YXIgYTtpZihyIT09dW5kZWZpbmVkJiZyLmxlbmd0aD4wJiZyLmxlbmd0aDw9ZS5sZW5ndGgpe2lmKHIubGVuZ3RoPT09ZS5sZW5ndGgmJnI9PT1lKXJldHVyblwiXCI7dmFyIGY9ci5sZW5ndGgtMTt2YXIgbD0tMTtmb3IoYT1lLmxlbmd0aC0xO2E+PTA7LS1hKXt2YXIgcz1lLmNoYXJDb2RlQXQoYSk7aWYocz09PTQ3KXtpZighbil7dD1hKzE7YnJlYWt9fWVsc2V7aWYobD09PS0xKXtuPWZhbHNlO2w9YSsxfWlmKGY+PTApe2lmKHM9PT1yLmNoYXJDb2RlQXQoZikpe2lmKC0tZj09PS0xKXtpPWF9fWVsc2V7Zj0tMTtpPWx9fX19aWYodD09PWkpaT1sO2Vsc2UgaWYoaT09PS0xKWk9ZS5sZW5ndGg7cmV0dXJuIGUuc2xpY2UodCxpKX1lbHNle2ZvcihhPWUubGVuZ3RoLTE7YT49MDstLWEpe2lmKGUuY2hhckNvZGVBdChhKT09PTQ3KXtpZighbil7dD1hKzE7YnJlYWt9fWVsc2UgaWYoaT09PS0xKXtuPWZhbHNlO2k9YSsxfX1pZihpPT09LTEpcmV0dXJuXCJcIjtyZXR1cm4gZS5zbGljZSh0LGkpfX0sZXh0bmFtZTpmdW5jdGlvbiBleHRuYW1lKGUpe2Fzc2VydFBhdGgoZSk7dmFyIHI9LTE7dmFyIHQ9MDt2YXIgaT0tMTt2YXIgbj10cnVlO3ZhciBhPTA7Zm9yKHZhciBmPWUubGVuZ3RoLTE7Zj49MDstLWYpe3ZhciBsPWUuY2hhckNvZGVBdChmKTtpZihsPT09NDcpe2lmKCFuKXt0PWYrMTticmVha31jb250aW51ZX1pZihpPT09LTEpe249ZmFsc2U7aT1mKzF9aWYobD09PTQ2KXtpZihyPT09LTEpcj1mO2Vsc2UgaWYoYSE9PTEpYT0xfWVsc2UgaWYociE9PS0xKXthPS0xfX1pZihyPT09LTF8fGk9PT0tMXx8YT09PTB8fGE9PT0xJiZyPT09aS0xJiZyPT09dCsxKXtyZXR1cm5cIlwifXJldHVybiBlLnNsaWNlKHIsaSl9LGZvcm1hdDpmdW5jdGlvbiBmb3JtYXQoZSl7aWYoZT09PW51bGx8fHR5cGVvZiBlIT09XCJvYmplY3RcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwicGF0aE9iamVjdFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2YgZSl9cmV0dXJuIF9mb3JtYXQoXCIvXCIsZSl9LHBhcnNlOmZ1bmN0aW9uIHBhcnNlKGUpe2Fzc2VydFBhdGgoZSk7dmFyIHI9e3Jvb3Q6XCJcIixkaXI6XCJcIixiYXNlOlwiXCIsZXh0OlwiXCIsbmFtZTpcIlwifTtpZihlLmxlbmd0aD09PTApcmV0dXJuIHI7dmFyIHQ9ZS5jaGFyQ29kZUF0KDApO3ZhciBpPXQ9PT00Nzt2YXIgbjtpZihpKXtyLnJvb3Q9XCIvXCI7bj0xfWVsc2V7bj0wfXZhciBhPS0xO3ZhciBmPTA7dmFyIGw9LTE7dmFyIHM9dHJ1ZTt2YXIgbz1lLmxlbmd0aC0xO3ZhciB1PTA7Zm9yKDtvPj1uOy0tbyl7dD1lLmNoYXJDb2RlQXQobyk7aWYodD09PTQ3KXtpZighcyl7Zj1vKzE7YnJlYWt9Y29udGludWV9aWYobD09PS0xKXtzPWZhbHNlO2w9bysxfWlmKHQ9PT00Nil7aWYoYT09PS0xKWE9bztlbHNlIGlmKHUhPT0xKXU9MX1lbHNlIGlmKGEhPT0tMSl7dT0tMX19aWYoYT09PS0xfHxsPT09LTF8fHU9PT0wfHx1PT09MSYmYT09PWwtMSYmYT09PWYrMSl7aWYobCE9PS0xKXtpZihmPT09MCYmaSlyLmJhc2U9ci5uYW1lPWUuc2xpY2UoMSxsKTtlbHNlIHIuYmFzZT1yLm5hbWU9ZS5zbGljZShmLGwpfX1lbHNle2lmKGY9PT0wJiZpKXtyLm5hbWU9ZS5zbGljZSgxLGEpO3IuYmFzZT1lLnNsaWNlKDEsbCl9ZWxzZXtyLm5hbWU9ZS5zbGljZShmLGEpO3IuYmFzZT1lLnNsaWNlKGYsbCl9ci5leHQ9ZS5zbGljZShhLGwpfWlmKGY+MClyLmRpcj1lLnNsaWNlKDAsZi0xKTtlbHNlIGlmKGkpci5kaXI9XCIvXCI7cmV0dXJuIHJ9LHNlcDpcIi9cIixkZWxpbWl0ZXI6XCI6XCIsd2luMzI6bnVsbCxwb3NpeDpudWxsfTtyLnBvc2l4PXI7ZS5leHBvcnRzPXJ9fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBpPXJbdF07aWYoaSE9PXVuZGVmaW5lZCl7cmV0dXJuIGkuZXhwb3J0c312YXIgbj1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKG4sbi5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBuLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oMTE0KTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOlsiZSIsImFzc2VydFBhdGgiLCJUeXBlRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwibm9ybWFsaXplU3RyaW5nUG9zaXgiLCJyIiwidCIsImkiLCJuIiwiYSIsImYiLCJsIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsInMiLCJsYXN0SW5kZXhPZiIsInNsaWNlIiwiX2Zvcm1hdCIsImRpciIsInJvb3QiLCJiYXNlIiwibmFtZSIsImV4dCIsInJlc29sdmUiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJub3JtYWxpemUiLCJpc0Fic29sdXRlIiwiam9pbiIsInJlbGF0aXZlIiwibyIsInUiLCJoIiwiYyIsInYiLCJnIiwiX21ha2VMb25nIiwiZGlybmFtZSIsImJhc2VuYW1lIiwiZXh0bmFtZSIsImZvcm1hdCIsInBhcnNlIiwic2VwIiwiZGVsaW1pdGVyIiwid2luMzIiLCJwb3NpeCIsImV4cG9ydHMiLCJfX25jY3dwY2tfcmVxdWlyZV9fIiwiYWIiLCJfX2Rpcm5hbWUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/path-browserify/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n\n(function() {\n    var e = {\n        229: function(e) {\n            var t = e.exports = {};\n            var r;\n            var n;\n            function defaultSetTimout() {\n                throw new Error(\"setTimeout has not been defined\");\n            }\n            function defaultClearTimeout() {\n                throw new Error(\"clearTimeout has not been defined\");\n            }\n            (function() {\n                try {\n                    if (typeof setTimeout === \"function\") {\n                        r = setTimeout;\n                    } else {\n                        r = defaultSetTimout;\n                    }\n                } catch (e) {\n                    r = defaultSetTimout;\n                }\n                try {\n                    if (typeof clearTimeout === \"function\") {\n                        n = clearTimeout;\n                    } else {\n                        n = defaultClearTimeout;\n                    }\n                } catch (e) {\n                    n = defaultClearTimeout;\n                }\n            })();\n            function runTimeout(e) {\n                if (r === setTimeout) {\n                    return setTimeout(e, 0);\n                }\n                if ((r === defaultSetTimout || !r) && setTimeout) {\n                    r = setTimeout;\n                    return setTimeout(e, 0);\n                }\n                try {\n                    return r(e, 0);\n                } catch (t) {\n                    try {\n                        return r.call(null, e, 0);\n                    } catch (t) {\n                        return r.call(this, e, 0);\n                    }\n                }\n            }\n            function runClearTimeout(e) {\n                if (n === clearTimeout) {\n                    return clearTimeout(e);\n                }\n                if ((n === defaultClearTimeout || !n) && clearTimeout) {\n                    n = clearTimeout;\n                    return clearTimeout(e);\n                }\n                try {\n                    return n(e);\n                } catch (t) {\n                    try {\n                        return n.call(null, e);\n                    } catch (t) {\n                        return n.call(this, e);\n                    }\n                }\n            }\n            var i = [];\n            var o = false;\n            var u;\n            var a = -1;\n            function cleanUpNextTick() {\n                if (!o || !u) {\n                    return;\n                }\n                o = false;\n                if (u.length) {\n                    i = u.concat(i);\n                } else {\n                    a = -1;\n                }\n                if (i.length) {\n                    drainQueue();\n                }\n            }\n            function drainQueue() {\n                if (o) {\n                    return;\n                }\n                var e = runTimeout(cleanUpNextTick);\n                o = true;\n                var t = i.length;\n                while(t){\n                    u = i;\n                    i = [];\n                    while(++a < t){\n                        if (u) {\n                            u[a].run();\n                        }\n                    }\n                    a = -1;\n                    t = i.length;\n                }\n                u = null;\n                o = false;\n                runClearTimeout(e);\n            }\n            t.nextTick = function(e) {\n                var t = new Array(arguments.length - 1);\n                if (arguments.length > 1) {\n                    for(var r = 1; r < arguments.length; r++){\n                        t[r - 1] = arguments[r];\n                    }\n                }\n                i.push(new Item(e, t));\n                if (i.length === 1 && !o) {\n                    runTimeout(drainQueue);\n                }\n            };\n            function Item(e, t) {\n                this.fun = e;\n                this.array = t;\n            }\n            Item.prototype.run = function() {\n                this.fun.apply(null, this.array);\n            };\n            t.title = \"browser\";\n            t.browser = true;\n            t.env = {};\n            t.argv = [];\n            t.version = \"\";\n            t.versions = {};\n            function noop() {}\n            t.on = noop;\n            t.addListener = noop;\n            t.once = noop;\n            t.off = noop;\n            t.removeListener = noop;\n            t.removeAllListeners = noop;\n            t.emit = noop;\n            t.prependListener = noop;\n            t.prependOnceListener = noop;\n            t.listeners = function(e) {\n                return [];\n            };\n            t.binding = function(e) {\n                throw new Error(\"process.binding is not supported\");\n            };\n            t.cwd = function() {\n                return \"/\";\n            };\n            t.chdir = function(e) {\n                throw new Error(\"process.chdir is not supported\");\n            };\n            t.umask = function() {\n                return 0;\n            };\n        }\n    };\n    var t = {};\n    function __nccwpck_require__(r) {\n        var n = t[r];\n        if (n !== undefined) {\n            return n.exports;\n        }\n        var i = t[r] = {\n            exports: {}\n        };\n        var o = true;\n        try {\n            e[r](i, i.exports, __nccwpck_require__);\n            o = false;\n        } finally{\n            if (o) delete t[r];\n        }\n        return i.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var r = __nccwpck_require__(229);\n    module.exports = r;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7O0FBQUM7SUFBVyxJQUFJQSxJQUFFO1FBQUMsS0FBSSxTQUFTQSxDQUFDO1lBQUUsSUFBSUMsSUFBRUQsRUFBRUUsT0FBTyxHQUFDLENBQUM7WUFBRSxJQUFJQztZQUFFLElBQUlDO1lBQUUsU0FBU0M7Z0JBQW1CLE1BQU0sSUFBSUMsTUFBTTtZQUFrQztZQUFDLFNBQVNDO2dCQUFzQixNQUFNLElBQUlELE1BQU07WUFBb0M7WUFBRTtnQkFBVyxJQUFHO29CQUFDLElBQUcsT0FBT0UsZUFBYSxZQUFXO3dCQUFDTCxJQUFFSztvQkFBVSxPQUFLO3dCQUFDTCxJQUFFRTtvQkFBZ0I7Z0JBQUMsRUFBQyxPQUFNTCxHQUFFO29CQUFDRyxJQUFFRTtnQkFBZ0I7Z0JBQUMsSUFBRztvQkFBQyxJQUFHLE9BQU9JLGlCQUFlLFlBQVc7d0JBQUNMLElBQUVLO29CQUFZLE9BQUs7d0JBQUNMLElBQUVHO29CQUFtQjtnQkFBQyxFQUFDLE9BQU1QLEdBQUU7b0JBQUNJLElBQUVHO2dCQUFtQjtZQUFDO1lBQUssU0FBU0csV0FBV1YsQ0FBQztnQkFBRSxJQUFHRyxNQUFJSyxZQUFXO29CQUFDLE9BQU9BLFdBQVdSLEdBQUU7Z0JBQUU7Z0JBQUMsSUFBRyxDQUFDRyxNQUFJRSxvQkFBa0IsQ0FBQ0YsQ0FBQUEsS0FBSUssWUFBVztvQkFBQ0wsSUFBRUs7b0JBQVcsT0FBT0EsV0FBV1IsR0FBRTtnQkFBRTtnQkFBQyxJQUFHO29CQUFDLE9BQU9HLEVBQUVILEdBQUU7Z0JBQUUsRUFBQyxPQUFNQyxHQUFFO29CQUFDLElBQUc7d0JBQUMsT0FBT0UsRUFBRVEsSUFBSSxDQUFDLE1BQUtYLEdBQUU7b0JBQUUsRUFBQyxPQUFNQyxHQUFFO3dCQUFDLE9BQU9FLEVBQUVRLElBQUksQ0FBQyxJQUFJLEVBQUNYLEdBQUU7b0JBQUU7Z0JB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c3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzPzFiMWQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIGU9ezIyOTpmdW5jdGlvbihlKXt2YXIgdD1lLmV4cG9ydHM9e307dmFyIHI7dmFyIG47ZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX0oZnVuY3Rpb24oKXt0cnl7aWYodHlwZW9mIHNldFRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe3I9c2V0VGltZW91dH1lbHNle3I9ZGVmYXVsdFNldFRpbW91dH19Y2F0Y2goZSl7cj1kZWZhdWx0U2V0VGltb3V0fXRyeXtpZih0eXBlb2YgY2xlYXJUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtuPWNsZWFyVGltZW91dH1lbHNle249ZGVmYXVsdENsZWFyVGltZW91dH19Y2F0Y2goZSl7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX0pKCk7ZnVuY3Rpb24gcnVuVGltZW91dChlKXtpZihyPT09c2V0VGltZW91dCl7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX1pZigocj09PWRlZmF1bHRTZXRUaW1vdXR8fCFyKSYmc2V0VGltZW91dCl7cj1zZXRUaW1lb3V0O3JldHVybiBzZXRUaW1lb3V0KGUsMCl9dHJ5e3JldHVybiByKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiByLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiByLmNhbGwodGhpcyxlLDApfX19ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KGUpe2lmKG49PT1jbGVhclRpbWVvdXQpe3JldHVybiBjbGVhclRpbWVvdXQoZSl9aWYoKG49PT1kZWZhdWx0Q2xlYXJUaW1lb3V0fHwhbikmJmNsZWFyVGltZW91dCl7bj1jbGVhclRpbWVvdXQ7cmV0dXJuIGNsZWFyVGltZW91dChlKX10cnl7cmV0dXJuIG4oZSl9Y2F0Y2godCl7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxlKX1jYXRjaCh0KXtyZXR1cm4gbi5jYWxsKHRoaXMsZSl9fX12YXIgaT1bXTt2YXIgbz1mYWxzZTt2YXIgdTt2YXIgYT0tMTtmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKXtpZighb3x8IXUpe3JldHVybn1vPWZhbHNlO2lmKHUubGVuZ3RoKXtpPXUuY29uY2F0KGkpfWVsc2V7YT0tMX1pZihpLmxlbmd0aCl7ZHJhaW5RdWV1ZSgpfX1mdW5jdGlvbiBkcmFpblF1ZXVlKCl7aWYobyl7cmV0dXJufXZhciBlPXJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtvPXRydWU7dmFyIHQ9aS5sZW5ndGg7d2hpbGUodCl7dT1pO2k9W107d2hpbGUoKythPHQpe2lmKHUpe3VbYV0ucnVuKCl9fWE9LTE7dD1pLmxlbmd0aH11PW51bGw7bz1mYWxzZTtydW5DbGVhclRpbWVvdXQoZSl9dC5uZXh0VGljaz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3Rbci0xXT1hcmd1bWVudHNbcl19fWkucHVzaChuZXcgSXRlbShlLHQpKTtpZihpLmxlbmd0aD09PTEmJiFvKXtydW5UaW1lb3V0KGRyYWluUXVldWUpfX07ZnVuY3Rpb24gSXRlbShlLHQpe3RoaXMuZnVuPWU7dGhpcy5hcnJheT10fUl0ZW0ucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9O3QudGl0bGU9XCJicm93c2VyXCI7dC5icm93c2VyPXRydWU7dC5lbnY9e307dC5hcmd2PVtdO3QudmVyc2lvbj1cIlwiO3QudmVyc2lvbnM9e307ZnVuY3Rpb24gbm9vcCgpe310Lm9uPW5vb3A7dC5hZGRMaXN0ZW5lcj1ub29wO3Qub25jZT1ub29wO3Qub2ZmPW5vb3A7dC5yZW1vdmVMaXN0ZW5lcj1ub29wO3QucmVtb3ZlQWxsTGlzdGVuZXJzPW5vb3A7dC5lbWl0PW5vb3A7dC5wcmVwZW5kTGlzdGVuZXI9bm9vcDt0LnByZXBlbmRPbmNlTGlzdGVuZXI9bm9vcDt0Lmxpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm5bXX07dC5iaW5kaW5nPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LmN3ZD1mdW5jdGlvbigpe3JldHVyblwiL1wifTt0LmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX07dC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18ocil7dmFyIG49dFtyXTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBpPXRbcl09e2V4cG9ydHM6e319O3ZhciBvPXRydWU7dHJ5e2Vbcl0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bz1mYWxzZX1maW5hbGx5e2lmKG8pZGVsZXRlIHRbcl19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHI9X19uY2N3cGNrX3JlcXVpcmVfXygyMjkpO21vZHVsZS5leHBvcnRzPXJ9KSgpOyJdLCJuYW1lcyI6WyJlIiwidCIsImV4cG9ydHMiLCJyIiwibiIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJpIiwibyIsInUiLCJhIiwiY2xlYW5VcE5leHRUaWNrIiwibGVuZ3RoIiwiY29uY2F0IiwiZHJhaW5RdWV1ZSIsInJ1biIsIm5leHRUaWNrIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJwdXNoIiwiSXRlbSIsImZ1biIsImFycmF5IiwicHJvdG90eXBlIiwiYXBwbHkiLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsInVtYXNrIiwiX19uY2N3cGNrX3JlcXVpcmVfXyIsInVuZGVmaW5lZCIsImFiIiwiX19kaXJuYW1lIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMv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LE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/compiled/util/util.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n(function() {\n    var r = {\n        992: function(r) {\n            r.exports = function(r, t, o) {\n                if (r.filter) return r.filter(t, o);\n                if (void 0 === r || null === r) throw new TypeError;\n                if (\"function\" != typeof t) throw new TypeError;\n                var n = [];\n                for(var i = 0; i < r.length; i++){\n                    if (!e.call(r, i)) continue;\n                    var a = r[i];\n                    if (t.call(o, a, i, r)) n.push(a);\n                }\n                return n;\n            };\n            var e = Object.prototype.hasOwnProperty;\n        },\n        256: function(r, e, t) {\n            \"use strict\";\n            var o = t(925);\n            var n = t(139);\n            var i = n(o(\"String.prototype.indexOf\"));\n            r.exports = function callBoundIntrinsic(r, e) {\n                var t = o(r, !!e);\n                if (typeof t === \"function\" && i(r, \".prototype.\") > -1) {\n                    return n(t);\n                }\n                return t;\n            };\n        },\n        139: function(r, e, t) {\n            \"use strict\";\n            var o = t(174);\n            var n = t(925);\n            var i = n(\"%Function.prototype.apply%\");\n            var a = n(\"%Function.prototype.call%\");\n            var y = n(\"%Reflect.apply%\", true) || o.call(a, i);\n            var f = n(\"%Object.getOwnPropertyDescriptor%\", true);\n            var p = n(\"%Object.defineProperty%\", true);\n            var u = n(\"%Math.max%\");\n            if (p) {\n                try {\n                    p({}, \"a\", {\n                        value: 1\n                    });\n                } catch (r) {\n                    p = null;\n                }\n            }\n            r.exports = function callBind(r) {\n                var e = y(o, a, arguments);\n                if (f && p) {\n                    var t = f(e, \"length\");\n                    if (t.configurable) {\n                        p(e, \"length\", {\n                            value: 1 + u(0, r.length - (arguments.length - 1))\n                        });\n                    }\n                }\n                return e;\n            };\n            var s = function applyBind() {\n                return y(o, i, arguments);\n            };\n            if (p) {\n                p(r.exports, \"apply\", {\n                    value: s\n                });\n            } else {\n                r.exports.apply = s;\n            }\n        },\n        144: function(r) {\n            var e = Object.prototype.hasOwnProperty;\n            var t = Object.prototype.toString;\n            r.exports = function forEach(r, o, n) {\n                if (t.call(o) !== \"[object Function]\") {\n                    throw new TypeError(\"iterator must be a function\");\n                }\n                var i = r.length;\n                if (i === +i) {\n                    for(var a = 0; a < i; a++){\n                        o.call(n, r[a], a, r);\n                    }\n                } else {\n                    for(var y in r){\n                        if (e.call(r, y)) {\n                            o.call(n, r[y], y, r);\n                        }\n                    }\n                }\n            };\n        },\n        426: function(r) {\n            \"use strict\";\n            var e = \"Function.prototype.bind called on incompatible \";\n            var t = Array.prototype.slice;\n            var o = Object.prototype.toString;\n            var n = \"[object Function]\";\n            r.exports = function bind(r) {\n                var i = this;\n                if (typeof i !== \"function\" || o.call(i) !== n) {\n                    throw new TypeError(e + i);\n                }\n                var a = t.call(arguments, 1);\n                var y;\n                var binder = function() {\n                    if (this instanceof y) {\n                        var e = i.apply(this, a.concat(t.call(arguments)));\n                        if (Object(e) === e) {\n                            return e;\n                        }\n                        return this;\n                    } else {\n                        return i.apply(r, a.concat(t.call(arguments)));\n                    }\n                };\n                var f = Math.max(0, i.length - a.length);\n                var p = [];\n                for(var u = 0; u < f; u++){\n                    p.push(\"$\" + u);\n                }\n                y = Function(\"binder\", \"return function (\" + p.join(\",\") + \"){ return binder.apply(this,arguments); }\")(binder);\n                if (i.prototype) {\n                    var s = function Empty() {};\n                    s.prototype = i.prototype;\n                    y.prototype = new s;\n                    s.prototype = null;\n                }\n                return y;\n            };\n        },\n        174: function(r, e, t) {\n            \"use strict\";\n            var o = t(426);\n            r.exports = Function.prototype.bind || o;\n        },\n        500: function(r, e, t) {\n            \"use strict\";\n            var o;\n            var n = SyntaxError;\n            var i = Function;\n            var a = TypeError;\n            var getEvalledConstructor = function(r) {\n                try {\n                    return i('\"use strict\"; return (' + r + \").constructor;\")();\n                } catch (r) {}\n            };\n            var y = Object.getOwnPropertyDescriptor;\n            if (y) {\n                try {\n                    y({}, \"\");\n                } catch (r) {\n                    y = null;\n                }\n            }\n            var throwTypeError = function() {\n                throw new a;\n            };\n            var f = y ? function() {\n                try {\n                    arguments.callee;\n                    return throwTypeError;\n                } catch (r) {\n                    try {\n                        return y(arguments, \"callee\").get;\n                    } catch (r) {\n                        return throwTypeError;\n                    }\n                }\n            }() : throwTypeError;\n            var p = t(115)();\n            var u = Object.getPrototypeOf || function(r) {\n                return r.__proto__;\n            };\n            var s = {};\n            var c = typeof Uint8Array === \"undefined\" ? o : u(Uint8Array);\n            var l = {\n                \"%AggregateError%\": typeof AggregateError === \"undefined\" ? o : AggregateError,\n                \"%Array%\": Array,\n                \"%ArrayBuffer%\": typeof ArrayBuffer === \"undefined\" ? o : ArrayBuffer,\n                \"%ArrayIteratorPrototype%\": p ? u([][Symbol.iterator]()) : o,\n                \"%AsyncFromSyncIteratorPrototype%\": o,\n                \"%AsyncFunction%\": s,\n                \"%AsyncGenerator%\": s,\n                \"%AsyncGeneratorFunction%\": s,\n                \"%AsyncIteratorPrototype%\": s,\n                \"%Atomics%\": typeof Atomics === \"undefined\" ? o : Atomics,\n                \"%BigInt%\": typeof BigInt === \"undefined\" ? o : BigInt,\n                \"%Boolean%\": Boolean,\n                \"%DataView%\": typeof DataView === \"undefined\" ? o : DataView,\n                \"%Date%\": Date,\n                \"%decodeURI%\": decodeURI,\n                \"%decodeURIComponent%\": decodeURIComponent,\n                \"%encodeURI%\": encodeURI,\n                \"%encodeURIComponent%\": encodeURIComponent,\n                \"%Error%\": Error,\n                \"%eval%\": eval,\n                \"%EvalError%\": EvalError,\n                \"%Float32Array%\": typeof Float32Array === \"undefined\" ? o : Float32Array,\n                \"%Float64Array%\": typeof Float64Array === \"undefined\" ? o : Float64Array,\n                \"%FinalizationRegistry%\": typeof FinalizationRegistry === \"undefined\" ? o : FinalizationRegistry,\n                \"%Function%\": i,\n                \"%GeneratorFunction%\": s,\n                \"%Int8Array%\": typeof Int8Array === \"undefined\" ? o : Int8Array,\n                \"%Int16Array%\": typeof Int16Array === \"undefined\" ? o : Int16Array,\n                \"%Int32Array%\": typeof Int32Array === \"undefined\" ? o : Int32Array,\n                \"%isFinite%\": isFinite,\n                \"%isNaN%\": isNaN,\n                \"%IteratorPrototype%\": p ? u(u([][Symbol.iterator]())) : o,\n                \"%JSON%\": typeof JSON === \"object\" ? JSON : o,\n                \"%Map%\": typeof Map === \"undefined\" ? o : Map,\n                \"%MapIteratorPrototype%\": typeof Map === \"undefined\" || !p ? o : u((new Map)[Symbol.iterator]()),\n                \"%Math%\": Math,\n                \"%Number%\": Number,\n                \"%Object%\": Object,\n                \"%parseFloat%\": parseFloat,\n                \"%parseInt%\": parseInt,\n                \"%Promise%\": typeof Promise === \"undefined\" ? o : Promise,\n                \"%Proxy%\": typeof Proxy === \"undefined\" ? o : Proxy,\n                \"%RangeError%\": RangeError,\n                \"%ReferenceError%\": ReferenceError,\n                \"%Reflect%\": typeof Reflect === \"undefined\" ? o : Reflect,\n                \"%RegExp%\": RegExp,\n                \"%Set%\": typeof Set === \"undefined\" ? o : Set,\n                \"%SetIteratorPrototype%\": typeof Set === \"undefined\" || !p ? o : u((new Set)[Symbol.iterator]()),\n                \"%SharedArrayBuffer%\": typeof SharedArrayBuffer === \"undefined\" ? o : SharedArrayBuffer,\n                \"%String%\": String,\n                \"%StringIteratorPrototype%\": p ? u(\"\"[Symbol.iterator]()) : o,\n                \"%Symbol%\": p ? Symbol : o,\n                \"%SyntaxError%\": n,\n                \"%ThrowTypeError%\": f,\n                \"%TypedArray%\": c,\n                \"%TypeError%\": a,\n                \"%Uint8Array%\": typeof Uint8Array === \"undefined\" ? o : Uint8Array,\n                \"%Uint8ClampedArray%\": typeof Uint8ClampedArray === \"undefined\" ? o : Uint8ClampedArray,\n                \"%Uint16Array%\": typeof Uint16Array === \"undefined\" ? o : Uint16Array,\n                \"%Uint32Array%\": typeof Uint32Array === \"undefined\" ? o : Uint32Array,\n                \"%URIError%\": URIError,\n                \"%WeakMap%\": typeof WeakMap === \"undefined\" ? o : WeakMap,\n                \"%WeakRef%\": typeof WeakRef === \"undefined\" ? o : WeakRef,\n                \"%WeakSet%\": typeof WeakSet === \"undefined\" ? o : WeakSet\n            };\n            var d = function doEval(r) {\n                var e;\n                if (r === \"%AsyncFunction%\") {\n                    e = getEvalledConstructor(\"async function () {}\");\n                } else if (r === \"%GeneratorFunction%\") {\n                    e = getEvalledConstructor(\"function* () {}\");\n                } else if (r === \"%AsyncGeneratorFunction%\") {\n                    e = getEvalledConstructor(\"async function* () {}\");\n                } else if (r === \"%AsyncGenerator%\") {\n                    var t = doEval(\"%AsyncGeneratorFunction%\");\n                    if (t) {\n                        e = t.prototype;\n                    }\n                } else if (r === \"%AsyncIteratorPrototype%\") {\n                    var o = doEval(\"%AsyncGenerator%\");\n                    if (o) {\n                        e = u(o.prototype);\n                    }\n                }\n                l[r] = e;\n                return e;\n            };\n            var g = {\n                \"%ArrayBufferPrototype%\": [\n                    \"ArrayBuffer\",\n                    \"prototype\"\n                ],\n                \"%ArrayPrototype%\": [\n                    \"Array\",\n                    \"prototype\"\n                ],\n                \"%ArrayProto_entries%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"entries\"\n                ],\n                \"%ArrayProto_forEach%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"forEach\"\n                ],\n                \"%ArrayProto_keys%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"keys\"\n                ],\n                \"%ArrayProto_values%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"values\"\n                ],\n                \"%AsyncFunctionPrototype%\": [\n                    \"AsyncFunction\",\n                    \"prototype\"\n                ],\n                \"%AsyncGenerator%\": [\n                    \"AsyncGeneratorFunction\",\n                    \"prototype\"\n                ],\n                \"%AsyncGeneratorPrototype%\": [\n                    \"AsyncGeneratorFunction\",\n                    \"prototype\",\n                    \"prototype\"\n                ],\n                \"%BooleanPrototype%\": [\n                    \"Boolean\",\n                    \"prototype\"\n                ],\n                \"%DataViewPrototype%\": [\n                    \"DataView\",\n                    \"prototype\"\n                ],\n                \"%DatePrototype%\": [\n                    \"Date\",\n                    \"prototype\"\n                ],\n                \"%ErrorPrototype%\": [\n                    \"Error\",\n                    \"prototype\"\n                ],\n                \"%EvalErrorPrototype%\": [\n                    \"EvalError\",\n                    \"prototype\"\n                ],\n                \"%Float32ArrayPrototype%\": [\n                    \"Float32Array\",\n                    \"prototype\"\n                ],\n                \"%Float64ArrayPrototype%\": [\n                    \"Float64Array\",\n                    \"prototype\"\n                ],\n                \"%FunctionPrototype%\": [\n                    \"Function\",\n                    \"prototype\"\n                ],\n                \"%Generator%\": [\n                    \"GeneratorFunction\",\n                    \"prototype\"\n                ],\n                \"%GeneratorPrototype%\": [\n                    \"GeneratorFunction\",\n                    \"prototype\",\n                    \"prototype\"\n                ],\n                \"%Int8ArrayPrototype%\": [\n                    \"Int8Array\",\n                    \"prototype\"\n                ],\n                \"%Int16ArrayPrototype%\": [\n                    \"Int16Array\",\n                    \"prototype\"\n                ],\n                \"%Int32ArrayPrototype%\": [\n                    \"Int32Array\",\n                    \"prototype\"\n                ],\n                \"%JSONParse%\": [\n                    \"JSON\",\n                    \"parse\"\n                ],\n                \"%JSONStringify%\": [\n                    \"JSON\",\n                    \"stringify\"\n                ],\n                \"%MapPrototype%\": [\n                    \"Map\",\n                    \"prototype\"\n                ],\n                \"%NumberPrototype%\": [\n                    \"Number\",\n                    \"prototype\"\n                ],\n                \"%ObjectPrototype%\": [\n                    \"Object\",\n                    \"prototype\"\n                ],\n                \"%ObjProto_toString%\": [\n                    \"Object\",\n                    \"prototype\",\n                    \"toString\"\n                ],\n                \"%ObjProto_valueOf%\": [\n                    \"Object\",\n                    \"prototype\",\n                    \"valueOf\"\n                ],\n                \"%PromisePrototype%\": [\n                    \"Promise\",\n                    \"prototype\"\n                ],\n                \"%PromiseProto_then%\": [\n                    \"Promise\",\n                    \"prototype\",\n                    \"then\"\n                ],\n                \"%Promise_all%\": [\n                    \"Promise\",\n                    \"all\"\n                ],\n                \"%Promise_reject%\": [\n                    \"Promise\",\n                    \"reject\"\n                ],\n                \"%Promise_resolve%\": [\n                    \"Promise\",\n                    \"resolve\"\n                ],\n                \"%RangeErrorPrototype%\": [\n                    \"RangeError\",\n                    \"prototype\"\n                ],\n                \"%ReferenceErrorPrototype%\": [\n                    \"ReferenceError\",\n                    \"prototype\"\n                ],\n                \"%RegExpPrototype%\": [\n                    \"RegExp\",\n                    \"prototype\"\n                ],\n                \"%SetPrototype%\": [\n                    \"Set\",\n                    \"prototype\"\n                ],\n                \"%SharedArrayBufferPrototype%\": [\n                    \"SharedArrayBuffer\",\n                    \"prototype\"\n                ],\n                \"%StringPrototype%\": [\n                    \"String\",\n                    \"prototype\"\n                ],\n                \"%SymbolPrototype%\": [\n                    \"Symbol\",\n                    \"prototype\"\n                ],\n                \"%SyntaxErrorPrototype%\": [\n                    \"SyntaxError\",\n                    \"prototype\"\n                ],\n                \"%TypedArrayPrototype%\": [\n                    \"TypedArray\",\n                    \"prototype\"\n                ],\n                \"%TypeErrorPrototype%\": [\n                    \"TypeError\",\n                    \"prototype\"\n                ],\n                \"%Uint8ArrayPrototype%\": [\n                    \"Uint8Array\",\n                    \"prototype\"\n                ],\n                \"%Uint8ClampedArrayPrototype%\": [\n                    \"Uint8ClampedArray\",\n                    \"prototype\"\n                ],\n                \"%Uint16ArrayPrototype%\": [\n                    \"Uint16Array\",\n                    \"prototype\"\n                ],\n                \"%Uint32ArrayPrototype%\": [\n                    \"Uint32Array\",\n                    \"prototype\"\n                ],\n                \"%URIErrorPrototype%\": [\n                    \"URIError\",\n                    \"prototype\"\n                ],\n                \"%WeakMapPrototype%\": [\n                    \"WeakMap\",\n                    \"prototype\"\n                ],\n                \"%WeakSetPrototype%\": [\n                    \"WeakSet\",\n                    \"prototype\"\n                ]\n            };\n            var v = t(174);\n            var b = t(101);\n            var A = v.call(Function.call, Array.prototype.concat);\n            var m = v.call(Function.apply, Array.prototype.splice);\n            var S = v.call(Function.call, String.prototype.replace);\n            var h = v.call(Function.call, String.prototype.slice);\n            var P = v.call(Function.call, RegExp.prototype.exec);\n            var O = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\n            var w = /\\\\(\\\\)?/g;\n            var j = function stringToPath(r) {\n                var e = h(r, 0, 1);\n                var t = h(r, -1);\n                if (e === \"%\" && t !== \"%\") {\n                    throw new n(\"invalid intrinsic syntax, expected closing `%`\");\n                } else if (t === \"%\" && e !== \"%\") {\n                    throw new n(\"invalid intrinsic syntax, expected opening `%`\");\n                }\n                var o = [];\n                S(r, O, function(r, e, t, n) {\n                    o[o.length] = t ? S(n, w, \"$1\") : e || r;\n                });\n                return o;\n            };\n            var E = function getBaseIntrinsic(r, e) {\n                var t = r;\n                var o;\n                if (b(g, t)) {\n                    o = g[t];\n                    t = \"%\" + o[0] + \"%\";\n                }\n                if (b(l, t)) {\n                    var i = l[t];\n                    if (i === s) {\n                        i = d(t);\n                    }\n                    if (typeof i === \"undefined\" && !e) {\n                        throw new a(\"intrinsic \" + r + \" exists, but is not available. Please file an issue!\");\n                    }\n                    return {\n                        alias: o,\n                        name: t,\n                        value: i\n                    };\n                }\n                throw new n(\"intrinsic \" + r + \" does not exist!\");\n            };\n            r.exports = function GetIntrinsic(r, e) {\n                if (typeof r !== \"string\" || r.length === 0) {\n                    throw new a(\"intrinsic name must be a non-empty string\");\n                }\n                if (arguments.length > 1 && typeof e !== \"boolean\") {\n                    throw new a('\"allowMissing\" argument must be a boolean');\n                }\n                if (P(/^%?[^%]*%?$/g, r) === null) {\n                    throw new n(\"`%` may not be present anywhere but at the beginning and end of the intrinsic name\");\n                }\n                var t = j(r);\n                var i = t.length > 0 ? t[0] : \"\";\n                var f = E(\"%\" + i + \"%\", e);\n                var p = f.name;\n                var u = f.value;\n                var s = false;\n                var c = f.alias;\n                if (c) {\n                    i = c[0];\n                    m(t, A([\n                        0,\n                        1\n                    ], c));\n                }\n                for(var d = 1, g = true; d < t.length; d += 1){\n                    var v = t[d];\n                    var S = h(v, 0, 1);\n                    var O = h(v, -1);\n                    if ((S === '\"' || S === \"'\" || S === \"`\" || O === '\"' || O === \"'\" || O === \"`\") && S !== O) {\n                        throw new n(\"property names with quotes must have matching quotes\");\n                    }\n                    if (v === \"constructor\" || !g) {\n                        s = true;\n                    }\n                    i += \".\" + v;\n                    p = \"%\" + i + \"%\";\n                    if (b(l, p)) {\n                        u = l[p];\n                    } else if (u != null) {\n                        if (!(v in u)) {\n                            if (!e) {\n                                throw new a(\"base intrinsic for \" + r + \" exists, but the property is not available.\");\n                            }\n                            return void o;\n                        }\n                        if (y && d + 1 >= t.length) {\n                            var w = y(u, v);\n                            g = !!w;\n                            if (g && \"get\" in w && !(\"originalValue\" in w.get)) {\n                                u = w.get;\n                            } else {\n                                u = u[v];\n                            }\n                        } else {\n                            g = b(u, v);\n                            u = u[v];\n                        }\n                        if (g && !s) {\n                            l[p] = u;\n                        }\n                    }\n                }\n                return u;\n            };\n        },\n        925: function(r, e, t) {\n            \"use strict\";\n            var o;\n            var n = SyntaxError;\n            var i = Function;\n            var a = TypeError;\n            var getEvalledConstructor = function(r) {\n                try {\n                    return i('\"use strict\"; return (' + r + \").constructor;\")();\n                } catch (r) {}\n            };\n            var y = Object.getOwnPropertyDescriptor;\n            if (y) {\n                try {\n                    y({}, \"\");\n                } catch (r) {\n                    y = null;\n                }\n            }\n            var throwTypeError = function() {\n                throw new a;\n            };\n            var f = y ? function() {\n                try {\n                    arguments.callee;\n                    return throwTypeError;\n                } catch (r) {\n                    try {\n                        return y(arguments, \"callee\").get;\n                    } catch (r) {\n                        return throwTypeError;\n                    }\n                }\n            }() : throwTypeError;\n            var p = t(115)();\n            var u = t(504)();\n            var s = Object.getPrototypeOf || (u ? function(r) {\n                return r.__proto__;\n            } : null);\n            var c = {};\n            var l = typeof Uint8Array === \"undefined\" || !s ? o : s(Uint8Array);\n            var d = {\n                \"%AggregateError%\": typeof AggregateError === \"undefined\" ? o : AggregateError,\n                \"%Array%\": Array,\n                \"%ArrayBuffer%\": typeof ArrayBuffer === \"undefined\" ? o : ArrayBuffer,\n                \"%ArrayIteratorPrototype%\": p && s ? s([][Symbol.iterator]()) : o,\n                \"%AsyncFromSyncIteratorPrototype%\": o,\n                \"%AsyncFunction%\": c,\n                \"%AsyncGenerator%\": c,\n                \"%AsyncGeneratorFunction%\": c,\n                \"%AsyncIteratorPrototype%\": c,\n                \"%Atomics%\": typeof Atomics === \"undefined\" ? o : Atomics,\n                \"%BigInt%\": typeof BigInt === \"undefined\" ? o : BigInt,\n                \"%BigInt64Array%\": typeof BigInt64Array === \"undefined\" ? o : BigInt64Array,\n                \"%BigUint64Array%\": typeof BigUint64Array === \"undefined\" ? o : BigUint64Array,\n                \"%Boolean%\": Boolean,\n                \"%DataView%\": typeof DataView === \"undefined\" ? o : DataView,\n                \"%Date%\": Date,\n                \"%decodeURI%\": decodeURI,\n                \"%decodeURIComponent%\": decodeURIComponent,\n                \"%encodeURI%\": encodeURI,\n                \"%encodeURIComponent%\": encodeURIComponent,\n                \"%Error%\": Error,\n                \"%eval%\": eval,\n                \"%EvalError%\": EvalError,\n                \"%Float32Array%\": typeof Float32Array === \"undefined\" ? o : Float32Array,\n                \"%Float64Array%\": typeof Float64Array === \"undefined\" ? o : Float64Array,\n                \"%FinalizationRegistry%\": typeof FinalizationRegistry === \"undefined\" ? o : FinalizationRegistry,\n                \"%Function%\": i,\n                \"%GeneratorFunction%\": c,\n                \"%Int8Array%\": typeof Int8Array === \"undefined\" ? o : Int8Array,\n                \"%Int16Array%\": typeof Int16Array === \"undefined\" ? o : Int16Array,\n                \"%Int32Array%\": typeof Int32Array === \"undefined\" ? o : Int32Array,\n                \"%isFinite%\": isFinite,\n                \"%isNaN%\": isNaN,\n                \"%IteratorPrototype%\": p && s ? s(s([][Symbol.iterator]())) : o,\n                \"%JSON%\": typeof JSON === \"object\" ? JSON : o,\n                \"%Map%\": typeof Map === \"undefined\" ? o : Map,\n                \"%MapIteratorPrototype%\": typeof Map === \"undefined\" || !p || !s ? o : s((new Map)[Symbol.iterator]()),\n                \"%Math%\": Math,\n                \"%Number%\": Number,\n                \"%Object%\": Object,\n                \"%parseFloat%\": parseFloat,\n                \"%parseInt%\": parseInt,\n                \"%Promise%\": typeof Promise === \"undefined\" ? o : Promise,\n                \"%Proxy%\": typeof Proxy === \"undefined\" ? o : Proxy,\n                \"%RangeError%\": RangeError,\n                \"%ReferenceError%\": ReferenceError,\n                \"%Reflect%\": typeof Reflect === \"undefined\" ? o : Reflect,\n                \"%RegExp%\": RegExp,\n                \"%Set%\": typeof Set === \"undefined\" ? o : Set,\n                \"%SetIteratorPrototype%\": typeof Set === \"undefined\" || !p || !s ? o : s((new Set)[Symbol.iterator]()),\n                \"%SharedArrayBuffer%\": typeof SharedArrayBuffer === \"undefined\" ? o : SharedArrayBuffer,\n                \"%String%\": String,\n                \"%StringIteratorPrototype%\": p && s ? s(\"\"[Symbol.iterator]()) : o,\n                \"%Symbol%\": p ? Symbol : o,\n                \"%SyntaxError%\": n,\n                \"%ThrowTypeError%\": f,\n                \"%TypedArray%\": l,\n                \"%TypeError%\": a,\n                \"%Uint8Array%\": typeof Uint8Array === \"undefined\" ? o : Uint8Array,\n                \"%Uint8ClampedArray%\": typeof Uint8ClampedArray === \"undefined\" ? o : Uint8ClampedArray,\n                \"%Uint16Array%\": typeof Uint16Array === \"undefined\" ? o : Uint16Array,\n                \"%Uint32Array%\": typeof Uint32Array === \"undefined\" ? o : Uint32Array,\n                \"%URIError%\": URIError,\n                \"%WeakMap%\": typeof WeakMap === \"undefined\" ? o : WeakMap,\n                \"%WeakRef%\": typeof WeakRef === \"undefined\" ? o : WeakRef,\n                \"%WeakSet%\": typeof WeakSet === \"undefined\" ? o : WeakSet\n            };\n            if (s) {\n                try {\n                    null.error;\n                } catch (r) {\n                    var g = s(s(r));\n                    d[\"%Error.prototype%\"] = g;\n                }\n            }\n            var v = function doEval(r) {\n                var e;\n                if (r === \"%AsyncFunction%\") {\n                    e = getEvalledConstructor(\"async function () {}\");\n                } else if (r === \"%GeneratorFunction%\") {\n                    e = getEvalledConstructor(\"function* () {}\");\n                } else if (r === \"%AsyncGeneratorFunction%\") {\n                    e = getEvalledConstructor(\"async function* () {}\");\n                } else if (r === \"%AsyncGenerator%\") {\n                    var t = doEval(\"%AsyncGeneratorFunction%\");\n                    if (t) {\n                        e = t.prototype;\n                    }\n                } else if (r === \"%AsyncIteratorPrototype%\") {\n                    var o = doEval(\"%AsyncGenerator%\");\n                    if (o && s) {\n                        e = s(o.prototype);\n                    }\n                }\n                d[r] = e;\n                return e;\n            };\n            var b = {\n                \"%ArrayBufferPrototype%\": [\n                    \"ArrayBuffer\",\n                    \"prototype\"\n                ],\n                \"%ArrayPrototype%\": [\n                    \"Array\",\n                    \"prototype\"\n                ],\n                \"%ArrayProto_entries%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"entries\"\n                ],\n                \"%ArrayProto_forEach%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"forEach\"\n                ],\n                \"%ArrayProto_keys%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"keys\"\n                ],\n                \"%ArrayProto_values%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"values\"\n                ],\n                \"%AsyncFunctionPrototype%\": [\n                    \"AsyncFunction\",\n                    \"prototype\"\n                ],\n                \"%AsyncGenerator%\": [\n                    \"AsyncGeneratorFunction\",\n                    \"prototype\"\n                ],\n                \"%AsyncGeneratorPrototype%\": [\n                    \"AsyncGeneratorFunction\",\n                    \"prototype\",\n                    \"prototype\"\n                ],\n                \"%BooleanPrototype%\": [\n                    \"Boolean\",\n                    \"prototype\"\n                ],\n                \"%DataViewPrototype%\": [\n                    \"DataView\",\n                    \"prototype\"\n                ],\n                \"%DatePrototype%\": [\n                    \"Date\",\n                    \"prototype\"\n                ],\n                \"%ErrorPrototype%\": [\n                    \"Error\",\n                    \"prototype\"\n                ],\n                \"%EvalErrorPrototype%\": [\n                    \"EvalError\",\n                    \"prototype\"\n                ],\n                \"%Float32ArrayPrototype%\": [\n                    \"Float32Array\",\n                    \"prototype\"\n                ],\n                \"%Float64ArrayPrototype%\": [\n                    \"Float64Array\",\n                    \"prototype\"\n                ],\n                \"%FunctionPrototype%\": [\n                    \"Function\",\n                    \"prototype\"\n                ],\n                \"%Generator%\": [\n                    \"GeneratorFunction\",\n                    \"prototype\"\n                ],\n                \"%GeneratorPrototype%\": [\n                    \"GeneratorFunction\",\n                    \"prototype\",\n                    \"prototype\"\n                ],\n                \"%Int8ArrayPrototype%\": [\n                    \"Int8Array\",\n                    \"prototype\"\n                ],\n                \"%Int16ArrayPrototype%\": [\n                    \"Int16Array\",\n                    \"prototype\"\n                ],\n                \"%Int32ArrayPrototype%\": [\n                    \"Int32Array\",\n                    \"prototype\"\n                ],\n                \"%JSONParse%\": [\n                    \"JSON\",\n                    \"parse\"\n                ],\n                \"%JSONStringify%\": [\n                    \"JSON\",\n                    \"stringify\"\n                ],\n                \"%MapPrototype%\": [\n                    \"Map\",\n                    \"prototype\"\n                ],\n                \"%NumberPrototype%\": [\n                    \"Number\",\n                    \"prototype\"\n                ],\n                \"%ObjectPrototype%\": [\n                    \"Object\",\n                    \"prototype\"\n                ],\n                \"%ObjProto_toString%\": [\n                    \"Object\",\n                    \"prototype\",\n                    \"toString\"\n                ],\n                \"%ObjProto_valueOf%\": [\n                    \"Object\",\n                    \"prototype\",\n                    \"valueOf\"\n                ],\n                \"%PromisePrototype%\": [\n                    \"Promise\",\n                    \"prototype\"\n                ],\n                \"%PromiseProto_then%\": [\n                    \"Promise\",\n                    \"prototype\",\n                    \"then\"\n                ],\n                \"%Promise_all%\": [\n                    \"Promise\",\n                    \"all\"\n                ],\n                \"%Promise_reject%\": [\n                    \"Promise\",\n                    \"reject\"\n                ],\n                \"%Promise_resolve%\": [\n                    \"Promise\",\n                    \"resolve\"\n                ],\n                \"%RangeErrorPrototype%\": [\n                    \"RangeError\",\n                    \"prototype\"\n                ],\n                \"%ReferenceErrorPrototype%\": [\n                    \"ReferenceError\",\n                    \"prototype\"\n                ],\n                \"%RegExpPrototype%\": [\n                    \"RegExp\",\n                    \"prototype\"\n                ],\n                \"%SetPrototype%\": [\n                    \"Set\",\n                    \"prototype\"\n                ],\n                \"%SharedArrayBufferPrototype%\": [\n                    \"SharedArrayBuffer\",\n                    \"prototype\"\n                ],\n                \"%StringPrototype%\": [\n                    \"String\",\n                    \"prototype\"\n                ],\n                \"%SymbolPrototype%\": [\n                    \"Symbol\",\n                    \"prototype\"\n                ],\n                \"%SyntaxErrorPrototype%\": [\n                    \"SyntaxError\",\n                    \"prototype\"\n                ],\n                \"%TypedArrayPrototype%\": [\n                    \"TypedArray\",\n                    \"prototype\"\n                ],\n                \"%TypeErrorPrototype%\": [\n                    \"TypeError\",\n                    \"prototype\"\n                ],\n                \"%Uint8ArrayPrototype%\": [\n                    \"Uint8Array\",\n                    \"prototype\"\n                ],\n                \"%Uint8ClampedArrayPrototype%\": [\n                    \"Uint8ClampedArray\",\n                    \"prototype\"\n                ],\n                \"%Uint16ArrayPrototype%\": [\n                    \"Uint16Array\",\n                    \"prototype\"\n                ],\n                \"%Uint32ArrayPrototype%\": [\n                    \"Uint32Array\",\n                    \"prototype\"\n                ],\n                \"%URIErrorPrototype%\": [\n                    \"URIError\",\n                    \"prototype\"\n                ],\n                \"%WeakMapPrototype%\": [\n                    \"WeakMap\",\n                    \"prototype\"\n                ],\n                \"%WeakSetPrototype%\": [\n                    \"WeakSet\",\n                    \"prototype\"\n                ]\n            };\n            var A = t(174);\n            var m = t(101);\n            var S = A.call(Function.call, Array.prototype.concat);\n            var h = A.call(Function.apply, Array.prototype.splice);\n            var P = A.call(Function.call, String.prototype.replace);\n            var O = A.call(Function.call, String.prototype.slice);\n            var w = A.call(Function.call, RegExp.prototype.exec);\n            var j = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\n            var E = /\\\\(\\\\)?/g;\n            var I = function stringToPath(r) {\n                var e = O(r, 0, 1);\n                var t = O(r, -1);\n                if (e === \"%\" && t !== \"%\") {\n                    throw new n(\"invalid intrinsic syntax, expected closing `%`\");\n                } else if (t === \"%\" && e !== \"%\") {\n                    throw new n(\"invalid intrinsic syntax, expected opening `%`\");\n                }\n                var o = [];\n                P(r, j, function(r, e, t, n) {\n                    o[o.length] = t ? P(n, E, \"$1\") : e || r;\n                });\n                return o;\n            };\n            var B = function getBaseIntrinsic(r, e) {\n                var t = r;\n                var o;\n                if (m(b, t)) {\n                    o = b[t];\n                    t = \"%\" + o[0] + \"%\";\n                }\n                if (m(d, t)) {\n                    var i = d[t];\n                    if (i === c) {\n                        i = v(t);\n                    }\n                    if (typeof i === \"undefined\" && !e) {\n                        throw new a(\"intrinsic \" + r + \" exists, but is not available. Please file an issue!\");\n                    }\n                    return {\n                        alias: o,\n                        name: t,\n                        value: i\n                    };\n                }\n                throw new n(\"intrinsic \" + r + \" does not exist!\");\n            };\n            r.exports = function GetIntrinsic(r, e) {\n                if (typeof r !== \"string\" || r.length === 0) {\n                    throw new a(\"intrinsic name must be a non-empty string\");\n                }\n                if (arguments.length > 1 && typeof e !== \"boolean\") {\n                    throw new a('\"allowMissing\" argument must be a boolean');\n                }\n                if (w(/^%?[^%]*%?$/, r) === null) {\n                    throw new n(\"`%` may not be present anywhere but at the beginning and end of the intrinsic name\");\n                }\n                var t = I(r);\n                var i = t.length > 0 ? t[0] : \"\";\n                var f = B(\"%\" + i + \"%\", e);\n                var p = f.name;\n                var u = f.value;\n                var s = false;\n                var c = f.alias;\n                if (c) {\n                    i = c[0];\n                    h(t, S([\n                        0,\n                        1\n                    ], c));\n                }\n                for(var l = 1, g = true; l < t.length; l += 1){\n                    var v = t[l];\n                    var b = O(v, 0, 1);\n                    var A = O(v, -1);\n                    if ((b === '\"' || b === \"'\" || b === \"`\" || A === '\"' || A === \"'\" || A === \"`\") && b !== A) {\n                        throw new n(\"property names with quotes must have matching quotes\");\n                    }\n                    if (v === \"constructor\" || !g) {\n                        s = true;\n                    }\n                    i += \".\" + v;\n                    p = \"%\" + i + \"%\";\n                    if (m(d, p)) {\n                        u = d[p];\n                    } else if (u != null) {\n                        if (!(v in u)) {\n                            if (!e) {\n                                throw new a(\"base intrinsic for \" + r + \" exists, but the property is not available.\");\n                            }\n                            return void o;\n                        }\n                        if (y && l + 1 >= t.length) {\n                            var P = y(u, v);\n                            g = !!P;\n                            if (g && \"get\" in P && !(\"originalValue\" in P.get)) {\n                                u = P.get;\n                            } else {\n                                u = u[v];\n                            }\n                        } else {\n                            g = m(u, v);\n                            u = u[v];\n                        }\n                        if (g && !s) {\n                            d[p] = u;\n                        }\n                    }\n                }\n                return u;\n            };\n        },\n        504: function(r) {\n            \"use strict\";\n            var e = {\n                foo: {}\n            };\n            var t = Object;\n            r.exports = function hasProto() {\n                return ({\n                    __proto__: e\n                }).foo === e.foo && !(({\n                    __proto__: null\n                }) instanceof t);\n            };\n        },\n        942: function(r, e, t) {\n            \"use strict\";\n            var o = typeof Symbol !== \"undefined\" && Symbol;\n            var n = t(773);\n            r.exports = function hasNativeSymbols() {\n                if (typeof o !== \"function\") {\n                    return false;\n                }\n                if (typeof Symbol !== \"function\") {\n                    return false;\n                }\n                if (typeof o(\"foo\") !== \"symbol\") {\n                    return false;\n                }\n                if (typeof Symbol(\"bar\") !== \"symbol\") {\n                    return false;\n                }\n                return n();\n            };\n        },\n        773: function(r) {\n            \"use strict\";\n            r.exports = function hasSymbols() {\n                if (typeof Symbol !== \"function\" || typeof Object.getOwnPropertySymbols !== \"function\") {\n                    return false;\n                }\n                if (typeof Symbol.iterator === \"symbol\") {\n                    return true;\n                }\n                var r = {};\n                var e = Symbol(\"test\");\n                var t = Object(e);\n                if (typeof e === \"string\") {\n                    return false;\n                }\n                if (Object.prototype.toString.call(e) !== \"[object Symbol]\") {\n                    return false;\n                }\n                if (Object.prototype.toString.call(t) !== \"[object Symbol]\") {\n                    return false;\n                }\n                var o = 42;\n                r[e] = o;\n                for(e in r){\n                    return false;\n                }\n                if (typeof Object.keys === \"function\" && Object.keys(r).length !== 0) {\n                    return false;\n                }\n                if (typeof Object.getOwnPropertyNames === \"function\" && Object.getOwnPropertyNames(r).length !== 0) {\n                    return false;\n                }\n                var n = Object.getOwnPropertySymbols(r);\n                if (n.length !== 1 || n[0] !== e) {\n                    return false;\n                }\n                if (!Object.prototype.propertyIsEnumerable.call(r, e)) {\n                    return false;\n                }\n                if (typeof Object.getOwnPropertyDescriptor === \"function\") {\n                    var i = Object.getOwnPropertyDescriptor(r, e);\n                    if (i.value !== o || i.enumerable !== true) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n        },\n        115: function(r, e, t) {\n            \"use strict\";\n            var o = typeof Symbol !== \"undefined\" && Symbol;\n            var n = t(832);\n            r.exports = function hasNativeSymbols() {\n                if (typeof o !== \"function\") {\n                    return false;\n                }\n                if (typeof Symbol !== \"function\") {\n                    return false;\n                }\n                if (typeof o(\"foo\") !== \"symbol\") {\n                    return false;\n                }\n                if (typeof Symbol(\"bar\") !== \"symbol\") {\n                    return false;\n                }\n                return n();\n            };\n        },\n        832: function(r) {\n            \"use strict\";\n            r.exports = function hasSymbols() {\n                if (typeof Symbol !== \"function\" || typeof Object.getOwnPropertySymbols !== \"function\") {\n                    return false;\n                }\n                if (typeof Symbol.iterator === \"symbol\") {\n                    return true;\n                }\n                var r = {};\n                var e = Symbol(\"test\");\n                var t = Object(e);\n                if (typeof e === \"string\") {\n                    return false;\n                }\n                if (Object.prototype.toString.call(e) !== \"[object Symbol]\") {\n                    return false;\n                }\n                if (Object.prototype.toString.call(t) !== \"[object Symbol]\") {\n                    return false;\n                }\n                var o = 42;\n                r[e] = o;\n                for(e in r){\n                    return false;\n                }\n                if (typeof Object.keys === \"function\" && Object.keys(r).length !== 0) {\n                    return false;\n                }\n                if (typeof Object.getOwnPropertyNames === \"function\" && Object.getOwnPropertyNames(r).length !== 0) {\n                    return false;\n                }\n                var n = Object.getOwnPropertySymbols(r);\n                if (n.length !== 1 || n[0] !== e) {\n                    return false;\n                }\n                if (!Object.prototype.propertyIsEnumerable.call(r, e)) {\n                    return false;\n                }\n                if (typeof Object.getOwnPropertyDescriptor === \"function\") {\n                    var i = Object.getOwnPropertyDescriptor(r, e);\n                    if (i.value !== o || i.enumerable !== true) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n        },\n        101: function(r, e, t) {\n            \"use strict\";\n            var o = t(174);\n            r.exports = o.call(Function.call, Object.prototype.hasOwnProperty);\n        },\n        782: function(r) {\n            if (typeof Object.create === \"function\") {\n                r.exports = function inherits(r, e) {\n                    if (e) {\n                        r.super_ = e;\n                        r.prototype = Object.create(e.prototype, {\n                            constructor: {\n                                value: r,\n                                enumerable: false,\n                                writable: true,\n                                configurable: true\n                            }\n                        });\n                    }\n                };\n            } else {\n                r.exports = function inherits(r, e) {\n                    if (e) {\n                        r.super_ = e;\n                        var TempCtor = function() {};\n                        TempCtor.prototype = e.prototype;\n                        r.prototype = new TempCtor;\n                        r.prototype.constructor = r;\n                    }\n                };\n            }\n        },\n        157: function(r) {\n            \"use strict\";\n            var e = typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\";\n            var t = Object.prototype.toString;\n            var o = function isArguments(r) {\n                if (e && r && typeof r === \"object\" && Symbol.toStringTag in r) {\n                    return false;\n                }\n                return t.call(r) === \"[object Arguments]\";\n            };\n            var n = function isArguments(r) {\n                if (o(r)) {\n                    return true;\n                }\n                return r !== null && typeof r === \"object\" && typeof r.length === \"number\" && r.length >= 0 && t.call(r) !== \"[object Array]\" && t.call(r.callee) === \"[object Function]\";\n            };\n            var i = function() {\n                return o(arguments);\n            }();\n            o.isLegacyArguments = n;\n            r.exports = i ? o : n;\n        },\n        391: function(r) {\n            \"use strict\";\n            var e = Object.prototype.toString;\n            var t = Function.prototype.toString;\n            var o = /^\\s*(?:function)?\\*/;\n            var n = typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\";\n            var i = Object.getPrototypeOf;\n            var getGeneratorFunc = function() {\n                if (!n) {\n                    return false;\n                }\n                try {\n                    return Function(\"return function*() {}\")();\n                } catch (r) {}\n            };\n            var a = getGeneratorFunc();\n            var y = a ? i(a) : {};\n            r.exports = function isGeneratorFunction(r) {\n                if (typeof r !== \"function\") {\n                    return false;\n                }\n                if (o.test(t.call(r))) {\n                    return true;\n                }\n                if (!n) {\n                    var a = e.call(r);\n                    return a === \"[object GeneratorFunction]\";\n                }\n                return i(r) === y;\n            };\n        },\n        994: function(r, e, t) {\n            \"use strict\";\n            var o = t(144);\n            var n = t(349);\n            var i = t(256);\n            var a = i(\"Object.prototype.toString\");\n            var y = t(942)();\n            var f = y && typeof Symbol.toStringTag === \"symbol\";\n            var p = n();\n            var u = i(\"Array.prototype.indexOf\", true) || function indexOf(r, e) {\n                for(var t = 0; t < r.length; t += 1){\n                    if (r[t] === e) {\n                        return t;\n                    }\n                }\n                return -1;\n            };\n            var s = i(\"String.prototype.slice\");\n            var c = {};\n            var l = t(24);\n            var d = Object.getPrototypeOf;\n            if (f && l && d) {\n                o(p, function(r) {\n                    var e = new __webpack_require__.g[r];\n                    if (!(Symbol.toStringTag in e)) {\n                        throw new EvalError(\"this engine has support for Symbol.toStringTag, but \" + r + \" does not have the property! Please report this.\");\n                    }\n                    var t = d(e);\n                    var o = l(t, Symbol.toStringTag);\n                    if (!o) {\n                        var n = d(t);\n                        o = l(n, Symbol.toStringTag);\n                    }\n                    c[r] = o.get;\n                });\n            }\n            var g = function tryAllTypedArrays(r) {\n                var e = false;\n                o(c, function(t, o) {\n                    if (!e) {\n                        try {\n                            e = t.call(r) === o;\n                        } catch (r) {}\n                    }\n                });\n                return e;\n            };\n            r.exports = function isTypedArray(r) {\n                if (!r || typeof r !== \"object\") {\n                    return false;\n                }\n                if (!f) {\n                    var e = s(a(r), 8, -1);\n                    return u(p, e) > -1;\n                }\n                if (!l) {\n                    return false;\n                }\n                return g(r);\n            };\n        },\n        369: function(r) {\n            r.exports = function isBuffer(r) {\n                return r instanceof Buffer;\n            };\n        },\n        584: function(r, e, t) {\n            \"use strict\";\n            var o = t(157);\n            var n = t(391);\n            var i = t(490);\n            var a = t(994);\n            function uncurryThis(r) {\n                return r.call.bind(r);\n            }\n            var y = typeof BigInt !== \"undefined\";\n            var f = typeof Symbol !== \"undefined\";\n            var p = uncurryThis(Object.prototype.toString);\n            var u = uncurryThis(Number.prototype.valueOf);\n            var s = uncurryThis(String.prototype.valueOf);\n            var c = uncurryThis(Boolean.prototype.valueOf);\n            if (y) {\n                var l = uncurryThis(BigInt.prototype.valueOf);\n            }\n            if (f) {\n                var d = uncurryThis(Symbol.prototype.valueOf);\n            }\n            function checkBoxedPrimitive(r, e) {\n                if (typeof r !== \"object\") {\n                    return false;\n                }\n                try {\n                    e(r);\n                    return true;\n                } catch (r) {\n                    return false;\n                }\n            }\n            e.isArgumentsObject = o;\n            e.isGeneratorFunction = n;\n            e.isTypedArray = a;\n            function isPromise(r) {\n                return typeof Promise !== \"undefined\" && r instanceof Promise || r !== null && typeof r === \"object\" && typeof r.then === \"function\" && typeof r.catch === \"function\";\n            }\n            e.isPromise = isPromise;\n            function isArrayBufferView(r) {\n                if (typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView) {\n                    return ArrayBuffer.isView(r);\n                }\n                return a(r) || isDataView(r);\n            }\n            e.isArrayBufferView = isArrayBufferView;\n            function isUint8Array(r) {\n                return i(r) === \"Uint8Array\";\n            }\n            e.isUint8Array = isUint8Array;\n            function isUint8ClampedArray(r) {\n                return i(r) === \"Uint8ClampedArray\";\n            }\n            e.isUint8ClampedArray = isUint8ClampedArray;\n            function isUint16Array(r) {\n                return i(r) === \"Uint16Array\";\n            }\n            e.isUint16Array = isUint16Array;\n            function isUint32Array(r) {\n                return i(r) === \"Uint32Array\";\n            }\n            e.isUint32Array = isUint32Array;\n            function isInt8Array(r) {\n                return i(r) === \"Int8Array\";\n            }\n            e.isInt8Array = isInt8Array;\n            function isInt16Array(r) {\n                return i(r) === \"Int16Array\";\n            }\n            e.isInt16Array = isInt16Array;\n            function isInt32Array(r) {\n                return i(r) === \"Int32Array\";\n            }\n            e.isInt32Array = isInt32Array;\n            function isFloat32Array(r) {\n                return i(r) === \"Float32Array\";\n            }\n            e.isFloat32Array = isFloat32Array;\n            function isFloat64Array(r) {\n                return i(r) === \"Float64Array\";\n            }\n            e.isFloat64Array = isFloat64Array;\n            function isBigInt64Array(r) {\n                return i(r) === \"BigInt64Array\";\n            }\n            e.isBigInt64Array = isBigInt64Array;\n            function isBigUint64Array(r) {\n                return i(r) === \"BigUint64Array\";\n            }\n            e.isBigUint64Array = isBigUint64Array;\n            function isMapToString(r) {\n                return p(r) === \"[object Map]\";\n            }\n            isMapToString.working = typeof Map !== \"undefined\" && isMapToString(new Map);\n            function isMap(r) {\n                if (typeof Map === \"undefined\") {\n                    return false;\n                }\n                return isMapToString.working ? isMapToString(r) : r instanceof Map;\n            }\n            e.isMap = isMap;\n            function isSetToString(r) {\n                return p(r) === \"[object Set]\";\n            }\n            isSetToString.working = typeof Set !== \"undefined\" && isSetToString(new Set);\n            function isSet(r) {\n                if (typeof Set === \"undefined\") {\n                    return false;\n                }\n                return isSetToString.working ? isSetToString(r) : r instanceof Set;\n            }\n            e.isSet = isSet;\n            function isWeakMapToString(r) {\n                return p(r) === \"[object WeakMap]\";\n            }\n            isWeakMapToString.working = typeof WeakMap !== \"undefined\" && isWeakMapToString(new WeakMap);\n            function isWeakMap(r) {\n                if (typeof WeakMap === \"undefined\") {\n                    return false;\n                }\n                return isWeakMapToString.working ? isWeakMapToString(r) : r instanceof WeakMap;\n            }\n            e.isWeakMap = isWeakMap;\n            function isWeakSetToString(r) {\n                return p(r) === \"[object WeakSet]\";\n            }\n            isWeakSetToString.working = typeof WeakSet !== \"undefined\" && isWeakSetToString(new WeakSet);\n            function isWeakSet(r) {\n                return isWeakSetToString(r);\n            }\n            e.isWeakSet = isWeakSet;\n            function isArrayBufferToString(r) {\n                return p(r) === \"[object ArrayBuffer]\";\n            }\n            isArrayBufferToString.working = typeof ArrayBuffer !== \"undefined\" && isArrayBufferToString(new ArrayBuffer);\n            function isArrayBuffer(r) {\n                if (typeof ArrayBuffer === \"undefined\") {\n                    return false;\n                }\n                return isArrayBufferToString.working ? isArrayBufferToString(r) : r instanceof ArrayBuffer;\n            }\n            e.isArrayBuffer = isArrayBuffer;\n            function isDataViewToString(r) {\n                return p(r) === \"[object DataView]\";\n            }\n            isDataViewToString.working = typeof ArrayBuffer !== \"undefined\" && typeof DataView !== \"undefined\" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));\n            function isDataView(r) {\n                if (typeof DataView === \"undefined\") {\n                    return false;\n                }\n                return isDataViewToString.working ? isDataViewToString(r) : r instanceof DataView;\n            }\n            e.isDataView = isDataView;\n            var g = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : undefined;\n            function isSharedArrayBufferToString(r) {\n                return p(r) === \"[object SharedArrayBuffer]\";\n            }\n            function isSharedArrayBuffer(r) {\n                if (typeof g === \"undefined\") {\n                    return false;\n                }\n                if (typeof isSharedArrayBufferToString.working === \"undefined\") {\n                    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new g);\n                }\n                return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(r) : r instanceof g;\n            }\n            e.isSharedArrayBuffer = isSharedArrayBuffer;\n            function isAsyncFunction(r) {\n                return p(r) === \"[object AsyncFunction]\";\n            }\n            e.isAsyncFunction = isAsyncFunction;\n            function isMapIterator(r) {\n                return p(r) === \"[object Map Iterator]\";\n            }\n            e.isMapIterator = isMapIterator;\n            function isSetIterator(r) {\n                return p(r) === \"[object Set Iterator]\";\n            }\n            e.isSetIterator = isSetIterator;\n            function isGeneratorObject(r) {\n                return p(r) === \"[object Generator]\";\n            }\n            e.isGeneratorObject = isGeneratorObject;\n            function isWebAssemblyCompiledModule(r) {\n                return p(r) === \"[object WebAssembly.Module]\";\n            }\n            e.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n            function isNumberObject(r) {\n                return checkBoxedPrimitive(r, u);\n            }\n            e.isNumberObject = isNumberObject;\n            function isStringObject(r) {\n                return checkBoxedPrimitive(r, s);\n            }\n            e.isStringObject = isStringObject;\n            function isBooleanObject(r) {\n                return checkBoxedPrimitive(r, c);\n            }\n            e.isBooleanObject = isBooleanObject;\n            function isBigIntObject(r) {\n                return y && checkBoxedPrimitive(r, l);\n            }\n            e.isBigIntObject = isBigIntObject;\n            function isSymbolObject(r) {\n                return f && checkBoxedPrimitive(r, d);\n            }\n            e.isSymbolObject = isSymbolObject;\n            function isBoxedPrimitive(r) {\n                return isNumberObject(r) || isStringObject(r) || isBooleanObject(r) || isBigIntObject(r) || isSymbolObject(r);\n            }\n            e.isBoxedPrimitive = isBoxedPrimitive;\n            function isAnyArrayBuffer(r) {\n                return typeof Uint8Array !== \"undefined\" && (isArrayBuffer(r) || isSharedArrayBuffer(r));\n            }\n            e.isAnyArrayBuffer = isAnyArrayBuffer;\n            [\n                \"isProxy\",\n                \"isExternal\",\n                \"isModuleNamespaceObject\"\n            ].forEach(function(r) {\n                Object.defineProperty(e, r, {\n                    enumerable: false,\n                    value: function() {\n                        throw new Error(r + \" is not supported in userland\");\n                    }\n                });\n            });\n        },\n        177: function(r, e, t) {\n            var o = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(r) {\n                var e = Object.keys(r);\n                var t = {};\n                for(var o = 0; o < e.length; o++){\n                    t[e[o]] = Object.getOwnPropertyDescriptor(r, e[o]);\n                }\n                return t;\n            };\n            var n = /%[sdj%]/g;\n            e.format = function(r) {\n                if (!isString(r)) {\n                    var e = [];\n                    for(var t = 0; t < arguments.length; t++){\n                        e.push(inspect(arguments[t]));\n                    }\n                    return e.join(\" \");\n                }\n                var t = 1;\n                var o = arguments;\n                var i = o.length;\n                var a = String(r).replace(n, function(r) {\n                    if (r === \"%%\") return \"%\";\n                    if (t >= i) return r;\n                    switch(r){\n                        case \"%s\":\n                            return String(o[t++]);\n                        case \"%d\":\n                            return Number(o[t++]);\n                        case \"%j\":\n                            try {\n                                return JSON.stringify(o[t++]);\n                            } catch (r) {\n                                return \"[Circular]\";\n                            }\n                        default:\n                            return r;\n                    }\n                });\n                for(var y = o[t]; t < i; y = o[++t]){\n                    if (isNull(y) || !isObject(y)) {\n                        a += \" \" + y;\n                    } else {\n                        a += \" \" + inspect(y);\n                    }\n                }\n                return a;\n            };\n            e.deprecate = function(r, t) {\n                if (typeof process !== \"undefined\" && process.noDeprecation === true) {\n                    return r;\n                }\n                if (typeof process === \"undefined\") {\n                    return function() {\n                        return e.deprecate(r, t).apply(this, arguments);\n                    };\n                }\n                var o = false;\n                function deprecated() {\n                    if (!o) {\n                        if (process.throwDeprecation) {\n                            throw new Error(t);\n                        } else if (process.traceDeprecation) {\n                            console.trace(t);\n                        } else {\n                            console.error(t);\n                        }\n                        o = true;\n                    }\n                    return r.apply(this, arguments);\n                }\n                return deprecated;\n            };\n            var i = {};\n            var a = /^$/;\n            if (process.env.NODE_DEBUG) {\n                var y = process.env.NODE_DEBUG;\n                y = y.replace(/[|\\\\{}()[\\]^$+?.]/g, \"\\\\$&\").replace(/\\*/g, \".*\").replace(/,/g, \"$|^\").toUpperCase();\n                a = new RegExp(\"^\" + y + \"$\", \"i\");\n            }\n            e.debuglog = function(r) {\n                r = r.toUpperCase();\n                if (!i[r]) {\n                    if (a.test(r)) {\n                        var t = process.pid;\n                        i[r] = function() {\n                            var o = e.format.apply(e, arguments);\n                            console.error(\"%s %d: %s\", r, t, o);\n                        };\n                    } else {\n                        i[r] = function() {};\n                    }\n                }\n                return i[r];\n            };\n            function inspect(r, t) {\n                var o = {\n                    seen: [],\n                    stylize: stylizeNoColor\n                };\n                if (arguments.length >= 3) o.depth = arguments[2];\n                if (arguments.length >= 4) o.colors = arguments[3];\n                if (isBoolean(t)) {\n                    o.showHidden = t;\n                } else if (t) {\n                    e._extend(o, t);\n                }\n                if (isUndefined(o.showHidden)) o.showHidden = false;\n                if (isUndefined(o.depth)) o.depth = 2;\n                if (isUndefined(o.colors)) o.colors = false;\n                if (isUndefined(o.customInspect)) o.customInspect = true;\n                if (o.colors) o.stylize = stylizeWithColor;\n                return formatValue(o, r, o.depth);\n            }\n            e.inspect = inspect;\n            inspect.colors = {\n                bold: [\n                    1,\n                    22\n                ],\n                italic: [\n                    3,\n                    23\n                ],\n                underline: [\n                    4,\n                    24\n                ],\n                inverse: [\n                    7,\n                    27\n                ],\n                white: [\n                    37,\n                    39\n                ],\n                grey: [\n                    90,\n                    39\n                ],\n                black: [\n                    30,\n                    39\n                ],\n                blue: [\n                    34,\n                    39\n                ],\n                cyan: [\n                    36,\n                    39\n                ],\n                green: [\n                    32,\n                    39\n                ],\n                magenta: [\n                    35,\n                    39\n                ],\n                red: [\n                    31,\n                    39\n                ],\n                yellow: [\n                    33,\n                    39\n                ]\n            };\n            inspect.styles = {\n                special: \"cyan\",\n                number: \"yellow\",\n                boolean: \"yellow\",\n                undefined: \"grey\",\n                null: \"bold\",\n                string: \"green\",\n                date: \"magenta\",\n                regexp: \"red\"\n            };\n            function stylizeWithColor(r, e) {\n                var t = inspect.styles[e];\n                if (t) {\n                    return \"\\x1b[\" + inspect.colors[t][0] + \"m\" + r + \"\\x1b[\" + inspect.colors[t][1] + \"m\";\n                } else {\n                    return r;\n                }\n            }\n            function stylizeNoColor(r, e) {\n                return r;\n            }\n            function arrayToHash(r) {\n                var e = {};\n                r.forEach(function(r, t) {\n                    e[r] = true;\n                });\n                return e;\n            }\n            function formatValue(r, t, o) {\n                if (r.customInspect && t && isFunction(t.inspect) && t.inspect !== e.inspect && !(t.constructor && t.constructor.prototype === t)) {\n                    var n = t.inspect(o, r);\n                    if (!isString(n)) {\n                        n = formatValue(r, n, o);\n                    }\n                    return n;\n                }\n                var i = formatPrimitive(r, t);\n                if (i) {\n                    return i;\n                }\n                var a = Object.keys(t);\n                var y = arrayToHash(a);\n                if (r.showHidden) {\n                    a = Object.getOwnPropertyNames(t);\n                }\n                if (isError(t) && (a.indexOf(\"message\") >= 0 || a.indexOf(\"description\") >= 0)) {\n                    return formatError(t);\n                }\n                if (a.length === 0) {\n                    if (isFunction(t)) {\n                        var f = t.name ? \": \" + t.name : \"\";\n                        return r.stylize(\"[Function\" + f + \"]\", \"special\");\n                    }\n                    if (isRegExp(t)) {\n                        return r.stylize(RegExp.prototype.toString.call(t), \"regexp\");\n                    }\n                    if (isDate(t)) {\n                        return r.stylize(Date.prototype.toString.call(t), \"date\");\n                    }\n                    if (isError(t)) {\n                        return formatError(t);\n                    }\n                }\n                var p = \"\", u = false, s = [\n                    \"{\",\n                    \"}\"\n                ];\n                if (isArray(t)) {\n                    u = true;\n                    s = [\n                        \"[\",\n                        \"]\"\n                    ];\n                }\n                if (isFunction(t)) {\n                    var c = t.name ? \": \" + t.name : \"\";\n                    p = \" [Function\" + c + \"]\";\n                }\n                if (isRegExp(t)) {\n                    p = \" \" + RegExp.prototype.toString.call(t);\n                }\n                if (isDate(t)) {\n                    p = \" \" + Date.prototype.toUTCString.call(t);\n                }\n                if (isError(t)) {\n                    p = \" \" + formatError(t);\n                }\n                if (a.length === 0 && (!u || t.length == 0)) {\n                    return s[0] + p + s[1];\n                }\n                if (o < 0) {\n                    if (isRegExp(t)) {\n                        return r.stylize(RegExp.prototype.toString.call(t), \"regexp\");\n                    } else {\n                        return r.stylize(\"[Object]\", \"special\");\n                    }\n                }\n                r.seen.push(t);\n                var l;\n                if (u) {\n                    l = formatArray(r, t, o, y, a);\n                } else {\n                    l = a.map(function(e) {\n                        return formatProperty(r, t, o, y, e, u);\n                    });\n                }\n                r.seen.pop();\n                return reduceToSingleString(l, p, s);\n            }\n            function formatPrimitive(r, e) {\n                if (isUndefined(e)) return r.stylize(\"undefined\", \"undefined\");\n                if (isString(e)) {\n                    var t = \"'\" + JSON.stringify(e).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n                    return r.stylize(t, \"string\");\n                }\n                if (isNumber(e)) return r.stylize(\"\" + e, \"number\");\n                if (isBoolean(e)) return r.stylize(\"\" + e, \"boolean\");\n                if (isNull(e)) return r.stylize(\"null\", \"null\");\n            }\n            function formatError(r) {\n                return \"[\" + Error.prototype.toString.call(r) + \"]\";\n            }\n            function formatArray(r, e, t, o, n) {\n                var i = [];\n                for(var a = 0, y = e.length; a < y; ++a){\n                    if (hasOwnProperty(e, String(a))) {\n                        i.push(formatProperty(r, e, t, o, String(a), true));\n                    } else {\n                        i.push(\"\");\n                    }\n                }\n                n.forEach(function(n) {\n                    if (!n.match(/^\\d+$/)) {\n                        i.push(formatProperty(r, e, t, o, n, true));\n                    }\n                });\n                return i;\n            }\n            function formatProperty(r, e, t, o, n, i) {\n                var a, y, f;\n                f = Object.getOwnPropertyDescriptor(e, n) || {\n                    value: e[n]\n                };\n                if (f.get) {\n                    if (f.set) {\n                        y = r.stylize(\"[Getter/Setter]\", \"special\");\n                    } else {\n                        y = r.stylize(\"[Getter]\", \"special\");\n                    }\n                } else {\n                    if (f.set) {\n                        y = r.stylize(\"[Setter]\", \"special\");\n                    }\n                }\n                if (!hasOwnProperty(o, n)) {\n                    a = \"[\" + n + \"]\";\n                }\n                if (!y) {\n                    if (r.seen.indexOf(f.value) < 0) {\n                        if (isNull(t)) {\n                            y = formatValue(r, f.value, null);\n                        } else {\n                            y = formatValue(r, f.value, t - 1);\n                        }\n                        if (y.indexOf(\"\\n\") > -1) {\n                            if (i) {\n                                y = y.split(\"\\n\").map(function(r) {\n                                    return \"  \" + r;\n                                }).join(\"\\n\").substr(2);\n                            } else {\n                                y = \"\\n\" + y.split(\"\\n\").map(function(r) {\n                                    return \"   \" + r;\n                                }).join(\"\\n\");\n                            }\n                        }\n                    } else {\n                        y = r.stylize(\"[Circular]\", \"special\");\n                    }\n                }\n                if (isUndefined(a)) {\n                    if (i && n.match(/^\\d+$/)) {\n                        return y;\n                    }\n                    a = JSON.stringify(\"\" + n);\n                    if (a.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n                        a = a.substr(1, a.length - 2);\n                        a = r.stylize(a, \"name\");\n                    } else {\n                        a = a.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n                        a = r.stylize(a, \"string\");\n                    }\n                }\n                return a + \": \" + y;\n            }\n            function reduceToSingleString(r, e, t) {\n                var o = 0;\n                var n = r.reduce(function(r, e) {\n                    o++;\n                    if (e.indexOf(\"\\n\") >= 0) o++;\n                    return r + e.replace(/\\u001b\\[\\d\\d?m/g, \"\").length + 1;\n                }, 0);\n                if (n > 60) {\n                    return t[0] + (e === \"\" ? \"\" : e + \"\\n \") + \" \" + r.join(\",\\n  \") + \" \" + t[1];\n                }\n                return t[0] + e + \" \" + r.join(\", \") + \" \" + t[1];\n            }\n            e.types = t(584);\n            function isArray(r) {\n                return Array.isArray(r);\n            }\n            e.isArray = isArray;\n            function isBoolean(r) {\n                return typeof r === \"boolean\";\n            }\n            e.isBoolean = isBoolean;\n            function isNull(r) {\n                return r === null;\n            }\n            e.isNull = isNull;\n            function isNullOrUndefined(r) {\n                return r == null;\n            }\n            e.isNullOrUndefined = isNullOrUndefined;\n            function isNumber(r) {\n                return typeof r === \"number\";\n            }\n            e.isNumber = isNumber;\n            function isString(r) {\n                return typeof r === \"string\";\n            }\n            e.isString = isString;\n            function isSymbol(r) {\n                return typeof r === \"symbol\";\n            }\n            e.isSymbol = isSymbol;\n            function isUndefined(r) {\n                return r === void 0;\n            }\n            e.isUndefined = isUndefined;\n            function isRegExp(r) {\n                return isObject(r) && objectToString(r) === \"[object RegExp]\";\n            }\n            e.isRegExp = isRegExp;\n            e.types.isRegExp = isRegExp;\n            function isObject(r) {\n                return typeof r === \"object\" && r !== null;\n            }\n            e.isObject = isObject;\n            function isDate(r) {\n                return isObject(r) && objectToString(r) === \"[object Date]\";\n            }\n            e.isDate = isDate;\n            e.types.isDate = isDate;\n            function isError(r) {\n                return isObject(r) && (objectToString(r) === \"[object Error]\" || r instanceof Error);\n            }\n            e.isError = isError;\n            e.types.isNativeError = isError;\n            function isFunction(r) {\n                return typeof r === \"function\";\n            }\n            e.isFunction = isFunction;\n            function isPrimitive(r) {\n                return r === null || typeof r === \"boolean\" || typeof r === \"number\" || typeof r === \"string\" || typeof r === \"symbol\" || typeof r === \"undefined\";\n            }\n            e.isPrimitive = isPrimitive;\n            e.isBuffer = t(369);\n            function objectToString(r) {\n                return Object.prototype.toString.call(r);\n            }\n            function pad(r) {\n                return r < 10 ? \"0\" + r.toString(10) : r.toString(10);\n            }\n            var f = [\n                \"Jan\",\n                \"Feb\",\n                \"Mar\",\n                \"Apr\",\n                \"May\",\n                \"Jun\",\n                \"Jul\",\n                \"Aug\",\n                \"Sep\",\n                \"Oct\",\n                \"Nov\",\n                \"Dec\"\n            ];\n            function timestamp() {\n                var r = new Date;\n                var e = [\n                    pad(r.getHours()),\n                    pad(r.getMinutes()),\n                    pad(r.getSeconds())\n                ].join(\":\");\n                return [\n                    r.getDate(),\n                    f[r.getMonth()],\n                    e\n                ].join(\" \");\n            }\n            e.log = function() {\n                console.log(\"%s - %s\", timestamp(), e.format.apply(e, arguments));\n            };\n            e.inherits = t(782);\n            e._extend = function(r, e) {\n                if (!e || !isObject(e)) return r;\n                var t = Object.keys(e);\n                var o = t.length;\n                while(o--){\n                    r[t[o]] = e[t[o]];\n                }\n                return r;\n            };\n            function hasOwnProperty(r, e) {\n                return Object.prototype.hasOwnProperty.call(r, e);\n            }\n            var p = typeof Symbol !== \"undefined\" ? Symbol(\"util.promisify.custom\") : undefined;\n            e.promisify = function promisify(r) {\n                if (typeof r !== \"function\") throw new TypeError('The \"original\" argument must be of type Function');\n                if (p && r[p]) {\n                    var e = r[p];\n                    if (typeof e !== \"function\") {\n                        throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n                    }\n                    Object.defineProperty(e, p, {\n                        value: e,\n                        enumerable: false,\n                        writable: false,\n                        configurable: true\n                    });\n                    return e;\n                }\n                function e() {\n                    var e, t;\n                    var o = new Promise(function(r, o) {\n                        e = r;\n                        t = o;\n                    });\n                    var n = [];\n                    for(var i = 0; i < arguments.length; i++){\n                        n.push(arguments[i]);\n                    }\n                    n.push(function(r, o) {\n                        if (r) {\n                            t(r);\n                        } else {\n                            e(o);\n                        }\n                    });\n                    try {\n                        r.apply(this, n);\n                    } catch (r) {\n                        t(r);\n                    }\n                    return o;\n                }\n                Object.setPrototypeOf(e, Object.getPrototypeOf(r));\n                if (p) Object.defineProperty(e, p, {\n                    value: e,\n                    enumerable: false,\n                    writable: false,\n                    configurable: true\n                });\n                return Object.defineProperties(e, o(r));\n            };\n            e.promisify.custom = p;\n            function callbackifyOnRejected(r, e) {\n                if (!r) {\n                    var t = new Error(\"Promise was rejected with a falsy value\");\n                    t.reason = r;\n                    r = t;\n                }\n                return e(r);\n            }\n            function callbackify(r) {\n                if (typeof r !== \"function\") {\n                    throw new TypeError('The \"original\" argument must be of type Function');\n                }\n                function callbackified() {\n                    var e = [];\n                    for(var t = 0; t < arguments.length; t++){\n                        e.push(arguments[t]);\n                    }\n                    var o = e.pop();\n                    if (typeof o !== \"function\") {\n                        throw new TypeError(\"The last argument must be of type Function\");\n                    }\n                    var n = this;\n                    var cb = function() {\n                        return o.apply(n, arguments);\n                    };\n                    r.apply(this, e).then(function(r) {\n                        process.nextTick(cb.bind(null, null, r));\n                    }, function(r) {\n                        process.nextTick(callbackifyOnRejected.bind(null, r, cb));\n                    });\n                }\n                Object.setPrototypeOf(callbackified, Object.getPrototypeOf(r));\n                Object.defineProperties(callbackified, o(r));\n                return callbackified;\n            }\n            e.callbackify = callbackify;\n        },\n        490: function(r, e, t) {\n            \"use strict\";\n            var o = t(144);\n            var n = t(349);\n            var i = t(256);\n            var a = i(\"Object.prototype.toString\");\n            var y = t(942)();\n            var f = y && typeof Symbol.toStringTag === \"symbol\";\n            var p = n();\n            var u = i(\"String.prototype.slice\");\n            var s = {};\n            var c = t(24);\n            var l = Object.getPrototypeOf;\n            if (f && c && l) {\n                o(p, function(r) {\n                    if (typeof __webpack_require__.g[r] === \"function\") {\n                        var e = new __webpack_require__.g[r];\n                        if (!(Symbol.toStringTag in e)) {\n                            throw new EvalError(\"this engine has support for Symbol.toStringTag, but \" + r + \" does not have the property! Please report this.\");\n                        }\n                        var t = l(e);\n                        var o = c(t, Symbol.toStringTag);\n                        if (!o) {\n                            var n = l(t);\n                            o = c(n, Symbol.toStringTag);\n                        }\n                        s[r] = o.get;\n                    }\n                });\n            }\n            var d = function tryAllTypedArrays(r) {\n                var e = false;\n                o(s, function(t, o) {\n                    if (!e) {\n                        try {\n                            var n = t.call(r);\n                            if (n === o) {\n                                e = n;\n                            }\n                        } catch (r) {}\n                    }\n                });\n                return e;\n            };\n            var g = t(994);\n            r.exports = function whichTypedArray(r) {\n                if (!g(r)) {\n                    return false;\n                }\n                if (!f) {\n                    return u(a(r), 8, -1);\n                }\n                return d(r);\n            };\n        },\n        349: function(r, e, t) {\n            \"use strict\";\n            var o = t(992);\n            r.exports = function availableTypedArrays() {\n                return o([\n                    \"BigInt64Array\",\n                    \"BigUint64Array\",\n                    \"Float32Array\",\n                    \"Float64Array\",\n                    \"Int16Array\",\n                    \"Int32Array\",\n                    \"Int8Array\",\n                    \"Uint16Array\",\n                    \"Uint32Array\",\n                    \"Uint8Array\",\n                    \"Uint8ClampedArray\"\n                ], function(r) {\n                    return typeof __webpack_require__.g[r] === \"function\";\n                });\n            };\n        },\n        24: function(r, e, t) {\n            \"use strict\";\n            var o = t(500);\n            var n = o(\"%Object.getOwnPropertyDescriptor%\", true);\n            if (n) {\n                try {\n                    n([], \"length\");\n                } catch (r) {\n                    n = null;\n                }\n            }\n            r.exports = n;\n        }\n    };\n    var e = {};\n    function __nccwpck_require__(t) {\n        var o = e[t];\n        if (o !== undefined) {\n            return o.exports;\n        }\n        var n = e[t] = {\n            exports: {}\n        };\n        var i = true;\n        try {\n            r[t](n, n.exports, __nccwpck_require__);\n            i = false;\n        } finally{\n            if (i) delete e[t];\n        }\n        return n.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var t = __nccwpck_require__(177);\n    module.exports = t;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvdXRpbC91dGlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQztJQUFXLElBQUlBLElBQUU7UUFBQyxLQUFJLFNBQVNBLENBQUM7WUFBRUEsRUFBRUMsT0FBTyxHQUFDLFNBQVNELENBQUMsRUFBQ0UsQ0FBQyxFQUFDQyxDQUFDO2dCQUFFLElBQUdILEVBQUVJLE1BQU0sRUFBQyxPQUFPSixFQUFFSSxNQUFNLENBQUNGLEdBQUVDO2dCQUFHLElBQUcsS0FBSyxNQUFJSCxLQUFHLFNBQU9BLEdBQUUsTUFBTSxJQUFJSztnQkFBVSxJQUFHLGNBQVksT0FBT0gsR0FBRSxNQUFNLElBQUlHO2dCQUFVLElBQUlDLElBQUUsRUFBRTtnQkFBQyxJQUFJLElBQUlDLElBQUUsR0FBRUEsSUFBRVAsRUFBRVEsTUFBTSxFQUFDRCxJQUFJO29CQUFDLElBQUcsQ0FBQ0UsRUFBRUMsSUFBSSxDQUFDVixHQUFFTyxJQUFHO29CQUFTLElBQUlJLElBQUVYLENBQUMsQ0FBQ08sRUFBRTtvQkFBQyxJQUFHTCxFQUFFUSxJQUFJLENBQUNQLEdBQUVRLEdBQUVKLEdBQUVQLElBQUdNLEVBQUVNLElBQUksQ0FBQ0Q7Z0JBQUU7Z0JBQUMsT0FBT0w7WUFBQztZQUFFLElBQUlHLElBQUVJLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYztRQUFBO1FBQUUsS0FBSSxTQUFTZixDQUFDLEVBQUNTLENBQUMsRUFBQ1AsQ0FBQztZQUFFO1lBQWEsSUFBSUMsSUFBRUQsRUFBRTtZQUFLLElBQUlJLElBQUVKLEVBQUU7WUFBSyxJQUFJSyxJQUFFRCxFQUFFSCxFQUFFO1lBQTZCSCxFQUFFQyxPQUFPLEdBQUMsU0FBU2UsbUJBQW1CaEIsQ0FBQyxFQUFDUyxDQUFDO2dCQUFFLElBQUlQLElBQUVDLEVBQUVILEdBQUUsQ0FBQyxDQUFDUztnQkFBRyxJQUFHLE9BQU9QLE1BQUksY0FBWUssRUFBRVAsR0FBRSxpQkFBZSxD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O1lBQUM7WUFBQ04sRUFBRUMsT0FBTyxHQUFDSztRQUFDO0lBQUM7SUFBRSxJQUFJRyxJQUFFLENBQUM7SUFBRSxTQUFTaVMsb0JBQW9CeFMsQ0FBQztRQUFFLElBQUlDLElBQUVNLENBQUMsQ0FBQ1AsRUFBRTtRQUFDLElBQUdDLE1BQUlvTCxXQUFVO1lBQUMsT0FBT3BMLEVBQUVGLE9BQU87UUFBQTtRQUFDLElBQUlLLElBQUVHLENBQUMsQ0FBQ1AsRUFBRSxHQUFDO1lBQUNELFNBQVEsQ0FBQztRQUFDO1FBQUUsSUFBSU0sSUFBRTtRQUFLLElBQUc7WUFBQ1AsQ0FBQyxDQUFDRSxFQUFFLENBQUNJLEdBQUVBLEVBQUVMLE9BQU8sRUFBQ3lTO1lBQXFCblMsSUFBRTtRQUFLLFNBQVE7WUFBQyxJQUFHQSxHQUFFLE9BQU9FLENBQUMsQ0FBQ1AsRUFBRTtRQUFBO1FBQUMsT0FBT0ksRUFBRUwsT0FBTztJQUFBO0lBQUMsSUFBRyxPQUFPeVMsd0JBQXNCLGFBQVlBLG9CQUFvQkMsRUFBRSxHQUFDQyxTQUFTQSxHQUFDO0lBQUksSUFBSTFTLElBQUV3UyxvQkFBb0I7SUFBS0csT0FBTzVTLE9BQU8sR0FBQ0M7QUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3V0aWwvdXRpbC5qcz9hYzE0Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciByPXs5OTI6ZnVuY3Rpb24ocil7ci5leHBvcnRzPWZ1bmN0aW9uKHIsdCxvKXtpZihyLmZpbHRlcilyZXR1cm4gci5maWx0ZXIodCxvKTtpZih2b2lkIDA9PT1yfHxudWxsPT09cil0aHJvdyBuZXcgVHlwZUVycm9yO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjt2YXIgbj1bXTtmb3IodmFyIGk9MDtpPHIubGVuZ3RoO2krKyl7aWYoIWUuY2FsbChyLGkpKWNvbnRpbnVlO3ZhciBhPXJbaV07aWYodC5jYWxsKG8sYSxpLHIpKW4ucHVzaChhKX1yZXR1cm4gbn07dmFyIGU9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eX0sMjU2OmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbz10KDkyNSk7dmFyIG49dCgxMzkpO3ZhciBpPW4obyhcIlN0cmluZy5wcm90b3R5cGUuaW5kZXhPZlwiKSk7ci5leHBvcnRzPWZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhyLGUpe3ZhciB0PW8ociwhIWUpO2lmKHR5cGVvZiB0PT09XCJmdW5jdGlvblwiJiZpKHIsXCIucHJvdG90eXBlLlwiKT4tMSl7cmV0dXJuIG4odCl9cmV0dXJuIHR9fSwxMzk6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXQoMTc0KTt2YXIgbj10KDkyNSk7dmFyIGk9bihcIiVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklXCIpO3ZhciBhPW4oXCIlRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlXCIpO3ZhciB5PW4oXCIlUmVmbGVjdC5hcHBseSVcIix0cnVlKXx8by5jYWxsKGEsaSk7dmFyIGY9bihcIiVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJVwiLHRydWUpO3ZhciBwPW4oXCIlT2JqZWN0LmRlZmluZVByb3BlcnR5JVwiLHRydWUpO3ZhciB1PW4oXCIlTWF0aC5tYXglXCIpO2lmKHApe3RyeXtwKHt9LFwiYVwiLHt2YWx1ZToxfSl9Y2F0Y2gocil7cD1udWxsfX1yLmV4cG9ydHM9ZnVuY3Rpb24gY2FsbEJpbmQocil7dmFyIGU9eShvLGEsYXJndW1lbnRzKTtpZihmJiZwKXt2YXIgdD1mKGUsXCJsZW5ndGhcIik7aWYodC5jb25maWd1cmFibGUpe3AoZSxcImxlbmd0aFwiLHt2YWx1ZToxK3UoMCxyLmxlbmd0aC0oYXJndW1lbnRzLmxlbmd0aC0xKSl9KX19cmV0dXJuIGV9O3ZhciBzPWZ1bmN0aW9uIGFwcGx5QmluZCgpe3JldHVybiB5KG8saSxhcmd1bWVudHMpfTtpZihwKXtwKHIuZXhwb3J0cyxcImFwcGx5XCIse3ZhbHVlOnN9KX1lbHNle3IuZXhwb3J0cy5hcHBseT1zfX0sMTQ0OmZ1bmN0aW9uKHIpe3ZhciBlPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIHQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztyLmV4cG9ydHM9ZnVuY3Rpb24gZm9yRWFjaChyLG8sbil7aWYodC5jYWxsKG8pIT09XCJbb2JqZWN0IEZ1bmN0aW9uXVwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpfXZhciBpPXIubGVuZ3RoO2lmKGk9PT0raSl7Zm9yKHZhciBhPTA7YTxpO2ErKyl7by5jYWxsKG4sclthXSxhLHIpfX1lbHNle2Zvcih2YXIgeSBpbiByKXtpZihlLmNhbGwocix5KSl7by5jYWxsKG4sclt5XSx5LHIpfX19fX0sNDI2OmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3ZhciBlPVwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSBcIjt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2U7dmFyIG89T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt2YXIgbj1cIltvYmplY3QgRnVuY3Rpb25dXCI7ci5leHBvcnRzPWZ1bmN0aW9uIGJpbmQocil7dmFyIGk9dGhpcztpZih0eXBlb2YgaSE9PVwiZnVuY3Rpb25cInx8by5jYWxsKGkpIT09bil7dGhyb3cgbmV3IFR5cGVFcnJvcihlK2kpfXZhciBhPXQuY2FsbChhcmd1bWVudHMsMSk7dmFyIHk7dmFyIGJpbmRlcj1mdW5jdGlvbigpe2lmKHRoaXMgaW5zdGFuY2VvZiB5KXt2YXIgZT1pLmFwcGx5KHRoaXMsYS5jb25jYXQodC5jYWxsKGFyZ3VtZW50cykpKTtpZihPYmplY3QoZSk9PT1lKXtyZXR1cm4gZX1yZXR1cm4gdGhpc31lbHNle3JldHVybiBpLmFwcGx5KHIsYS5jb25jYXQodC5jYWxsKGFyZ3VtZW50cykpKX19O3ZhciBmPU1hdGgubWF4KDAsaS5sZW5ndGgtYS5sZW5ndGgpO3ZhciBwPVtdO2Zvcih2YXIgdT0wO3U8Zjt1Kyspe3AucHVzaChcIiRcIit1KX15PUZ1bmN0aW9uKFwiYmluZGVyXCIsXCJyZXR1cm4gZnVuY3Rpb24gKFwiK3Auam9pbihcIixcIikrXCIpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfVwiKShiaW5kZXIpO2lmKGkucHJvdG90eXBlKXt2YXIgcz1mdW5jdGlvbiBFbXB0eSgpe307cy5wcm90b3R5cGU9aS5wcm90b3R5cGU7eS5wcm90b3R5cGU9bmV3IHM7cy5wcm90b3R5cGU9bnVsbH1yZXR1cm4geX19LDE3NDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG89dCg0MjYpO3IuZXhwb3J0cz1GdW5jdGlvbi5wcm90b3R5cGUuYmluZHx8b30sNTAwOmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbzt2YXIgbj1TeW50YXhFcnJvcjt2YXIgaT1GdW5jdGlvbjt2YXIgYT1UeXBlRXJyb3I7dmFyIGdldEV2YWxsZWRDb25zdHJ1Y3Rvcj1mdW5jdGlvbihyKXt0cnl7cmV0dXJuIGkoJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcrcitcIikuY29uc3RydWN0b3I7XCIpKCl9Y2F0Y2gocil7fX07dmFyIHk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtpZih5KXt0cnl7eSh7fSxcIlwiKX1jYXRjaChyKXt5PW51bGx9fXZhciB0aHJvd1R5cGVFcnJvcj1mdW5jdGlvbigpe3Rocm93IG5ldyBhfTt2YXIgZj15P2Z1bmN0aW9uKCl7dHJ5e2FyZ3VtZW50cy5jYWxsZWU7cmV0dXJuIHRocm93VHlwZUVycm9yfWNhdGNoKHIpe3RyeXtyZXR1cm4geShhcmd1bWVudHMsXCJjYWxsZWVcIikuZ2V0fWNhdGNoKHIpe3JldHVybiB0aHJvd1R5cGVFcnJvcn19fSgpOnRocm93VHlwZUVycm9yO3ZhciBwPXQoMTE1KSgpO3ZhciB1PU9iamVjdC5nZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24ocil7cmV0dXJuIHIuX19wcm90b19ffTt2YXIgcz17fTt2YXIgYz10eXBlb2YgVWludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bzp1KFVpbnQ4QXJyYXkpO3ZhciBsPXtcIiVBZ2dyZWdhdGVFcnJvciVcIjp0eXBlb2YgQWdncmVnYXRlRXJyb3I9PT1cInVuZGVmaW5lZFwiP286QWdncmVnYXRlRXJyb3IsXCIlQXJyYXklXCI6QXJyYXksXCIlQXJyYXlCdWZmZXIlXCI6dHlwZW9mIEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIj9vOkFycmF5QnVmZmVyLFwiJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlXCI6cD91KFtdW1N5bWJvbC5pdGVyYXRvcl0oKSk6byxcIiVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlXCI6byxcIiVBc3luY0Z1bmN0aW9uJVwiOnMsXCIlQXN5bmNHZW5lcmF0b3IlXCI6cyxcIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiOnMsXCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIjpzLFwiJUF0b21pY3MlXCI6dHlwZW9mIEF0b21pY3M9PT1cInVuZGVmaW5lZFwiP286QXRvbWljcyxcIiVCaWdJbnQlXCI6dHlwZW9mIEJpZ0ludD09PVwidW5kZWZpbmVkXCI/bzpCaWdJbnQsXCIlQm9vbGVhbiVcIjpCb29sZWFuLFwiJURhdGFWaWV3JVwiOnR5cGVvZiBEYXRhVmlldz09PVwidW5kZWZpbmVkXCI/bzpEYXRhVmlldyxcIiVEYXRlJVwiOkRhdGUsXCIlZGVjb2RlVVJJJVwiOmRlY29kZVVSSSxcIiVkZWNvZGVVUklDb21wb25lbnQlXCI6ZGVjb2RlVVJJQ29tcG9uZW50LFwiJWVuY29kZVVSSSVcIjplbmNvZGVVUkksXCIlZW5jb2RlVVJJQ29tcG9uZW50JVwiOmVuY29kZVVSSUNvbXBvbmVudCxcIiVFcnJvciVcIjpFcnJvcixcIiVldmFsJVwiOmV2YWwsXCIlRXZhbEVycm9yJVwiOkV2YWxFcnJvcixcIiVGbG9hdDMyQXJyYXklXCI6dHlwZW9mIEZsb2F0MzJBcnJheT09PVwidW5kZWZpbmVkXCI/bzpGbG9hdDMyQXJyYXksXCIlRmxvYXQ2NEFycmF5JVwiOnR5cGVvZiBGbG9hdDY0QXJyYXk9PT1cInVuZGVmaW5lZFwiP286RmxvYXQ2NEFycmF5LFwiJUZpbmFsaXphdGlvblJlZ2lzdHJ5JVwiOnR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeT09PVwidW5kZWZpbmVkXCI/bzpGaW5hbGl6YXRpb25SZWdpc3RyeSxcIiVGdW5jdGlvbiVcIjppLFwiJUdlbmVyYXRvckZ1bmN0aW9uJVwiOnMsXCIlSW50OEFycmF5JVwiOnR5cGVvZiBJbnQ4QXJyYXk9PT1cInVuZGVmaW5lZFwiP286SW50OEFycmF5LFwiJUludDE2QXJyYXklXCI6dHlwZW9mIEludDE2QXJyYXk9PT1cInVuZGVmaW5lZFwiP286SW50MTZBcnJheSxcIiVJbnQzMkFycmF5JVwiOnR5cGVvZiBJbnQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9vOkludDMyQXJyYXksXCIlaXNGaW5pdGUlXCI6aXNGaW5pdGUsXCIlaXNOYU4lXCI6aXNOYU4sXCIlSXRlcmF0b3JQcm90b3R5cGUlXCI6cD91KHUoW11bU3ltYm9sLml0ZXJhdG9yXSgpKSk6byxcIiVKU09OJVwiOnR5cGVvZiBKU09OPT09XCJvYmplY3RcIj9KU09OOm8sXCIlTWFwJVwiOnR5cGVvZiBNYXA9PT1cInVuZGVmaW5lZFwiP286TWFwLFwiJU1hcEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBNYXA9PT1cInVuZGVmaW5lZFwifHwhcD9vOnUoKG5ldyBNYXApW1N5bWJvbC5pdGVyYXRvcl0oKSksXCIlTWF0aCVcIjpNYXRoLFwiJU51bWJlciVcIjpOdW1iZXIsXCIlT2JqZWN0JVwiOk9iamVjdCxcIiVwYXJzZUZsb2F0JVwiOnBhcnNlRmxvYXQsXCIlcGFyc2VJbnQlXCI6cGFyc2VJbnQsXCIlUHJvbWlzZSVcIjp0eXBlb2YgUHJvbWlzZT09PVwidW5kZWZpbmVkXCI/bzpQcm9taXNlLFwiJVByb3h5JVwiOnR5cGVvZiBQcm94eT09PVwidW5kZWZpbmVkXCI/bzpQcm94eSxcIiVSYW5nZUVycm9yJVwiOlJhbmdlRXJyb3IsXCIlUmVmZXJlbmNlRXJyb3IlXCI6UmVmZXJlbmNlRXJyb3IsXCIlUmVmbGVjdCVcIjp0eXBlb2YgUmVmbGVjdD09PVwidW5kZWZpbmVkXCI/bzpSZWZsZWN0LFwiJVJlZ0V4cCVcIjpSZWdFeHAsXCIlU2V0JVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwiP286U2V0LFwiJVNldEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwifHwhcD9vOnUoKG5ldyBTZXQpW1N5bWJvbC5pdGVyYXRvcl0oKSksXCIlU2hhcmVkQXJyYXlCdWZmZXIlXCI6dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIj9vOlNoYXJlZEFycmF5QnVmZmVyLFwiJVN0cmluZyVcIjpTdHJpbmcsXCIlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlXCI6cD91KFwiXCJbU3ltYm9sLml0ZXJhdG9yXSgpKTpvLFwiJVN5bWJvbCVcIjpwP1N5bWJvbDpvLFwiJVN5bnRheEVycm9yJVwiOm4sXCIlVGhyb3dUeXBlRXJyb3IlXCI6ZixcIiVUeXBlZEFycmF5JVwiOmMsXCIlVHlwZUVycm9yJVwiOmEsXCIlVWludDhBcnJheSVcIjp0eXBlb2YgVWludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bzpVaW50OEFycmF5LFwiJVVpbnQ4Q2xhbXBlZEFycmF5JVwiOnR5cGVvZiBVaW50OENsYW1wZWRBcnJheT09PVwidW5kZWZpbmVkXCI/bzpVaW50OENsYW1wZWRBcnJheSxcIiVVaW50MTZBcnJheSVcIjp0eXBlb2YgVWludDE2QXJyYXk9PT1cInVuZGVmaW5lZFwiP286VWludDE2QXJyYXksXCIlVWludDMyQXJyYXklXCI6dHlwZW9mIFVpbnQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9vOlVpbnQzMkFycmF5LFwiJVVSSUVycm9yJVwiOlVSSUVycm9yLFwiJVdlYWtNYXAlXCI6dHlwZW9mIFdlYWtNYXA9PT1cInVuZGVmaW5lZFwiP286V2Vha01hcCxcIiVXZWFrUmVmJVwiOnR5cGVvZiBXZWFrUmVmPT09XCJ1bmRlZmluZWRcIj9vOldlYWtSZWYsXCIlV2Vha1NldCVcIjp0eXBlb2YgV2Vha1NldD09PVwidW5kZWZpbmVkXCI/bzpXZWFrU2V0fTt2YXIgZD1mdW5jdGlvbiBkb0V2YWwocil7dmFyIGU7aWYocj09PVwiJUFzeW5jRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiYXN5bmMgZnVuY3Rpb24gKCkge31cIil9ZWxzZSBpZihyPT09XCIlR2VuZXJhdG9yRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiZnVuY3Rpb24qICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiYXN5bmMgZnVuY3Rpb24qICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUFzeW5jR2VuZXJhdG9yJVwiKXt2YXIgdD1kb0V2YWwoXCIlQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiVcIik7aWYodCl7ZT10LnByb3RvdHlwZX19ZWxzZSBpZihyPT09XCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIil7dmFyIG89ZG9FdmFsKFwiJUFzeW5jR2VuZXJhdG9yJVwiKTtpZihvKXtlPXUoby5wcm90b3R5cGUpfX1sW3JdPWU7cmV0dXJuIGV9O3ZhciBnPXtcIiVBcnJheUJ1ZmZlclByb3RvdHlwZSVcIjpbXCJBcnJheUJ1ZmZlclwiLFwicHJvdG90eXBlXCJdLFwiJUFycmF5UHJvdG90eXBlJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlQXJyYXlQcm90b19lbnRyaWVzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImVudHJpZXNcIl0sXCIlQXJyYXlQcm90b19mb3JFYWNoJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImZvckVhY2hcIl0sXCIlQXJyYXlQcm90b19rZXlzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImtleXNcIl0sXCIlQXJyYXlQcm90b192YWx1ZXMlXCI6W1wiQXJyYXlcIixcInByb3RvdHlwZVwiLFwidmFsdWVzXCJdLFwiJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlXCI6W1wiQXN5bmNGdW5jdGlvblwiLFwicHJvdG90eXBlXCJdLFwiJUFzeW5jR2VuZXJhdG9yJVwiOltcIkFzeW5jR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVBc3luY0dlbmVyYXRvclByb3RvdHlwZSVcIjpbXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIixcInByb3RvdHlwZVwiXSxcIiVCb29sZWFuUHJvdG90eXBlJVwiOltcIkJvb2xlYW5cIixcInByb3RvdHlwZVwiXSxcIiVEYXRhVmlld1Byb3RvdHlwZSVcIjpbXCJEYXRhVmlld1wiLFwicHJvdG90eXBlXCJdLFwiJURhdGVQcm90b3R5cGUlXCI6W1wiRGF0ZVwiLFwicHJvdG90eXBlXCJdLFwiJUVycm9yUHJvdG90eXBlJVwiOltcIkVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlRXZhbEVycm9yUHJvdG90eXBlJVwiOltcIkV2YWxFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJUZsb2F0MzJBcnJheVByb3RvdHlwZSVcIjpbXCJGbG9hdDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVGbG9hdDY0QXJyYXlQcm90b3R5cGUlXCI6W1wiRmxvYXQ2NEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlRnVuY3Rpb25Qcm90b3R5cGUlXCI6W1wiRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVHZW5lcmF0b3IlXCI6W1wiR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVHZW5lcmF0b3JQcm90b3R5cGUlXCI6W1wiR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiLFwicHJvdG90eXBlXCJdLFwiJUludDhBcnJheVByb3RvdHlwZSVcIjpbXCJJbnQ4QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVJbnQxNkFycmF5UHJvdG90eXBlJVwiOltcIkludDE2QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVJbnQzMkFycmF5UHJvdG90eXBlJVwiOltcIkludDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVKU09OUGFyc2UlXCI6W1wiSlNPTlwiLFwicGFyc2VcIl0sXCIlSlNPTlN0cmluZ2lmeSVcIjpbXCJKU09OXCIsXCJzdHJpbmdpZnlcIl0sXCIlTWFwUHJvdG90eXBlJVwiOltcIk1hcFwiLFwicHJvdG90eXBlXCJdLFwiJU51bWJlclByb3RvdHlwZSVcIjpbXCJOdW1iZXJcIixcInByb3RvdHlwZVwiXSxcIiVPYmplY3RQcm90b3R5cGUlXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIl0sXCIlT2JqUHJvdG9fdG9TdHJpbmclXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIixcInRvU3RyaW5nXCJdLFwiJU9ialByb3RvX3ZhbHVlT2YlXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIixcInZhbHVlT2ZcIl0sXCIlUHJvbWlzZVByb3RvdHlwZSVcIjpbXCJQcm9taXNlXCIsXCJwcm90b3R5cGVcIl0sXCIlUHJvbWlzZVByb3RvX3RoZW4lXCI6W1wiUHJvbWlzZVwiLFwicHJvdG90eXBlXCIsXCJ0aGVuXCJdLFwiJVByb21pc2VfYWxsJVwiOltcIlByb21pc2VcIixcImFsbFwiXSxcIiVQcm9taXNlX3JlamVjdCVcIjpbXCJQcm9taXNlXCIsXCJyZWplY3RcIl0sXCIlUHJvbWlzZV9yZXNvbHZlJVwiOltcIlByb21pc2VcIixcInJlc29sdmVcIl0sXCIlUmFuZ2VFcnJvclByb3RvdHlwZSVcIjpbXCJSYW5nZUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlXCI6W1wiUmVmZXJlbmNlRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVSZWdFeHBQcm90b3R5cGUlXCI6W1wiUmVnRXhwXCIsXCJwcm90b3R5cGVcIl0sXCIlU2V0UHJvdG90eXBlJVwiOltcIlNldFwiLFwicHJvdG90eXBlXCJdLFwiJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJVwiOltcIlNoYXJlZEFycmF5QnVmZmVyXCIsXCJwcm90b3R5cGVcIl0sXCIlU3RyaW5nUHJvdG90eXBlJVwiOltcIlN0cmluZ1wiLFwicHJvdG90eXBlXCJdLFwiJVN5bWJvbFByb3RvdHlwZSVcIjpbXCJTeW1ib2xcIixcInByb3RvdHlwZVwiXSxcIiVTeW50YXhFcnJvclByb3RvdHlwZSVcIjpbXCJTeW50YXhFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVR5cGVkQXJyYXlQcm90b3R5cGUlXCI6W1wiVHlwZWRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVR5cGVFcnJvclByb3RvdHlwZSVcIjpbXCJUeXBlRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVVaW50OEFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQ4QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50OENsYW1wZWRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVVpbnQxNkFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQxNkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDMyQXJyYXlQcm90b3R5cGUlXCI6W1wiVWludDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVUklFcnJvclByb3RvdHlwZSVcIjpbXCJVUklFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVdlYWtNYXBQcm90b3R5cGUlXCI6W1wiV2Vha01hcFwiLFwicHJvdG90eXBlXCJdLFwiJVdlYWtTZXRQcm90b3R5cGUlXCI6W1wiV2Vha1NldFwiLFwicHJvdG90eXBlXCJdfTt2YXIgdj10KDE3NCk7dmFyIGI9dCgxMDEpO3ZhciBBPXYuY2FsbChGdW5jdGlvbi5jYWxsLEFycmF5LnByb3RvdHlwZS5jb25jYXQpO3ZhciBtPXYuY2FsbChGdW5jdGlvbi5hcHBseSxBcnJheS5wcm90b3R5cGUuc3BsaWNlKTt2YXIgUz12LmNhbGwoRnVuY3Rpb24uY2FsbCxTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO3ZhciBoPXYuY2FsbChGdW5jdGlvbi5jYWxsLFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO3ZhciBQPXYuY2FsbChGdW5jdGlvbi5jYWxsLFJlZ0V4cC5wcm90b3R5cGUuZXhlYyk7dmFyIE89L1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7dmFyIHc9L1xcXFwoXFxcXCk/L2c7dmFyIGo9ZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHIpe3ZhciBlPWgociwwLDEpO3ZhciB0PWgociwtMSk7aWYoZT09PVwiJVwiJiZ0IT09XCIlXCIpe3Rocm93IG5ldyBuKFwiaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYFwiKX1lbHNlIGlmKHQ9PT1cIiVcIiYmZSE9PVwiJVwiKXt0aHJvdyBuZXcgbihcImludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWBcIil9dmFyIG89W107UyhyLE8sKGZ1bmN0aW9uKHIsZSx0LG4pe29bby5sZW5ndGhdPXQ/UyhuLHcsXCIkMVwiKTplfHxyfSkpO3JldHVybiBvfTt2YXIgRT1mdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKHIsZSl7dmFyIHQ9cjt2YXIgbztpZihiKGcsdCkpe289Z1t0XTt0PVwiJVwiK29bMF0rXCIlXCJ9aWYoYihsLHQpKXt2YXIgaT1sW3RdO2lmKGk9PT1zKXtpPWQodCl9aWYodHlwZW9mIGk9PT1cInVuZGVmaW5lZFwiJiYhZSl7dGhyb3cgbmV3IGEoXCJpbnRyaW5zaWMgXCIrcitcIiBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSFcIil9cmV0dXJue2FsaWFzOm8sbmFtZTp0LHZhbHVlOml9fXRocm93IG5ldyBuKFwiaW50cmluc2ljIFwiK3IrXCIgZG9lcyBub3QgZXhpc3QhXCIpfTtyLmV4cG9ydHM9ZnVuY3Rpb24gR2V0SW50cmluc2ljKHIsZSl7aWYodHlwZW9mIHIhPT1cInN0cmluZ1wifHxyLmxlbmd0aD09PTApe3Rocm93IG5ldyBhKFwiaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIil9aWYoYXJndW1lbnRzLmxlbmd0aD4xJiZ0eXBlb2YgZSE9PVwiYm9vbGVhblwiKXt0aHJvdyBuZXcgYSgnXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpfWlmKFAoL14lP1teJV0qJT8kL2cscik9PT1udWxsKXt0aHJvdyBuZXcgbihcImAlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWVcIil9dmFyIHQ9aihyKTt2YXIgaT10Lmxlbmd0aD4wP3RbMF06XCJcIjt2YXIgZj1FKFwiJVwiK2krXCIlXCIsZSk7dmFyIHA9Zi5uYW1lO3ZhciB1PWYudmFsdWU7dmFyIHM9ZmFsc2U7dmFyIGM9Zi5hbGlhcztpZihjKXtpPWNbMF07bSh0LEEoWzAsMV0sYykpfWZvcih2YXIgZD0xLGc9dHJ1ZTtkPHQubGVuZ3RoO2QrPTEpe3ZhciB2PXRbZF07dmFyIFM9aCh2LDAsMSk7dmFyIE89aCh2LC0xKTtpZigoUz09PSdcIid8fFM9PT1cIidcInx8Uz09PVwiYFwifHwoTz09PSdcIid8fE89PT1cIidcInx8Tz09PVwiYFwiKSkmJlMhPT1PKXt0aHJvdyBuZXcgbihcInByb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXNcIil9aWYodj09PVwiY29uc3RydWN0b3JcInx8IWcpe3M9dHJ1ZX1pKz1cIi5cIit2O3A9XCIlXCIraStcIiVcIjtpZihiKGwscCkpe3U9bFtwXX1lbHNlIGlmKHUhPW51bGwpe2lmKCEodiBpbiB1KSl7aWYoIWUpe3Rocm93IG5ldyBhKFwiYmFzZSBpbnRyaW5zaWMgZm9yIFwiK3IrXCIgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuXCIpfXJldHVybiB2b2lkIG99aWYoeSYmZCsxPj10Lmxlbmd0aCl7dmFyIHc9eSh1LHYpO2c9ISF3O2lmKGcmJlwiZ2V0XCJpbiB3JiYhKFwib3JpZ2luYWxWYWx1ZVwiaW4gdy5nZXQpKXt1PXcuZ2V0fWVsc2V7dT11W3ZdfX1lbHNle2c9Yih1LHYpO3U9dVt2XX1pZihnJiYhcyl7bFtwXT11fX19cmV0dXJuIHV9fSw5MjU6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvO3ZhciBuPVN5bnRheEVycm9yO3ZhciBpPUZ1bmN0aW9uO3ZhciBhPVR5cGVFcnJvcjt2YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yPWZ1bmN0aW9uKHIpe3RyeXtyZXR1cm4gaSgnXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJytyK1wiKS5jb25zdHJ1Y3RvcjtcIikoKX1jYXRjaChyKXt9fTt2YXIgeT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2lmKHkpe3RyeXt5KHt9LFwiXCIpfWNhdGNoKHIpe3k9bnVsbH19dmFyIHRocm93VHlwZUVycm9yPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IGF9O3ZhciBmPXk/ZnVuY3Rpb24oKXt0cnl7YXJndW1lbnRzLmNhbGxlZTtyZXR1cm4gdGhyb3dUeXBlRXJyb3J9Y2F0Y2gocil7dHJ5e3JldHVybiB5KGFyZ3VtZW50cyxcImNhbGxlZVwiKS5nZXR9Y2F0Y2gocil7cmV0dXJuIHRocm93VHlwZUVycm9yfX19KCk6dGhyb3dUeXBlRXJyb3I7dmFyIHA9dCgxMTUpKCk7dmFyIHU9dCg1MDQpKCk7dmFyIHM9T2JqZWN0LmdldFByb3RvdHlwZU9mfHwodT9mdW5jdGlvbihyKXtyZXR1cm4gci5fX3Byb3RvX199Om51bGwpO3ZhciBjPXt9O3ZhciBsPXR5cGVvZiBVaW50OEFycmF5PT09XCJ1bmRlZmluZWRcInx8IXM/bzpzKFVpbnQ4QXJyYXkpO3ZhciBkPXtcIiVBZ2dyZWdhdGVFcnJvciVcIjp0eXBlb2YgQWdncmVnYXRlRXJyb3I9PT1cInVuZGVmaW5lZFwiP286QWdncmVnYXRlRXJyb3IsXCIlQXJyYXklXCI6QXJyYXksXCIlQXJyYXlCdWZmZXIlXCI6dHlwZW9mIEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIj9vOkFycmF5QnVmZmVyLFwiJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlXCI6cCYmcz9zKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSk6byxcIiVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlXCI6byxcIiVBc3luY0Z1bmN0aW9uJVwiOmMsXCIlQXN5bmNHZW5lcmF0b3IlXCI6YyxcIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiOmMsXCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIjpjLFwiJUF0b21pY3MlXCI6dHlwZW9mIEF0b21pY3M9PT1cInVuZGVmaW5lZFwiP286QXRvbWljcyxcIiVCaWdJbnQlXCI6dHlwZW9mIEJpZ0ludD09PVwidW5kZWZpbmVkXCI/bzpCaWdJbnQsXCIlQmlnSW50NjRBcnJheSVcIjp0eXBlb2YgQmlnSW50NjRBcnJheT09PVwidW5kZWZpbmVkXCI/bzpCaWdJbnQ2NEFycmF5LFwiJUJpZ1VpbnQ2NEFycmF5JVwiOnR5cGVvZiBCaWdVaW50NjRBcnJheT09PVwidW5kZWZpbmVkXCI/bzpCaWdVaW50NjRBcnJheSxcIiVCb29sZWFuJVwiOkJvb2xlYW4sXCIlRGF0YVZpZXclXCI6dHlwZW9mIERhdGFWaWV3PT09XCJ1bmRlZmluZWRcIj9vOkRhdGFWaWV3LFwiJURhdGUlXCI6RGF0ZSxcIiVkZWNvZGVVUkklXCI6ZGVjb2RlVVJJLFwiJWRlY29kZVVSSUNvbXBvbmVudCVcIjpkZWNvZGVVUklDb21wb25lbnQsXCIlZW5jb2RlVVJJJVwiOmVuY29kZVVSSSxcIiVlbmNvZGVVUklDb21wb25lbnQlXCI6ZW5jb2RlVVJJQ29tcG9uZW50LFwiJUVycm9yJVwiOkVycm9yLFwiJWV2YWwlXCI6ZXZhbCxcIiVFdmFsRXJyb3IlXCI6RXZhbEVycm9yLFwiJUZsb2F0MzJBcnJheSVcIjp0eXBlb2YgRmxvYXQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9vOkZsb2F0MzJBcnJheSxcIiVGbG9hdDY0QXJyYXklXCI6dHlwZW9mIEZsb2F0NjRBcnJheT09PVwidW5kZWZpbmVkXCI/bzpGbG9hdDY0QXJyYXksXCIlRmluYWxpemF0aW9uUmVnaXN0cnklXCI6dHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5PT09XCJ1bmRlZmluZWRcIj9vOkZpbmFsaXphdGlvblJlZ2lzdHJ5LFwiJUZ1bmN0aW9uJVwiOmksXCIlR2VuZXJhdG9yRnVuY3Rpb24lXCI6YyxcIiVJbnQ4QXJyYXklXCI6dHlwZW9mIEludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bzpJbnQ4QXJyYXksXCIlSW50MTZBcnJheSVcIjp0eXBlb2YgSW50MTZBcnJheT09PVwidW5kZWZpbmVkXCI/bzpJbnQxNkFycmF5LFwiJUludDMyQXJyYXklXCI6dHlwZW9mIEludDMyQXJyYXk9PT1cInVuZGVmaW5lZFwiP286SW50MzJBcnJheSxcIiVpc0Zpbml0ZSVcIjppc0Zpbml0ZSxcIiVpc05hTiVcIjppc05hTixcIiVJdGVyYXRvclByb3RvdHlwZSVcIjpwJiZzP3MocyhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKTpvLFwiJUpTT04lXCI6dHlwZW9mIEpTT049PT1cIm9iamVjdFwiP0pTT046byxcIiVNYXAlXCI6dHlwZW9mIE1hcD09PVwidW5kZWZpbmVkXCI/bzpNYXAsXCIlTWFwSXRlcmF0b3JQcm90b3R5cGUlXCI6dHlwZW9mIE1hcD09PVwidW5kZWZpbmVkXCJ8fCFwfHwhcz9vOnMoKG5ldyBNYXApW1N5bWJvbC5pdGVyYXRvcl0oKSksXCIlTWF0aCVcIjpNYXRoLFwiJU51bWJlciVcIjpOdW1iZXIsXCIlT2JqZWN0JVwiOk9iamVjdCxcIiVwYXJzZUZsb2F0JVwiOnBhcnNlRmxvYXQsXCIlcGFyc2VJbnQlXCI6cGFyc2VJbnQsXCIlUHJvbWlzZSVcIjp0eXBlb2YgUHJvbWlzZT09PVwidW5kZWZpbmVkXCI/bzpQcm9taXNlLFwiJVByb3h5JVwiOnR5cGVvZiBQcm94eT09PVwidW5kZWZpbmVkXCI/bzpQcm94eSxcIiVSYW5nZUVycm9yJVwiOlJhbmdlRXJyb3IsXCIlUmVmZXJlbmNlRXJyb3IlXCI6UmVmZXJlbmNlRXJyb3IsXCIlUmVmbGVjdCVcIjp0eXBlb2YgUmVmbGVjdD09PVwidW5kZWZpbmVkXCI/bzpSZWZsZWN0LFwiJVJlZ0V4cCVcIjpSZWdFeHAsXCIlU2V0JVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwiP286U2V0LFwiJVNldEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwifHwhcHx8IXM/bzpzKChuZXcgU2V0KVtTeW1ib2wuaXRlcmF0b3JdKCkpLFwiJVNoYXJlZEFycmF5QnVmZmVyJVwiOnR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj09PVwidW5kZWZpbmVkXCI/bzpTaGFyZWRBcnJheUJ1ZmZlcixcIiVTdHJpbmclXCI6U3RyaW5nLFwiJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJVwiOnAmJnM/cyhcIlwiW1N5bWJvbC5pdGVyYXRvcl0oKSk6byxcIiVTeW1ib2wlXCI6cD9TeW1ib2w6byxcIiVTeW50YXhFcnJvciVcIjpuLFwiJVRocm93VHlwZUVycm9yJVwiOmYsXCIlVHlwZWRBcnJheSVcIjpsLFwiJVR5cGVFcnJvciVcIjphLFwiJVVpbnQ4QXJyYXklXCI6dHlwZW9mIFVpbnQ4QXJyYXk9PT1cInVuZGVmaW5lZFwiP286VWludDhBcnJheSxcIiVVaW50OENsYW1wZWRBcnJheSVcIjp0eXBlb2YgVWludDhDbGFtcGVkQXJyYXk9PT1cInVuZGVmaW5lZFwiP286VWludDhDbGFtcGVkQXJyYXksXCIlVWludDE2QXJyYXklXCI6dHlwZW9mIFVpbnQxNkFycmF5PT09XCJ1bmRlZmluZWRcIj9vOlVpbnQxNkFycmF5LFwiJVVpbnQzMkFycmF5JVwiOnR5cGVvZiBVaW50MzJBcnJheT09PVwidW5kZWZpbmVkXCI/bzpVaW50MzJBcnJheSxcIiVVUklFcnJvciVcIjpVUklFcnJvcixcIiVXZWFrTWFwJVwiOnR5cGVvZiBXZWFrTWFwPT09XCJ1bmRlZmluZWRcIj9vOldlYWtNYXAsXCIlV2Vha1JlZiVcIjp0eXBlb2YgV2Vha1JlZj09PVwidW5kZWZpbmVkXCI/bzpXZWFrUmVmLFwiJVdlYWtTZXQlXCI6dHlwZW9mIFdlYWtTZXQ9PT1cInVuZGVmaW5lZFwiP286V2Vha1NldH07aWYocyl7dHJ5e251bGwuZXJyb3J9Y2F0Y2gocil7dmFyIGc9cyhzKHIpKTtkW1wiJUVycm9yLnByb3RvdHlwZSVcIl09Z319dmFyIHY9ZnVuY3Rpb24gZG9FdmFsKHIpe3ZhciBlO2lmKHI9PT1cIiVBc3luY0Z1bmN0aW9uJVwiKXtlPWdldEV2YWxsZWRDb25zdHJ1Y3RvcihcImFzeW5jIGZ1bmN0aW9uICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUdlbmVyYXRvckZ1bmN0aW9uJVwiKXtlPWdldEV2YWxsZWRDb25zdHJ1Y3RvcihcImZ1bmN0aW9uKiAoKSB7fVwiKX1lbHNlIGlmKHI9PT1cIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiKXtlPWdldEV2YWxsZWRDb25zdHJ1Y3RvcihcImFzeW5jIGZ1bmN0aW9uKiAoKSB7fVwiKX1lbHNlIGlmKHI9PT1cIiVBc3luY0dlbmVyYXRvciVcIil7dmFyIHQ9ZG9FdmFsKFwiJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lXCIpO2lmKHQpe2U9dC5wcm90b3R5cGV9fWVsc2UgaWYocj09PVwiJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlXCIpe3ZhciBvPWRvRXZhbChcIiVBc3luY0dlbmVyYXRvciVcIik7aWYobyYmcyl7ZT1zKG8ucHJvdG90eXBlKX19ZFtyXT1lO3JldHVybiBlfTt2YXIgYj17XCIlQXJyYXlCdWZmZXJQcm90b3R5cGUlXCI6W1wiQXJyYXlCdWZmZXJcIixcInByb3RvdHlwZVwiXSxcIiVBcnJheVByb3RvdHlwZSVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUFycmF5UHJvdG9fZW50cmllcyVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCIsXCJlbnRyaWVzXCJdLFwiJUFycmF5UHJvdG9fZm9yRWFjaCVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCIsXCJmb3JFYWNoXCJdLFwiJUFycmF5UHJvdG9fa2V5cyVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCIsXCJrZXlzXCJdLFwiJUFycmF5UHJvdG9fdmFsdWVzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcInZhbHVlc1wiXSxcIiVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJVwiOltcIkFzeW5jRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVBc3luY0dlbmVyYXRvciVcIjpbXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIl0sXCIlQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlXCI6W1wiQXN5bmNHZW5lcmF0b3JGdW5jdGlvblwiLFwicHJvdG90eXBlXCIsXCJwcm90b3R5cGVcIl0sXCIlQm9vbGVhblByb3RvdHlwZSVcIjpbXCJCb29sZWFuXCIsXCJwcm90b3R5cGVcIl0sXCIlRGF0YVZpZXdQcm90b3R5cGUlXCI6W1wiRGF0YVZpZXdcIixcInByb3RvdHlwZVwiXSxcIiVEYXRlUHJvdG90eXBlJVwiOltcIkRhdGVcIixcInByb3RvdHlwZVwiXSxcIiVFcnJvclByb3RvdHlwZSVcIjpbXCJFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJUV2YWxFcnJvclByb3RvdHlwZSVcIjpbXCJFdmFsRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVGbG9hdDMyQXJyYXlQcm90b3R5cGUlXCI6W1wiRmxvYXQzMkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlRmxvYXQ2NEFycmF5UHJvdG90eXBlJVwiOltcIkZsb2F0NjRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUZ1bmN0aW9uUHJvdG90eXBlJVwiOltcIkZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIl0sXCIlR2VuZXJhdG9yJVwiOltcIkdlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIl0sXCIlR2VuZXJhdG9yUHJvdG90eXBlJVwiOltcIkdlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIixcInByb3RvdHlwZVwiXSxcIiVJbnQ4QXJyYXlQcm90b3R5cGUlXCI6W1wiSW50OEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlSW50MTZBcnJheVByb3RvdHlwZSVcIjpbXCJJbnQxNkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlSW50MzJBcnJheVByb3RvdHlwZSVcIjpbXCJJbnQzMkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlSlNPTlBhcnNlJVwiOltcIkpTT05cIixcInBhcnNlXCJdLFwiJUpTT05TdHJpbmdpZnklXCI6W1wiSlNPTlwiLFwic3RyaW5naWZ5XCJdLFwiJU1hcFByb3RvdHlwZSVcIjpbXCJNYXBcIixcInByb3RvdHlwZVwiXSxcIiVOdW1iZXJQcm90b3R5cGUlXCI6W1wiTnVtYmVyXCIsXCJwcm90b3R5cGVcIl0sXCIlT2JqZWN0UHJvdG90eXBlJVwiOltcIk9iamVjdFwiLFwicHJvdG90eXBlXCJdLFwiJU9ialByb3RvX3RvU3RyaW5nJVwiOltcIk9iamVjdFwiLFwicHJvdG90eXBlXCIsXCJ0b1N0cmluZ1wiXSxcIiVPYmpQcm90b192YWx1ZU9mJVwiOltcIk9iamVjdFwiLFwicHJvdG90eXBlXCIsXCJ2YWx1ZU9mXCJdLFwiJVByb21pc2VQcm90b3R5cGUlXCI6W1wiUHJvbWlzZVwiLFwicHJvdG90eXBlXCJdLFwiJVByb21pc2VQcm90b190aGVuJVwiOltcIlByb21pc2VcIixcInByb3RvdHlwZVwiLFwidGhlblwiXSxcIiVQcm9taXNlX2FsbCVcIjpbXCJQcm9taXNlXCIsXCJhbGxcIl0sXCIlUHJvbWlzZV9yZWplY3QlXCI6W1wiUHJvbWlzZVwiLFwicmVqZWN0XCJdLFwiJVByb21pc2VfcmVzb2x2ZSVcIjpbXCJQcm9taXNlXCIsXCJyZXNvbHZlXCJdLFwiJVJhbmdlRXJyb3JQcm90b3R5cGUlXCI6W1wiUmFuZ2VFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJVwiOltcIlJlZmVyZW5jZUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlUmVnRXhwUHJvdG90eXBlJVwiOltcIlJlZ0V4cFwiLFwicHJvdG90eXBlXCJdLFwiJVNldFByb3RvdHlwZSVcIjpbXCJTZXRcIixcInByb3RvdHlwZVwiXSxcIiVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSVcIjpbXCJTaGFyZWRBcnJheUJ1ZmZlclwiLFwicHJvdG90eXBlXCJdLFwiJVN0cmluZ1Byb3RvdHlwZSVcIjpbXCJTdHJpbmdcIixcInByb3RvdHlwZVwiXSxcIiVTeW1ib2xQcm90b3R5cGUlXCI6W1wiU3ltYm9sXCIsXCJwcm90b3R5cGVcIl0sXCIlU3ludGF4RXJyb3JQcm90b3R5cGUlXCI6W1wiU3ludGF4RXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVUeXBlZEFycmF5UHJvdG90eXBlJVwiOltcIlR5cGVkQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVUeXBlRXJyb3JQcm90b3R5cGUlXCI6W1wiVHlwZUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDhBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50OEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlXCI6W1wiVWludDhDbGFtcGVkQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVaW50MTZBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50MTZBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVVpbnQzMkFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQzMkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVVJJRXJyb3JQcm90b3R5cGUlXCI6W1wiVVJJRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVXZWFrTWFwUHJvdG90eXBlJVwiOltcIldlYWtNYXBcIixcInByb3RvdHlwZVwiXSxcIiVXZWFrU2V0UHJvdG90eXBlJVwiOltcIldlYWtTZXRcIixcInByb3RvdHlwZVwiXX07dmFyIEE9dCgxNzQpO3ZhciBtPXQoMTAxKTt2YXIgUz1BLmNhbGwoRnVuY3Rpb24uY2FsbCxBcnJheS5wcm90b3R5cGUuY29uY2F0KTt2YXIgaD1BLmNhbGwoRnVuY3Rpb24uYXBwbHksQXJyYXkucHJvdG90eXBlLnNwbGljZSk7dmFyIFA9QS5jYWxsKEZ1bmN0aW9uLmNhbGwsU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTt2YXIgTz1BLmNhbGwoRnVuY3Rpb24uY2FsbCxTdHJpbmcucHJvdG90eXBlLnNsaWNlKTt2YXIgdz1BLmNhbGwoRnVuY3Rpb24uY2FsbCxSZWdFeHAucHJvdG90eXBlLmV4ZWMpO3ZhciBqPS9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO3ZhciBFPS9cXFxcKFxcXFwpPy9nO3ZhciBJPWZ1bmN0aW9uIHN0cmluZ1RvUGF0aChyKXt2YXIgZT1PKHIsMCwxKTt2YXIgdD1PKHIsLTEpO2lmKGU9PT1cIiVcIiYmdCE9PVwiJVwiKXt0aHJvdyBuZXcgbihcImludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWBcIil9ZWxzZSBpZih0PT09XCIlXCImJmUhPT1cIiVcIil7dGhyb3cgbmV3IG4oXCJpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgXCIpfXZhciBvPVtdO1AocixqLChmdW5jdGlvbihyLGUsdCxuKXtvW28ubGVuZ3RoXT10P1AobixFLFwiJDFcIik6ZXx8cn0pKTtyZXR1cm4gb307dmFyIEI9ZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhyLGUpe3ZhciB0PXI7dmFyIG87aWYobShiLHQpKXtvPWJbdF07dD1cIiVcIitvWzBdK1wiJVwifWlmKG0oZCx0KSl7dmFyIGk9ZFt0XTtpZihpPT09Yyl7aT12KHQpfWlmKHR5cGVvZiBpPT09XCJ1bmRlZmluZWRcIiYmIWUpe3Rocm93IG5ldyBhKFwiaW50cmluc2ljIFwiK3IrXCIgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhXCIpfXJldHVybnthbGlhczpvLG5hbWU6dCx2YWx1ZTppfX10aHJvdyBuZXcgbihcImludHJpbnNpYyBcIityK1wiIGRvZXMgbm90IGV4aXN0IVwiKX07ci5leHBvcnRzPWZ1bmN0aW9uIEdldEludHJpbnNpYyhyLGUpe2lmKHR5cGVvZiByIT09XCJzdHJpbmdcInx8ci5sZW5ndGg9PT0wKXt0aHJvdyBuZXcgYShcImludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpfWlmKGFyZ3VtZW50cy5sZW5ndGg+MSYmdHlwZW9mIGUhPT1cImJvb2xlYW5cIil7dGhyb3cgbmV3IGEoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKX1pZih3KC9eJT9bXiVdKiU/JC8scik9PT1udWxsKXt0aHJvdyBuZXcgbihcImAlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWVcIil9dmFyIHQ9SShyKTt2YXIgaT10Lmxlbmd0aD4wP3RbMF06XCJcIjt2YXIgZj1CKFwiJVwiK2krXCIlXCIsZSk7dmFyIHA9Zi5uYW1lO3ZhciB1PWYudmFsdWU7dmFyIHM9ZmFsc2U7dmFyIGM9Zi5hbGlhcztpZihjKXtpPWNbMF07aCh0LFMoWzAsMV0sYykpfWZvcih2YXIgbD0xLGc9dHJ1ZTtsPHQubGVuZ3RoO2wrPTEpe3ZhciB2PXRbbF07dmFyIGI9Tyh2LDAsMSk7dmFyIEE9Tyh2LC0xKTtpZigoYj09PSdcIid8fGI9PT1cIidcInx8Yj09PVwiYFwifHwoQT09PSdcIid8fEE9PT1cIidcInx8QT09PVwiYFwiKSkmJmIhPT1BKXt0aHJvdyBuZXcgbihcInByb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXNcIil9aWYodj09PVwiY29uc3RydWN0b3JcInx8IWcpe3M9dHJ1ZX1pKz1cIi5cIit2O3A9XCIlXCIraStcIiVcIjtpZihtKGQscCkpe3U9ZFtwXX1lbHNlIGlmKHUhPW51bGwpe2lmKCEodiBpbiB1KSl7aWYoIWUpe3Rocm93IG5ldyBhKFwiYmFzZSBpbnRyaW5zaWMgZm9yIFwiK3IrXCIgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuXCIpfXJldHVybiB2b2lkIG99aWYoeSYmbCsxPj10Lmxlbmd0aCl7dmFyIFA9eSh1LHYpO2c9ISFQO2lmKGcmJlwiZ2V0XCJpbiBQJiYhKFwib3JpZ2luYWxWYWx1ZVwiaW4gUC5nZXQpKXt1PVAuZ2V0fWVsc2V7dT11W3ZdfX1lbHNle2c9bSh1LHYpO3U9dVt2XX1pZihnJiYhcyl7ZFtwXT11fX19cmV0dXJuIHV9fSw1MDQ6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9e2Zvbzp7fX07dmFyIHQ9T2JqZWN0O3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNQcm90bygpe3JldHVybntfX3Byb3RvX186ZX0uZm9vPT09ZS5mb28mJiEoe19fcHJvdG9fXzpudWxsfWluc3RhbmNlb2YgdCl9fSw5NDI6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiJiZTeW1ib2w7dmFyIG49dCg3NzMpO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCl7aWYodHlwZW9mIG8hPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIG8oXCJmb29cIikhPT1cInN5bWJvbFwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIFN5bWJvbChcImJhclwiKSE9PVwic3ltYm9sXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gbigpfX0sNzczOmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNTeW1ib2xzKCl7aWYodHlwZW9mIFN5bWJvbCE9PVwiZnVuY3Rpb25cInx8dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMhPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sLml0ZXJhdG9yPT09XCJzeW1ib2xcIil7cmV0dXJuIHRydWV9dmFyIHI9e307dmFyIGU9U3ltYm9sKFwidGVzdFwiKTt2YXIgdD1PYmplY3QoZSk7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtyZXR1cm4gZmFsc2V9aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpIT09XCJbb2JqZWN0IFN5bWJvbF1cIil7cmV0dXJuIGZhbHNlfWlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSE9PVwiW29iamVjdCBTeW1ib2xdXCIpe3JldHVybiBmYWxzZX12YXIgbz00MjtyW2VdPW87Zm9yKGUgaW4gcil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3Qua2V5cz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmtleXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfXZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocik7aWYobi5sZW5ndGghPT0xfHxuWzBdIT09ZSl7cmV0dXJuIGZhbHNlfWlmKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocixlKSl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yPT09XCJmdW5jdGlvblwiKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZSk7aWYoaS52YWx1ZSE9PW98fGkuZW51bWVyYWJsZSE9PXRydWUpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9fSwxMTU6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiJiZTeW1ib2w7dmFyIG49dCg4MzIpO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCl7aWYodHlwZW9mIG8hPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIG8oXCJmb29cIikhPT1cInN5bWJvbFwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIFN5bWJvbChcImJhclwiKSE9PVwic3ltYm9sXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gbigpfX0sODMyOmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNTeW1ib2xzKCl7aWYodHlwZW9mIFN5bWJvbCE9PVwiZnVuY3Rpb25cInx8dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMhPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sLml0ZXJhdG9yPT09XCJzeW1ib2xcIil7cmV0dXJuIHRydWV9dmFyIHI9e307dmFyIGU9U3ltYm9sKFwidGVzdFwiKTt2YXIgdD1PYmplY3QoZSk7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtyZXR1cm4gZmFsc2V9aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpIT09XCJbb2JqZWN0IFN5bWJvbF1cIil7cmV0dXJuIGZhbHNlfWlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSE9PVwiW29iamVjdCBTeW1ib2xdXCIpe3JldHVybiBmYWxzZX12YXIgbz00MjtyW2VdPW87Zm9yKGUgaW4gcil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3Qua2V5cz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmtleXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfXZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocik7aWYobi5sZW5ndGghPT0xfHxuWzBdIT09ZSl7cmV0dXJuIGZhbHNlfWlmKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocixlKSl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yPT09XCJmdW5jdGlvblwiKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZSk7aWYoaS52YWx1ZSE9PW98fGkuZW51bWVyYWJsZSE9PXRydWUpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9fSwxMDE6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXQoMTc0KTtyLmV4cG9ydHM9by5jYWxsKEZ1bmN0aW9uLmNhbGwsT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSl9LDc4MjpmdW5jdGlvbihyKXtpZih0eXBlb2YgT2JqZWN0LmNyZWF0ZT09PVwiZnVuY3Rpb25cIil7ci5leHBvcnRzPWZ1bmN0aW9uIGluaGVyaXRzKHIsZSl7aWYoZSl7ci5zdXBlcl89ZTtyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6cixlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWV9fSl9fX1lbHNle3IuZXhwb3J0cz1mdW5jdGlvbiBpbmhlcml0cyhyLGUpe2lmKGUpe3Iuc3VwZXJfPWU7dmFyIFRlbXBDdG9yPWZ1bmN0aW9uKCl7fTtUZW1wQ3Rvci5wcm90b3R5cGU9ZS5wcm90b3R5cGU7ci5wcm90b3R5cGU9bmV3IFRlbXBDdG9yO3IucHJvdG90eXBlLmNvbnN0cnVjdG9yPXJ9fX19LDE1NzpmdW5jdGlvbihyKXtcInVzZSBzdHJpY3RcIjt2YXIgZT10eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT09XCJzeW1ib2xcIjt2YXIgdD1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO3ZhciBvPWZ1bmN0aW9uIGlzQXJndW1lbnRzKHIpe2lmKGUmJnImJnR5cGVvZiByPT09XCJvYmplY3RcIiYmU3ltYm9sLnRvU3RyaW5nVGFnIGluIHIpe3JldHVybiBmYWxzZX1yZXR1cm4gdC5jYWxsKHIpPT09XCJbb2JqZWN0IEFyZ3VtZW50c11cIn07dmFyIG49ZnVuY3Rpb24gaXNBcmd1bWVudHMocil7aWYobyhyKSl7cmV0dXJuIHRydWV9cmV0dXJuIHIhPT1udWxsJiZ0eXBlb2Ygcj09PVwib2JqZWN0XCImJnR5cGVvZiByLmxlbmd0aD09PVwibnVtYmVyXCImJnIubGVuZ3RoPj0wJiZ0LmNhbGwocikhPT1cIltvYmplY3QgQXJyYXldXCImJnQuY2FsbChyLmNhbGxlZSk9PT1cIltvYmplY3QgRnVuY3Rpb25dXCJ9O3ZhciBpPWZ1bmN0aW9uKCl7cmV0dXJuIG8oYXJndW1lbnRzKX0oKTtvLmlzTGVnYWN5QXJndW1lbnRzPW47ci5leHBvcnRzPWk/bzpufSwzOTE6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt2YXIgdD1GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7dmFyIG89L15cXHMqKD86ZnVuY3Rpb24pP1xcKi87dmFyIG49dHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09PVwic3ltYm9sXCI7dmFyIGk9T2JqZWN0LmdldFByb3RvdHlwZU9mO3ZhciBnZXRHZW5lcmF0b3JGdW5jPWZ1bmN0aW9uKCl7aWYoIW4pe3JldHVybiBmYWxzZX10cnl7cmV0dXJuIEZ1bmN0aW9uKFwicmV0dXJuIGZ1bmN0aW9uKigpIHt9XCIpKCl9Y2F0Y2gocil7fX07dmFyIGE9Z2V0R2VuZXJhdG9yRnVuYygpO3ZhciB5PWE/aShhKTp7fTtyLmV4cG9ydHM9ZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihyKXtpZih0eXBlb2YgciE9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZhbHNlfWlmKG8udGVzdCh0LmNhbGwocikpKXtyZXR1cm4gdHJ1ZX1pZighbil7dmFyIGE9ZS5jYWxsKHIpO3JldHVybiBhPT09XCJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXVwifXJldHVybiBpKHIpPT09eX19LDk5NDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG89dCgxNDQpO3ZhciBuPXQoMzQ5KTt2YXIgaT10KDI1Nik7dmFyIGE9aShcIk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcIik7dmFyIHk9dCg5NDIpKCk7dmFyIGY9eSYmdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09PVwic3ltYm9sXCI7dmFyIHA9bigpO3ZhciB1PWkoXCJBcnJheS5wcm90b3R5cGUuaW5kZXhPZlwiLHRydWUpfHxmdW5jdGlvbiBpbmRleE9mKHIsZSl7Zm9yKHZhciB0PTA7dDxyLmxlbmd0aDt0Kz0xKXtpZihyW3RdPT09ZSl7cmV0dXJuIHR9fXJldHVybi0xfTt2YXIgcz1pKFwiU3RyaW5nLnByb3RvdHlwZS5zbGljZVwiKTt2YXIgYz17fTt2YXIgbD10KDI0KTt2YXIgZD1PYmplY3QuZ2V0UHJvdG90eXBlT2Y7aWYoZiYmbCYmZCl7byhwLChmdW5jdGlvbihyKXt2YXIgZT1uZXcgZ2xvYmFsW3JdO2lmKCEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGUpKXt0aHJvdyBuZXcgRXZhbEVycm9yKFwidGhpcyBlbmdpbmUgaGFzIHN1cHBvcnQgZm9yIFN5bWJvbC50b1N0cmluZ1RhZywgYnV0IFwiK3IrXCIgZG9lcyBub3QgaGF2ZSB0aGUgcHJvcGVydHkhIFBsZWFzZSByZXBvcnQgdGhpcy5cIil9dmFyIHQ9ZChlKTt2YXIgbz1sKHQsU3ltYm9sLnRvU3RyaW5nVGFnKTtpZighbyl7dmFyIG49ZCh0KTtvPWwobixTeW1ib2wudG9TdHJpbmdUYWcpfWNbcl09by5nZXR9KSl9dmFyIGc9ZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXMocil7dmFyIGU9ZmFsc2U7byhjLChmdW5jdGlvbih0LG8pe2lmKCFlKXt0cnl7ZT10LmNhbGwocik9PT1vfWNhdGNoKHIpe319fSkpO3JldHVybiBlfTtyLmV4cG9ydHM9ZnVuY3Rpb24gaXNUeXBlZEFycmF5KHIpe2lmKCFyfHx0eXBlb2YgciE9PVwib2JqZWN0XCIpe3JldHVybiBmYWxzZX1pZighZil7dmFyIGU9cyhhKHIpLDgsLTEpO3JldHVybiB1KHAsZSk+LTF9aWYoIWwpe3JldHVybiBmYWxzZX1yZXR1cm4gZyhyKX19LDM2OTpmdW5jdGlvbihyKXtyLmV4cG9ydHM9ZnVuY3Rpb24gaXNCdWZmZXIocil7cmV0dXJuIHIgaW5zdGFuY2VvZiBCdWZmZXJ9fSw1ODQ6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXQoMTU3KTt2YXIgbj10KDM5MSk7dmFyIGk9dCg0OTApO3ZhciBhPXQoOTk0KTtmdW5jdGlvbiB1bmN1cnJ5VGhpcyhyKXtyZXR1cm4gci5jYWxsLmJpbmQocil9dmFyIHk9dHlwZW9mIEJpZ0ludCE9PVwidW5kZWZpbmVkXCI7dmFyIGY9dHlwZW9mIFN5bWJvbCE9PVwidW5kZWZpbmVkXCI7dmFyIHA9dW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7dmFyIHU9dW5jdXJyeVRoaXMoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mKTt2YXIgcz11bmN1cnJ5VGhpcyhTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YpO3ZhciBjPXVuY3VycnlUaGlzKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpO2lmKHkpe3ZhciBsPXVuY3VycnlUaGlzKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZil9aWYoZil7dmFyIGQ9dW5jdXJyeVRoaXMoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mKX1mdW5jdGlvbiBjaGVja0JveGVkUHJpbWl0aXZlKHIsZSl7aWYodHlwZW9mIHIhPT1cIm9iamVjdFwiKXtyZXR1cm4gZmFsc2V9dHJ5e2Uocik7cmV0dXJuIHRydWV9Y2F0Y2gocil7cmV0dXJuIGZhbHNlfX1lLmlzQXJndW1lbnRzT2JqZWN0PW87ZS5pc0dlbmVyYXRvckZ1bmN0aW9uPW47ZS5pc1R5cGVkQXJyYXk9YTtmdW5jdGlvbiBpc1Byb21pc2Uocil7cmV0dXJuIHR5cGVvZiBQcm9taXNlIT09XCJ1bmRlZmluZWRcIiYmciBpbnN0YW5jZW9mIFByb21pc2V8fHIhPT1udWxsJiZ0eXBlb2Ygcj09PVwib2JqZWN0XCImJnR5cGVvZiByLnRoZW49PT1cImZ1bmN0aW9uXCImJnR5cGVvZiByLmNhdGNoPT09XCJmdW5jdGlvblwifWUuaXNQcm9taXNlPWlzUHJvbWlzZTtmdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyhyKXtpZih0eXBlb2YgQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiJiZBcnJheUJ1ZmZlci5pc1ZpZXcpe3JldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcocil9cmV0dXJuIGEocil8fGlzRGF0YVZpZXcocil9ZS5pc0FycmF5QnVmZmVyVmlldz1pc0FycmF5QnVmZmVyVmlldztmdW5jdGlvbiBpc1VpbnQ4QXJyYXkocil7cmV0dXJuIGkocik9PT1cIlVpbnQ4QXJyYXlcIn1lLmlzVWludDhBcnJheT1pc1VpbnQ4QXJyYXk7ZnVuY3Rpb24gaXNVaW50OENsYW1wZWRBcnJheShyKXtyZXR1cm4gaShyKT09PVwiVWludDhDbGFtcGVkQXJyYXlcIn1lLmlzVWludDhDbGFtcGVkQXJyYXk9aXNVaW50OENsYW1wZWRBcnJheTtmdW5jdGlvbiBpc1VpbnQxNkFycmF5KHIpe3JldHVybiBpKHIpPT09XCJVaW50MTZBcnJheVwifWUuaXNVaW50MTZBcnJheT1pc1VpbnQxNkFycmF5O2Z1bmN0aW9uIGlzVWludDMyQXJyYXkocil7cmV0dXJuIGkocik9PT1cIlVpbnQzMkFycmF5XCJ9ZS5pc1VpbnQzMkFycmF5PWlzVWludDMyQXJyYXk7ZnVuY3Rpb24gaXNJbnQ4QXJyYXkocil7cmV0dXJuIGkocik9PT1cIkludDhBcnJheVwifWUuaXNJbnQ4QXJyYXk9aXNJbnQ4QXJyYXk7ZnVuY3Rpb24gaXNJbnQxNkFycmF5KHIpe3JldHVybiBpKHIpPT09XCJJbnQxNkFycmF5XCJ9ZS5pc0ludDE2QXJyYXk9aXNJbnQxNkFycmF5O2Z1bmN0aW9uIGlzSW50MzJBcnJheShyKXtyZXR1cm4gaShyKT09PVwiSW50MzJBcnJheVwifWUuaXNJbnQzMkFycmF5PWlzSW50MzJBcnJheTtmdW5jdGlvbiBpc0Zsb2F0MzJBcnJheShyKXtyZXR1cm4gaShyKT09PVwiRmxvYXQzMkFycmF5XCJ9ZS5pc0Zsb2F0MzJBcnJheT1pc0Zsb2F0MzJBcnJheTtmdW5jdGlvbiBpc0Zsb2F0NjRBcnJheShyKXtyZXR1cm4gaShyKT09PVwiRmxvYXQ2NEFycmF5XCJ9ZS5pc0Zsb2F0NjRBcnJheT1pc0Zsb2F0NjRBcnJheTtmdW5jdGlvbiBpc0JpZ0ludDY0QXJyYXkocil7cmV0dXJuIGkocik9PT1cIkJpZ0ludDY0QXJyYXlcIn1lLmlzQmlnSW50NjRBcnJheT1pc0JpZ0ludDY0QXJyYXk7ZnVuY3Rpb24gaXNCaWdVaW50NjRBcnJheShyKXtyZXR1cm4gaShyKT09PVwiQmlnVWludDY0QXJyYXlcIn1lLmlzQmlnVWludDY0QXJyYXk9aXNCaWdVaW50NjRBcnJheTtmdW5jdGlvbiBpc01hcFRvU3RyaW5nKHIpe3JldHVybiBwKHIpPT09XCJbb2JqZWN0IE1hcF1cIn1pc01hcFRvU3RyaW5nLndvcmtpbmc9dHlwZW9mIE1hcCE9PVwidW5kZWZpbmVkXCImJmlzTWFwVG9TdHJpbmcobmV3IE1hcCk7ZnVuY3Rpb24gaXNNYXAocil7aWYodHlwZW9mIE1hcD09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gaXNNYXBUb1N0cmluZy53b3JraW5nP2lzTWFwVG9TdHJpbmcocik6ciBpbnN0YW5jZW9mIE1hcH1lLmlzTWFwPWlzTWFwO2Z1bmN0aW9uIGlzU2V0VG9TdHJpbmcocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgU2V0XVwifWlzU2V0VG9TdHJpbmcud29ya2luZz10eXBlb2YgU2V0IT09XCJ1bmRlZmluZWRcIiYmaXNTZXRUb1N0cmluZyhuZXcgU2V0KTtmdW5jdGlvbiBpc1NldChyKXtpZih0eXBlb2YgU2V0PT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZhbHNlfXJldHVybiBpc1NldFRvU3RyaW5nLndvcmtpbmc/aXNTZXRUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgU2V0fWUuaXNTZXQ9aXNTZXQ7ZnVuY3Rpb24gaXNXZWFrTWFwVG9TdHJpbmcocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgV2Vha01hcF1cIn1pc1dlYWtNYXBUb1N0cmluZy53b3JraW5nPXR5cGVvZiBXZWFrTWFwIT09XCJ1bmRlZmluZWRcIiYmaXNXZWFrTWFwVG9TdHJpbmcobmV3IFdlYWtNYXApO2Z1bmN0aW9uIGlzV2Vha01hcChyKXtpZih0eXBlb2YgV2Vha01hcD09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZz9pc1dlYWtNYXBUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgV2Vha01hcH1lLmlzV2Vha01hcD1pc1dlYWtNYXA7ZnVuY3Rpb24gaXNXZWFrU2V0VG9TdHJpbmcocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgV2Vha1NldF1cIn1pc1dlYWtTZXRUb1N0cmluZy53b3JraW5nPXR5cGVvZiBXZWFrU2V0IT09XCJ1bmRlZmluZWRcIiYmaXNXZWFrU2V0VG9TdHJpbmcobmV3IFdlYWtTZXQpO2Z1bmN0aW9uIGlzV2Vha1NldChyKXtyZXR1cm4gaXNXZWFrU2V0VG9TdHJpbmcocil9ZS5pc1dlYWtTZXQ9aXNXZWFrU2V0O2Z1bmN0aW9uIGlzQXJyYXlCdWZmZXJUb1N0cmluZyhyKXtyZXR1cm4gcChyKT09PVwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIn1pc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZz10eXBlb2YgQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiJiZpc0FycmF5QnVmZmVyVG9TdHJpbmcobmV3IEFycmF5QnVmZmVyKTtmdW5jdGlvbiBpc0FycmF5QnVmZmVyKHIpe2lmKHR5cGVvZiBBcnJheUJ1ZmZlcj09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmc/aXNBcnJheUJ1ZmZlclRvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcn1lLmlzQXJyYXlCdWZmZXI9aXNBcnJheUJ1ZmZlcjtmdW5jdGlvbiBpc0RhdGFWaWV3VG9TdHJpbmcocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgRGF0YVZpZXddXCJ9aXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmc9dHlwZW9mIEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIiYmdHlwZW9mIERhdGFWaWV3IT09XCJ1bmRlZmluZWRcIiYmaXNEYXRhVmlld1RvU3RyaW5nKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSksMCwxKSk7ZnVuY3Rpb24gaXNEYXRhVmlldyhyKXtpZih0eXBlb2YgRGF0YVZpZXc9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZmFsc2V9cmV0dXJuIGlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nP2lzRGF0YVZpZXdUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgRGF0YVZpZXd9ZS5pc0RhdGFWaWV3PWlzRGF0YVZpZXc7dmFyIGc9dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIj9TaGFyZWRBcnJheUJ1ZmZlcjp1bmRlZmluZWQ7ZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHIpe3JldHVybiBwKHIpPT09XCJbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXVwifWZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIocil7aWYodHlwZW9mIGc9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nPT09XCJ1bmRlZmluZWRcIil7aXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmc9aXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBnKX1yZXR1cm4gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmc/aXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBnfWUuaXNTaGFyZWRBcnJheUJ1ZmZlcj1pc1NoYXJlZEFycmF5QnVmZmVyO2Z1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbihyKXtyZXR1cm4gcChyKT09PVwiW29iamVjdCBBc3luY0Z1bmN0aW9uXVwifWUuaXNBc3luY0Z1bmN0aW9uPWlzQXN5bmNGdW5jdGlvbjtmdW5jdGlvbiBpc01hcEl0ZXJhdG9yKHIpe3JldHVybiBwKHIpPT09XCJbb2JqZWN0IE1hcCBJdGVyYXRvcl1cIn1lLmlzTWFwSXRlcmF0b3I9aXNNYXBJdGVyYXRvcjtmdW5jdGlvbiBpc1NldEl0ZXJhdG9yKHIpe3JldHVybiBwKHIpPT09XCJbb2JqZWN0IFNldCBJdGVyYXRvcl1cIn1lLmlzU2V0SXRlcmF0b3I9aXNTZXRJdGVyYXRvcjtmdW5jdGlvbiBpc0dlbmVyYXRvck9iamVjdChyKXtyZXR1cm4gcChyKT09PVwiW29iamVjdCBHZW5lcmF0b3JdXCJ9ZS5pc0dlbmVyYXRvck9iamVjdD1pc0dlbmVyYXRvck9iamVjdDtmdW5jdGlvbiBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgV2ViQXNzZW1ibHkuTW9kdWxlXVwifWUuaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlPWlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZTtmdW5jdGlvbiBpc051bWJlck9iamVjdChyKXtyZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZShyLHUpfWUuaXNOdW1iZXJPYmplY3Q9aXNOdW1iZXJPYmplY3Q7ZnVuY3Rpb24gaXNTdHJpbmdPYmplY3Qocil7cmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUocixzKX1lLmlzU3RyaW5nT2JqZWN0PWlzU3RyaW5nT2JqZWN0O2Z1bmN0aW9uIGlzQm9vbGVhbk9iamVjdChyKXtyZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZShyLGMpfWUuaXNCb29sZWFuT2JqZWN0PWlzQm9vbGVhbk9iamVjdDtmdW5jdGlvbiBpc0JpZ0ludE9iamVjdChyKXtyZXR1cm4geSYmY2hlY2tCb3hlZFByaW1pdGl2ZShyLGwpfWUuaXNCaWdJbnRPYmplY3Q9aXNCaWdJbnRPYmplY3Q7ZnVuY3Rpb24gaXNTeW1ib2xPYmplY3Qocil7cmV0dXJuIGYmJmNoZWNrQm94ZWRQcmltaXRpdmUocixkKX1lLmlzU3ltYm9sT2JqZWN0PWlzU3ltYm9sT2JqZWN0O2Z1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUocil7cmV0dXJuIGlzTnVtYmVyT2JqZWN0KHIpfHxpc1N0cmluZ09iamVjdChyKXx8aXNCb29sZWFuT2JqZWN0KHIpfHxpc0JpZ0ludE9iamVjdChyKXx8aXNTeW1ib2xPYmplY3Qocil9ZS5pc0JveGVkUHJpbWl0aXZlPWlzQm94ZWRQcmltaXRpdmU7ZnVuY3Rpb24gaXNBbnlBcnJheUJ1ZmZlcihyKXtyZXR1cm4gdHlwZW9mIFVpbnQ4QXJyYXkhPT1cInVuZGVmaW5lZFwiJiYoaXNBcnJheUJ1ZmZlcihyKXx8aXNTaGFyZWRBcnJheUJ1ZmZlcihyKSl9ZS5pc0FueUFycmF5QnVmZmVyPWlzQW55QXJyYXlCdWZmZXI7W1wiaXNQcm94eVwiLFwiaXNFeHRlcm5hbFwiLFwiaXNNb2R1bGVOYW1lc3BhY2VPYmplY3RcIl0uZm9yRWFjaCgoZnVuY3Rpb24ocil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7ZW51bWVyYWJsZTpmYWxzZSx2YWx1ZTpmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihyK1wiIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdXNlcmxhbmRcIil9fSl9KSl9LDE3NzpmdW5jdGlvbihyLGUsdCl7dmFyIG89T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnN8fGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocil7dmFyIGU9T2JqZWN0LmtleXMocik7dmFyIHQ9e307Zm9yKHZhciBvPTA7bzxlLmxlbmd0aDtvKyspe3RbZVtvXV09T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLGVbb10pfXJldHVybiB0fTt2YXIgbj0vJVtzZGolXS9nO2UuZm9ybWF0PWZ1bmN0aW9uKHIpe2lmKCFpc1N0cmluZyhyKSl7dmFyIGU9W107Zm9yKHZhciB0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7ZS5wdXNoKGluc3BlY3QoYXJndW1lbnRzW3RdKSl9cmV0dXJuIGUuam9pbihcIiBcIil9dmFyIHQ9MTt2YXIgbz1hcmd1bWVudHM7dmFyIGk9by5sZW5ndGg7dmFyIGE9U3RyaW5nKHIpLnJlcGxhY2UobiwoZnVuY3Rpb24ocil7aWYocj09PVwiJSVcIilyZXR1cm5cIiVcIjtpZih0Pj1pKXJldHVybiByO3N3aXRjaChyKXtjYXNlXCIlc1wiOnJldHVybiBTdHJpbmcob1t0KytdKTtjYXNlXCIlZFwiOnJldHVybiBOdW1iZXIob1t0KytdKTtjYXNlXCIlalwiOnRyeXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkob1t0KytdKX1jYXRjaChyKXtyZXR1cm5cIltDaXJjdWxhcl1cIn1kZWZhdWx0OnJldHVybiByfX0pKTtmb3IodmFyIHk9b1t0XTt0PGk7eT1vWysrdF0pe2lmKGlzTnVsbCh5KXx8IWlzT2JqZWN0KHkpKXthKz1cIiBcIit5fWVsc2V7YSs9XCIgXCIraW5zcGVjdCh5KX19cmV0dXJuIGF9O2UuZGVwcmVjYXRlPWZ1bmN0aW9uKHIsdCl7aWYodHlwZW9mIHByb2Nlc3MhPT1cInVuZGVmaW5lZFwiJiZwcm9jZXNzLm5vRGVwcmVjYXRpb249PT10cnVlKXtyZXR1cm4gcn1pZih0eXBlb2YgcHJvY2Vzcz09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBlLmRlcHJlY2F0ZShyLHQpLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19dmFyIG89ZmFsc2U7ZnVuY3Rpb24gZGVwcmVjYXRlZCgpe2lmKCFvKXtpZihwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pe3Rocm93IG5ldyBFcnJvcih0KX1lbHNlIGlmKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbil7Y29uc29sZS50cmFjZSh0KX1lbHNle2NvbnNvbGUuZXJyb3IodCl9bz10cnVlfXJldHVybiByLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gZGVwcmVjYXRlZH07dmFyIGk9e307dmFyIGE9L14kLztpZihwcm9jZXNzLmVudi5OT0RFX0RFQlVHKXt2YXIgeT1wcm9jZXNzLmVudi5OT0RFX0RFQlVHO3k9eS5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKz8uXS9nLFwiXFxcXCQmXCIpLnJlcGxhY2UoL1xcKi9nLFwiLipcIikucmVwbGFjZSgvLC9nLFwiJHxeXCIpLnRvVXBwZXJDYXNlKCk7YT1uZXcgUmVnRXhwKFwiXlwiK3krXCIkXCIsXCJpXCIpfWUuZGVidWdsb2c9ZnVuY3Rpb24ocil7cj1yLnRvVXBwZXJDYXNlKCk7aWYoIWlbcl0pe2lmKGEudGVzdChyKSl7dmFyIHQ9cHJvY2Vzcy5waWQ7aVtyXT1mdW5jdGlvbigpe3ZhciBvPWUuZm9ybWF0LmFwcGx5KGUsYXJndW1lbnRzKTtjb25zb2xlLmVycm9yKFwiJXMgJWQ6ICVzXCIscix0LG8pfX1lbHNle2lbcl09ZnVuY3Rpb24oKXt9fX1yZXR1cm4gaVtyXX07ZnVuY3Rpb24gaW5zcGVjdChyLHQpe3ZhciBvPXtzZWVuOltdLHN0eWxpemU6c3R5bGl6ZU5vQ29sb3J9O2lmKGFyZ3VtZW50cy5sZW5ndGg+PTMpby5kZXB0aD1hcmd1bWVudHNbMl07aWYoYXJndW1lbnRzLmxlbmd0aD49NClvLmNvbG9ycz1hcmd1bWVudHNbM107aWYoaXNCb29sZWFuKHQpKXtvLnNob3dIaWRkZW49dH1lbHNlIGlmKHQpe2UuX2V4dGVuZChvLHQpfWlmKGlzVW5kZWZpbmVkKG8uc2hvd0hpZGRlbikpby5zaG93SGlkZGVuPWZhbHNlO2lmKGlzVW5kZWZpbmVkKG8uZGVwdGgpKW8uZGVwdGg9MjtpZihpc1VuZGVmaW5lZChvLmNvbG9ycykpby5jb2xvcnM9ZmFsc2U7aWYoaXNVbmRlZmluZWQoby5jdXN0b21JbnNwZWN0KSlvLmN1c3RvbUluc3BlY3Q9dHJ1ZTtpZihvLmNvbG9ycylvLnN0eWxpemU9c3R5bGl6ZVdpdGhDb2xvcjtyZXR1cm4gZm9ybWF0VmFsdWUobyxyLG8uZGVwdGgpfWUuaW5zcGVjdD1pbnNwZWN0O2luc3BlY3QuY29sb3JzPXtib2xkOlsxLDIyXSxpdGFsaWM6WzMsMjNdLHVuZGVybGluZTpbNCwyNF0saW52ZXJzZTpbNywyN10sd2hpdGU6WzM3LDM5XSxncmV5Ols5MCwzOV0sYmxhY2s6WzMwLDM5XSxibHVlOlszNCwzOV0sY3lhbjpbMzYsMzldLGdyZWVuOlszMiwzOV0sbWFnZW50YTpbMzUsMzldLHJlZDpbMzEsMzldLHllbGxvdzpbMzMsMzldfTtpbnNwZWN0LnN0eWxlcz17c3BlY2lhbDpcImN5YW5cIixudW1iZXI6XCJ5ZWxsb3dcIixib29sZWFuOlwieWVsbG93XCIsdW5kZWZpbmVkOlwiZ3JleVwiLG51bGw6XCJib2xkXCIsc3RyaW5nOlwiZ3JlZW5cIixkYXRlOlwibWFnZW50YVwiLHJlZ2V4cDpcInJlZFwifTtmdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHIsZSl7dmFyIHQ9aW5zcGVjdC5zdHlsZXNbZV07aWYodCl7cmV0dXJuXCJcdTAwMWJbXCIraW5zcGVjdC5jb2xvcnNbdF1bMF0rXCJtXCIrcitcIlx1MDAxYltcIitpbnNwZWN0LmNvbG9yc1t0XVsxXStcIm1cIn1lbHNle3JldHVybiByfX1mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihyLGUpe3JldHVybiByfWZ1bmN0aW9uIGFycmF5VG9IYXNoKHIpe3ZhciBlPXt9O3IuZm9yRWFjaCgoZnVuY3Rpb24ocix0KXtlW3JdPXRydWV9KSk7cmV0dXJuIGV9ZnVuY3Rpb24gZm9ybWF0VmFsdWUocix0LG8pe2lmKHIuY3VzdG9tSW5zcGVjdCYmdCYmaXNGdW5jdGlvbih0Lmluc3BlY3QpJiZ0Lmluc3BlY3QhPT1lLmluc3BlY3QmJiEodC5jb25zdHJ1Y3RvciYmdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU9PT10KSl7dmFyIG49dC5pbnNwZWN0KG8scik7aWYoIWlzU3RyaW5nKG4pKXtuPWZvcm1hdFZhbHVlKHIsbixvKX1yZXR1cm4gbn12YXIgaT1mb3JtYXRQcmltaXRpdmUocix0KTtpZihpKXtyZXR1cm4gaX12YXIgYT1PYmplY3Qua2V5cyh0KTt2YXIgeT1hcnJheVRvSGFzaChhKTtpZihyLnNob3dIaWRkZW4pe2E9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModCl9aWYoaXNFcnJvcih0KSYmKGEuaW5kZXhPZihcIm1lc3NhZ2VcIik+PTB8fGEuaW5kZXhPZihcImRlc2NyaXB0aW9uXCIpPj0wKSl7cmV0dXJuIGZvcm1hdEVycm9yKHQpfWlmKGEubGVuZ3RoPT09MCl7aWYoaXNGdW5jdGlvbih0KSl7dmFyIGY9dC5uYW1lP1wiOiBcIit0Lm5hbWU6XCJcIjtyZXR1cm4gci5zdHlsaXplKFwiW0Z1bmN0aW9uXCIrZitcIl1cIixcInNwZWNpYWxcIil9aWYoaXNSZWdFeHAodCkpe3JldHVybiByLnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpLFwicmVnZXhwXCIpfWlmKGlzRGF0ZSh0KSl7cmV0dXJuIHIuc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpLFwiZGF0ZVwiKX1pZihpc0Vycm9yKHQpKXtyZXR1cm4gZm9ybWF0RXJyb3IodCl9fXZhciBwPVwiXCIsdT1mYWxzZSxzPVtcIntcIixcIn1cIl07aWYoaXNBcnJheSh0KSl7dT10cnVlO3M9W1wiW1wiLFwiXVwiXX1pZihpc0Z1bmN0aW9uKHQpKXt2YXIgYz10Lm5hbWU/XCI6IFwiK3QubmFtZTpcIlwiO3A9XCIgW0Z1bmN0aW9uXCIrYytcIl1cIn1pZihpc1JlZ0V4cCh0KSl7cD1cIiBcIitSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCl9aWYoaXNEYXRlKHQpKXtwPVwiIFwiK0RhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodCl9aWYoaXNFcnJvcih0KSl7cD1cIiBcIitmb3JtYXRFcnJvcih0KX1pZihhLmxlbmd0aD09PTAmJighdXx8dC5sZW5ndGg9PTApKXtyZXR1cm4gc1swXStwK3NbMV19aWYobzwwKXtpZihpc1JlZ0V4cCh0KSl7cmV0dXJuIHIuc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCksXCJyZWdleHBcIil9ZWxzZXtyZXR1cm4gci5zdHlsaXplKFwiW09iamVjdF1cIixcInNwZWNpYWxcIil9fXIuc2Vlbi5wdXNoKHQpO3ZhciBsO2lmKHUpe2w9Zm9ybWF0QXJyYXkocix0LG8seSxhKX1lbHNle2w9YS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBmb3JtYXRQcm9wZXJ0eShyLHQsbyx5LGUsdSl9KSl9ci5zZWVuLnBvcCgpO3JldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhsLHAscyl9ZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKHIsZSl7aWYoaXNVbmRlZmluZWQoZSkpcmV0dXJuIHIuc3R5bGl6ZShcInVuZGVmaW5lZFwiLFwidW5kZWZpbmVkXCIpO2lmKGlzU3RyaW5nKGUpKXt2YXIgdD1cIidcIitKU09OLnN0cmluZ2lmeShlKS5yZXBsYWNlKC9eXCJ8XCIkL2csXCJcIikucmVwbGFjZSgvJy9nLFwiXFxcXCdcIikucmVwbGFjZSgvXFxcXFwiL2csJ1wiJykrXCInXCI7cmV0dXJuIHIuc3R5bGl6ZSh0LFwic3RyaW5nXCIpfWlmKGlzTnVtYmVyKGUpKXJldHVybiByLnN0eWxpemUoXCJcIitlLFwibnVtYmVyXCIpO2lmKGlzQm9vbGVhbihlKSlyZXR1cm4gci5zdHlsaXplKFwiXCIrZSxcImJvb2xlYW5cIik7aWYoaXNOdWxsKGUpKXJldHVybiByLnN0eWxpemUoXCJudWxsXCIsXCJudWxsXCIpfWZ1bmN0aW9uIGZvcm1hdEVycm9yKHIpe3JldHVyblwiW1wiK0Vycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHIpK1wiXVwifWZ1bmN0aW9uIGZvcm1hdEFycmF5KHIsZSx0LG8sbil7dmFyIGk9W107Zm9yKHZhciBhPTAseT1lLmxlbmd0aDthPHk7KythKXtpZihoYXNPd25Qcm9wZXJ0eShlLFN0cmluZyhhKSkpe2kucHVzaChmb3JtYXRQcm9wZXJ0eShyLGUsdCxvLFN0cmluZyhhKSx0cnVlKSl9ZWxzZXtpLnB1c2goXCJcIil9fW4uZm9yRWFjaCgoZnVuY3Rpb24obil7aWYoIW4ubWF0Y2goL15cXGQrJC8pKXtpLnB1c2goZm9ybWF0UHJvcGVydHkocixlLHQsbyxuLHRydWUpKX19KSk7cmV0dXJuIGl9ZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkocixlLHQsbyxuLGkpe3ZhciBhLHksZjtmPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKXx8e3ZhbHVlOmVbbl19O2lmKGYuZ2V0KXtpZihmLnNldCl7eT1yLnN0eWxpemUoXCJbR2V0dGVyL1NldHRlcl1cIixcInNwZWNpYWxcIil9ZWxzZXt5PXIuc3R5bGl6ZShcIltHZXR0ZXJdXCIsXCJzcGVjaWFsXCIpfX1lbHNle2lmKGYuc2V0KXt5PXIuc3R5bGl6ZShcIltTZXR0ZXJdXCIsXCJzcGVjaWFsXCIpfX1pZighaGFzT3duUHJvcGVydHkobyxuKSl7YT1cIltcIituK1wiXVwifWlmKCF5KXtpZihyLnNlZW4uaW5kZXhPZihmLnZhbHVlKTwwKXtpZihpc051bGwodCkpe3k9Zm9ybWF0VmFsdWUocixmLnZhbHVlLG51bGwpfWVsc2V7eT1mb3JtYXRWYWx1ZShyLGYudmFsdWUsdC0xKX1pZih5LmluZGV4T2YoXCJcXG5cIik+LTEpe2lmKGkpe3k9eS5zcGxpdChcIlxcblwiKS5tYXAoKGZ1bmN0aW9uKHIpe3JldHVyblwiICBcIityfSkpLmpvaW4oXCJcXG5cIikuc3Vic3RyKDIpfWVsc2V7eT1cIlxcblwiK3kuc3BsaXQoXCJcXG5cIikubWFwKChmdW5jdGlvbihyKXtyZXR1cm5cIiAgIFwiK3J9KSkuam9pbihcIlxcblwiKX19fWVsc2V7eT1yLnN0eWxpemUoXCJbQ2lyY3VsYXJdXCIsXCJzcGVjaWFsXCIpfX1pZihpc1VuZGVmaW5lZChhKSl7aWYoaSYmbi5tYXRjaCgvXlxcZCskLykpe3JldHVybiB5fWE9SlNPTi5zdHJpbmdpZnkoXCJcIituKTtpZihhLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSl7YT1hLnN1YnN0cigxLGEubGVuZ3RoLTIpO2E9ci5zdHlsaXplKGEsXCJuYW1lXCIpfWVsc2V7YT1hLnJlcGxhY2UoLycvZyxcIlxcXFwnXCIpLnJlcGxhY2UoL1xcXFxcIi9nLCdcIicpLnJlcGxhY2UoLyheXCJ8XCIkKS9nLFwiJ1wiKTthPXIuc3R5bGl6ZShhLFwic3RyaW5nXCIpfX1yZXR1cm4gYStcIjogXCIreX1mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhyLGUsdCl7dmFyIG89MDt2YXIgbj1yLnJlZHVjZSgoZnVuY3Rpb24ocixlKXtvKys7aWYoZS5pbmRleE9mKFwiXFxuXCIpPj0wKW8rKztyZXR1cm4gcitlLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLFwiXCIpLmxlbmd0aCsxfSksMCk7aWYobj42MCl7cmV0dXJuIHRbMF0rKGU9PT1cIlwiP1wiXCI6ZStcIlxcbiBcIikrXCIgXCIrci5qb2luKFwiLFxcbiAgXCIpK1wiIFwiK3RbMV19cmV0dXJuIHRbMF0rZStcIiBcIityLmpvaW4oXCIsIFwiKStcIiBcIit0WzFdfWUudHlwZXM9dCg1ODQpO2Z1bmN0aW9uIGlzQXJyYXkocil7cmV0dXJuIEFycmF5LmlzQXJyYXkocil9ZS5pc0FycmF5PWlzQXJyYXk7ZnVuY3Rpb24gaXNCb29sZWFuKHIpe3JldHVybiB0eXBlb2Ygcj09PVwiYm9vbGVhblwifWUuaXNCb29sZWFuPWlzQm9vbGVhbjtmdW5jdGlvbiBpc051bGwocil7cmV0dXJuIHI9PT1udWxsfWUuaXNOdWxsPWlzTnVsbDtmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChyKXtyZXR1cm4gcj09bnVsbH1lLmlzTnVsbE9yVW5kZWZpbmVkPWlzTnVsbE9yVW5kZWZpbmVkO2Z1bmN0aW9uIGlzTnVtYmVyKHIpe3JldHVybiB0eXBlb2Ygcj09PVwibnVtYmVyXCJ9ZS5pc051bWJlcj1pc051bWJlcjtmdW5jdGlvbiBpc1N0cmluZyhyKXtyZXR1cm4gdHlwZW9mIHI9PT1cInN0cmluZ1wifWUuaXNTdHJpbmc9aXNTdHJpbmc7ZnVuY3Rpb24gaXNTeW1ib2wocil7cmV0dXJuIHR5cGVvZiByPT09XCJzeW1ib2xcIn1lLmlzU3ltYm9sPWlzU3ltYm9sO2Z1bmN0aW9uIGlzVW5kZWZpbmVkKHIpe3JldHVybiByPT09dm9pZCAwfWUuaXNVbmRlZmluZWQ9aXNVbmRlZmluZWQ7ZnVuY3Rpb24gaXNSZWdFeHAocil7cmV0dXJuIGlzT2JqZWN0KHIpJiZvYmplY3RUb1N0cmluZyhyKT09PVwiW29iamVjdCBSZWdFeHBdXCJ9ZS5pc1JlZ0V4cD1pc1JlZ0V4cDtlLnR5cGVzLmlzUmVnRXhwPWlzUmVnRXhwO2Z1bmN0aW9uIGlzT2JqZWN0KHIpe3JldHVybiB0eXBlb2Ygcj09PVwib2JqZWN0XCImJnIhPT1udWxsfWUuaXNPYmplY3Q9aXNPYmplY3Q7ZnVuY3Rpb24gaXNEYXRlKHIpe3JldHVybiBpc09iamVjdChyKSYmb2JqZWN0VG9TdHJpbmcocik9PT1cIltvYmplY3QgRGF0ZV1cIn1lLmlzRGF0ZT1pc0RhdGU7ZS50eXBlcy5pc0RhdGU9aXNEYXRlO2Z1bmN0aW9uIGlzRXJyb3Iocil7cmV0dXJuIGlzT2JqZWN0KHIpJiYob2JqZWN0VG9TdHJpbmcocik9PT1cIltvYmplY3QgRXJyb3JdXCJ8fHIgaW5zdGFuY2VvZiBFcnJvcil9ZS5pc0Vycm9yPWlzRXJyb3I7ZS50eXBlcy5pc05hdGl2ZUVycm9yPWlzRXJyb3I7ZnVuY3Rpb24gaXNGdW5jdGlvbihyKXtyZXR1cm4gdHlwZW9mIHI9PT1cImZ1bmN0aW9uXCJ9ZS5pc0Z1bmN0aW9uPWlzRnVuY3Rpb247ZnVuY3Rpb24gaXNQcmltaXRpdmUocil7cmV0dXJuIHI9PT1udWxsfHx0eXBlb2Ygcj09PVwiYm9vbGVhblwifHx0eXBlb2Ygcj09PVwibnVtYmVyXCJ8fHR5cGVvZiByPT09XCJzdHJpbmdcInx8dHlwZW9mIHI9PT1cInN5bWJvbFwifHx0eXBlb2Ygcj09PVwidW5kZWZpbmVkXCJ9ZS5pc1ByaW1pdGl2ZT1pc1ByaW1pdGl2ZTtlLmlzQnVmZmVyPXQoMzY5KTtmdW5jdGlvbiBvYmplY3RUb1N0cmluZyhyKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHIpfWZ1bmN0aW9uIHBhZChyKXtyZXR1cm4gcjwxMD9cIjBcIityLnRvU3RyaW5nKDEwKTpyLnRvU3RyaW5nKDEwKX12YXIgZj1bXCJKYW5cIixcIkZlYlwiLFwiTWFyXCIsXCJBcHJcIixcIk1heVwiLFwiSnVuXCIsXCJKdWxcIixcIkF1Z1wiLFwiU2VwXCIsXCJPY3RcIixcIk5vdlwiLFwiRGVjXCJdO2Z1bmN0aW9uIHRpbWVzdGFtcCgpe3ZhciByPW5ldyBEYXRlO3ZhciBlPVtwYWQoci5nZXRIb3VycygpKSxwYWQoci5nZXRNaW51dGVzKCkpLHBhZChyLmdldFNlY29uZHMoKSldLmpvaW4oXCI6XCIpO3JldHVybltyLmdldERhdGUoKSxmW3IuZ2V0TW9udGgoKV0sZV0uam9pbihcIiBcIil9ZS5sb2c9ZnVuY3Rpb24oKXtjb25zb2xlLmxvZyhcIiVzIC0gJXNcIix0aW1lc3RhbXAoKSxlLmZvcm1hdC5hcHBseShlLGFyZ3VtZW50cykpfTtlLmluaGVyaXRzPXQoNzgyKTtlLl9leHRlbmQ9ZnVuY3Rpb24ocixlKXtpZighZXx8IWlzT2JqZWN0KGUpKXJldHVybiByO3ZhciB0PU9iamVjdC5rZXlzKGUpO3ZhciBvPXQubGVuZ3RoO3doaWxlKG8tLSl7clt0W29dXT1lW3Rbb11dfXJldHVybiByfTtmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShyLGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixlKX12YXIgcD10eXBlb2YgU3ltYm9sIT09XCJ1bmRlZmluZWRcIj9TeW1ib2woXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIik6dW5kZWZpbmVkO2UucHJvbWlzaWZ5PWZ1bmN0aW9uIHByb21pc2lmeShyKXtpZih0eXBlb2YgciE9PVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO2lmKHAmJnJbcF0pe3ZhciBlPXJbcF07aWYodHlwZW9mIGUhPT1cImZ1bmN0aW9uXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHAse3ZhbHVlOmUsZW51bWVyYWJsZTpmYWxzZSx3cml0YWJsZTpmYWxzZSxjb25maWd1cmFibGU6dHJ1ZX0pO3JldHVybiBlfWZ1bmN0aW9uIGUoKXt2YXIgZSx0O3ZhciBvPW5ldyBQcm9taXNlKChmdW5jdGlvbihyLG8pe2U9cjt0PW99KSk7dmFyIG49W107Zm9yKHZhciBpPTA7aTxhcmd1bWVudHMubGVuZ3RoO2krKyl7bi5wdXNoKGFyZ3VtZW50c1tpXSl9bi5wdXNoKChmdW5jdGlvbihyLG8pe2lmKHIpe3Qocil9ZWxzZXtlKG8pfX0pKTt0cnl7ci5hcHBseSh0aGlzLG4pfWNhdGNoKHIpe3Qocil9cmV0dXJuIG99T2JqZWN0LnNldFByb3RvdHlwZU9mKGUsT2JqZWN0LmdldFByb3RvdHlwZU9mKHIpKTtpZihwKU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHAse3ZhbHVlOmUsZW51bWVyYWJsZTpmYWxzZSx3cml0YWJsZTpmYWxzZSxjb25maWd1cmFibGU6dHJ1ZX0pO3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLG8ocikpfTtlLnByb21pc2lmeS5jdXN0b209cDtmdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocixlKXtpZighcil7dmFyIHQ9bmV3IEVycm9yKFwiUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlXCIpO3QucmVhc29uPXI7cj10fXJldHVybiBlKHIpfWZ1bmN0aW9uIGNhbGxiYWNraWZ5KHIpe2lmKHR5cGVvZiByIT09XCJmdW5jdGlvblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpfWZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKXt2YXIgZT1bXTtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXtlLnB1c2goYXJndW1lbnRzW3RdKX12YXIgbz1lLnBvcCgpO2lmKHR5cGVvZiBvIT09XCJmdW5jdGlvblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uXCIpfXZhciBuPXRoaXM7dmFyIGNiPWZ1bmN0aW9uKCl7cmV0dXJuIG8uYXBwbHkobixhcmd1bWVudHMpfTtyLmFwcGx5KHRoaXMsZSkudGhlbigoZnVuY3Rpb24ocil7cHJvY2Vzcy5uZXh0VGljayhjYi5iaW5kKG51bGwsbnVsbCxyKSl9KSwoZnVuY3Rpb24ocil7cHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQuYmluZChudWxsLHIsY2IpKX0pKX1PYmplY3Quc2V0UHJvdG90eXBlT2YoY2FsbGJhY2tpZmllZCxPYmplY3QuZ2V0UHJvdG90eXBlT2YocikpO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNhbGxiYWNraWZpZWQsbyhyKSk7cmV0dXJuIGNhbGxiYWNraWZpZWR9ZS5jYWxsYmFja2lmeT1jYWxsYmFja2lmeX0sNDkwOmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbz10KDE0NCk7dmFyIG49dCgzNDkpO3ZhciBpPXQoMjU2KTt2YXIgYT1pKFwiT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1wiKTt2YXIgeT10KDk0MikoKTt2YXIgZj15JiZ0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT09XCJzeW1ib2xcIjt2YXIgcD1uKCk7dmFyIHU9aShcIlN0cmluZy5wcm90b3R5cGUuc2xpY2VcIik7dmFyIHM9e307dmFyIGM9dCgyNCk7dmFyIGw9T2JqZWN0LmdldFByb3RvdHlwZU9mO2lmKGYmJmMmJmwpe28ocCwoZnVuY3Rpb24ocil7aWYodHlwZW9mIGdsb2JhbFtyXT09PVwiZnVuY3Rpb25cIil7dmFyIGU9bmV3IGdsb2JhbFtyXTtpZighKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBlKSl7dGhyb3cgbmV3IEV2YWxFcnJvcihcInRoaXMgZW5naW5lIGhhcyBzdXBwb3J0IGZvciBTeW1ib2wudG9TdHJpbmdUYWcsIGJ1dCBcIityK1wiIGRvZXMgbm90IGhhdmUgdGhlIHByb3BlcnR5ISBQbGVhc2UgcmVwb3J0IHRoaXMuXCIpfXZhciB0PWwoZSk7dmFyIG89Yyh0LFN5bWJvbC50b1N0cmluZ1RhZyk7aWYoIW8pe3ZhciBuPWwodCk7bz1jKG4sU3ltYm9sLnRvU3RyaW5nVGFnKX1zW3JdPW8uZ2V0fX0pKX12YXIgZD1mdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyhyKXt2YXIgZT1mYWxzZTtvKHMsKGZ1bmN0aW9uKHQsbyl7aWYoIWUpe3RyeXt2YXIgbj10LmNhbGwocik7aWYobj09PW8pe2U9bn19Y2F0Y2gocil7fX19KSk7cmV0dXJuIGV9O3ZhciBnPXQoOTk0KTtyLmV4cG9ydHM9ZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHIpe2lmKCFnKHIpKXtyZXR1cm4gZmFsc2V9aWYoIWYpe3JldHVybiB1KGEociksOCwtMSl9cmV0dXJuIGQocil9fSwzNDk6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXQoOTkyKTtyLmV4cG9ydHM9ZnVuY3Rpb24gYXZhaWxhYmxlVHlwZWRBcnJheXMoKXtyZXR1cm4gbyhbXCJCaWdJbnQ2NEFycmF5XCIsXCJCaWdVaW50NjRBcnJheVwiLFwiRmxvYXQzMkFycmF5XCIsXCJGbG9hdDY0QXJyYXlcIixcIkludDE2QXJyYXlcIixcIkludDMyQXJyYXlcIixcIkludDhBcnJheVwiLFwiVWludDE2QXJyYXlcIixcIlVpbnQzMkFycmF5XCIsXCJVaW50OEFycmF5XCIsXCJVaW50OENsYW1wZWRBcnJheVwiXSwoZnVuY3Rpb24ocil7cmV0dXJuIHR5cGVvZiBnbG9iYWxbcl09PT1cImZ1bmN0aW9uXCJ9KSl9fSwyNDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG89dCg1MDApO3ZhciBuPW8oXCIlT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciVcIix0cnVlKTtpZihuKXt0cnl7bihbXSxcImxlbmd0aFwiKX1jYXRjaChyKXtuPW51bGx9fXIuZXhwb3J0cz1ufX07dmFyIGU9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyh0KXt2YXIgbz1lW3RdO2lmKG8hPT11bmRlZmluZWQpe3JldHVybiBvLmV4cG9ydHN9dmFyIG49ZVt0XT17ZXhwb3J0czp7fX07dmFyIGk9dHJ1ZTt0cnl7clt0XShuLG4uZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtpPWZhbHNlfWZpbmFsbHl7aWYoaSlkZWxldGUgZVt0XX1yZXR1cm4gbi5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgdD1fX25jY3dwY2tfcmVxdWlyZV9fKDE3Nyk7bW9kdWxlLmV4cG9ydHM9dH0pKCk7Il0sIm5hbWVzIjpbInIiLCJleHBvcnRzIiwidCIsIm8iLCJmaWx0ZXIiLCJUeXBlRXJyb3IiLCJuIiwiaSIsImxlbmd0aCIsImUiLCJjYWxsIiwiYSIsInB1c2giLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGxCb3VuZEludHJpbnNpYyIsInkiLCJmIiwicCIsInUiLCJ2YWx1ZSIsImNhbGxCaW5kIiwiYXJndW1lbnRzIiwiY29uZmlndXJhYmxlIiwicyIsImFwcGx5QmluZCIsImFwcGx5IiwidG9TdHJpbmciLCJmb3JFYWNoIiwiQXJyYXkiLCJzbGljZSIsImJpbmQiLCJiaW5kZXIiLCJjb25jYXQiLCJNYXRoIiwibWF4IiwiRnVuY3Rpb24iLCJqb2luIiwiRW1wdHkiLCJTeW50YXhFcnJvciIsImdldEV2YWxsZWRDb25zdHJ1Y3RvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInRocm93VHlwZUVycm9yIiwiY2FsbGVlIiwiZ2V0IiwiZ2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJjIiwiVWludDhBcnJheSIsImwiLCJBZ2dyZWdhdGVFcnJvciIsIkFycmF5QnVmZmVyIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJBdG9taWNzIiwiQmlnSW50IiwiQm9vbGVhbiIsIkRhdGFWaWV3IiwiRGF0ZSIsImRlY29kZVVSSSIsImRlY29kZVVSSUNvbXBvbmVudCIsImVuY29kZVVSSSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkVycm9yIiwiZXZhbCIsIkV2YWxFcnJvciIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIkZpbmFsaXphdGlvblJlZ2lzdHJ5IiwiSW50OEFycmF5IiwiSW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJpc0Zpbml0ZSIsImlzTmFOIiwiSlNPTiIsIk1hcCIsIk51bWJlciIsInBhcnNlRmxvYXQiLCJwYXJzZUludCIsIlByb21pc2UiLCJQcm94eSIsIlJhbmdlRXJyb3IiLCJSZWZlcmVuY2VFcnJvciIsIlJlZmxlY3QiLCJSZWdFeHAiLCJTZXQiLCJTaGFyZWRBcnJheUJ1ZmZlciIsIlN0cmluZyIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiVWludDE2QXJyYXkiLCJVaW50MzJBcnJheSIsIlVSSUVycm9yIiwiV2Vha01hcCIsIldlYWtSZWYiLCJXZWFrU2V0IiwiZCIsImRvRXZhbCIsImciLCJ2IiwiYiIsIkEiLCJtIiwic3BsaWNlIiwiUyIsInJlcGxhY2UiLCJoIiwiUCIsImV4ZWMiLCJPIiwidyIsImoiLCJzdHJpbmdUb1BhdGgiLCJFIiwiZ2V0QmFzZUludHJpbnNpYyIsImFsaWFzIiwibmFtZSIsIkdldEludHJpbnNpYyIsIkJpZ0ludDY0QXJyYXkiLCJCaWdVaW50NjRBcnJheSIsImVycm9yIiwiSSIsIkIiLCJmb28iLCJoYXNQcm90byIsImhhc05hdGl2ZVN5bWJvbHMiLCJoYXNTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwia2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImVudW1lcmFibGUiLCJjcmVhdGUiLCJpbmhlcml0cyIsInN1cGVyXyIsImNvbnN0cnVjdG9yIiwid3JpdGFibGUiLCJUZW1wQ3RvciIsInRvU3RyaW5nVGFnIiwiaXNBcmd1bWVudHMiLCJpc0xlZ2FjeUFyZ3VtZW50cyIsImdldEdlbmVyYXRvckZ1bmMiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwidGVzdCIsImluZGV4T2YiLCJnbG9iYWwiLCJ0cnlBbGxUeXBlZEFycmF5cyIsImlzVHlwZWRBcnJheSIsImlzQnVmZmVyIiwiQnVmZmVyIiwidW5jdXJyeVRoaXMiLCJ2YWx1ZU9mIiwiY2hlY2tCb3hlZFByaW1pdGl2ZSIsImlzQXJndW1lbnRzT2JqZWN0IiwiaXNQcm9taXNlIiwidGhlbiIsImNhdGNoIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJpc1ZpZXciLCJpc0RhdGFWaWV3IiwiaXNVaW50OEFycmF5IiwiaXNVaW50OENsYW1wZWRBcnJheSIsImlzVWludDE2QXJyYXkiLCJpc1VpbnQzMkFycmF5IiwiaXNJbnQ4QXJyYXkiLCJpc0ludDE2QXJyYXkiLCJpc0ludDMyQXJyYXkiLCJpc0Zsb2F0MzJBcnJheSIsImlzRmxvYXQ2NEFycmF5IiwiaXNCaWdJbnQ2NEFycmF5IiwiaXNCaWdVaW50NjRBcnJheSIsImlzTWFwVG9TdHJpbmciLCJ3b3JraW5nIiwiaXNNYXAiLCJpc1NldFRvU3RyaW5nIiwiaXNTZXQiLCJpc1dlYWtNYXBUb1N0cmluZyIsImlzV2Vha01hcCIsImlzV2Vha1NldFRvU3RyaW5nIiwiaXNXZWFrU2V0IiwiaXNBcnJheUJ1ZmZlclRvU3RyaW5nIiwiaXNBcnJheUJ1ZmZlciIsImlzRGF0YVZpZXdUb1N0cmluZyIsInVuZGVmaW5lZCIsImlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyIsImlzU2hhcmVkQXJyYXlCdWZmZXIiLCJpc0FzeW5jRnVuY3Rpb24iLCJpc01hcEl0ZXJhdG9yIiwiaXNTZXRJdGVyYXRvciIsImlzR2VuZXJhdG9yT2JqZWN0IiwiaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlIiwiaXNOdW1iZXJPYmplY3QiLCJpc1N0cmluZ09iamVjdCIsImlzQm9vbGVhbk9iamVjdCIsImlzQmlnSW50T2JqZWN0IiwiaXNTeW1ib2xPYmplY3QiLCJpc0JveGVkUHJpbWl0aXZlIiwiaXNBbnlBcnJheUJ1ZmZlciIsImRlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImZvcm1hdCIsImlzU3RyaW5nIiwiaW5zcGVjdCIsInN0cmluZ2lmeSIsImlzTnVsbCIsImlzT2JqZWN0IiwiZGVwcmVjYXRlIiwicHJvY2VzcyIsIm5vRGVwcmVjYXRpb24iLCJkZXByZWNhdGVkIiwidGhyb3dEZXByZWNhdGlvbiIsInRyYWNlRGVwcmVjYXRpb24iLCJjb25zb2xlIiwidHJhY2UiLCJlbnYiLCJOT0RFX0RFQlVHIiwidG9VcHBlckNhc2UiLCJkZWJ1Z2xvZyIsInBpZCIsInNlZW4iLCJzdHlsaXplIiwic3R5bGl6ZU5vQ29sb3IiLCJkZXB0aCIsImNvbG9ycyIsImlzQm9vbGVhbiIsInNob3dIaWRkZW4iLCJfZXh0ZW5kIiwiaXNVbmRlZmluZWQiLCJjdXN0b21JbnNwZWN0Iiwic3R5bGl6ZVdpdGhDb2xvciIsImZvcm1hdFZhbHVlIiwiYm9sZCIsIml0YWxpYyIsInVuZGVybGluZSIsImludmVyc2UiLCJ3aGl0ZSIsImdyZXkiLCJibGFjayIsImJsdWUiLCJjeWFuIiwiZ3JlZW4iLCJtYWdlbnRhIiwicmVkIiwieWVsbG93Iiwic3R5bGVzIiwic3BlY2lhbCIsIm51bWJlciIsImJvb2xlYW4iLCJudWxsIiwic3RyaW5nIiwiZGF0ZSIsInJlZ2V4cCIsImFycmF5VG9IYXNoIiwiaXNGdW5jdGlvbiIsImZvcm1hdFByaW1pdGl2ZSIsImlzRXJyb3IiLCJmb3JtYXRFcnJvciIsImlzUmVnRXhwIiwiaXNEYXRlIiwiaXNBcnJheSIsInRvVVRDU3RyaW5nIiwiZm9ybWF0QXJyYXkiLCJtYXAiLCJmb3JtYXRQcm9wZXJ0eSIsInBvcCIsInJlZHVjZVRvU2luZ2xlU3RyaW5nIiwiaXNOdW1iZXIiLCJtYXRjaCIsInNldCIsInNwbGl0Iiwic3Vic3RyIiwicmVkdWNlIiwidHlwZXMiLCJpc051bGxPclVuZGVmaW5lZCIsImlzU3ltYm9sIiwib2JqZWN0VG9TdHJpbmciLCJpc05hdGl2ZUVycm9yIiwiaXNQcmltaXRpdmUiLCJwYWQiLCJ0aW1lc3RhbXAiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0RGF0ZSIsImdldE1vbnRoIiwibG9nIiwicHJvbWlzaWZ5Iiwic2V0UHJvdG90eXBlT2YiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY3VzdG9tIiwiY2FsbGJhY2tpZnlPblJlamVjdGVkIiwicmVhc29uIiwiY2FsbGJhY2tpZnkiLCJjYWxsYmFja2lmaWVkIiwiY2IiLCJuZXh0VGljayIsIndoaWNoVHlwZWRBcnJheSIsImF2YWlsYWJsZVR5cGVkQXJyYXlzIiwiX19uY2N3cGNrX3JlcXVpcmVfXyIsImFiIiwiX19kaXJuYW1lIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/recoil/es/index.js":
/*!*****************************************!*\
  !*** ./node_modules/recoil/es/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultValue: function() { return /* binding */ Recoil_index_1; },\n/* harmony export */   RecoilEnv: function() { return /* binding */ Recoil_index_4; },\n/* harmony export */   RecoilLoadable: function() { return /* binding */ Recoil_index_3; },\n/* harmony export */   RecoilRoot: function() { return /* binding */ Recoil_index_5; },\n/* harmony export */   atom: function() { return /* binding */ Recoil_index_8; },\n/* harmony export */   atomFamily: function() { return /* binding */ Recoil_index_10; },\n/* harmony export */   constSelector: function() { return /* binding */ Recoil_index_12; },\n/* harmony export */   errorSelector: function() { return /* binding */ Recoil_index_13; },\n/* harmony export */   isRecoilValue: function() { return /* binding */ Recoil_index_2; },\n/* harmony export */   noWait: function() { return /* binding */ Recoil_index_15; },\n/* harmony export */   readOnlySelector: function() { return /* binding */ Recoil_index_14; },\n/* harmony export */   retentionZone: function() { return /* binding */ Recoil_index_38; },\n/* harmony export */   selector: function() { return /* binding */ Recoil_index_9; },\n/* harmony export */   selectorFamily: function() { return /* binding */ Recoil_index_11; },\n/* harmony export */   snapshot_UNSTABLE: function() { return /* binding */ Recoil_index_36; },\n/* harmony export */   useGetRecoilValueInfo_UNSTABLE: function() { return /* binding */ Recoil_index_26; },\n/* harmony export */   useGotoRecoilSnapshot: function() { return /* binding */ Recoil_index_33; },\n/* harmony export */   useRecoilBridgeAcrossReactRoots_UNSTABLE: function() { return /* binding */ Recoil_index_7; },\n/* harmony export */   useRecoilCallback: function() { return /* binding */ Recoil_index_31; },\n/* harmony export */   useRecoilRefresher_UNSTABLE: function() { return /* binding */ Recoil_index_27; },\n/* harmony export */   useRecoilSnapshot: function() { return /* binding */ Recoil_index_34; },\n/* harmony export */   useRecoilState: function() { return /* binding */ Recoil_index_22; },\n/* harmony export */   useRecoilStateLoadable: function() { return /* binding */ Recoil_index_23; },\n/* harmony export */   useRecoilState_TRANSITION_SUPPORT_UNSTABLE: function() { return /* binding */ Recoil_index_30; },\n/* harmony export */   useRecoilStoreID: function() { return /* binding */ Recoil_index_6; },\n/* harmony export */   useRecoilTransactionObserver_UNSTABLE: function() { return /* binding */ Recoil_index_35; },\n/* harmony export */   useRecoilTransaction_UNSTABLE: function() { return /* binding */ Recoil_index_32; },\n/* harmony export */   useRecoilValue: function() { return /* binding */ Recoil_index_20; },\n/* harmony export */   useRecoilValueLoadable: function() { return /* binding */ Recoil_index_21; },\n/* harmony export */   useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: function() { return /* binding */ Recoil_index_28; },\n/* harmony export */   useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: function() { return /* binding */ Recoil_index_29; },\n/* harmony export */   useResetRecoilState: function() { return /* binding */ Recoil_index_25; },\n/* harmony export */   useRetain: function() { return /* binding */ Recoil_index_37; },\n/* harmony export */   useSetRecoilState: function() { return /* binding */ Recoil_index_24; },\n/* harmony export */   waitForAll: function() { return /* binding */ Recoil_index_18; },\n/* harmony export */   waitForAllSettled: function() { return /* binding */ Recoil_index_19; },\n/* harmony export */   waitForAny: function() { return /* binding */ Recoil_index_17; },\n/* harmony export */   waitForNone: function() { return /* binding */ Recoil_index_16; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$(), _s8 = $RefreshSig$(), _s9 = $RefreshSig$(), _s10 = $RefreshSig$(), _s11 = $RefreshSig$(), _s12 = $RefreshSig$(), _s13 = $RefreshSig$(), _s14 = $RefreshSig$(), _s15 = $RefreshSig$(), _s16 = $RefreshSig$(), _s17 = $RefreshSig$(), _s18 = $RefreshSig$(), _s19 = $RefreshSig$(), _s20 = $RefreshSig$(), _s21 = $RefreshSig$(), _s22 = $RefreshSig$(), _s23 = $RefreshSig$(), _s24 = $RefreshSig$(), _s25 = $RefreshSig$(), _s26 = $RefreshSig$(), _s27 = $RefreshSig$(), _s28 = $RefreshSig$(), _s29 = $RefreshSig$(), _s30 = $RefreshSig$(), _s31 = $RefreshSig$(), _s32 = $RefreshSig$(), _s33 = $RefreshSig$();\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ function err(message) {\n    const error = new Error(message); // In V8, Error objects keep the closure scope chain alive until the\n    // err.stack property is accessed.\n    if (error.stack === undefined) {\n        // IE sets the stack only if error is thrown\n        try {\n            throw error;\n        } catch (_) {} // eslint-disable-line fb-www/no-unused-catch-bindings, no-empty\n    }\n    return error;\n}\nvar err_1 = err;\n// @oss-only\nvar Recoil_err = err_1;\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ // Split declaration and implementation to allow this function to pretend to\n// check for actual instance of Promise instead of something with a `then`\n// method.\n// eslint-disable-next-line no-redeclare\nfunction isPromise(p) {\n    return !!p && typeof p.then === \"function\";\n}\nvar Recoil_isPromise = isPromise;\nfunction nullthrows(x, message) {\n    if (x != null) {\n        return x;\n    }\n    throw Recoil_err(message !== null && message !== void 0 ? message : \"Got unexpected null or undefined\");\n}\nvar Recoil_nullthrows = nullthrows;\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nclass BaseLoadable {\n    getValue() {\n        throw Recoil_err(\"BaseLoadable\");\n    }\n    toPromise() {\n        throw Recoil_err(\"BaseLoadable\");\n    }\n    valueMaybe() {\n        throw Recoil_err(\"BaseLoadable\");\n    }\n    valueOrThrow() {\n        // $FlowFixMe[prop-missing]\n        throw Recoil_err('Loadable expected value, but in \"'.concat(this.state, '\" state'));\n    }\n    promiseMaybe() {\n        throw Recoil_err(\"BaseLoadable\");\n    }\n    promiseOrThrow() {\n        // $FlowFixMe[prop-missing]\n        throw Recoil_err('Loadable expected promise, but in \"'.concat(this.state, '\" state'));\n    }\n    errorMaybe() {\n        throw Recoil_err(\"BaseLoadable\");\n    }\n    errorOrThrow() {\n        // $FlowFixMe[prop-missing]\n        throw Recoil_err('Loadable expected error, but in \"'.concat(this.state, '\" state'));\n    }\n    is(other) {\n        // $FlowFixMe[prop-missing]\n        return other.state === this.state && other.contents === this.contents;\n    }\n    map(_map) {\n        throw Recoil_err(\"BaseLoadable\");\n    }\n}\nclass ValueLoadable extends BaseLoadable {\n    getValue() {\n        return this.contents;\n    }\n    toPromise() {\n        return Promise.resolve(this.contents);\n    }\n    valueMaybe() {\n        return this.contents;\n    }\n    valueOrThrow() {\n        return this.contents;\n    }\n    promiseMaybe() {\n        return undefined;\n    }\n    errorMaybe() {\n        return undefined;\n    }\n    map(map) {\n        try {\n            const next = map(this.contents);\n            return Recoil_isPromise(next) ? loadableWithPromise(next) : isLoadable(next) ? next : loadableWithValue(next);\n        } catch (e) {\n            return Recoil_isPromise(e) ? // errors and subsequent retries will be handled in 'loading' case\n            // $FlowFixMe[prop-missing]\n            loadableWithPromise(e.next(()=>this.map(map))) : loadableWithError(e);\n        }\n    }\n    constructor(value){\n        super();\n        _defineProperty(this, \"state\", \"hasValue\");\n        _defineProperty(this, \"contents\", void 0);\n        this.contents = value;\n    }\n}\nclass ErrorLoadable extends BaseLoadable {\n    getValue() {\n        throw this.contents;\n    }\n    toPromise() {\n        return Promise.reject(this.contents);\n    }\n    valueMaybe() {\n        return undefined;\n    }\n    promiseMaybe() {\n        return undefined;\n    }\n    errorMaybe() {\n        return this.contents;\n    }\n    errorOrThrow() {\n        return this.contents;\n    }\n    map(_map) {\n        // $FlowIssue[incompatible-return]\n        return this;\n    }\n    constructor(error){\n        super();\n        _defineProperty(this, \"state\", \"hasError\");\n        _defineProperty(this, \"contents\", void 0);\n        this.contents = error;\n    }\n}\nclass LoadingLoadable extends BaseLoadable {\n    getValue() {\n        throw this.contents;\n    }\n    toPromise() {\n        return this.contents;\n    }\n    valueMaybe() {\n        return undefined;\n    }\n    promiseMaybe() {\n        return this.contents;\n    }\n    promiseOrThrow() {\n        return this.contents;\n    }\n    errorMaybe() {\n        return undefined;\n    }\n    map(map) {\n        return loadableWithPromise(this.contents.then((value)=>{\n            const next = map(value);\n            if (isLoadable(next)) {\n                const nextLoadable = next;\n                switch(nextLoadable.state){\n                    case \"hasValue\":\n                        return nextLoadable.contents;\n                    case \"hasError\":\n                        throw nextLoadable.contents;\n                    case \"loading\":\n                        return nextLoadable.contents;\n                }\n            } // $FlowIssue[incompatible-return]\n            return next;\n        }) // $FlowFixMe[incompatible-call]\n        .catch((e)=>{\n            if (Recoil_isPromise(e)) {\n                // we were \"suspended,\" try again\n                return e.then(()=>this.map(map).contents);\n            }\n            throw e;\n        }));\n    }\n    constructor(promise){\n        super();\n        _defineProperty(this, \"state\", \"loading\");\n        _defineProperty(this, \"contents\", void 0);\n        this.contents = promise;\n    }\n}\nfunction loadableWithValue(value) {\n    return Object.freeze(new ValueLoadable(value));\n}\nfunction loadableWithError(error) {\n    return Object.freeze(new ErrorLoadable(error));\n}\nfunction loadableWithPromise(promise) {\n    return Object.freeze(new LoadingLoadable(promise));\n}\nfunction loadableLoading() {\n    return Object.freeze(new LoadingLoadable(new Promise(()=>{})));\n}\nfunction loadableAllArray(inputs) {\n    return inputs.every((i)=>i.state === \"hasValue\") ? loadableWithValue(inputs.map((i)=>i.contents)) : inputs.some((i)=>i.state === \"hasError\") ? loadableWithError(Recoil_nullthrows(inputs.find((i)=>i.state === \"hasError\"), \"Invalid loadable passed to loadableAll\").contents) : loadableWithPromise(Promise.all(inputs.map((i)=>i.contents)));\n}\nfunction loadableAll(inputs) {\n    const unwrapedInputs = Array.isArray(inputs) ? inputs : Object.getOwnPropertyNames(inputs).map((key)=>inputs[key]);\n    const normalizedInputs = unwrapedInputs.map((x)=>isLoadable(x) ? x : Recoil_isPromise(x) ? loadableWithPromise(x) : loadableWithValue(x));\n    const output = loadableAllArray(normalizedInputs);\n    return Array.isArray(inputs) ? output : // $FlowIssue[incompatible-call]\n    output.map((outputs)=>Object.getOwnPropertyNames(inputs).reduce((out, key, idx)=>({\n                ...out,\n                [key]: outputs[idx]\n            }), {}));\n}\nfunction isLoadable(x) {\n    return x instanceof BaseLoadable;\n}\nconst LoadableStaticInterface = {\n    of: (value)=>Recoil_isPromise(value) ? loadableWithPromise(value) : isLoadable(value) ? value : loadableWithValue(value),\n    error: (error)=>loadableWithError(error),\n    // $FlowIssue[incompatible-return]\n    loading: ()=>loadableLoading(),\n    // $FlowIssue[unclear-type]\n    all: loadableAll,\n    isLoadable\n};\nvar Recoil_Loadable = {\n    loadableWithValue,\n    loadableWithError,\n    loadableWithPromise,\n    loadableLoading,\n    loadableAll,\n    isLoadable,\n    RecoilLoadable: LoadableStaticInterface\n};\nvar Recoil_Loadable_1 = Recoil_Loadable.loadableWithValue;\nvar Recoil_Loadable_2 = Recoil_Loadable.loadableWithError;\nvar Recoil_Loadable_3 = Recoil_Loadable.loadableWithPromise;\nvar Recoil_Loadable_4 = Recoil_Loadable.loadableLoading;\nvar Recoil_Loadable_5 = Recoil_Loadable.loadableAll;\nvar Recoil_Loadable_6 = Recoil_Loadable.isLoadable;\nvar Recoil_Loadable_7 = Recoil_Loadable.RecoilLoadable;\nvar Recoil_Loadable$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    loadableWithValue: Recoil_Loadable_1,\n    loadableWithError: Recoil_Loadable_2,\n    loadableWithPromise: Recoil_Loadable_3,\n    loadableLoading: Recoil_Loadable_4,\n    loadableAll: Recoil_Loadable_5,\n    isLoadable: Recoil_Loadable_6,\n    RecoilLoadable: Recoil_Loadable_7\n});\nconst env = {\n    RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED: true,\n    // Note: RECOIL_GKS_ENABLED settings will only be honored in OSS builds of Recoil\n    RECOIL_GKS_ENABLED: new Set([\n        \"recoil_hamt_2020\",\n        \"recoil_sync_external_store\",\n        \"recoil_suppress_rerender_in_callback\",\n        \"recoil_memory_managament_2020\"\n    ])\n};\nfunction readProcessEnvBooleanFlag(name, set) {\n    var _process$env$name, _process$env$name$toL;\n    const sanitizedValue = (_process$env$name = process.env[name]) === null || _process$env$name === void 0 ? void 0 : (_process$env$name$toL = _process$env$name.toLowerCase()) === null || _process$env$name$toL === void 0 ? void 0 : _process$env$name$toL.trim();\n    if (sanitizedValue == null || sanitizedValue === \"\") {\n        return;\n    }\n    const allowedValues = [\n        \"true\",\n        \"false\"\n    ];\n    if (!allowedValues.includes(sanitizedValue)) {\n        throw Recoil_err(\"process.env.\".concat(name, \" value must be 'true', 'false', or empty: \").concat(sanitizedValue));\n    }\n    set(sanitizedValue === \"true\");\n}\nfunction readProcessEnvStringArrayFlag(name, set) {\n    var _process$env$name2;\n    const sanitizedValue = (_process$env$name2 = process.env[name]) === null || _process$env$name2 === void 0 ? void 0 : _process$env$name2.trim();\n    if (sanitizedValue == null || sanitizedValue === \"\") {\n        return;\n    }\n    set(sanitizedValue.split(/\\s*,\\s*|\\s+/));\n}\n/**\n * Allow NodeJS/NextJS/etc to set the initial state through process.env variable\n * Note:  we don't assume 'process' is available in all runtime environments\n *\n * @see https://github.com/facebookexperimental/Recoil/issues/733\n */ function applyProcessEnvFlagOverrides() {\n    var _process;\n    // note: this check is needed in addition to the check below, runtime error will occur without it!\n    // eslint-disable-next-line fb-www/typeof-undefined\n    if (typeof process === \"undefined\") {\n        return;\n    }\n    if (((_process = process) === null || process === void 0 ? void 0 : process.env) == null) {\n        return;\n    }\n    readProcessEnvBooleanFlag(\"RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED\", (value)=>{\n        env.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED = value;\n    });\n    readProcessEnvStringArrayFlag(\"RECOIL_GKS_ENABLED\", (value)=>{\n        value.forEach((gk)=>{\n            env.RECOIL_GKS_ENABLED.add(gk);\n        });\n    });\n}\napplyProcessEnvFlagOverrides();\nvar Recoil_RecoilEnv = env;\nfunction Recoil_gkx_OSS(gk) {\n    return Recoil_RecoilEnv.RECOIL_GKS_ENABLED.has(gk);\n}\n_c = Recoil_gkx_OSS;\nRecoil_gkx_OSS.setPass = (gk)=>{\n    Recoil_RecoilEnv.RECOIL_GKS_ENABLED.add(gk);\n};\nRecoil_gkx_OSS.setFail = (gk)=>{\n    Recoil_RecoilEnv.RECOIL_GKS_ENABLED.delete(gk);\n};\nRecoil_gkx_OSS.clear = ()=>{\n    Recoil_RecoilEnv.RECOIL_GKS_ENABLED.clear();\n};\nvar Recoil_gkx = Recoil_gkx_OSS; // @oss-only\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ function recoverableViolation(message, _projectName) {\n    let { error } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    if (true) {\n        console.error(message, error);\n    }\n    return null;\n}\nvar recoverableViolation_1 = recoverableViolation;\n// @oss-only\nvar Recoil_recoverableViolation = recoverableViolation_1;\nvar _createMutableSource, _useMutableSource, _useSyncExternalStore;\nconst createMutableSource = (_createMutableSource = (react__WEBPACK_IMPORTED_MODULE_0___default().createMutableSource)) !== null && _createMutableSource !== void 0 ? _createMutableSource : (react__WEBPACK_IMPORTED_MODULE_0___default().unstable_createMutableSource);\nconst useMutableSource = (_useMutableSource = (react__WEBPACK_IMPORTED_MODULE_0___default().useMutableSource)) !== null && _useMutableSource !== void 0 ? _useMutableSource : (react__WEBPACK_IMPORTED_MODULE_0___default().unstable_useMutableSource); // https://github.com/reactwg/react-18/discussions/86\nconst useSyncExternalStore = (_useSyncExternalStore = (react__WEBPACK_IMPORTED_MODULE_0___default().useSyncExternalStore)) !== null && _useSyncExternalStore !== void 0 ? _useSyncExternalStore : (react__WEBPACK_IMPORTED_MODULE_0___default().unstable_useSyncExternalStore);\nlet ReactRendererVersionMismatchWarnOnce = false; // Check if the current renderer supports `useSyncExternalStore()`.\n// Since React goes through a proxy dispatcher and the current renderer can\n// change we can't simply check if `React.useSyncExternalStore()` is defined.\nfunction currentRendererSupportsUseSyncExternalStore() {\n    var _ReactCurrentDispatch;\n    // $FlowFixMe[incompatible-use]\n    const { ReactCurrentDispatcher, ReactCurrentOwner } = /* $FlowFixMe[prop-missing] This workaround was approved as a safer mechanism\n   * to detect if the current renderer supports useSyncExternalStore()\n   * https://fb.workplace.com/groups/reactjs/posts/9558682330846963/ */ (react__WEBPACK_IMPORTED_MODULE_0___default().__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED);\n    const dispatcher = (_ReactCurrentDispatch = ReactCurrentDispatcher === null || ReactCurrentDispatcher === void 0 ? void 0 : ReactCurrentDispatcher.current) !== null && _ReactCurrentDispatch !== void 0 ? _ReactCurrentDispatch : ReactCurrentOwner.currentDispatcher;\n    const isUseSyncExternalStoreSupported = dispatcher.useSyncExternalStore != null;\n    if (useSyncExternalStore && !isUseSyncExternalStoreSupported && !ReactRendererVersionMismatchWarnOnce) {\n        ReactRendererVersionMismatchWarnOnce = true;\n        Recoil_recoverableViolation(\"A React renderer without React 18+ API support is being used with React 18+.\");\n    }\n    return isUseSyncExternalStoreSupported;\n}\n/**\n * mode: The React API and approach to use for syncing state with React\n * early: Re-renders from Recoil updates occur:\n *    1) earlier\n *    2) in sync with React updates in the same batch\n *    3) before transaction observers instead of after.\n * concurrent: Is the current mode compatible with Concurrent Mode and useTransition()\n */ function reactMode() {\n    // NOTE: This mode is currently broken with some Suspense cases\n    // see Recoil_selector-test.js\n    if (Recoil_gkx(\"recoil_transition_support\")) {\n        return {\n            mode: \"TRANSITION_SUPPORT\",\n            early: true,\n            concurrent: true\n        };\n    }\n    if (Recoil_gkx(\"recoil_sync_external_store\") && useSyncExternalStore != null) {\n        return {\n            mode: \"SYNC_EXTERNAL_STORE\",\n            early: true,\n            concurrent: false\n        };\n    }\n    if (Recoil_gkx(\"recoil_mutable_source\") && useMutableSource != null && \"object\" !== \"undefined\" && !window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE) {\n        return Recoil_gkx(\"recoil_suppress_rerender_in_callback\") ? {\n            mode: \"MUTABLE_SOURCE\",\n            early: true,\n            concurrent: true\n        } : {\n            mode: \"MUTABLE_SOURCE\",\n            early: false,\n            concurrent: false\n        };\n    }\n    return Recoil_gkx(\"recoil_suppress_rerender_in_callback\") ? {\n        mode: \"LEGACY\",\n        early: true,\n        concurrent: false\n    } : {\n        mode: \"LEGACY\",\n        early: false,\n        concurrent: false\n    };\n} // TODO Need to figure out if there is a standard/open-source equivalent to see if hot module replacement is happening:\nfunction isFastRefreshEnabled() {\n    // @fb-only: const {isAcceptingUpdate} = require('__debug');\n    // @fb-only: return typeof isAcceptingUpdate === 'function' && isAcceptingUpdate();\n    return false; // @oss-only\n}\nvar Recoil_ReactMode = {\n    createMutableSource,\n    useMutableSource,\n    useSyncExternalStore,\n    currentRendererSupportsUseSyncExternalStore,\n    reactMode,\n    isFastRefreshEnabled\n};\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ // eslint-disable-next-line no-unused-vars\nclass AbstractRecoilValue {\n    toJSON() {\n        return {\n            key: this.key\n        };\n    }\n    constructor(newKey){\n        _defineProperty(this, \"key\", void 0);\n        this.key = newKey;\n    }\n}\nclass RecoilState extends AbstractRecoilValue {\n}\nclass RecoilValueReadOnly extends AbstractRecoilValue {\n}\nfunction isRecoilValue(x) {\n    return x instanceof RecoilState || x instanceof RecoilValueReadOnly;\n}\nvar Recoil_RecoilValue = {\n    AbstractRecoilValue,\n    RecoilState,\n    RecoilValueReadOnly,\n    isRecoilValue\n};\nvar Recoil_RecoilValue_1 = Recoil_RecoilValue.AbstractRecoilValue;\nvar Recoil_RecoilValue_2 = Recoil_RecoilValue.RecoilState;\nvar Recoil_RecoilValue_3 = Recoil_RecoilValue.RecoilValueReadOnly;\nvar Recoil_RecoilValue_4 = Recoil_RecoilValue.isRecoilValue;\nvar Recoil_RecoilValue$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    AbstractRecoilValue: Recoil_RecoilValue_1,\n    RecoilState: Recoil_RecoilValue_2,\n    RecoilValueReadOnly: Recoil_RecoilValue_3,\n    isRecoilValue: Recoil_RecoilValue_4\n});\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ function sprintf(format) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    let index = 0;\n    return format.replace(/%s/g, ()=>String(args[index++]));\n}\nvar sprintf_1 = sprintf;\nfunction expectationViolation(format) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (true) {\n        const message = sprintf_1.call(null, format, ...args);\n        const error = new Error(message);\n        error.name = \"Expectation Violation\";\n        console.error(error);\n    }\n}\nvar expectationViolation_1 = expectationViolation;\n// @oss-only\nvar Recoil_expectationViolation = expectationViolation_1;\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * Creates a new iterable whose output is generated by passing the input\n * iterable's values through the mapper function.\n */ function mapIterable(iterable, callback) {\n    // Use generator to create iterable/iterator\n    return function*() {\n        let index = 0;\n        for (const value of iterable){\n            yield callback(value, index++);\n        }\n    }();\n}\nvar Recoil_mapIterable = mapIterable;\nconst { isFastRefreshEnabled: isFastRefreshEnabled$1 } = Recoil_ReactMode;\nclass DefaultValue {\n}\nconst DEFAULT_VALUE = new DefaultValue();\n// flowlint-next-line unclear-type:off\nconst nodes = new Map(); // flowlint-next-line unclear-type:off\nconst recoilValues = new Map();\n/* eslint-disable no-redeclare */ function recoilValuesForKeys(keys) {\n    return Recoil_mapIterable(keys, (key)=>Recoil_nullthrows(recoilValues.get(key)));\n}\nfunction checkForDuplicateAtomKey(key) {\n    if (nodes.has(key)) {\n        const message = 'Duplicate atom key \"'.concat(key, '\". This is a FATAL ERROR in\\n      production. But it is safe to ignore this warning if it occurred because of\\n      hot module replacement.');\n        if (true) {\n            // TODO Figure this out for open-source\n            if (!isFastRefreshEnabled$1()) {\n                Recoil_expectationViolation(message, \"recoil\");\n            }\n        } else {}\n    }\n}\nfunction registerNode(node) {\n    if (Recoil_RecoilEnv.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED) {\n        checkForDuplicateAtomKey(node.key);\n    }\n    nodes.set(node.key, node);\n    const recoilValue = node.set == null ? new Recoil_RecoilValue$1.RecoilValueReadOnly(node.key) : new Recoil_RecoilValue$1.RecoilState(node.key);\n    recoilValues.set(node.key, recoilValue);\n    return recoilValue;\n}\n/* eslint-enable no-redeclare */ class NodeMissingError extends Error {\n} // flowlint-next-line unclear-type:off\nfunction getNode(key) {\n    const node = nodes.get(key);\n    if (node == null) {\n        throw new NodeMissingError('Missing definition for RecoilValue: \"'.concat(key, '\"\"'));\n    }\n    return node;\n} // flowlint-next-line unclear-type:off\nfunction getNodeMaybe(key) {\n    return nodes.get(key);\n}\nconst configDeletionHandlers = new Map();\nfunction deleteNodeConfigIfPossible(key) {\n    var _node$shouldDeleteCon;\n    if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n        return;\n    }\n    const node = nodes.get(key);\n    if (node !== null && node !== void 0 && (_node$shouldDeleteCon = node.shouldDeleteConfigOnRelease) !== null && _node$shouldDeleteCon !== void 0 && _node$shouldDeleteCon.call(node)) {\n        var _getConfigDeletionHan;\n        nodes.delete(key);\n        (_getConfigDeletionHan = getConfigDeletionHandler(key)) === null || _getConfigDeletionHan === void 0 ? void 0 : _getConfigDeletionHan();\n        configDeletionHandlers.delete(key);\n    }\n}\nfunction setConfigDeletionHandler(key, fn) {\n    if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n        return;\n    }\n    if (fn === undefined) {\n        configDeletionHandlers.delete(key);\n    } else {\n        configDeletionHandlers.set(key, fn);\n    }\n}\nfunction getConfigDeletionHandler(key) {\n    return configDeletionHandlers.get(key);\n}\nvar Recoil_Node = {\n    nodes,\n    recoilValues,\n    registerNode,\n    getNode,\n    getNodeMaybe,\n    deleteNodeConfigIfPossible,\n    setConfigDeletionHandler,\n    getConfigDeletionHandler,\n    recoilValuesForKeys,\n    NodeMissingError,\n    DefaultValue,\n    DEFAULT_VALUE\n};\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ function enqueueExecution(s, f) {\n    f();\n}\nvar Recoil_Queue = {\n    enqueueExecution\n};\nfunction createCommonjsModule(fn, module) {\n    return module = {\n        exports: {}\n    }, fn(module, module.exports), module.exports;\n}\nvar hamt_1 = createCommonjsModule(function(module) {\n    var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n        return typeof obj;\n    } : function(obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n    /**\n    @fileOverview Hash Array Mapped Trie.\n\n    Code based on: https://github.com/exclipy/pdata\n*/ var hamt = {}; // export\n    /* Configuration\n ******************************************************************************/ var SIZE = 5;\n    var BUCKET_SIZE = Math.pow(2, SIZE);\n    var MASK = BUCKET_SIZE - 1;\n    var MAX_INDEX_NODE = BUCKET_SIZE / 2;\n    var MIN_ARRAY_NODE = BUCKET_SIZE / 4;\n    /*\n ******************************************************************************/ var nothing = {};\n    var constant = function constant(x) {\n        return function() {\n            return x;\n        };\n    };\n    /**\n    Get 32 bit hash of string.\n\n    Based on:\n    http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n*/ var hash = hamt.hash = function(str) {\n        var type = typeof str === \"undefined\" ? \"undefined\" : _typeof(str);\n        if (type === \"number\") return str;\n        if (type !== \"string\") str += \"\";\n        var hash = 0;\n        for(var i = 0, len = str.length; i < len; ++i){\n            var c = str.charCodeAt(i);\n            hash = (hash << 5) - hash + c | 0;\n        }\n        return hash;\n    };\n    /* Bit Ops\n ******************************************************************************/ /**\n    Hamming weight.\n\n    Taken from: http://jsperf.com/hamming-weight\n*/ var popcount = function popcount(x) {\n        x -= x >> 1 & 0x55555555;\n        x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n        x = x + (x >> 4) & 0x0f0f0f0f;\n        x += x >> 8;\n        x += x >> 16;\n        return x & 0x7f;\n    };\n    var hashFragment = function hashFragment(shift, h) {\n        return h >>> shift & MASK;\n    };\n    var toBitmap = function toBitmap(x) {\n        return 1 << x;\n    };\n    var fromBitmap = function fromBitmap(bitmap, bit) {\n        return popcount(bitmap & bit - 1);\n    };\n    /* Array Ops\n ******************************************************************************/ /**\n    Set a value in an array.\n\n    @param mutate Should the input array be mutated?\n    @param at Index to change.\n    @param v New value\n    @param arr Array.\n*/ var arrayUpdate = function arrayUpdate(mutate, at, v, arr) {\n        var out = arr;\n        if (!mutate) {\n            var len = arr.length;\n            out = new Array(len);\n            for(var i = 0; i < len; ++i){\n                out[i] = arr[i];\n            }\n        }\n        out[at] = v;\n        return out;\n    };\n    /**\n    Remove a value from an array.\n\n    @param mutate Should the input array be mutated?\n    @param at Index to remove.\n    @param arr Array.\n*/ var arraySpliceOut = function arraySpliceOut(mutate, at, arr) {\n        var newLen = arr.length - 1;\n        var i = 0;\n        var g = 0;\n        var out = arr;\n        if (mutate) {\n            i = g = at;\n        } else {\n            out = new Array(newLen);\n            while(i < at){\n                out[g++] = arr[i++];\n            }\n        }\n        ++i;\n        while(i <= newLen){\n            out[g++] = arr[i++];\n        }\n        if (mutate) {\n            out.length = newLen;\n        }\n        return out;\n    };\n    /**\n    Insert a value into an array.\n\n    @param mutate Should the input array be mutated?\n    @param at Index to insert at.\n    @param v Value to insert,\n    @param arr Array.\n*/ var arraySpliceIn = function arraySpliceIn(mutate, at, v, arr) {\n        var len = arr.length;\n        if (mutate) {\n            var _i = len;\n            while(_i >= at){\n                arr[_i--] = arr[_i];\n            }\n            arr[at] = v;\n            return arr;\n        }\n        var i = 0, g = 0;\n        var out = new Array(len + 1);\n        while(i < at){\n            out[g++] = arr[i++];\n        }\n        out[at] = v;\n        while(i < len){\n            out[++g] = arr[i++];\n        }\n        return out;\n    };\n    /* Node Structures\n ******************************************************************************/ var LEAF = 1;\n    var COLLISION = 2;\n    var INDEX = 3;\n    var ARRAY = 4;\n    /**\n    Empty node.\n*/ var empty = {\n        __hamt_isEmpty: true\n    };\n    var isEmptyNode = function isEmptyNode(x) {\n        return x === empty || x && x.__hamt_isEmpty;\n    };\n    /**\n    Leaf holding a value.\n\n    @member edit Edit of the node.\n    @member hash Hash of key.\n    @member key Key.\n    @member value Value stored.\n*/ var Leaf = function Leaf(edit, hash, key, value) {\n        return {\n            type: LEAF,\n            edit: edit,\n            hash: hash,\n            key: key,\n            value: value,\n            _modify: Leaf__modify\n        };\n    };\n    /**\n    Leaf holding multiple values with the same hash but different keys.\n\n    @member edit Edit of the node.\n    @member hash Hash of key.\n    @member children Array of collision children node.\n*/ var Collision = function Collision(edit, hash, children) {\n        return {\n            type: COLLISION,\n            edit: edit,\n            hash: hash,\n            children: children,\n            _modify: Collision__modify\n        };\n    };\n    /**\n    Internal node with a sparse set of children.\n\n    Uses a bitmap and array to pack children.\n\n  @member edit Edit of the node.\n    @member mask Bitmap that encode the positions of children in the array.\n    @member children Array of child nodes.\n*/ var IndexedNode = function IndexedNode(edit, mask, children) {\n        return {\n            type: INDEX,\n            edit: edit,\n            mask: mask,\n            children: children,\n            _modify: IndexedNode__modify\n        };\n    };\n    /**\n    Internal node with many children.\n\n    @member edit Edit of the node.\n    @member size Number of children.\n    @member children Array of child nodes.\n*/ var ArrayNode = function ArrayNode(edit, size, children) {\n        return {\n            type: ARRAY,\n            edit: edit,\n            size: size,\n            children: children,\n            _modify: ArrayNode__modify\n        };\n    };\n    /**\n    Is `node` a leaf node?\n*/ var isLeaf = function isLeaf(node) {\n        return node === empty || node.type === LEAF || node.type === COLLISION;\n    };\n    /* Internal node operations.\n ******************************************************************************/ /**\n    Expand an indexed node into an array node.\n\n  @param edit Current edit.\n    @param frag Index of added child.\n    @param child Added child.\n    @param mask Index node mask before child added.\n    @param subNodes Index node children before child added.\n*/ var expand = function expand(edit, frag, child, bitmap, subNodes) {\n        var arr = [];\n        var bit = bitmap;\n        var count = 0;\n        for(var i = 0; bit; ++i){\n            if (bit & 1) arr[i] = subNodes[count++];\n            bit >>>= 1;\n        }\n        arr[frag] = child;\n        return ArrayNode(edit, count + 1, arr);\n    };\n    /**\n    Collapse an array node into a indexed node.\n\n  @param edit Current edit.\n    @param count Number of elements in new array.\n    @param removed Index of removed element.\n    @param elements Array node children before remove.\n*/ var pack = function pack(edit, count, removed, elements) {\n        var children = new Array(count - 1);\n        var g = 0;\n        var bitmap = 0;\n        for(var i = 0, len = elements.length; i < len; ++i){\n            if (i !== removed) {\n                var elem = elements[i];\n                if (elem && !isEmptyNode(elem)) {\n                    children[g++] = elem;\n                    bitmap |= 1 << i;\n                }\n            }\n        }\n        return IndexedNode(edit, bitmap, children);\n    };\n    /**\n    Merge two leaf nodes.\n\n    @param shift Current shift.\n    @param h1 Node 1 hash.\n    @param n1 Node 1.\n    @param h2 Node 2 hash.\n    @param n2 Node 2.\n*/ var mergeLeaves = function mergeLeaves(edit, shift, h1, n1, h2, n2) {\n        if (h1 === h2) return Collision(edit, h1, [\n            n2,\n            n1\n        ]);\n        var subH1 = hashFragment(shift, h1);\n        var subH2 = hashFragment(shift, h2);\n        return IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), subH1 === subH2 ? [\n            mergeLeaves(edit, shift + SIZE, h1, n1, h2, n2)\n        ] : subH1 < subH2 ? [\n            n1,\n            n2\n        ] : [\n            n2,\n            n1\n        ]);\n    };\n    /**\n    Update an entry in a collision list.\n\n    @param mutate Should mutation be used?\n    @param edit Current edit.\n    @param keyEq Key compare function.\n    @param hash Hash of collision.\n    @param list Collision list.\n    @param f Update function.\n    @param k Key to update.\n    @param size Size ref.\n*/ var updateCollisionList = function updateCollisionList(mutate, edit, keyEq, h, list, f, k, size) {\n        var len = list.length;\n        for(var i = 0; i < len; ++i){\n            var child = list[i];\n            if (keyEq(k, child.key)) {\n                var value = child.value;\n                var _newValue = f(value);\n                if (_newValue === value) return list;\n                if (_newValue === nothing) {\n                    --size.value;\n                    return arraySpliceOut(mutate, i, list);\n                }\n                return arrayUpdate(mutate, i, Leaf(edit, h, k, _newValue), list);\n            }\n        }\n        var newValue = f();\n        if (newValue === nothing) return list;\n        ++size.value;\n        return arrayUpdate(mutate, len, Leaf(edit, h, k, newValue), list);\n    };\n    var canEditNode = function canEditNode(edit, node) {\n        return edit === node.edit;\n    };\n    /* Editing\n ******************************************************************************/ var Leaf__modify = function Leaf__modify(edit, keyEq, shift, f, h, k, size) {\n        if (keyEq(k, this.key)) {\n            var _v = f(this.value);\n            if (_v === this.value) return this;\n            else if (_v === nothing) {\n                --size.value;\n                return empty;\n            }\n            if (canEditNode(edit, this)) {\n                this.value = _v;\n                return this;\n            }\n            return Leaf(edit, h, k, _v);\n        }\n        var v = f();\n        if (v === nothing) return this;\n        ++size.value;\n        return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n    };\n    var Collision__modify = function Collision__modify(edit, keyEq, shift, f, h, k, size) {\n        if (h === this.hash) {\n            var canEdit = canEditNode(edit, this);\n            var list = updateCollisionList(canEdit, edit, keyEq, this.hash, this.children, f, k, size);\n            if (list === this.children) return this;\n            return list.length > 1 ? Collision(edit, this.hash, list) : list[0]; // collapse single element collision list\n        }\n        var v = f();\n        if (v === nothing) return this;\n        ++size.value;\n        return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n    };\n    var IndexedNode__modify = function IndexedNode__modify(edit, keyEq, shift, f, h, k, size) {\n        var mask = this.mask;\n        var children = this.children;\n        var frag = hashFragment(shift, h);\n        var bit = toBitmap(frag);\n        var indx = fromBitmap(mask, bit);\n        var exists = mask & bit;\n        var current = exists ? children[indx] : empty;\n        var child = current._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n        if (current === child) return this;\n        var canEdit = canEditNode(edit, this);\n        var bitmap = mask;\n        var newChildren = void 0;\n        if (exists && isEmptyNode(child)) {\n            // remove\n            bitmap &= ~bit;\n            if (!bitmap) return empty;\n            if (children.length <= 2 && isLeaf(children[indx ^ 1])) return children[indx ^ 1]; // collapse\n            newChildren = arraySpliceOut(canEdit, indx, children);\n        } else if (!exists && !isEmptyNode(child)) {\n            // add\n            if (children.length >= MAX_INDEX_NODE) return expand(edit, frag, child, mask, children);\n            bitmap |= bit;\n            newChildren = arraySpliceIn(canEdit, indx, child, children);\n        } else {\n            // modify\n            newChildren = arrayUpdate(canEdit, indx, child, children);\n        }\n        if (canEdit) {\n            this.mask = bitmap;\n            this.children = newChildren;\n            return this;\n        }\n        return IndexedNode(edit, bitmap, newChildren);\n    };\n    var ArrayNode__modify = function ArrayNode__modify(edit, keyEq, shift, f, h, k, size) {\n        var count = this.size;\n        var children = this.children;\n        var frag = hashFragment(shift, h);\n        var child = children[frag];\n        var newChild = (child || empty)._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n        if (child === newChild) return this;\n        var canEdit = canEditNode(edit, this);\n        var newChildren = void 0;\n        if (isEmptyNode(child) && !isEmptyNode(newChild)) {\n            // add\n            ++count;\n            newChildren = arrayUpdate(canEdit, frag, newChild, children);\n        } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {\n            // remove\n            --count;\n            if (count <= MIN_ARRAY_NODE) return pack(edit, count, frag, children);\n            newChildren = arrayUpdate(canEdit, frag, empty, children);\n        } else {\n            // modify\n            newChildren = arrayUpdate(canEdit, frag, newChild, children);\n        }\n        if (canEdit) {\n            this.size = count;\n            this.children = newChildren;\n            return this;\n        }\n        return ArrayNode(edit, count, newChildren);\n    };\n    empty._modify = function(edit, keyEq, shift, f, h, k, size) {\n        var v = f();\n        if (v === nothing) return empty;\n        ++size.value;\n        return Leaf(edit, h, k, v);\n    };\n    /*\n ******************************************************************************/ function Map1(editable, edit, config, root, size) {\n        this._editable = editable;\n        this._edit = edit;\n        this._config = config;\n        this._root = root;\n        this._size = size;\n    }\n    Map1.prototype.setTree = function(newRoot, newSize) {\n        if (this._editable) {\n            this._root = newRoot;\n            this._size = newSize;\n            return this;\n        }\n        return newRoot === this._root ? this : new Map1(this._editable, this._edit, this._config, newRoot, newSize);\n    };\n    /* Queries\n ******************************************************************************/ /**\n    Lookup the value for `key` in `map` using a custom `hash`.\n\n    Returns the value or `alt` if none.\n*/ var tryGetHash = hamt.tryGetHash = function(alt, hash, key, map) {\n        var node = map._root;\n        var shift = 0;\n        var keyEq = map._config.keyEq;\n        while(true){\n            switch(node.type){\n                case LEAF:\n                    {\n                        return keyEq(key, node.key) ? node.value : alt;\n                    }\n                case COLLISION:\n                    {\n                        if (hash === node.hash) {\n                            var children = node.children;\n                            for(var i = 0, len = children.length; i < len; ++i){\n                                var child = children[i];\n                                if (keyEq(key, child.key)) return child.value;\n                            }\n                        }\n                        return alt;\n                    }\n                case INDEX:\n                    {\n                        var frag = hashFragment(shift, hash);\n                        var bit = toBitmap(frag);\n                        if (node.mask & bit) {\n                            node = node.children[fromBitmap(node.mask, bit)];\n                            shift += SIZE;\n                            break;\n                        }\n                        return alt;\n                    }\n                case ARRAY:\n                    {\n                        node = node.children[hashFragment(shift, hash)];\n                        if (node) {\n                            shift += SIZE;\n                            break;\n                        }\n                        return alt;\n                    }\n                default:\n                    return alt;\n            }\n        }\n    };\n    Map1.prototype.tryGetHash = function(alt, hash, key) {\n        return tryGetHash(alt, hash, key, this);\n    };\n    /**\n    Lookup the value for `key` in `map` using internal hash function.\n\n    @see `tryGetHash`\n*/ var tryGet = hamt.tryGet = function(alt, key, map) {\n        return tryGetHash(alt, map._config.hash(key), key, map);\n    };\n    Map1.prototype.tryGet = function(alt, key) {\n        return tryGet(alt, key, this);\n    };\n    /**\n    Lookup the value for `key` in `map` using a custom `hash`.\n\n    Returns the value or `undefined` if none.\n*/ var getHash = hamt.getHash = function(hash, key, map) {\n        return tryGetHash(undefined, hash, key, map);\n    };\n    Map1.prototype.getHash = function(hash, key) {\n        return getHash(hash, key, this);\n    };\n    /**\n    Lookup the value for `key` in `map` using internal hash function.\n\n    @see `get`\n*/ var get = hamt.get = function(key, map) {\n        return tryGetHash(undefined, map._config.hash(key), key, map);\n    };\n    Map1.prototype.get = function(key, alt) {\n        return tryGet(alt, key, this);\n    };\n    /**\n    Does an entry exist for `key` in `map`? Uses custom `hash`.\n*/ var hasHash = hamt.has = function(hash, key, map) {\n        return tryGetHash(nothing, hash, key, map) !== nothing;\n    };\n    Map1.prototype.hasHash = function(hash, key) {\n        return hasHash(hash, key, this);\n    };\n    /**\n    Does an entry exist for `key` in `map`? Uses internal hash function.\n*/ var has = hamt.has = function(key, map) {\n        return hasHash(map._config.hash(key), key, map);\n    };\n    Map1.prototype.has = function(key) {\n        return has(key, this);\n    };\n    var defKeyCompare = function defKeyCompare(x, y) {\n        return x === y;\n    };\n    /**\n    Create an empty map.\n\n    @param config Configuration.\n*/ hamt.make = function(config) {\n        return new Map1(0, 0, {\n            keyEq: config && config.keyEq || defKeyCompare,\n            hash: config && config.hash || hash\n        }, empty, 0);\n    };\n    /**\n    Empty map.\n*/ hamt.empty = hamt.make();\n    /**\n    Does `map` contain any elements?\n*/ var isEmpty = hamt.isEmpty = function(map) {\n        return map && !!isEmptyNode(map._root);\n    };\n    Map1.prototype.isEmpty = function() {\n        return isEmpty(this);\n    };\n    /* Updates\n ******************************************************************************/ /**\n    Alter the value stored for `key` in `map` using function `f` using\n    custom hash.\n\n    `f` is invoked with the current value for `k` if it exists,\n    or no arguments if no such value exists. `modify` will always either\n    update or insert a value into the map.\n\n    Returns a map with the modified value. Does not alter `map`.\n*/ var modifyHash = hamt.modifyHash = function(f, hash, key, map) {\n        var size = {\n            value: map._size\n        };\n        var newRoot = map._root._modify(map._editable ? map._edit : NaN, map._config.keyEq, 0, f, hash, key, size);\n        return map.setTree(newRoot, size.value);\n    };\n    Map1.prototype.modifyHash = function(hash, key, f) {\n        return modifyHash(f, hash, key, this);\n    };\n    /**\n    Alter the value stored for `key` in `map` using function `f` using\n    internal hash function.\n\n    @see `modifyHash`\n*/ var modify = hamt.modify = function(f, key, map) {\n        return modifyHash(f, map._config.hash(key), key, map);\n    };\n    Map1.prototype.modify = function(key, f) {\n        return modify(f, key, this);\n    };\n    /**\n    Store `value` for `key` in `map` using custom `hash`.\n\n    Returns a map with the modified value. Does not alter `map`.\n*/ var setHash = hamt.setHash = function(hash, key, value, map) {\n        return modifyHash(constant(value), hash, key, map);\n    };\n    Map1.prototype.setHash = function(hash, key, value) {\n        return setHash(hash, key, value, this);\n    };\n    /**\n    Store `value` for `key` in `map` using internal hash function.\n\n    @see `setHash`\n*/ var set = hamt.set = function(key, value, map) {\n        return setHash(map._config.hash(key), key, value, map);\n    };\n    Map1.prototype.set = function(key, value) {\n        return set(key, value, this);\n    };\n    /**\n    Remove the entry for `key` in `map`.\n\n    Returns a map with the value removed. Does not alter `map`.\n*/ var del = constant(nothing);\n    var removeHash = hamt.removeHash = function(hash, key, map) {\n        return modifyHash(del, hash, key, map);\n    };\n    Map1.prototype.removeHash = Map1.prototype.deleteHash = function(hash, key) {\n        return removeHash(hash, key, this);\n    };\n    /**\n    Remove the entry for `key` in `map` using internal hash function.\n\n    @see `removeHash`\n*/ var remove = hamt.remove = function(key, map) {\n        return removeHash(map._config.hash(key), key, map);\n    };\n    Map1.prototype.remove = Map1.prototype.delete = function(key) {\n        return remove(key, this);\n    };\n    /* Mutation\n ******************************************************************************/ /**\n    Mark `map` as mutable.\n */ var beginMutation = hamt.beginMutation = function(map) {\n        return new Map1(map._editable + 1, map._edit + 1, map._config, map._root, map._size);\n    };\n    Map1.prototype.beginMutation = function() {\n        return beginMutation(this);\n    };\n    /**\n    Mark `map` as immutable.\n */ var endMutation = hamt.endMutation = function(map) {\n        map._editable = map._editable && map._editable - 1;\n        return map;\n    };\n    Map1.prototype.endMutation = function() {\n        return endMutation(this);\n    };\n    /**\n    Mutate `map` within the context of `f`.\n    @param f\n    @param map HAMT\n*/ var mutate = hamt.mutate = function(f, map) {\n        var transient = beginMutation(map);\n        f(transient);\n        return endMutation(transient);\n    };\n    Map1.prototype.mutate = function(f) {\n        return mutate(f, this);\n    };\n    /* Traversal\n ******************************************************************************/ /**\n    Apply a continuation.\n*/ var appk = function appk(k) {\n        return k && lazyVisitChildren(k[0], k[1], k[2], k[3], k[4]);\n    };\n    /**\n    Recursively visit all values stored in an array of nodes lazily.\n*/ var lazyVisitChildren = function lazyVisitChildren(len, children, i, f, k) {\n        while(i < len){\n            var child = children[i++];\n            if (child && !isEmptyNode(child)) return lazyVisit(child, f, [\n                len,\n                children,\n                i,\n                f,\n                k\n            ]);\n        }\n        return appk(k);\n    };\n    /**\n    Recursively visit all values stored in `node` lazily.\n*/ var lazyVisit = function lazyVisit(node, f, k) {\n        switch(node.type){\n            case LEAF:\n                return {\n                    value: f(node),\n                    rest: k\n                };\n            case COLLISION:\n            case ARRAY:\n            case INDEX:\n                var children = node.children;\n                return lazyVisitChildren(children.length, children, 0, f, k);\n            default:\n                return appk(k);\n        }\n    };\n    var DONE = {\n        done: true\n    };\n    /**\n    Javascript iterator over a map.\n*/ function MapIterator(v) {\n        this.v = v;\n    }\n    MapIterator.prototype.next = function() {\n        if (!this.v) return DONE;\n        var v0 = this.v;\n        this.v = appk(v0.rest);\n        return v0;\n    };\n    MapIterator.prototype[Symbol.iterator] = function() {\n        return this;\n    };\n    /**\n    Lazily visit each value in map with function `f`.\n*/ var visit = function visit(map, f) {\n        return new MapIterator(lazyVisit(map._root, f));\n    };\n    /**\n    Get a Javascsript iterator of `map`.\n\n    Iterates over `[key, value]` arrays.\n*/ var buildPairs = function buildPairs(x) {\n        return [\n            x.key,\n            x.value\n        ];\n    };\n    var entries = hamt.entries = function(map) {\n        return visit(map, buildPairs);\n    };\n    Map1.prototype.entries = Map1.prototype[Symbol.iterator] = function() {\n        return entries(this);\n    };\n    /**\n    Get array of all keys in `map`.\n\n    Order is not guaranteed.\n*/ var buildKeys = function buildKeys(x) {\n        return x.key;\n    };\n    var keys = hamt.keys = function(map) {\n        return visit(map, buildKeys);\n    };\n    Map1.prototype.keys = function() {\n        return keys(this);\n    };\n    /**\n    Get array of all values in `map`.\n\n    Order is not guaranteed, duplicates are preserved.\n*/ var buildValues = function buildValues(x) {\n        return x.value;\n    };\n    var values = hamt.values = Map1.prototype.values = function(map) {\n        return visit(map, buildValues);\n    };\n    Map1.prototype.values = function() {\n        return values(this);\n    };\n    /* Fold\n ******************************************************************************/ /**\n    Visit every entry in the map, aggregating data.\n\n    Order of nodes is not guaranteed.\n\n    @param f Function mapping accumulated value, value, and key to new value.\n    @param z Starting value.\n    @param m HAMT\n*/ var fold = hamt.fold = function(f, z, m) {\n        var root = m._root;\n        if (root.type === LEAF) return f(z, root.value, root.key);\n        var toVisit = [\n            root.children\n        ];\n        var children = void 0;\n        while(children = toVisit.pop()){\n            for(var i = 0, len = children.length; i < len;){\n                var child = children[i++];\n                if (child && child.type) {\n                    if (child.type === LEAF) z = f(z, child.value, child.key);\n                    else toVisit.push(child.children);\n                }\n            }\n        }\n        return z;\n    };\n    Map1.prototype.fold = function(f, z) {\n        return fold(f, z, this);\n    };\n    /**\n    Visit every entry in the map, aggregating data.\n\n    Order of nodes is not guaranteed.\n\n    @param f Function invoked with value and key\n    @param map HAMT\n*/ var forEach = hamt.forEach = function(f, map) {\n        return fold(function(_, value, key) {\n            return f(value, key, map);\n        }, null, map);\n    };\n    Map1.prototype.forEach = function(f) {\n        return forEach(f, this);\n    };\n    /* Aggregate\n ******************************************************************************/ /**\n    Get the number of entries in `map`.\n*/ var count = hamt.count = function(map) {\n        return map._size;\n    };\n    Map1.prototype.count = function() {\n        return count(this);\n    };\n    Object.defineProperty(Map1.prototype, \"size\", {\n        get: Map1.prototype.count\n    });\n    /* Export\n ******************************************************************************/ if (module.exports) {\n        module.exports = hamt;\n    } else {\n        undefined.hamt = hamt;\n    }\n});\nclass BuiltInMap {\n    keys() {\n        return this._map.keys();\n    }\n    entries() {\n        return this._map.entries();\n    }\n    get(k) {\n        return this._map.get(k);\n    }\n    has(k) {\n        return this._map.has(k);\n    }\n    set(k, v) {\n        this._map.set(k, v);\n        return this;\n    }\n    delete(k) {\n        this._map.delete(k);\n        return this;\n    }\n    clone() {\n        return persistentMap(this);\n    }\n    toMap() {\n        return new Map(this._map);\n    }\n    constructor(existing){\n        _defineProperty(this, \"_map\", void 0);\n        this._map = new Map(existing === null || existing === void 0 ? void 0 : existing.entries());\n    }\n}\nclass HashArrayMappedTrieMap {\n    keys() {\n        return this._hamt.keys();\n    }\n    entries() {\n        return this._hamt.entries();\n    }\n    get(k) {\n        return this._hamt.get(k);\n    }\n    has(k) {\n        return this._hamt.has(k);\n    }\n    set(k, v) {\n        this._hamt.set(k, v);\n        return this;\n    }\n    delete(k) {\n        this._hamt.delete(k);\n        return this;\n    }\n    clone() {\n        return persistentMap(this);\n    }\n    toMap() {\n        return new Map(this._hamt);\n    }\n    // Because hamt.empty is not a function there is no way to introduce type\n    // parameters on it, so empty is typed as HAMTPlusMap<string, mixed>.\n    // $FlowIssue\n    constructor(existing){\n        _defineProperty(this, \"_hamt\", hamt_1.empty.beginMutation());\n        if (existing instanceof HashArrayMappedTrieMap) {\n            const h = existing._hamt.endMutation();\n            existing._hamt = h.beginMutation();\n            this._hamt = h.beginMutation();\n        } else if (existing) {\n            for (const [k, v] of existing.entries()){\n                this._hamt.set(k, v);\n            }\n        }\n    }\n}\nfunction persistentMap(existing) {\n    if (Recoil_gkx(\"recoil_hamt_2020\")) {\n        return new HashArrayMappedTrieMap(existing);\n    } else {\n        return new BuiltInMap(existing);\n    }\n}\nvar Recoil_PersistentMap = {\n    persistentMap\n};\nvar Recoil_PersistentMap_1 = Recoil_PersistentMap.persistentMap;\nvar Recoil_PersistentMap$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    persistentMap: Recoil_PersistentMap_1\n});\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * Returns a set containing all of the values from the first set that are not\n * present in any of the subsequent sets.\n *\n * Note: this is written procedurally (i.e., without filterSet) for performant\n * use in tight loops.\n */ function differenceSets(set) {\n    for(var _len = arguments.length, setsWithValuesToRemove = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        setsWithValuesToRemove[_key - 1] = arguments[_key];\n    }\n    const ret = new Set();\n    FIRST: for (const value of set){\n        for (const otherSet of setsWithValuesToRemove){\n            if (otherSet.has(value)) {\n                continue FIRST;\n            }\n        }\n        ret.add(value);\n    }\n    return ret;\n}\nvar Recoil_differenceSets = differenceSets;\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * Returns a new Map object with the same keys as the original, but with the\n * values replaced with the output of the given callback function.\n */ function mapMap(map, callback) {\n    const result = new Map();\n    map.forEach((value, key)=>{\n        result.set(key, callback(value, key));\n    });\n    return result;\n}\nvar Recoil_mapMap = mapMap;\nfunction makeGraph() {\n    return {\n        nodeDeps: new Map(),\n        nodeToNodeSubscriptions: new Map()\n    };\n}\nfunction cloneGraph(graph) {\n    return {\n        nodeDeps: Recoil_mapMap(graph.nodeDeps, (s)=>new Set(s)),\n        nodeToNodeSubscriptions: Recoil_mapMap(graph.nodeToNodeSubscriptions, (s)=>new Set(s))\n    };\n} // Note that this overwrites the deps of existing nodes, rather than unioning\n// the new deps with the old deps.\nfunction mergeDepsIntoGraph(key, newDeps, graph, // graph compared with olderGraph:\nolderGraph) {\n    const { nodeDeps, nodeToNodeSubscriptions } = graph;\n    const oldDeps = nodeDeps.get(key);\n    if (oldDeps && olderGraph && oldDeps !== olderGraph.nodeDeps.get(key)) {\n        return;\n    } // Update nodeDeps:\n    nodeDeps.set(key, newDeps); // Add new deps to nodeToNodeSubscriptions:\n    const addedDeps = oldDeps == null ? newDeps : Recoil_differenceSets(newDeps, oldDeps);\n    for (const dep of addedDeps){\n        if (!nodeToNodeSubscriptions.has(dep)) {\n            nodeToNodeSubscriptions.set(dep, new Set());\n        }\n        const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));\n        existing.add(key);\n    } // Remove removed deps from nodeToNodeSubscriptions:\n    if (oldDeps) {\n        const removedDeps = Recoil_differenceSets(oldDeps, newDeps);\n        for (const dep of removedDeps){\n            if (!nodeToNodeSubscriptions.has(dep)) {\n                return;\n            }\n            const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));\n            existing.delete(key);\n            if (existing.size === 0) {\n                nodeToNodeSubscriptions.delete(dep);\n            }\n        }\n    }\n}\nfunction saveDepsToStore(key, deps, store, version) {\n    var _storeState$nextTree, _storeState$previousT, _storeState$previousT2, _storeState$previousT3;\n    const storeState = store.getState();\n    if (!(version === storeState.currentTree.version || version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {\n        Recoil_recoverableViolation(\"Tried to save dependencies to a discarded tree\");\n    } // Merge the dependencies discovered into the store's dependency map\n    // for the version that was read:\n    const graph = store.getGraph(version);\n    mergeDepsIntoGraph(key, deps, graph); // If this version is not the latest version, also write these dependencies\n    // into later versions if they don't already have their own:\n    if (version === ((_storeState$previousT2 = storeState.previousTree) === null || _storeState$previousT2 === void 0 ? void 0 : _storeState$previousT2.version)) {\n        const currentGraph = store.getGraph(storeState.currentTree.version);\n        mergeDepsIntoGraph(key, deps, currentGraph, graph);\n    }\n    if (version === ((_storeState$previousT3 = storeState.previousTree) === null || _storeState$previousT3 === void 0 ? void 0 : _storeState$previousT3.version) || version === storeState.currentTree.version) {\n        var _storeState$nextTree2;\n        const nextVersion = (_storeState$nextTree2 = storeState.nextTree) === null || _storeState$nextTree2 === void 0 ? void 0 : _storeState$nextTree2.version;\n        if (nextVersion !== undefined) {\n            const nextGraph = store.getGraph(nextVersion);\n            mergeDepsIntoGraph(key, deps, nextGraph, graph);\n        }\n    }\n}\nvar Recoil_Graph = {\n    cloneGraph,\n    graph: makeGraph,\n    saveDepsToStore\n};\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ let nextTreeStateVersion = 0;\nconst getNextTreeStateVersion = ()=>nextTreeStateVersion++;\nlet nextStoreID = 0;\nconst getNextStoreID = ()=>nextStoreID++;\nlet nextComponentID = 0;\nconst getNextComponentID = ()=>nextComponentID++;\nvar Recoil_Keys = {\n    getNextTreeStateVersion,\n    getNextStoreID,\n    getNextComponentID\n};\nconst { persistentMap: persistentMap$1 } = Recoil_PersistentMap$1;\nconst { graph } = Recoil_Graph;\nconst { getNextTreeStateVersion: getNextTreeStateVersion$1 } = Recoil_Keys;\nfunction makeEmptyTreeState() {\n    const version = getNextTreeStateVersion$1();\n    return {\n        version,\n        stateID: version,\n        transactionMetadata: {},\n        dirtyAtoms: new Set(),\n        atomValues: persistentMap$1(),\n        nonvalidatedAtoms: persistentMap$1()\n    };\n}\nfunction makeEmptyStoreState() {\n    const currentTree = makeEmptyTreeState();\n    return {\n        currentTree,\n        nextTree: null,\n        previousTree: null,\n        commitDepth: 0,\n        knownAtoms: new Set(),\n        knownSelectors: new Set(),\n        transactionSubscriptions: new Map(),\n        nodeTransactionSubscriptions: new Map(),\n        nodeToComponentSubscriptions: new Map(),\n        queuedComponentCallbacks_DEPRECATED: [],\n        suspendedComponentResolvers: new Set(),\n        graphsByVersion: new Map().set(currentTree.version, graph()),\n        retention: {\n            referenceCounts: new Map(),\n            nodesRetainedByZone: new Map(),\n            retainablesToCheckForRelease: new Set()\n        },\n        nodeCleanupFunctions: new Map()\n    };\n}\nvar Recoil_State = {\n    makeEmptyTreeState,\n    makeEmptyStoreState,\n    getNextTreeStateVersion: getNextTreeStateVersion$1\n};\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ class RetentionZone {\n}\nfunction retentionZone() {\n    return new RetentionZone();\n}\nvar Recoil_RetentionZone = {\n    RetentionZone,\n    retentionZone\n};\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Utilities for working with built-in Maps and Sets without mutating them.\n *\n * \n * @format\n * @oncall recoil\n */ function setByAddingToSet(set, v) {\n    const next = new Set(set);\n    next.add(v);\n    return next;\n}\nfunction setByDeletingFromSet(set, v) {\n    const next = new Set(set);\n    next.delete(v);\n    return next;\n}\nfunction mapBySettingInMap(map, k, v) {\n    const next = new Map(map);\n    next.set(k, v);\n    return next;\n}\nfunction mapByUpdatingInMap(map, k, updater) {\n    const next = new Map(map);\n    next.set(k, updater(next.get(k)));\n    return next;\n}\nfunction mapByDeletingFromMap(map, k) {\n    const next = new Map(map);\n    next.delete(k);\n    return next;\n}\nfunction mapByDeletingMultipleFromMap(map, ks) {\n    const next = new Map(map);\n    ks.forEach((k)=>next.delete(k));\n    return next;\n}\nvar Recoil_CopyOnWrite = {\n    setByAddingToSet,\n    setByDeletingFromSet,\n    mapBySettingInMap,\n    mapByUpdatingInMap,\n    mapByDeletingFromMap,\n    mapByDeletingMultipleFromMap\n};\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * Creates a new iterable whose output is generated by passing the input\n * iterable's values through the filter function.\n */ function* filterIterable(iterable, predicate) {\n    // Use generator to create iterable/iterator\n    let index = 0;\n    for (const value of iterable){\n        if (predicate(value, index++)) {\n            yield value;\n        }\n    }\n}\nvar Recoil_filterIterable = filterIterable;\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * Return a proxy object based on the provided base and factories objects.\n * The proxy will include all properties of the base object as-is.\n * The factories object contains callbacks to obtain the values of the properies\n * for its keys.\n *\n * This is useful for providing users an object where some properties may be\n * lazily computed only on first access.\n */ // $FlowIssue[unclear-type]\nfunction lazyProxy(base, factories) {\n    const proxy = new Proxy(base, {\n        // Compute and cache lazy property if not already done.\n        get: (target, prop)=>{\n            if (!(prop in target) && prop in factories) {\n                target[prop] = factories[prop]();\n            }\n            return target[prop];\n        },\n        // This method allows user to iterate keys as normal\n        ownKeys: (target)=>{\n            return Object.keys(target);\n        }\n    }); // $FlowIssue[incompatible-return]\n    return proxy;\n}\nvar Recoil_lazyProxy = lazyProxy;\nconst { getNode: getNode$1, getNodeMaybe: getNodeMaybe$1, recoilValuesForKeys: recoilValuesForKeys$1 } = Recoil_Node;\nconst { RetentionZone: RetentionZone$1 } = Recoil_RetentionZone;\nconst { setByAddingToSet: setByAddingToSet$1 } = Recoil_CopyOnWrite;\n// flowlint-next-line unclear-type:off\nconst emptySet = Object.freeze(new Set());\nclass ReadOnlyRecoilValueError extends Error {\n}\nfunction initializeRetentionForNode(store, nodeKey, retainedBy) {\n    if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n        return ()=>undefined;\n    }\n    const { nodesRetainedByZone } = store.getState().retention;\n    function addToZone(zone) {\n        let set = nodesRetainedByZone.get(zone);\n        if (!set) {\n            nodesRetainedByZone.set(zone, set = new Set());\n        }\n        set.add(nodeKey);\n    }\n    if (retainedBy instanceof RetentionZone$1) {\n        addToZone(retainedBy);\n    } else if (Array.isArray(retainedBy)) {\n        for (const zone of retainedBy){\n            addToZone(zone);\n        }\n    }\n    return ()=>{\n        if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n            return;\n        }\n        const { retention } = store.getState();\n        function deleteFromZone(zone) {\n            const set = retention.nodesRetainedByZone.get(zone);\n            set === null || set === void 0 ? void 0 : set.delete(nodeKey);\n            if (set && set.size === 0) {\n                retention.nodesRetainedByZone.delete(zone);\n            }\n        }\n        if (retainedBy instanceof RetentionZone$1) {\n            deleteFromZone(retainedBy);\n        } else if (Array.isArray(retainedBy)) {\n            for (const zone of retainedBy){\n                deleteFromZone(zone);\n            }\n        }\n    };\n}\nfunction initializeNodeIfNewToStore(store, treeState, key, trigger) {\n    const storeState = store.getState();\n    if (storeState.nodeCleanupFunctions.has(key)) {\n        return;\n    }\n    const node = getNode$1(key);\n    const retentionCleanup = initializeRetentionForNode(store, key, node.retainedBy);\n    const nodeCleanup = node.init(store, treeState, trigger);\n    storeState.nodeCleanupFunctions.set(key, ()=>{\n        nodeCleanup();\n        retentionCleanup();\n    });\n}\nfunction initializeNode(store, key, trigger) {\n    initializeNodeIfNewToStore(store, store.getState().currentTree, key, trigger);\n}\nfunction cleanUpNode(store, key) {\n    var _state$nodeCleanupFun;\n    const state = store.getState();\n    (_state$nodeCleanupFun = state.nodeCleanupFunctions.get(key)) === null || _state$nodeCleanupFun === void 0 ? void 0 : _state$nodeCleanupFun();\n    state.nodeCleanupFunctions.delete(key);\n} // Get the current value loadable of a node and update the state.\n// Update dependencies and subscriptions for selectors.\n// Update saved value validation for atoms.\nfunction getNodeLoadable(store, state, key) {\n    initializeNodeIfNewToStore(store, state, key, \"get\");\n    return getNode$1(key).get(store, state);\n} // Peek at the current value loadable for a node without any evaluation or state change\nfunction peekNodeLoadable(store, state, key) {\n    return getNode$1(key).peek(store, state);\n} // Write value directly to state bypassing the Node interface as the node\n// definitions may not have been loaded yet when processing the initial snapshot.\nfunction setUnvalidatedAtomValue_DEPRECATED(state, key, newValue) {\n    var _node$invalidate;\n    const node = getNodeMaybe$1(key);\n    node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);\n    return {\n        ...state,\n        atomValues: state.atomValues.clone().delete(key),\n        nonvalidatedAtoms: state.nonvalidatedAtoms.clone().set(key, newValue),\n        dirtyAtoms: setByAddingToSet$1(state.dirtyAtoms, key)\n    };\n} // Return the discovered dependencies and values to be written by setting\n// a node value. (Multiple values may be written due to selectors getting to\n// set upstreams; deps may be discovered because of reads in updater functions.)\nfunction setNodeValue(store, state, key, newValue) {\n    const node = getNode$1(key);\n    if (node.set == null) {\n        throw new ReadOnlyRecoilValueError(\"Attempt to set read-only RecoilValue: \".concat(key));\n    }\n    const set = node.set; // so flow doesn't lose the above refinement.\n    initializeNodeIfNewToStore(store, state, key, \"set\");\n    return set(store, state, newValue);\n}\nfunction peekNodeInfo(store, state, key) {\n    const storeState = store.getState();\n    const graph = store.getGraph(state.version);\n    const type = getNode$1(key).nodeType;\n    return Recoil_lazyProxy({\n        type\n    }, {\n        // $FlowFixMe[underconstrained-implicit-instantiation]\n        loadable: ()=>peekNodeLoadable(store, state, key),\n        isActive: ()=>storeState.knownAtoms.has(key) || storeState.knownSelectors.has(key),\n        isSet: ()=>type === \"selector\" ? false : state.atomValues.has(key),\n        isModified: ()=>state.dirtyAtoms.has(key),\n        // Report current dependencies.  If the node hasn't been evaluated, then\n        // dependencies may be missing based on the current state.\n        deps: ()=>{\n            var _graph$nodeDeps$get;\n            return recoilValuesForKeys$1((_graph$nodeDeps$get = graph.nodeDeps.get(key)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : []);\n        },\n        // Reports all \"current\" subscribers.  Evaluating other nodes or\n        // previous in-progress async evaluations may introduce new subscribers.\n        subscribers: ()=>{\n            var _storeState$nodeToCom, _storeState$nodeToCom2;\n            return {\n                nodes: recoilValuesForKeys$1(Recoil_filterIterable(getDownstreamNodes(store, state, new Set([\n                    key\n                ])), (nodeKey)=>nodeKey !== key)),\n                components: Recoil_mapIterable((_storeState$nodeToCom = (_storeState$nodeToCom2 = storeState.nodeToComponentSubscriptions.get(key)) === null || _storeState$nodeToCom2 === void 0 ? void 0 : _storeState$nodeToCom2.values()) !== null && _storeState$nodeToCom !== void 0 ? _storeState$nodeToCom : [], (param)=>{\n                    let [name] = param;\n                    return {\n                        name\n                    };\n                })\n            };\n        }\n    });\n} // Find all of the recursively dependent nodes\nfunction getDownstreamNodes(store, state, keys) {\n    const visitedNodes = new Set();\n    const visitingNodes = Array.from(keys);\n    const graph = store.getGraph(state.version);\n    for(let key = visitingNodes.pop(); key; key = visitingNodes.pop()){\n        var _graph$nodeToNodeSubs;\n        visitedNodes.add(key);\n        const subscribedNodes = (_graph$nodeToNodeSubs = graph.nodeToNodeSubscriptions.get(key)) !== null && _graph$nodeToNodeSubs !== void 0 ? _graph$nodeToNodeSubs : emptySet;\n        for (const downstreamNode of subscribedNodes){\n            if (!visitedNodes.has(downstreamNode)) {\n                visitingNodes.push(downstreamNode);\n            }\n        }\n    }\n    return visitedNodes;\n}\nvar Recoil_FunctionalCore = {\n    getNodeLoadable,\n    peekNodeLoadable,\n    setNodeValue,\n    initializeNode,\n    cleanUpNode,\n    setUnvalidatedAtomValue_DEPRECATED,\n    peekNodeInfo,\n    getDownstreamNodes\n};\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ let _invalidateMemoizedSnapshot = null;\nfunction setInvalidateMemoizedSnapshot(invalidate) {\n    _invalidateMemoizedSnapshot = invalidate;\n}\nfunction invalidateMemoizedSnapshot() {\n    var _invalidateMemoizedSn;\n    (_invalidateMemoizedSn = _invalidateMemoizedSnapshot) === null || _invalidateMemoizedSn === void 0 ? void 0 : _invalidateMemoizedSn();\n}\nvar Recoil_SnapshotCache = {\n    setInvalidateMemoizedSnapshot,\n    invalidateMemoizedSnapshot\n};\nconst { getDownstreamNodes: getDownstreamNodes$1, getNodeLoadable: getNodeLoadable$1, setNodeValue: setNodeValue$1 } = Recoil_FunctionalCore;\nconst { getNextComponentID: getNextComponentID$1 } = Recoil_Keys;\nconst { getNode: getNode$2, getNodeMaybe: getNodeMaybe$2 } = Recoil_Node;\nconst { DefaultValue: DefaultValue$1 } = Recoil_Node;\nconst { reactMode: reactMode$1 } = Recoil_ReactMode;\nconst { AbstractRecoilValue: AbstractRecoilValue$1, RecoilState: RecoilState$1, RecoilValueReadOnly: RecoilValueReadOnly$1, isRecoilValue: isRecoilValue$1 } = Recoil_RecoilValue$1;\nconst { invalidateMemoizedSnapshot: invalidateMemoizedSnapshot$1 } = Recoil_SnapshotCache;\nfunction getRecoilValueAsLoadable(store, param) {\n    let { key } = param, treeState = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : store.getState().currentTree;\n    var _storeState$nextTree, _storeState$previousT;\n    // Reading from an older tree can cause bugs because the dependencies that we\n    // discover during the read are lost.\n    const storeState = store.getState();\n    if (!(treeState.version === storeState.currentTree.version || treeState.version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || treeState.version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {\n        Recoil_recoverableViolation(\"Tried to read from a discarded tree\");\n    }\n    const loadable = getNodeLoadable$1(store, treeState, key);\n    if (loadable.state === \"loading\") {\n        loadable.contents.catch(()=>{\n            /**\n       * HACK: intercept thrown error here to prevent an uncaught promise exception. Ideally this would happen closer to selector\n       * execution (perhaps introducing a new ERROR class to be resolved by async selectors that are in an error state)\n       */ return;\n        });\n    }\n    return loadable;\n}\nfunction applyAtomValueWrites(atomValues, writes) {\n    const result = atomValues.clone();\n    writes.forEach((v, k)=>{\n        if (v.state === \"hasValue\" && v.contents instanceof DefaultValue$1) {\n            result.delete(k);\n        } else {\n            result.set(k, v);\n        }\n    });\n    return result;\n}\nfunction valueFromValueOrUpdater(store, state, param, valueOrUpdater) {\n    let { key } = param;\n    if (typeof valueOrUpdater === \"function\") {\n        // Updater form: pass in the current value. Throw if the current value\n        // is unavailable (namely when updating an async selector that's\n        // pending or errored):\n        const current = getNodeLoadable$1(store, state, key);\n        if (current.state === \"loading\") {\n            const msg = 'Tried to set atom or selector \"'.concat(key, '\" using an updater function while the current state is pending, this is not currently supported.');\n            Recoil_recoverableViolation(msg);\n            throw Recoil_err(msg);\n        } else if (current.state === \"hasError\") {\n            throw current.contents;\n        } // T itself may be a function, so our refinement is not sufficient:\n        return valueOrUpdater(current.contents); // flowlint-line unclear-type:off\n    } else {\n        return valueOrUpdater;\n    }\n}\nfunction applyAction(store, state, action) {\n    if (action.type === \"set\") {\n        const { recoilValue, valueOrUpdater } = action;\n        const newValue = valueFromValueOrUpdater(store, state, recoilValue, valueOrUpdater);\n        const writes = setNodeValue$1(store, state, recoilValue.key, newValue);\n        for (const [key, loadable] of writes.entries()){\n            writeLoadableToTreeState(state, key, loadable);\n        }\n    } else if (action.type === \"setLoadable\") {\n        const { recoilValue: { key }, loadable } = action;\n        writeLoadableToTreeState(state, key, loadable);\n    } else if (action.type === \"markModified\") {\n        const { recoilValue: { key } } = action;\n        state.dirtyAtoms.add(key);\n    } else if (action.type === \"setUnvalidated\") {\n        var _node$invalidate;\n        // Write value directly to state bypassing the Node interface as the node\n        // definitions may not have been loaded yet when processing the initial snapshot.\n        const { recoilValue: { key }, unvalidatedValue } = action;\n        const node = getNodeMaybe$2(key);\n        node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);\n        state.atomValues.delete(key);\n        state.nonvalidatedAtoms.set(key, unvalidatedValue);\n        state.dirtyAtoms.add(key);\n    } else {\n        Recoil_recoverableViolation(\"Unknown action \".concat(action.type));\n    }\n}\nfunction writeLoadableToTreeState(state, key, loadable) {\n    if (loadable.state === \"hasValue\" && loadable.contents instanceof DefaultValue$1) {\n        state.atomValues.delete(key);\n    } else {\n        state.atomValues.set(key, loadable);\n    }\n    state.dirtyAtoms.add(key);\n    state.nonvalidatedAtoms.delete(key);\n}\nfunction applyActionsToStore(store, actions) {\n    store.replaceState((state)=>{\n        const newState = copyTreeState(state);\n        for (const action of actions){\n            applyAction(store, newState, action);\n        }\n        invalidateDownstreams(store, newState);\n        invalidateMemoizedSnapshot$1();\n        return newState;\n    });\n}\nfunction queueOrPerformStateUpdate(store, action) {\n    if (batchStack.length) {\n        const actionsByStore = batchStack[batchStack.length - 1];\n        let actions = actionsByStore.get(store);\n        if (!actions) {\n            actionsByStore.set(store, actions = []);\n        }\n        actions.push(action);\n    } else {\n        applyActionsToStore(store, [\n            action\n        ]);\n    }\n}\nconst batchStack = [];\nfunction batchStart() {\n    const actionsByStore = new Map();\n    batchStack.push(actionsByStore);\n    return ()=>{\n        for (const [store, actions] of actionsByStore){\n            applyActionsToStore(store, actions);\n        }\n        const popped = batchStack.pop();\n        if (popped !== actionsByStore) {\n            Recoil_recoverableViolation(\"Incorrect order of batch popping\");\n        }\n    };\n}\nfunction copyTreeState(state) {\n    return {\n        ...state,\n        atomValues: state.atomValues.clone(),\n        nonvalidatedAtoms: state.nonvalidatedAtoms.clone(),\n        dirtyAtoms: new Set(state.dirtyAtoms)\n    };\n}\nfunction invalidateDownstreams(store, state) {\n    // Inform any nodes that were changed or downstream of changes so that they\n    // can clear out any caches as needed due to the update:\n    const downstreams = getDownstreamNodes$1(store, state, state.dirtyAtoms);\n    for (const key of downstreams){\n        var _getNodeMaybe, _getNodeMaybe$invalid;\n        (_getNodeMaybe = getNodeMaybe$2(key)) === null || _getNodeMaybe === void 0 ? void 0 : (_getNodeMaybe$invalid = _getNodeMaybe.invalidate) === null || _getNodeMaybe$invalid === void 0 ? void 0 : _getNodeMaybe$invalid.call(_getNodeMaybe, state);\n    }\n}\nfunction setRecoilValue(store, recoilValue, valueOrUpdater) {\n    queueOrPerformStateUpdate(store, {\n        type: \"set\",\n        recoilValue,\n        valueOrUpdater\n    });\n}\nfunction setRecoilValueLoadable(store, recoilValue, loadable) {\n    if (loadable instanceof DefaultValue$1) {\n        return setRecoilValue(store, recoilValue, loadable);\n    }\n    queueOrPerformStateUpdate(store, {\n        type: \"setLoadable\",\n        recoilValue,\n        loadable: loadable\n    });\n}\nfunction markRecoilValueModified(store, recoilValue) {\n    queueOrPerformStateUpdate(store, {\n        type: \"markModified\",\n        recoilValue\n    });\n}\nfunction setUnvalidatedRecoilValue(store, recoilValue, unvalidatedValue) {\n    queueOrPerformStateUpdate(store, {\n        type: \"setUnvalidated\",\n        recoilValue,\n        unvalidatedValue\n    });\n}\nfunction subscribeToRecoilValue(store, param, callback) {\n    let { key } = param, componentDebugName = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n    const subID = getNextComponentID$1();\n    const storeState = store.getState();\n    if (!storeState.nodeToComponentSubscriptions.has(key)) {\n        storeState.nodeToComponentSubscriptions.set(key, new Map());\n    }\n    Recoil_nullthrows(storeState.nodeToComponentSubscriptions.get(key)).set(subID, [\n        componentDebugName !== null && componentDebugName !== void 0 ? componentDebugName : \"<not captured>\",\n        callback\n    ]); // Handle the case that, during the same tick that we are subscribing, an atom\n    // has been updated by some effect handler. Otherwise we will miss the update.\n    const mode = reactMode$1();\n    if (mode.early && (mode.mode === \"LEGACY\" || mode.mode === \"MUTABLE_SOURCE\")) {\n        const nextTree = store.getState().nextTree;\n        if (nextTree && nextTree.dirtyAtoms.has(key)) {\n            callback(nextTree);\n        }\n    }\n    return {\n        release: ()=>{\n            const releaseStoreState = store.getState();\n            const subs = releaseStoreState.nodeToComponentSubscriptions.get(key);\n            if (subs === undefined || !subs.has(subID)) {\n                Recoil_recoverableViolation(\"Subscription missing at release time for atom \".concat(key, \". This is a bug in Recoil.\"));\n                return;\n            }\n            subs.delete(subID);\n            if (subs.size === 0) {\n                releaseStoreState.nodeToComponentSubscriptions.delete(key);\n            }\n        }\n    };\n}\nfunction refreshRecoilValue(store, recoilValue) {\n    var _node$clearCache;\n    const { currentTree } = store.getState();\n    const node = getNode$2(recoilValue.key);\n    (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, currentTree);\n}\nvar Recoil_RecoilValueInterface = {\n    RecoilValueReadOnly: RecoilValueReadOnly$1,\n    AbstractRecoilValue: AbstractRecoilValue$1,\n    RecoilState: RecoilState$1,\n    getRecoilValueAsLoadable,\n    setRecoilValue,\n    setRecoilValueLoadable,\n    markRecoilValueModified,\n    setUnvalidatedRecoilValue,\n    subscribeToRecoilValue,\n    isRecoilValue: isRecoilValue$1,\n    applyAtomValueWrites,\n    // TODO Remove export when deprecating initialStoreState_DEPRECATED in RecoilRoot\n    batchStart,\n    writeLoadableToTreeState,\n    invalidateDownstreams,\n    copyTreeState,\n    refreshRecoilValue\n};\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * The someSet() method tests whether some elements in the given Set pass the\n * test implemented by the provided function.\n */ function someSet(set, callback, context) {\n    const iterator = set.entries();\n    let current = iterator.next();\n    while(!current.done){\n        const entry = current.value;\n        if (callback.call(context, entry[1], entry[0], set)) {\n            return true;\n        }\n        current = iterator.next();\n    }\n    return false;\n}\nvar Recoil_someSet = someSet;\nconst { cleanUpNode: cleanUpNode$1 } = Recoil_FunctionalCore;\nconst { deleteNodeConfigIfPossible: deleteNodeConfigIfPossible$1, getNode: getNode$3 } = Recoil_Node;\nconst { RetentionZone: RetentionZone$2 } = Recoil_RetentionZone;\n// Components that aren't mounted after suspending for this long will be assumed\n// to be discarded and their resources released.\nconst SUSPENSE_TIMEOUT_MS = 120000;\nconst emptySet$1 = new Set();\nfunction releaseRetainablesNowOnCurrentTree(store, retainables) {\n    const storeState = store.getState();\n    const treeState = storeState.currentTree;\n    if (storeState.nextTree) {\n        Recoil_recoverableViolation(\"releaseNodesNowOnCurrentTree should only be called at the end of a batch\");\n        return; // leak memory rather than erase something that's about to be used.\n    }\n    const nodes = new Set();\n    for (const r of retainables){\n        if (r instanceof RetentionZone$2) {\n            for (const n of nodesRetainedByZone(storeState, r)){\n                nodes.add(n);\n            }\n        } else {\n            nodes.add(r);\n        }\n    }\n    const releasableNodes = findReleasableNodes(store, nodes);\n    for (const node of releasableNodes){\n        releaseNode(store, treeState, node);\n    }\n}\nfunction findReleasableNodes(store, searchFromNodes) {\n    const storeState = store.getState();\n    const treeState = storeState.currentTree;\n    const graph = store.getGraph(treeState.version);\n    const releasableNodes = new Set(); // mutated to collect answer\n    const nonReleasableNodes = new Set();\n    findReleasableNodesInner(searchFromNodes);\n    return releasableNodes;\n    function findReleasableNodesInner(searchFromNodes) {\n        const releasableNodesFoundThisIteration = new Set();\n        const downstreams = getDownstreamNodesInTopologicalOrder(store, treeState, searchFromNodes, releasableNodes, nonReleasableNodes // don't descend into these\n        ); // Find which of the downstream nodes are releasable and which are not:\n        for (const node of downstreams){\n            var _storeState$retention;\n            // Not releasable if configured to be retained forever:\n            if (getNode$3(node).retainedBy === \"recoilRoot\") {\n                nonReleasableNodes.add(node);\n                continue;\n            } // Not releasable if retained directly by a component:\n            if (((_storeState$retention = storeState.retention.referenceCounts.get(node)) !== null && _storeState$retention !== void 0 ? _storeState$retention : 0) > 0) {\n                nonReleasableNodes.add(node);\n                continue;\n            } // Not releasable if retained by a zone:\n            if (zonesThatCouldRetainNode(node).some((z)=>storeState.retention.referenceCounts.get(z))) {\n                nonReleasableNodes.add(node);\n                continue;\n            } // Not releasable if it has a non-releasable child (which will already be in\n            // nonReleasableNodes because we are going in topological order):\n            const nodeChildren = graph.nodeToNodeSubscriptions.get(node);\n            if (nodeChildren && Recoil_someSet(nodeChildren, (child)=>nonReleasableNodes.has(child))) {\n                nonReleasableNodes.add(node);\n                continue;\n            }\n            releasableNodes.add(node);\n            releasableNodesFoundThisIteration.add(node);\n        } // If we found any releasable nodes, we need to walk UP from those nodes to\n        // find whether their parents can now be released as well:\n        const parents = new Set();\n        for (const node of releasableNodesFoundThisIteration){\n            for (const parent of (_graph$nodeDeps$get = graph.nodeDeps.get(node)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : emptySet$1){\n                var _graph$nodeDeps$get;\n                if (!releasableNodes.has(parent)) {\n                    parents.add(parent);\n                }\n            }\n        }\n        if (parents.size) {\n            findReleasableNodesInner(parents);\n        }\n    }\n} // Children before parents\nfunction getDownstreamNodesInTopologicalOrder(store, treeState, nodes, doNotDescendInto1, doNotDescendInto2) {\n    const graph = store.getGraph(treeState.version);\n    const answer = [];\n    const visited = new Set();\n    while(nodes.size > 0){\n        visit(Recoil_nullthrows(nodes.values().next().value));\n    }\n    return answer;\n    function visit(node) {\n        if (doNotDescendInto1.has(node) || doNotDescendInto2.has(node)) {\n            nodes.delete(node);\n            return;\n        }\n        if (visited.has(node)) {\n            return;\n        }\n        const children = graph.nodeToNodeSubscriptions.get(node);\n        if (children) {\n            for (const child of children){\n                visit(child);\n            }\n        }\n        visited.add(node);\n        nodes.delete(node);\n        answer.push(node);\n    }\n}\nfunction releaseNode(store, treeState, node) {\n    if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n        return;\n    } // Atom effects, in-closure caches, etc.:\n    cleanUpNode$1(store, node); // Delete from store state:\n    const storeState = store.getState();\n    storeState.knownAtoms.delete(node);\n    storeState.knownSelectors.delete(node);\n    storeState.nodeTransactionSubscriptions.delete(node);\n    storeState.retention.referenceCounts.delete(node);\n    const zones = zonesThatCouldRetainNode(node);\n    for (const zone of zones){\n        var _storeState$retention2;\n        (_storeState$retention2 = storeState.retention.nodesRetainedByZone.get(zone)) === null || _storeState$retention2 === void 0 ? void 0 : _storeState$retention2.delete(node);\n    } // Note that we DO NOT delete from nodeToComponentSubscriptions because this\n    // already happens when the last component that was retaining the node unmounts,\n    // and this could happen either before or after that.\n    // Delete from TreeState and dep graph:\n    treeState.atomValues.delete(node);\n    treeState.dirtyAtoms.delete(node);\n    treeState.nonvalidatedAtoms.delete(node);\n    const graph = storeState.graphsByVersion.get(treeState.version);\n    if (graph) {\n        const deps = graph.nodeDeps.get(node);\n        if (deps !== undefined) {\n            graph.nodeDeps.delete(node);\n            for (const dep of deps){\n                var _graph$nodeToNodeSubs;\n                (_graph$nodeToNodeSubs = graph.nodeToNodeSubscriptions.get(dep)) === null || _graph$nodeToNodeSubs === void 0 ? void 0 : _graph$nodeToNodeSubs.delete(node);\n            }\n        } // No need to delete sub's deps as there should be no subs at this point.\n        // But an invariant would require deleting nodes in topological order.\n        graph.nodeToNodeSubscriptions.delete(node);\n    } // Node config (for family members only as their configs can be recreated, and\n    // only if they are not retained within any other Stores):\n    deleteNodeConfigIfPossible$1(node);\n}\nfunction nodesRetainedByZone(storeState, zone) {\n    var _storeState$retention3;\n    return (_storeState$retention3 = storeState.retention.nodesRetainedByZone.get(zone)) !== null && _storeState$retention3 !== void 0 ? _storeState$retention3 : emptySet$1;\n}\nfunction zonesThatCouldRetainNode(node) {\n    const retainedBy = getNode$3(node).retainedBy;\n    if (retainedBy === undefined || retainedBy === \"components\" || retainedBy === \"recoilRoot\") {\n        return [];\n    } else if (retainedBy instanceof RetentionZone$2) {\n        return [\n            retainedBy\n        ];\n    } else {\n        return retainedBy; // it's an array of zones\n    }\n}\nfunction scheduleOrPerformPossibleReleaseOfRetainable(store, retainable) {\n    const state = store.getState();\n    if (state.nextTree) {\n        state.retention.retainablesToCheckForRelease.add(retainable);\n    } else {\n        releaseRetainablesNowOnCurrentTree(store, new Set([\n            retainable\n        ]));\n    }\n}\nfunction updateRetainCount(store, retainable, delta) {\n    var _map$get;\n    if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n        return;\n    }\n    const map = store.getState().retention.referenceCounts;\n    const newCount = ((_map$get = map.get(retainable)) !== null && _map$get !== void 0 ? _map$get : 0) + delta;\n    if (newCount === 0) {\n        updateRetainCountToZero(store, retainable);\n    } else {\n        map.set(retainable, newCount);\n    }\n}\nfunction updateRetainCountToZero(store, retainable) {\n    if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n        return;\n    }\n    const map = store.getState().retention.referenceCounts;\n    map.delete(retainable);\n    scheduleOrPerformPossibleReleaseOfRetainable(store, retainable);\n}\nfunction releaseScheduledRetainablesNow(store) {\n    if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n        return;\n    }\n    const state = store.getState();\n    releaseRetainablesNowOnCurrentTree(store, state.retention.retainablesToCheckForRelease);\n    state.retention.retainablesToCheckForRelease.clear();\n}\nfunction retainedByOptionWithDefault(r) {\n    // The default will change from 'recoilRoot' to 'components' in the future.\n    return r === undefined ? \"recoilRoot\" : r;\n}\nvar Recoil_Retention = {\n    SUSPENSE_TIMEOUT_MS,\n    updateRetainCount,\n    updateRetainCountToZero,\n    releaseScheduledRetainablesNow,\n    retainedByOptionWithDefault\n};\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * This is to export esstiential functions from react-dom\n * for our web build\n *\n * \n * @format\n * @oncall recoil\n */ const { unstable_batchedUpdates } = react_dom__WEBPACK_IMPORTED_MODULE_1__;\nvar ReactBatchedUpdates = {\n    unstable_batchedUpdates\n};\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * This is to export esstiential functions from react-dom\n * for our web build\n *\n * \n * @format\n * @oncall recoil\n */ // @fb-only: const {unstable_batchedUpdates} = require('ReactDOMComet');\n// prettier-ignore\nconst { unstable_batchedUpdates: unstable_batchedUpdates$1 } = ReactBatchedUpdates; // @oss-only\nvar Recoil_ReactBatchedUpdates = {\n    unstable_batchedUpdates: unstable_batchedUpdates$1\n};\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ const { batchStart: batchStart$1 } = Recoil_RecoilValueInterface;\nconst { unstable_batchedUpdates: unstable_batchedUpdates$2 } = Recoil_ReactBatchedUpdates; // flowlint-next-line unclear-type:off\n/*\n * During SSR, unstable_batchedUpdates may be undefined so this\n * falls back to a basic function that executes the batch\n */ let batcher = unstable_batchedUpdates$2 || ((batchFn)=>batchFn());\n/**\n * Sets the provided batcher function as the batcher function used by Recoil.\n *\n * Set the batcher to a custom batcher for your renderer,\n * if you use a renderer other than React DOM or React Native.\n */ const setBatcher = (newBatcher)=>{\n    batcher = newBatcher;\n};\n/**\n * Returns the current batcher function.\n */ const getBatcher = ()=>batcher;\n/**\n * Calls the current batcher function and passes the\n * provided callback function.\n */ const batchUpdates = (callback)=>{\n    batcher(()=>{\n        let batchEnd = ()=>undefined;\n        try {\n            batchEnd = batchStart$1();\n            callback();\n        } finally{\n            batchEnd();\n        }\n    });\n};\nvar Recoil_Batching = {\n    getBatcher,\n    setBatcher,\n    batchUpdates\n};\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * Combines multiple Iterables into a single Iterable.\n * Traverses the input Iterables in the order provided and maintains the order\n * of their elements.\n *\n * Example:\n * ```\n * const r = Array.from(concatIterables(['a', 'b'], ['c'], ['d', 'e', 'f']));\n * r == ['a', 'b', 'c', 'd', 'e', 'f'];\n * ```\n */ function* concatIterables(iters) {\n    for (const iter of iters){\n        for (const val of iter){\n            yield val;\n        }\n    }\n}\nvar Recoil_concatIterables = concatIterables;\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /* eslint-disable fb-www/typeof-undefined */ const isSSR = typeof Window === \"undefined\" || \"object\" === \"undefined\";\n/* eslint-enable fb-www/typeof-undefined */ const isWindow = (value)=>!isSSR && (value === window || value instanceof Window);\nconst isReactNative = typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\"; // eslint-disable-line fb-www/typeof-undefined\nvar Recoil_Environment = {\n    isSSR,\n    isReactNative,\n    isWindow\n};\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * Caches a function's results based on the key returned by the passed\n * hashFunction.\n */ function memoizeWithArgsHash(fn, hashFunction) {\n    let cache;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!cache) {\n            cache = {};\n        }\n        const key = hashFunction(...args);\n        if (!Object.hasOwnProperty.call(cache, key)) {\n            cache[key] = fn(...args);\n        }\n        return cache[key];\n    };\n}\n/**\n * Caches a function's results based on a comparison of the arguments.\n * Only caches the last return of the function.\n * Defaults to reference equality\n */ function memoizeOneWithArgsHash(fn, hashFunction) {\n    let lastKey;\n    let lastResult; // breaking cache when arguments change\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const key = hashFunction(...args);\n        if (lastKey === key) {\n            return lastResult;\n        }\n        lastKey = key;\n        lastResult = fn(...args);\n        return lastResult;\n    };\n}\n/**\n * Caches a function's results based on a comparison of the arguments.\n * Only caches the last return of the function.\n * Defaults to reference equality\n */ function memoizeOneWithArgsHashAndInvalidation(fn, hashFunction) {\n    let lastKey;\n    let lastResult; // breaking cache when arguments change\n    const memoizedFn = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const key = hashFunction(...args);\n        if (lastKey === key) {\n            return lastResult;\n        }\n        lastKey = key;\n        lastResult = fn(...args);\n        return lastResult;\n    };\n    const invalidate = ()=>{\n        lastKey = null;\n    };\n    return [\n        memoizedFn,\n        invalidate\n    ];\n}\nvar Recoil_Memoize = {\n    memoizeWithArgsHash,\n    memoizeOneWithArgsHash,\n    memoizeOneWithArgsHashAndInvalidation\n};\nconst { batchUpdates: batchUpdates$1 } = Recoil_Batching;\nconst { initializeNode: initializeNode$1, peekNodeInfo: peekNodeInfo$1 } = Recoil_FunctionalCore;\nconst { graph: graph$1 } = Recoil_Graph;\nconst { getNextStoreID: getNextStoreID$1 } = Recoil_Keys;\nconst { DEFAULT_VALUE: DEFAULT_VALUE$1, recoilValues: recoilValues$1, recoilValuesForKeys: recoilValuesForKeys$2 } = Recoil_Node;\nconst { AbstractRecoilValue: AbstractRecoilValue$2, getRecoilValueAsLoadable: getRecoilValueAsLoadable$1, setRecoilValue: setRecoilValue$1, setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$1 } = Recoil_RecoilValueInterface;\nconst { updateRetainCount: updateRetainCount$1 } = Recoil_Retention;\nconst { setInvalidateMemoizedSnapshot: setInvalidateMemoizedSnapshot$1 } = Recoil_SnapshotCache;\nconst { getNextTreeStateVersion: getNextTreeStateVersion$2, makeEmptyStoreState: makeEmptyStoreState$1 } = Recoil_State;\nconst { isSSR: isSSR$1 } = Recoil_Environment;\nconst { memoizeOneWithArgsHashAndInvalidation: memoizeOneWithArgsHashAndInvalidation$1 } = Recoil_Memoize;\n// Opaque at this surface because it's part of the public API from here.\nconst retainWarning = \"\\nRecoil Snapshots only last for the duration of the callback they are provided to. To keep a Snapshot longer, do this:\\n\\n  const release = snapshot.retain();\\n  try {\\n    await doSomethingWithSnapshot(snapshot);\\n  } finally {\\n    release();\\n  }\\n\\nThis is currently a DEV-only warning but will become a thrown exception in the next release of Recoil.\\n\"; // A \"Snapshot\" is \"read-only\" and captures a specific set of values of atoms.\n// However, the data-flow-graph and selector values may evolve as selector\n// evaluation functions are executed and async selectors resolve.\nclass Snapshot {\n    retain() {\n        if (this._refCount <= 0) {\n            if (true) {\n                throw Recoil_err(\"Snapshot has already been released.\");\n            } else {}\n        }\n        this._refCount++;\n        let released = false;\n        return ()=>{\n            if (!released) {\n                released = true;\n                this._release();\n            }\n        };\n    }\n    /**\n   * Release the snapshot on the next tick.  This means the snapshot is retained\n   * during the execution of the current function using it.\n   */ autoRelease_INTERNAL() {\n        if (!isSSR$1) {\n            // Use timeout of 10 to workaround Firefox issue: https://github.com/facebookexperimental/Recoil/issues/1936\n            window.setTimeout(()=>this._release(), 10);\n        }\n    }\n    _release() {\n        this._refCount--;\n        if (this._refCount === 0) {\n            this._store.getState().nodeCleanupFunctions.forEach((cleanup)=>cleanup());\n            this._store.getState().nodeCleanupFunctions.clear();\n            if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n                return;\n            } // Temporarily nerfing this to allow us to find broken call sites without\n        // actually breaking anybody yet.\n        // for (const k of this._store.getState().knownAtoms) {\n        //   updateRetainCountToZero(this._store, k);\n        // }\n        } else if (this._refCount < 0) {\n            if (true) {\n                Recoil_recoverableViolation(\"Snapshot released an extra time.\");\n            }\n        }\n    }\n    isRetained() {\n        return this._refCount > 0;\n    }\n    checkRefCount_INTERNAL() {\n        if (Recoil_gkx(\"recoil_memory_managament_2020\") && this._refCount <= 0) {\n            if (true) {\n                Recoil_recoverableViolation(retainWarning);\n            } // What we will ship later:\n        // throw err(retainWarning);\n        }\n    }\n    getStore_INTERNAL() {\n        this.checkRefCount_INTERNAL();\n        return this._store;\n    }\n    getID() {\n        this.checkRefCount_INTERNAL();\n        return this._store.getState().currentTree.stateID;\n    }\n    getStoreID() {\n        this.checkRefCount_INTERNAL();\n        return this._store.storeID;\n    }\n    // eslint-disable-next-line fb-www/no-uninitialized-properties\n    constructor(storeState, parentStoreID){\n        _defineProperty(this, \"_store\", void 0);\n        _defineProperty(this, \"_refCount\", 1);\n        _defineProperty(this, \"getLoadable\", (recoilValue)=>{\n            this.checkRefCount_INTERNAL();\n            return getRecoilValueAsLoadable$1(this._store, recoilValue);\n        });\n        _defineProperty(this, \"getPromise\", (recoilValue)=>{\n            this.checkRefCount_INTERNAL();\n            return this.getLoadable(recoilValue).toPromise();\n        });\n        _defineProperty(this, \"getNodes_UNSTABLE\", (opt)=>{\n            this.checkRefCount_INTERNAL(); // TODO Deal with modified selectors\n            if ((opt === null || opt === void 0 ? void 0 : opt.isModified) === true) {\n                if ((opt === null || opt === void 0 ? void 0 : opt.isInitialized) === false) {\n                    return [];\n                }\n                const state = this._store.getState().currentTree;\n                return recoilValuesForKeys$2(state.dirtyAtoms);\n            }\n            const knownAtoms = this._store.getState().knownAtoms;\n            const knownSelectors = this._store.getState().knownSelectors;\n            return (opt === null || opt === void 0 ? void 0 : opt.isInitialized) == null ? recoilValues$1.values() : opt.isInitialized === true ? recoilValuesForKeys$2(Recoil_concatIterables([\n                knownAtoms,\n                knownSelectors\n            ])) : Recoil_filterIterable(recoilValues$1.values(), (param)=>{\n                let { key } = param;\n                return !knownAtoms.has(key) && !knownSelectors.has(key);\n            });\n        });\n        _defineProperty(this, \"getInfo_UNSTABLE\", (param)=>{\n            let { key } = param;\n            this.checkRefCount_INTERNAL();\n            return peekNodeInfo$1(this._store, this._store.getState().currentTree, key);\n        });\n        _defineProperty(this, \"map\", (mapper)=>{\n            this.checkRefCount_INTERNAL();\n            const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);\n            mapper(mutableSnapshot); // if removing batchUpdates from `set` add it here\n            return mutableSnapshot;\n        });\n        _defineProperty(this, \"asyncMap\", async (mapper)=>{\n            this.checkRefCount_INTERNAL();\n            const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);\n            mutableSnapshot.retain(); // Retain new snapshot during async mapper\n            await mapper(mutableSnapshot); // Continue to retain the new snapshot for the user, but auto-release it\n            // after the next tick, the same as a new synchronous snapshot.\n            mutableSnapshot.autoRelease_INTERNAL();\n            return mutableSnapshot;\n        });\n        this._store = {\n            storeID: getNextStoreID$1(),\n            parentStoreID,\n            getState: ()=>storeState,\n            replaceState: (replacer)=>{\n                // no batching, so nextTree is never active\n                storeState.currentTree = replacer(storeState.currentTree);\n            },\n            getGraph: (version)=>{\n                const graphs = storeState.graphsByVersion;\n                if (graphs.has(version)) {\n                    return Recoil_nullthrows(graphs.get(version));\n                }\n                const newGraph = graph$1();\n                graphs.set(version, newGraph);\n                return newGraph;\n            },\n            subscribeToTransactions: ()=>({\n                    release: ()=>{}\n                }),\n            addTransactionMetadata: ()=>{\n                throw Recoil_err(\"Cannot subscribe to Snapshots\");\n            }\n        }; // Initialize any nodes that are live in the parent store (primarily so that\n        // this snapshot gets counted towards the node's live stores count).\n        // TODO Optimize this when cloning snapshots for callbacks\n        for (const nodeKey of this._store.getState().knownAtoms){\n            initializeNode$1(this._store, nodeKey, \"get\");\n            updateRetainCount$1(this._store, nodeKey, 1);\n        }\n        this.autoRelease_INTERNAL();\n    }\n}\nfunction cloneStoreState(store, treeState) {\n    let bumpVersion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    const storeState = store.getState();\n    const version = bumpVersion ? getNextTreeStateVersion$2() : treeState.version;\n    return {\n        // Always clone the TreeState to isolate stores from accidental mutations.\n        // For example, reading a selector from a cloned snapshot shouldn't cache\n        // in the original treestate which may cause the original to skip\n        // initialization of upstream atoms.\n        currentTree: {\n            // TODO snapshots shouldn't really have versions because a new version number\n            // is always assigned when the snapshot is gone to.\n            version: bumpVersion ? version : treeState.version,\n            stateID: bumpVersion ? version : treeState.stateID,\n            transactionMetadata: {\n                ...treeState.transactionMetadata\n            },\n            dirtyAtoms: new Set(treeState.dirtyAtoms),\n            atomValues: treeState.atomValues.clone(),\n            nonvalidatedAtoms: treeState.nonvalidatedAtoms.clone()\n        },\n        commitDepth: 0,\n        nextTree: null,\n        previousTree: null,\n        knownAtoms: new Set(storeState.knownAtoms),\n        // FIXME here's a copy\n        knownSelectors: new Set(storeState.knownSelectors),\n        // FIXME here's a copy\n        transactionSubscriptions: new Map(),\n        nodeTransactionSubscriptions: new Map(),\n        nodeToComponentSubscriptions: new Map(),\n        queuedComponentCallbacks_DEPRECATED: [],\n        suspendedComponentResolvers: new Set(),\n        graphsByVersion: new Map().set(version, store.getGraph(treeState.version)),\n        retention: {\n            referenceCounts: new Map(),\n            nodesRetainedByZone: new Map(),\n            retainablesToCheckForRelease: new Set()\n        },\n        // FIXME here's a copy\n        // Create blank cleanup handlers for atoms so snapshots don't re-run\n        // atom effects.\n        nodeCleanupFunctions: new Map(Recoil_mapIterable(storeState.nodeCleanupFunctions.entries(), (param)=>{\n            let [key] = param;\n            return [\n                key,\n                ()=>{}\n            ];\n        }))\n    };\n} // Factory to build a fresh snapshot\nfunction freshSnapshot(initializeState) {\n    const snapshot = new Snapshot(makeEmptyStoreState$1());\n    return initializeState != null ? snapshot.map(initializeState) : snapshot;\n} // Factory to clone a snapshot state\nconst [memoizedCloneSnapshot, invalidateMemoizedSnapshot$2] = memoizeOneWithArgsHashAndInvalidation$1((store, version)=>{\n    var _storeState$nextTree;\n    const storeState = store.getState();\n    const treeState = version === \"latest\" ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : Recoil_nullthrows(storeState.previousTree);\n    return new Snapshot(cloneStoreState(store, treeState), store.storeID);\n}, (store, version)=>{\n    var _store$getState$nextT, _store$getState$previ;\n    return String(version) + String(store.storeID) + String((_store$getState$nextT = store.getState().nextTree) === null || _store$getState$nextT === void 0 ? void 0 : _store$getState$nextT.version) + String(store.getState().currentTree.version) + String((_store$getState$previ = store.getState().previousTree) === null || _store$getState$previ === void 0 ? void 0 : _store$getState$previ.version);\n}); // Avoid circular dependencies\nsetInvalidateMemoizedSnapshot$1(invalidateMemoizedSnapshot$2);\nfunction cloneSnapshot(store) {\n    let version = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"latest\";\n    const snapshot = memoizedCloneSnapshot(store, version);\n    if (!snapshot.isRetained()) {\n        invalidateMemoizedSnapshot$2();\n        return memoizedCloneSnapshot(store, version);\n    }\n    return snapshot;\n}\nclass MutableSnapshot extends Snapshot {\n    constructor(snapshot, batch){\n        super(cloneStoreState(snapshot.getStore_INTERNAL(), snapshot.getStore_INTERNAL().getState().currentTree, true), snapshot.getStoreID());\n        _defineProperty(this, \"_batch\", void 0);\n        _defineProperty(this, \"set\", (recoilState, newValueOrUpdater)=>{\n            this.checkRefCount_INTERNAL();\n            const store = this.getStore_INTERNAL(); // This batchUpdates ensures this `set` is applied immediately and you can\n            // read the written value after calling `set`. I would like to remove this\n            // behavior and only batch in `Snapshot.map`, but this would be a breaking\n            // change potentially.\n            this._batch(()=>{\n                updateRetainCount$1(store, recoilState.key, 1);\n                setRecoilValue$1(this.getStore_INTERNAL(), recoilState, newValueOrUpdater);\n            });\n        });\n        _defineProperty(this, \"reset\", (recoilState)=>{\n            this.checkRefCount_INTERNAL();\n            const store = this.getStore_INTERNAL(); // See note at `set` about batched updates.\n            this._batch(()=>{\n                updateRetainCount$1(store, recoilState.key, 1);\n                setRecoilValue$1(this.getStore_INTERNAL(), recoilState, DEFAULT_VALUE$1);\n            });\n        });\n        _defineProperty(this, \"setUnvalidatedAtomValues_DEPRECATED\", (values)=>{\n            this.checkRefCount_INTERNAL();\n            const store = this.getStore_INTERNAL(); // See note at `set` about batched updates.\n            batchUpdates$1(()=>{\n                for (const [k, v] of values.entries()){\n                    updateRetainCount$1(store, k, 1);\n                    setUnvalidatedRecoilValue$1(store, new AbstractRecoilValue$2(k), v);\n                }\n            });\n        });\n        this._batch = batch;\n    }\n}\nvar Recoil_Snapshot = {\n    Snapshot,\n    MutableSnapshot,\n    freshSnapshot,\n    cloneSnapshot\n};\nvar Recoil_Snapshot_1 = Recoil_Snapshot.Snapshot;\nvar Recoil_Snapshot_2 = Recoil_Snapshot.MutableSnapshot;\nvar Recoil_Snapshot_3 = Recoil_Snapshot.freshSnapshot;\nvar Recoil_Snapshot_4 = Recoil_Snapshot.cloneSnapshot;\nvar Recoil_Snapshot$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    Snapshot: Recoil_Snapshot_1,\n    MutableSnapshot: Recoil_Snapshot_2,\n    freshSnapshot: Recoil_Snapshot_3,\n    cloneSnapshot: Recoil_Snapshot_4\n});\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ function unionSets() {\n    for(var _len = arguments.length, sets = new Array(_len), _key = 0; _key < _len; _key++){\n        sets[_key] = arguments[_key];\n    }\n    const result = new Set();\n    for (const set of sets){\n        for (const value of set){\n            result.add(value);\n        }\n    }\n    return result;\n}\nvar Recoil_unionSets = unionSets;\nconst { useRef } = (react__WEBPACK_IMPORTED_MODULE_0___default());\n/**\n * The same as `useRef()` except that if a function is specified then it will\n * call that function to get the value to initialize the reference with.\n * This is similar to how `useState()` behaves when given a function.  It allows\n * the user to avoid generating the initial value for subsequent renders.\n * The tradeoff is that to set the reference to a function itself you need to\n * nest it: useRefInitOnce(() => () => {...});\n */ function useRefInitOnce(initialValue) {\n    _s();\n    // $FlowExpectedError[incompatible-call]\n    const ref = useRef(initialValue);\n    if (ref.current === initialValue && typeof initialValue === \"function\") {\n        // $FlowExpectedError[incompatible-use]\n        ref.current = initialValue();\n    }\n    return ref;\n}\n_s(useRefInitOnce, \"QMBuJFIdzLIeqBcFwhMf246mjOM=\");\nvar Recoil_useRefInitOnce = useRefInitOnce;\n// @fb-only: const RecoilusagelogEvent = require('RecoilusagelogEvent');\n// @fb-only: const RecoilUsageLogFalcoEvent = require('RecoilUsageLogFalcoEvent');\n// @fb-only: const URI = require('URI');\nconst { getNextTreeStateVersion: getNextTreeStateVersion$3, makeEmptyStoreState: makeEmptyStoreState$2 } = Recoil_State;\nconst { cleanUpNode: cleanUpNode$2, getDownstreamNodes: getDownstreamNodes$2, initializeNode: initializeNode$2, setNodeValue: setNodeValue$2, setUnvalidatedAtomValue_DEPRECATED: setUnvalidatedAtomValue_DEPRECATED$1 } = Recoil_FunctionalCore;\nconst { graph: graph$2 } = Recoil_Graph;\nconst { cloneGraph: cloneGraph$1 } = Recoil_Graph;\nconst { getNextStoreID: getNextStoreID$2 } = Recoil_Keys;\nconst { createMutableSource: createMutableSource$1, reactMode: reactMode$2 } = Recoil_ReactMode;\nconst { applyAtomValueWrites: applyAtomValueWrites$1 } = Recoil_RecoilValueInterface;\nconst { releaseScheduledRetainablesNow: releaseScheduledRetainablesNow$1 } = Recoil_Retention;\nconst { freshSnapshot: freshSnapshot$1 } = Recoil_Snapshot$1;\nconst { useCallback, useContext, useEffect, useMemo, useRef: useRef$1, useState } = (react__WEBPACK_IMPORTED_MODULE_0___default());\nfunction notInAContext() {\n    throw Recoil_err(\"This component must be used inside a <RecoilRoot> component.\");\n}\nconst defaultStore = Object.freeze({\n    storeID: getNextStoreID$2(),\n    getState: notInAContext,\n    replaceState: notInAContext,\n    getGraph: notInAContext,\n    subscribeToTransactions: notInAContext,\n    addTransactionMetadata: notInAContext\n});\nlet stateReplacerIsBeingExecuted = false;\nfunction startNextTreeIfNeeded(store) {\n    if (stateReplacerIsBeingExecuted) {\n        throw Recoil_err(\"An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.\");\n    }\n    const storeState = store.getState();\n    if (storeState.nextTree === null) {\n        if (Recoil_gkx(\"recoil_memory_managament_2020\") && Recoil_gkx(\"recoil_release_on_cascading_update_killswitch_2021\")) {\n            // If this is a cascading update (that is, rendering due to one state change\n            // invokes a second state change), we won't have cleaned up retainables yet\n            // because this normally happens after notifying components. Do it before\n            // proceeding with the cascading update so that it remains predictable:\n            if (storeState.commitDepth > 0) {\n                releaseScheduledRetainablesNow$1(store);\n            }\n        }\n        const version = storeState.currentTree.version;\n        const nextVersion = getNextTreeStateVersion$3();\n        storeState.nextTree = {\n            ...storeState.currentTree,\n            version: nextVersion,\n            stateID: nextVersion,\n            dirtyAtoms: new Set(),\n            transactionMetadata: {}\n        };\n        storeState.graphsByVersion.set(nextVersion, cloneGraph$1(Recoil_nullthrows(storeState.graphsByVersion.get(version))));\n    }\n}\nconst AppContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext({\n    current: defaultStore\n});\nconst useStoreRef = ()=>{\n    _s1();\n    return useContext(AppContext);\n}; // $FlowExpectedError[incompatible-call]\n_s1(useStoreRef, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst MutableSourceContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nfunction useRecoilMutableSource() {\n    _s2();\n    const mutableSource = useContext(MutableSourceContext);\n    if (mutableSource == null) {\n        Recoil_expectationViolation(\"Attempted to use a Recoil hook outside of a <RecoilRoot>. \" + \"<RecoilRoot> must be an ancestor of any component that uses \" + \"Recoil hooks.\");\n    }\n    return mutableSource;\n}\n_s2(useRecoilMutableSource, \"+eZDoBoQNh1WubM+URmxLw5FTJk=\");\nfunction notifyComponents(store, storeState, treeState) {\n    const dependentNodes = getDownstreamNodes$2(store, treeState, treeState.dirtyAtoms);\n    for (const key of dependentNodes){\n        const comps = storeState.nodeToComponentSubscriptions.get(key);\n        if (comps) {\n            for (const [_subID, [_debugName, callback]] of comps){\n                callback(treeState);\n            }\n        }\n    }\n}\nfunction sendEndOfBatchNotifications(store) {\n    const storeState = store.getState();\n    const treeState = storeState.currentTree; // Inform transaction subscribers of the transaction:\n    const dirtyAtoms = treeState.dirtyAtoms;\n    if (dirtyAtoms.size) {\n        // Execute Node-specific subscribers before global subscribers\n        for (const [key, subscriptions] of storeState.nodeTransactionSubscriptions){\n            if (dirtyAtoms.has(key)) {\n                for (const [_, subscription] of subscriptions){\n                    subscription(store);\n                }\n            }\n        }\n        for (const [_, subscription] of storeState.transactionSubscriptions){\n            subscription(store);\n        }\n        if (!reactMode$2().early || storeState.suspendedComponentResolvers.size > 0) {\n            // Notifying components is needed to wake from suspense, even when using\n            // early rendering.\n            notifyComponents(store, storeState, treeState); // Wake all suspended components so the right one(s) can try to re-render.\n            // We need to wake up components not just when some asynchronous selector\n            // resolved, but also when changing synchronous values because this may cause\n            // a selector to change from asynchronous to synchronous, in which case there\n            // would be no follow-up asynchronous resolution to wake us up.\n            // TODO OPTIMIZATION Only wake up related downstream components\n            storeState.suspendedComponentResolvers.forEach((cb)=>cb());\n            storeState.suspendedComponentResolvers.clear();\n        }\n    } // Special behavior ONLY invoked by useInterface.\n    // FIXME delete queuedComponentCallbacks_DEPRECATED when deleting useInterface.\n    storeState.queuedComponentCallbacks_DEPRECATED.forEach((cb)=>cb(treeState));\n    storeState.queuedComponentCallbacks_DEPRECATED.splice(0, storeState.queuedComponentCallbacks_DEPRECATED.length);\n}\nfunction endBatch(store) {\n    const storeState = store.getState();\n    storeState.commitDepth++;\n    try {\n        const { nextTree } = storeState; // Ignore commits that are not because of Recoil transactions -- namely,\n        // because something above RecoilRoot re-rendered:\n        if (nextTree == null) {\n            return;\n        } // nextTree is now committed -- note that copying and reset occurs when\n        // a transaction begins, in startNextTreeIfNeeded:\n        storeState.previousTree = storeState.currentTree;\n        storeState.currentTree = nextTree;\n        storeState.nextTree = null;\n        sendEndOfBatchNotifications(store);\n        if (storeState.previousTree != null) {\n            storeState.graphsByVersion.delete(storeState.previousTree.version);\n        } else {\n            Recoil_recoverableViolation(\"Ended batch with no previous state, which is unexpected\", \"recoil\");\n        }\n        storeState.previousTree = null;\n        if (Recoil_gkx(\"recoil_memory_managament_2020\")) {\n            // Only release retainables if there were no writes during the end of the\n            // batch.  This avoids releasing something we might be about to use.\n            if (nextTree == null) {\n                releaseScheduledRetainablesNow$1(store);\n            }\n        }\n    } finally{\n        storeState.commitDepth--;\n    }\n}\n/*\n * The purpose of the Batcher is to observe when React batches end so that\n * Recoil state changes can be batched. Whenever Recoil state changes, we call\n * setState on the batcher. Then we wait for that change to be committed, which\n * signifies the end of the batch. That's when we respond to the Recoil change.\n */ function Batcher(param) {\n    let { setNotifyBatcherOfChange } = param;\n    _s3();\n    const storeRef = useStoreRef();\n    const [, setState] = useState([]); // $FlowFixMe[incompatible-call]\n    setNotifyBatcherOfChange(()=>setState({}));\n    useEffect(()=>{\n        // $FlowFixMe[incompatible-call]\n        setNotifyBatcherOfChange(()=>setState({})); // If an asynchronous selector resolves after the Batcher is unmounted,\n        // notifyBatcherOfChange will still be called. An error gets thrown whenever\n        // setState is called after a component is already unmounted, so this sets\n        // notifyBatcherOfChange to be a no-op.\n        return ()=>{\n            setNotifyBatcherOfChange(()=>{});\n        };\n    }, [\n        setNotifyBatcherOfChange\n    ]);\n    useEffect(()=>{\n        // enqueueExecution runs this function immediately; it is only used to\n        // manipulate the order of useEffects during tests, since React seems to\n        // call useEffect in an unpredictable order sometimes.\n        Recoil_Queue.enqueueExecution(\"Batcher\", ()=>{\n            endBatch(storeRef.current);\n        });\n    });\n    return null;\n}\n_s3(Batcher, \"hW1eJitInZrOO0p+97whgnpfou8=\", false, function() {\n    return [\n        useStoreRef\n    ];\n});\n_c1 = Batcher;\nif (true) {\n    if ( true && !window.$recoilDebugStates) {\n        window.$recoilDebugStates = [];\n    }\n} // When removing this deprecated function, remove stateBySettingRecoilValue\n// which will no longer be needed.\nfunction initialStoreState_DEPRECATED(store, initializeState) {\n    const initial = makeEmptyStoreState$2();\n    initializeState({\n        set: (atom, value)=>{\n            const state = initial.currentTree;\n            const writes = setNodeValue$2(store, state, atom.key, value);\n            const writtenNodes = new Set(writes.keys());\n            const nonvalidatedAtoms = state.nonvalidatedAtoms.clone();\n            for (const n of writtenNodes){\n                nonvalidatedAtoms.delete(n);\n            }\n            initial.currentTree = {\n                ...state,\n                dirtyAtoms: Recoil_unionSets(state.dirtyAtoms, writtenNodes),\n                atomValues: applyAtomValueWrites$1(state.atomValues, writes),\n                // NB: PLEASE un-export applyAtomValueWrites when deleting this code\n                nonvalidatedAtoms\n            };\n        },\n        setUnvalidatedAtomValues: (atomValues)=>{\n            // FIXME replace this with a mutative loop\n            atomValues.forEach((v, k)=>{\n                initial.currentTree = setUnvalidatedAtomValue_DEPRECATED$1(initial.currentTree, k, v);\n            });\n        }\n    });\n    return initial;\n} // Initialize state snapshot for <RecoilRoot> for the initializeState prop.\n// Atom effect initialization takes precedence over this prop.\n// Any atom effects will be run before initialization, but then cleaned up,\n// they are then re-run when used as part of rendering.  These semantics are\n// compatible with React StrictMode where effects may be re-run multiple times\n// but state initialization only happens once the first time.\nfunction initialStoreState(initializeState) {\n    // Initialize a snapshot and get its store\n    const snapshot = freshSnapshot$1(initializeState);\n    const storeState = snapshot.getStore_INTERNAL().getState(); // Counteract the snapshot auto-release\n    snapshot.retain(); // Cleanup any effects run during initialization and clear the handlers so\n    // they will re-initialize if used during rendering.  This allows atom effect\n    // initialization to take precedence over initializeState and be compatible\n    // with StrictMode semantics.\n    storeState.nodeCleanupFunctions.forEach((cleanup)=>cleanup());\n    storeState.nodeCleanupFunctions.clear();\n    return storeState;\n}\nlet nextID = 0;\nfunction RecoilRoot_INTERNAL(param) {\n    let { initializeState_DEPRECATED, initializeState, store_INTERNAL: storeProp, // For use with React \"context bridging\"\n    children } = param;\n    _s4();\n    // prettier-ignore\n    // @fb-only: useEffect(() => {\n    // @fb-only: if (gkx('recoil_usage_logging')) {\n    // @fb-only: try {\n    // @fb-only: RecoilUsageLogFalcoEvent.log(() => ({\n    // @fb-only: type: RecoilusagelogEvent.RECOIL_ROOT_MOUNTED,\n    // @fb-only: path: URI.getRequestURI().getPath(),\n    // @fb-only: }));\n    // @fb-only: } catch {\n    // @fb-only: recoverableViolation(\n    // @fb-only: 'Error when logging Recoil Usage event',\n    // @fb-only: 'recoil',\n    // @fb-only: );\n    // @fb-only: }\n    // @fb-only: }\n    // @fb-only: }, []);\n    let storeStateRef; // eslint-disable-line prefer-const\n    const getGraph = (version)=>{\n        const graphs = storeStateRef.current.graphsByVersion;\n        if (graphs.has(version)) {\n            return Recoil_nullthrows(graphs.get(version));\n        }\n        const newGraph = graph$2();\n        graphs.set(version, newGraph);\n        return newGraph;\n    };\n    const subscribeToTransactions = (callback, key)=>{\n        if (key == null) {\n            // Global transaction subscriptions\n            const { transactionSubscriptions } = storeRef.current.getState();\n            const id = nextID++;\n            transactionSubscriptions.set(id, callback);\n            return {\n                release: ()=>{\n                    transactionSubscriptions.delete(id);\n                }\n            };\n        } else {\n            // Node-specific transaction subscriptions:\n            const { nodeTransactionSubscriptions } = storeRef.current.getState();\n            if (!nodeTransactionSubscriptions.has(key)) {\n                nodeTransactionSubscriptions.set(key, new Map());\n            }\n            const id = nextID++;\n            Recoil_nullthrows(nodeTransactionSubscriptions.get(key)).set(id, callback);\n            return {\n                release: ()=>{\n                    const subs = nodeTransactionSubscriptions.get(key);\n                    if (subs) {\n                        subs.delete(id);\n                        if (subs.size === 0) {\n                            nodeTransactionSubscriptions.delete(key);\n                        }\n                    }\n                }\n            };\n        }\n    };\n    const addTransactionMetadata = (metadata)=>{\n        startNextTreeIfNeeded(storeRef.current);\n        for (const k of Object.keys(metadata)){\n            Recoil_nullthrows(storeRef.current.getState().nextTree).transactionMetadata[k] = metadata[k];\n        }\n    };\n    const replaceState = (replacer)=>{\n        startNextTreeIfNeeded(storeRef.current); // Use replacer to get the next state:\n        const nextTree = Recoil_nullthrows(storeStateRef.current.nextTree);\n        let replaced;\n        try {\n            stateReplacerIsBeingExecuted = true;\n            replaced = replacer(nextTree);\n        } finally{\n            stateReplacerIsBeingExecuted = false;\n        }\n        if (replaced === nextTree) {\n            return;\n        }\n        if (true) {\n            if (true) {\n                window.$recoilDebugStates.push(replaced); // TODO this shouldn't happen here because it's not batched\n            }\n        } // Save changes to nextTree and schedule a React update:\n        storeStateRef.current.nextTree = replaced;\n        if (reactMode$2().early) {\n            notifyComponents(storeRef.current, storeStateRef.current, replaced);\n        }\n        Recoil_nullthrows(notifyBatcherOfChange.current)();\n    };\n    const notifyBatcherOfChange = useRef$1(null);\n    const setNotifyBatcherOfChange = useCallback((x)=>{\n        notifyBatcherOfChange.current = x;\n    }, [\n        notifyBatcherOfChange\n    ]);\n    const storeRef = Recoil_useRefInitOnce(()=>storeProp !== null && storeProp !== void 0 ? storeProp : {\n            storeID: getNextStoreID$2(),\n            getState: ()=>storeStateRef.current,\n            replaceState,\n            getGraph,\n            subscribeToTransactions,\n            addTransactionMetadata\n        });\n    if (storeProp != null) {\n        storeRef.current = storeProp;\n    }\n    storeStateRef = Recoil_useRefInitOnce(()=>initializeState_DEPRECATED != null ? initialStoreState_DEPRECATED(storeRef.current, initializeState_DEPRECATED) : initializeState != null ? initialStoreState(initializeState) : makeEmptyStoreState$2());\n    const mutableSource = useMemo(()=>createMutableSource$1 === null || createMutableSource$1 === void 0 ? void 0 : createMutableSource$1(storeStateRef, ()=>storeStateRef.current.currentTree.version), [\n        storeStateRef\n    ]); // Cleanup when the <RecoilRoot> is unmounted\n    useEffect(()=>{\n        // React is free to call effect cleanup handlers and effects at will, the\n        // deps array is only an optimization.  For example, React strict mode\n        // will execute each effect twice for testing.  Therefore, we need symmetry\n        // to re-initialize all known atoms after they were cleaned up.\n        const store = storeRef.current;\n        for (const atomKey of new Set(store.getState().knownAtoms)){\n            initializeNode$2(store, atomKey, \"get\");\n        }\n        return ()=>{\n            for (const atomKey of store.getState().knownAtoms){\n                cleanUpNode$2(store, atomKey);\n            }\n        };\n    }, [\n        storeRef\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AppContext.Provider, {\n        value: storeRef\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(MutableSourceContext.Provider, {\n        value: mutableSource\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Batcher, {\n        setNotifyBatcherOfChange: setNotifyBatcherOfChange\n    }), children));\n}\n_s4(RecoilRoot_INTERNAL, \"e0ZlGXUUjW0H0/kTLiqIU/2CoS8=\", false, function() {\n    return [\n        useRef$1\n    ];\n});\n_c2 = RecoilRoot_INTERNAL;\nfunction RecoilRoot(props) {\n    _s5();\n    const { override, ...propsExceptOverride } = props;\n    const ancestorStoreRef = useStoreRef();\n    if (override === false && ancestorStoreRef.current !== defaultStore) {\n        // If ancestorStoreRef.current !== defaultStore, it means that this\n        // RecoilRoot is not nested within another.\n        return props.children;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RecoilRoot_INTERNAL, propsExceptOverride);\n}\n_s5(RecoilRoot, \"Qr/5pnRCQzWuDJiEAY1nJBultrE=\", false, function() {\n    return [\n        useStoreRef\n    ];\n});\n_c3 = RecoilRoot;\nfunction useRecoilStoreID() {\n    _s6();\n    return useStoreRef().current.storeID;\n}\n_s6(useRecoilStoreID, \"ndm+r8POnR+w6+MrX9Jl/zqEg6c=\", false, function() {\n    return [\n        useStoreRef\n    ];\n});\nvar Recoil_RecoilRoot = {\n    RecoilRoot,\n    useStoreRef,\n    useRecoilMutableSource,\n    useRecoilStoreID,\n    notifyComponents_FOR_TESTING: notifyComponents,\n    sendEndOfBatchNotifications_FOR_TESTING: sendEndOfBatchNotifications\n};\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ function shallowArrayEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a.length !== b.length) {\n        return false;\n    }\n    for(let i = 0, l = a.length; i < l; i++){\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nvar Recoil_shallowArrayEqual = shallowArrayEqual;\nconst { useEffect: useEffect$1, useRef: useRef$2 } = (react__WEBPACK_IMPORTED_MODULE_0___default());\nfunction usePrevious(value) {\n    _s7();\n    const ref = useRef$2();\n    useEffect$1(()=>{\n        // $FlowFixMe[incompatible-type]\n        ref.current = value;\n    });\n    return ref.current;\n}\n_s7(usePrevious, \"kksd3a/iGXmPyr8HY5TVlClP0pY=\", false, function() {\n    return [\n        useRef$2,\n        useEffect$1\n    ];\n});\nvar Recoil_usePrevious = usePrevious;\nconst { useStoreRef: useStoreRef$1 } = Recoil_RecoilRoot;\nconst { SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$1 } = Recoil_Retention;\nconst { updateRetainCount: updateRetainCount$2 } = Recoil_Retention;\nconst { RetentionZone: RetentionZone$3 } = Recoil_RetentionZone;\nconst { useEffect: useEffect$2, useRef: useRef$3 } = (react__WEBPACK_IMPORTED_MODULE_0___default());\nconst { isSSR: isSSR$2 } = Recoil_Environment;\n// I don't see a way to avoid the any type here because we want to accept readable\n// and writable values with any type parameter, but normally with writable ones\n// RecoilState<SomeT> is not a subtype of RecoilState<mixed>.\n// flowlint-line unclear-type:off\nfunction useRetain(toRetain) {\n    _s8();\n    if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n        return;\n    } // eslint-disable-next-line fb-www/react-hooks\n    return useRetain_ACTUAL(toRetain);\n}\n_s8(useRetain, \"d+YrL5k9FGpC3I5gy/vXF5wbtQM=\", false, function() {\n    return [\n        useRetain_ACTUAL\n    ];\n});\nfunction useRetain_ACTUAL(toRetain) {\n    _s9();\n    const array = Array.isArray(toRetain) ? toRetain : [\n        toRetain\n    ];\n    const retainables = array.map((a)=>a instanceof RetentionZone$3 ? a : a.key);\n    const storeRef = useStoreRef$1();\n    useEffect$2(()=>{\n        if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n            return;\n        }\n        const store = storeRef.current;\n        if (timeoutID.current && !isSSR$2) {\n            // Already performed a temporary retain on render, simply cancel the release\n            // of that temporary retain.\n            window.clearTimeout(timeoutID.current);\n            timeoutID.current = null;\n        } else {\n            for (const r of retainables){\n                updateRetainCount$2(store, r, 1);\n            }\n        }\n        return ()=>{\n            for (const r of retainables){\n                updateRetainCount$2(store, r, -1);\n            }\n        }; // eslint-disable-next-line fb-www/react-hooks-deps\n    }, [\n        storeRef,\n        ...retainables\n    ]); // We want to retain if the component suspends. This is terrible but the Suspense\n    // API affords us no better option. If we suspend and never commit after some\n    // seconds, then release. The 'actual' retain/release in the effect above\n    // cancels this.\n    const timeoutID = useRef$3();\n    const previousRetainables = Recoil_usePrevious(retainables);\n    if (!isSSR$2 && (previousRetainables === undefined || !Recoil_shallowArrayEqual(previousRetainables, retainables))) {\n        const store = storeRef.current;\n        for (const r of retainables){\n            updateRetainCount$2(store, r, 1);\n        }\n        if (previousRetainables) {\n            for (const r of previousRetainables){\n                updateRetainCount$2(store, r, -1);\n            }\n        }\n        if (timeoutID.current) {\n            window.clearTimeout(timeoutID.current);\n        }\n        timeoutID.current = window.setTimeout(()=>{\n            timeoutID.current = null;\n            for (const r of retainables){\n                updateRetainCount$2(store, r, -1);\n            }\n        }, SUSPENSE_TIMEOUT_MS$1);\n    }\n}\n_s9(useRetain_ACTUAL, \"aw67vomgzXD807e3fs38765q+VY=\", false, function() {\n    return [\n        useStoreRef$1,\n        useEffect$2,\n        useRef$3\n    ];\n});\nvar Recoil_useRetain = useRetain;\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * THIS CODE HAS BEEN COMMENTED OUT INTENTIONALLY\n *\n * This technique of getting the component name is imperfect, since it both only\n * works in a non-minified code base, and more importantly introduces performance\n * problems since it relies in throwing errors which is an expensive operation.\n *\n * At some point we may want to reevaluate this technique hence why we have commented\n * this code out, rather than delete it all together.\n */ // const {useRef} = require('react');\n// const gkx = require('recoil-shared/util/Recoil_gkx');\n// const stackTraceParser = require('recoil-shared/util/Recoil_stackTraceParser');\nfunction useComponentName() {\n    // const nameRef = useRef();\n    // if (__DEV__) {\n    //   if (gkx('recoil_infer_component_names')) {\n    //     if (nameRef.current === undefined) {\n    //       // There is no blessed way to determine the calling React component from\n    //       // within a hook. This hack uses the fact that hooks must start with 'use'\n    //       // and that hooks are either called by React Components or other hooks. It\n    //       // follows therefore, that to find the calling component, you simply need\n    //       // to look down the stack and find the first function which doesn't start\n    //       // with 'use'. We are only enabling this in dev for now, since once the\n    //       // codebase is minified, the naming assumptions no longer hold true.\n    //       // eslint-disable-next-line fb-www/no-new-error\n    //       const frames = stackTraceParser(new Error().stack);\n    //       for (const {methodName} of frames) {\n    //         // I observed cases where the frame was of the form 'Object.useXXX'\n    //         // hence why I'm searching for hooks following a word boundary\n    //         if (!methodName.match(/\\buse[^\\b]+$/)) {\n    //           return (nameRef.current = methodName);\n    //         }\n    //       }\n    //       nameRef.current = null;\n    //     }\n    //     return nameRef.current ?? '<unable to determine component name>';\n    //   }\n    // }\n    // @fb-only: return \"<component name only available when both in dev mode and when passing GK 'recoil_infer_component_names'>\";\n    return \"<component name not available>\"; // @oss-only\n}\nvar Recoil_useComponentName = useComponentName;\nconst { batchUpdates: batchUpdates$2 } = Recoil_Batching;\nconst { DEFAULT_VALUE: DEFAULT_VALUE$2 } = Recoil_Node;\nconst { currentRendererSupportsUseSyncExternalStore: currentRendererSupportsUseSyncExternalStore$1, reactMode: reactMode$3, useMutableSource: useMutableSource$1, useSyncExternalStore: useSyncExternalStore$1 } = Recoil_ReactMode;\nconst { useRecoilMutableSource: useRecoilMutableSource$1, useStoreRef: useStoreRef$2 } = Recoil_RecoilRoot;\nconst { isRecoilValue: isRecoilValue$2 } = Recoil_RecoilValue$1;\nconst { AbstractRecoilValue: AbstractRecoilValue$3, getRecoilValueAsLoadable: getRecoilValueAsLoadable$2, setRecoilValue: setRecoilValue$2, setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$2, subscribeToRecoilValue: subscribeToRecoilValue$1 } = Recoil_RecoilValueInterface;\nconst { useCallback: useCallback$1, useEffect: useEffect$3, useMemo: useMemo$1, useRef: useRef$4, useState: useState$1 } = (react__WEBPACK_IMPORTED_MODULE_0___default());\nconst { setByAddingToSet: setByAddingToSet$2 } = Recoil_CopyOnWrite;\nconst { isSSR: isSSR$3 } = Recoil_Environment;\nfunction handleLoadable(loadable, recoilValue, storeRef) {\n    // We can't just throw the promise we are waiting on to Suspense.  If the\n    // upstream dependencies change it may produce a state in which the component\n    // can render, but it would still be suspended on a Promise that may never resolve.\n    if (loadable.state === \"hasValue\") {\n        return loadable.contents;\n    } else if (loadable.state === \"loading\") {\n        const promise = new Promise((resolve)=>{\n            const suspendedComponentResolvers = storeRef.current.getState().suspendedComponentResolvers;\n            suspendedComponentResolvers.add(resolve); // SSR should clear out the wake-up resolver if the Promise is resolved\n            // to avoid infinite loops.  (See https://github.com/facebookexperimental/Recoil/pull/2073)\n            if (isSSR$3 && Recoil_isPromise(loadable.contents)) {\n                loadable.contents.finally(()=>{\n                    suspendedComponentResolvers.delete(resolve);\n                });\n            }\n        }); // $FlowExpectedError Flow(prop-missing) for integrating with tools that inspect thrown promises @fb-only\n        // @fb-only: promise.displayName = `Recoil State: ${recoilValue.key}`;\n        throw promise;\n    } else if (loadable.state === \"hasError\") {\n        throw loadable.contents;\n    } else {\n        throw Recoil_err('Invalid value of loadable atom \"'.concat(recoilValue.key, '\"'));\n    }\n}\nfunction validateRecoilValue(recoilValue, hookName // $FlowFixMe[missing-local-annot]\n) {\n    if (!isRecoilValue$2(recoilValue)) {\n        throw Recoil_err(\"Invalid argument to \".concat(hookName, \": expected an atom or selector but got \").concat(String(recoilValue)));\n    }\n}\n/**\n * Various things are broken with useRecoilInterface, particularly concurrent\n * mode, React strict mode, and memory management. They will not be fixed.\n * */ function useRecoilInterface_DEPRECATED() {\n    _s10();\n    const componentName = Recoil_useComponentName();\n    const storeRef = useStoreRef$2(); // eslint-disable-next-line fb-www/react-no-unused-state-hook\n    const [, forceUpdate] = useState$1([]);\n    const recoilValuesUsed = useRef$4(new Set());\n    recoilValuesUsed.current = new Set(); // Track the RecoilValues used just during this render\n    const previousSubscriptions = useRef$4(new Set());\n    const subscriptions = useRef$4(new Map());\n    const unsubscribeFrom = useCallback$1((key)=>{\n        const sub = subscriptions.current.get(key);\n        if (sub) {\n            sub.release();\n            subscriptions.current.delete(key);\n        }\n    }, [\n        subscriptions\n    ]);\n    const updateState = useCallback$1((_state, key)=>{\n        if (subscriptions.current.has(key)) {\n            forceUpdate([]);\n        }\n    }, []); // Effect to add/remove subscriptions as nodes are used\n    useEffect$3(()=>{\n        const store = storeRef.current;\n        Recoil_differenceSets(recoilValuesUsed.current, previousSubscriptions.current).forEach((key)=>{\n            if (subscriptions.current.has(key)) {\n                Recoil_expectationViolation('Double subscription to RecoilValue \"'.concat(key, '\"'));\n                return;\n            }\n            const sub = subscribeToRecoilValue$1(store, new AbstractRecoilValue$3(key), (state)=>updateState(state, key), componentName);\n            subscriptions.current.set(key, sub);\n            /**\n       * Since we're subscribing in an effect we need to update to the latest\n       * value of the atom since it may have changed since we rendered. We can\n       * go ahead and do that now, unless we're in the middle of a batch --\n       * in which case we should do it at the end of the batch, due to the\n       * following edge case: Suppose an atom is updated in another useEffect\n       * of this same component. Then the following sequence of events occur:\n       * 1. Atom is updated and subs fired (but we may not be subscribed\n       *    yet depending on order of effects, so we miss this) Updated value\n       *    is now in nextTree, but not currentTree.\n       * 2. This effect happens. We subscribe and update.\n       * 3. From the update we re-render and read currentTree, with old value.\n       * 4. Batcher's effect sets currentTree to nextTree.\n       * In this sequence we miss the update. To avoid that, add the update\n       * to queuedComponentCallback if a batch is in progress.\n       */ // FIXME delete queuedComponentCallbacks_DEPRECATED when deleting useInterface.\n            const state = store.getState();\n            if (state.nextTree) {\n                store.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{\n                    updateState(store.getState(), key);\n                });\n            } else {\n                updateState(store.getState(), key);\n            }\n        });\n        Recoil_differenceSets(previousSubscriptions.current, recoilValuesUsed.current).forEach((key)=>{\n            unsubscribeFrom(key);\n        });\n        previousSubscriptions.current = recoilValuesUsed.current;\n    }); // Effect to unsubscribe from all when unmounting\n    useEffect$3(()=>{\n        const currentSubscriptions = subscriptions.current; // Restore subscriptions that were cleared due to StrictMode running this effect twice\n        Recoil_differenceSets(recoilValuesUsed.current, new Set(currentSubscriptions.keys())).forEach((key)=>{\n            const sub = subscribeToRecoilValue$1(storeRef.current, new AbstractRecoilValue$3(key), (state)=>updateState(state, key), componentName);\n            currentSubscriptions.set(key, sub);\n        });\n        return ()=>currentSubscriptions.forEach((_, key)=>unsubscribeFrom(key));\n    }, [\n        componentName,\n        storeRef,\n        unsubscribeFrom,\n        updateState\n    ]);\n    return useMemo$1(()=>{\n        var _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n        // eslint-disable-next-line no-shadow\n        function useSetRecoilState(recoilState) {\n            if (true) {\n                validateRecoilValue(recoilState, \"useSetRecoilState\");\n            }\n            return (newValueOrUpdater)=>{\n                setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);\n            };\n        } // eslint-disable-next-line no-shadow\n        function useResetRecoilState(recoilState) {\n            if (true) {\n                validateRecoilValue(recoilState, \"useResetRecoilState\");\n            }\n            return ()=>setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);\n        } // eslint-disable-next-line no-shadow\n        function useRecoilValueLoadable(recoilValue) {\n            var _storeState$nextTree;\n            if (true) {\n                validateRecoilValue(recoilValue, \"useRecoilValueLoadable\");\n            }\n            if (!recoilValuesUsed.current.has(recoilValue.key)) {\n                recoilValuesUsed.current = setByAddingToSet$2(recoilValuesUsed.current, recoilValue.key);\n            } // TODO Restore optimization to memoize lookup\n            const storeState = storeRef.current.getState();\n            return getRecoilValueAsLoadable$2(storeRef.current, recoilValue, reactMode$3().early ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : storeState.currentTree);\n        } // eslint-disable-next-line no-shadow\n        function useRecoilValue(recoilValue) {\n            _s();\n            if (true) {\n                validateRecoilValue(recoilValue, \"useRecoilValue\");\n            }\n            const loadable = useRecoilValueLoadable(recoilValue);\n            return handleLoadable(loadable, recoilValue, storeRef);\n        } // eslint-disable-next-line no-shadow\n        _s(useRecoilValue, \"v2T9AUkvC9UCe1jwaYSAtwAdEFU=\", false, function() {\n            return [\n                useRecoilValueLoadable\n            ];\n        });\n        function useRecoilState(recoilState) {\n            _s1();\n            if (true) {\n                validateRecoilValue(recoilState, \"useRecoilState\");\n            }\n            return [\n                useRecoilValue(recoilState),\n                useSetRecoilState(recoilState)\n            ];\n        } // eslint-disable-next-line no-shadow\n        _s1(useRecoilState, \"msEl7ALZc52vkqN6X20sfA7eHpY=\", false, function() {\n            return [\n                useRecoilValue,\n                useSetRecoilState\n            ];\n        });\n        function useRecoilStateLoadable(recoilState) {\n            _s2();\n            if (true) {\n                validateRecoilValue(recoilState, \"useRecoilStateLoadable\");\n            }\n            return [\n                useRecoilValueLoadable(recoilState),\n                useSetRecoilState(recoilState)\n            ];\n        }\n        _s2(useRecoilStateLoadable, \"PDFziEpi0LwwYh1DiWL3VJrLfjI=\", false, function() {\n            return [\n                useRecoilValueLoadable,\n                useSetRecoilState\n            ];\n        });\n        return {\n            getRecoilValue: useRecoilValue,\n            getRecoilValueLoadable: useRecoilValueLoadable,\n            getRecoilState: useRecoilState,\n            getRecoilStateLoadable: useRecoilStateLoadable,\n            getSetRecoilState: useSetRecoilState,\n            getResetRecoilState: useResetRecoilState\n        };\n    }, [\n        recoilValuesUsed,\n        storeRef\n    ]);\n}\n_s10(useRecoilInterface_DEPRECATED, \"q7cUZPIbq7Pi3BsDtUKI7nipngE=\", false, function() {\n    return [\n        useStoreRef$2,\n        useState$1,\n        useRef$4,\n        useRef$4,\n        useRef$4,\n        useCallback$1,\n        useCallback$1,\n        useEffect$3,\n        useEffect$3,\n        useMemo$1\n    ];\n});\nconst recoilComponentGetRecoilValueCount_FOR_TESTING = {\n    current: 0\n};\nfunction useRecoilValueLoadable_SYNC_EXTERNAL_STORE(recoilValue) {\n    _s11();\n    const storeRef = useStoreRef$2();\n    const componentName = Recoil_useComponentName();\n    const getSnapshot = useCallback$1(()=>{\n        var _storeState$nextTree2;\n        if (true) {\n            recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n        }\n        const store = storeRef.current;\n        const storeState = store.getState();\n        const treeState = reactMode$3().early ? (_storeState$nextTree2 = storeState.nextTree) !== null && _storeState$nextTree2 !== void 0 ? _storeState$nextTree2 : storeState.currentTree : storeState.currentTree;\n        const loadable = getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n        return {\n            loadable,\n            key: recoilValue.key\n        };\n    }, [\n        storeRef,\n        recoilValue\n    ]); // Memoize the state to avoid unnecessary rerenders\n    const memoizePreviousSnapshot = useCallback$1((getState)=>{\n        let prevState;\n        return ()=>{\n            var _prevState, _prevState2;\n            const nextState = getState();\n            if ((_prevState = prevState) !== null && _prevState !== void 0 && _prevState.loadable.is(nextState.loadable) && ((_prevState2 = prevState) === null || _prevState2 === void 0 ? void 0 : _prevState2.key) === nextState.key) {\n                return prevState;\n            }\n            prevState = nextState;\n            return nextState;\n        };\n    }, []);\n    const getMemoizedSnapshot = useMemo$1(()=>memoizePreviousSnapshot(getSnapshot), [\n        getSnapshot,\n        memoizePreviousSnapshot\n    ]);\n    const subscribe = useCallback$1((notify)=>{\n        const store = storeRef.current;\n        const subscription = subscribeToRecoilValue$1(store, recoilValue, notify, componentName);\n        return subscription.release;\n    }, [\n        storeRef,\n        recoilValue,\n        componentName\n    ]);\n    return useSyncExternalStore$1(subscribe, getMemoizedSnapshot, getMemoizedSnapshot // getServerSnapshot() for SSR support\n    ).loadable;\n}\n_s11(useRecoilValueLoadable_SYNC_EXTERNAL_STORE, \"Y/MXIijy+7ucfT02rvrIPKfoKwE=\", false, function() {\n    return [\n        useStoreRef$2,\n        useCallback$1,\n        useCallback$1,\n        useMemo$1,\n        useCallback$1,\n        useSyncExternalStore$1\n    ];\n});\nfunction useRecoilValueLoadable_MUTABLE_SOURCE(recoilValue) {\n    _s12();\n    const storeRef = useStoreRef$2();\n    const getLoadable = useCallback$1(()=>{\n        var _storeState$nextTree3;\n        const store = storeRef.current;\n        const storeState = store.getState();\n        const treeState = reactMode$3().early ? (_storeState$nextTree3 = storeState.nextTree) !== null && _storeState$nextTree3 !== void 0 ? _storeState$nextTree3 : storeState.currentTree : storeState.currentTree;\n        return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n    }, [\n        storeRef,\n        recoilValue\n    ]);\n    const getLoadableWithTesting = useCallback$1(()=>{\n        if (true) {\n            recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n        }\n        return getLoadable();\n    }, [\n        getLoadable\n    ]);\n    const componentName = Recoil_useComponentName();\n    const subscribe = useCallback$1((_storeState, notify)=>{\n        const store = storeRef.current;\n        const subscription = subscribeToRecoilValue$1(store, recoilValue, ()=>{\n            if (!Recoil_gkx(\"recoil_suppress_rerender_in_callback\")) {\n                return notify();\n            } // Only re-render if the value has changed.\n            // This will evaluate the atom/selector now as well as when the\n            // component renders, but that may help with prefetching.\n            const newLoadable = getLoadable();\n            if (!prevLoadableRef.current.is(newLoadable)) {\n                notify();\n            } // If the component is suspended then the effect setting prevLoadableRef\n            // will not run.  So, set the previous value here when its subscription\n            // is fired to wake it up.  We can't just rely on this, though, because\n            // this only executes when an atom/selector is dirty and the atom/selector\n            // passed to the hook can dynamically change.\n            prevLoadableRef.current = newLoadable;\n        }, componentName);\n        return subscription.release;\n    }, [\n        storeRef,\n        recoilValue,\n        componentName,\n        getLoadable\n    ]);\n    const source = useRecoilMutableSource$1();\n    if (source == null) {\n        throw Recoil_err(\"Recoil hooks must be used in components contained within a <RecoilRoot> component.\");\n    }\n    const loadable = useMutableSource$1(source, getLoadableWithTesting, subscribe);\n    const prevLoadableRef = useRef$4(loadable);\n    useEffect$3(()=>{\n        prevLoadableRef.current = loadable;\n    });\n    return loadable;\n}\n_s12(useRecoilValueLoadable_MUTABLE_SOURCE, \"OhmUZWiKroEiSad2hu8B5ek3zZA=\", false, function() {\n    return [\n        useStoreRef$2,\n        useCallback$1,\n        useCallback$1,\n        useCallback$1,\n        useRecoilMutableSource$1,\n        useMutableSource$1,\n        useRef$4,\n        useEffect$3\n    ];\n});\nfunction useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue) {\n    _s13();\n    const storeRef = useStoreRef$2();\n    const componentName = Recoil_useComponentName(); // Accessors to get the current state\n    const getLoadable = useCallback$1(()=>{\n        var _storeState$nextTree4;\n        if (true) {\n            recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n        }\n        const store = storeRef.current;\n        const storeState = store.getState();\n        const treeState = reactMode$3().early ? (_storeState$nextTree4 = storeState.nextTree) !== null && _storeState$nextTree4 !== void 0 ? _storeState$nextTree4 : storeState.currentTree : storeState.currentTree;\n        return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n    }, [\n        storeRef,\n        recoilValue\n    ]);\n    const getState = useCallback$1(()=>({\n            loadable: getLoadable(),\n            key: recoilValue.key\n        }), [\n        getLoadable,\n        recoilValue.key\n    ]); // Memoize state snapshots\n    const updateState = useCallback$1((prevState)=>{\n        const nextState = getState();\n        return prevState.loadable.is(nextState.loadable) && prevState.key === nextState.key ? prevState : nextState;\n    }, [\n        getState\n    ]); // Subscribe to Recoil state changes\n    useEffect$3(()=>{\n        const subscription = subscribeToRecoilValue$1(storeRef.current, recoilValue, (_state)=>{\n            setState(updateState);\n        }, componentName); // Update state in case we are using a different key\n        setState(updateState);\n        return subscription.release;\n    }, [\n        componentName,\n        recoilValue,\n        storeRef,\n        updateState\n    ]); // Get the current state\n    const [state, setState] = useState$1(getState); // If we changed keys, then return the state for the new key.\n    // This is important in case the old key would cause the component to suspend.\n    // We don't have to set the new state here since the subscribing effect above\n    // will do that.\n    return state.key !== recoilValue.key ? getState().loadable : state.loadable;\n}\n_s13(useRecoilValueLoadable_TRANSITION_SUPPORT, \"6OBAu30xCV25g/ie0rxhGJeZsl4=\", false, function() {\n    return [\n        useStoreRef$2,\n        useCallback$1,\n        useCallback$1,\n        useCallback$1,\n        useEffect$3,\n        useState$1\n    ];\n});\nfunction useRecoilValueLoadable_LEGACY(recoilValue) {\n    _s14();\n    const storeRef = useStoreRef$2(); // eslint-disable-next-line fb-www/react-no-unused-state-hook\n    const [, forceUpdate] = useState$1([]);\n    const componentName = Recoil_useComponentName();\n    const getLoadable = useCallback$1(()=>{\n        var _storeState$nextTree5;\n        if (true) {\n            recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n        }\n        const store = storeRef.current;\n        const storeState = store.getState();\n        const treeState = reactMode$3().early ? (_storeState$nextTree5 = storeState.nextTree) !== null && _storeState$nextTree5 !== void 0 ? _storeState$nextTree5 : storeState.currentTree : storeState.currentTree;\n        return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n    }, [\n        storeRef,\n        recoilValue\n    ]);\n    const loadable = getLoadable();\n    const prevLoadableRef = useRef$4(loadable);\n    useEffect$3(()=>{\n        prevLoadableRef.current = loadable;\n    });\n    useEffect$3(()=>{\n        const store = storeRef.current;\n        const storeState = store.getState();\n        const subscription = subscribeToRecoilValue$1(store, recoilValue, (_state)=>{\n            var _prevLoadableRef$curr;\n            if (!Recoil_gkx(\"recoil_suppress_rerender_in_callback\")) {\n                return forceUpdate([]);\n            }\n            const newLoadable = getLoadable();\n            if (!((_prevLoadableRef$curr = prevLoadableRef.current) !== null && _prevLoadableRef$curr !== void 0 && _prevLoadableRef$curr.is(newLoadable))) {\n                // $FlowFixMe[incompatible-call]\n                forceUpdate(newLoadable);\n            }\n            prevLoadableRef.current = newLoadable;\n        }, componentName);\n        /**\n     * Since we're subscribing in an effect we need to update to the latest\n     * value of the atom since it may have changed since we rendered. We can\n     * go ahead and do that now, unless we're in the middle of a batch --\n     * in which case we should do it at the end of the batch, due to the\n     * following edge case: Suppose an atom is updated in another useEffect\n     * of this same component. Then the following sequence of events occur:\n     * 1. Atom is updated and subs fired (but we may not be subscribed\n     *    yet depending on order of effects, so we miss this) Updated value\n     *    is now in nextTree, but not currentTree.\n     * 2. This effect happens. We subscribe and update.\n     * 3. From the update we re-render and read currentTree, with old value.\n     * 4. Batcher's effect sets currentTree to nextTree.\n     * In this sequence we miss the update. To avoid that, add the update\n     * to queuedComponentCallback if a batch is in progress.\n     */ if (storeState.nextTree) {\n            store.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{\n                // $FlowFixMe[incompatible-type]\n                prevLoadableRef.current = null;\n                forceUpdate([]);\n            });\n        } else {\n            var _prevLoadableRef$curr2;\n            if (!Recoil_gkx(\"recoil_suppress_rerender_in_callback\")) {\n                return forceUpdate([]);\n            }\n            const newLoadable = getLoadable();\n            if (!((_prevLoadableRef$curr2 = prevLoadableRef.current) !== null && _prevLoadableRef$curr2 !== void 0 && _prevLoadableRef$curr2.is(newLoadable))) {\n                // $FlowFixMe[incompatible-call]\n                forceUpdate(newLoadable);\n            }\n            prevLoadableRef.current = newLoadable;\n        }\n        return subscription.release;\n    }, [\n        componentName,\n        getLoadable,\n        recoilValue,\n        storeRef\n    ]);\n    return loadable;\n}\n_s14(useRecoilValueLoadable_LEGACY, \"h1u4jXAsOHm5I5NPI8Z0kUxPPBE=\", false, function() {\n    return [\n        useStoreRef$2,\n        useState$1,\n        useCallback$1,\n        useRef$4,\n        useEffect$3,\n        useEffect$3\n    ];\n});\n/**\n  Like useRecoilValue(), but either returns the value if available or\n  just undefined if not available for any reason, such as pending or error.\n*/ function useRecoilValueLoadable(recoilValue) {\n    if (true) {\n        validateRecoilValue(recoilValue, \"useRecoilValueLoadable\");\n    }\n    if (Recoil_gkx(\"recoil_memory_managament_2020\")) {\n        // eslint-disable-next-line fb-www/react-hooks\n        Recoil_useRetain(recoilValue);\n    }\n    return ({\n        TRANSITION_SUPPORT: useRecoilValueLoadable_TRANSITION_SUPPORT,\n        // Recoil will attemp to detect if `useSyncExternalStore()` is supported with\n        // `reactMode()` before calling it.  However, sometimes the host React\n        // environment supports it but uses additional React renderers (such as with\n        // `react-three-fiber`) which do not.  While this is technically a user issue\n        // by using a renderer with React 18+ that doesn't fully support React 18 we\n        // don't want to break users if it can be avoided. As the current renderer can\n        // change at runtime, we need to dynamically check and fallback if necessary.\n        SYNC_EXTERNAL_STORE: currentRendererSupportsUseSyncExternalStore$1() ? useRecoilValueLoadable_SYNC_EXTERNAL_STORE : useRecoilValueLoadable_TRANSITION_SUPPORT,\n        MUTABLE_SOURCE: useRecoilValueLoadable_MUTABLE_SOURCE,\n        LEGACY: useRecoilValueLoadable_LEGACY\n    })[reactMode$3().mode](recoilValue);\n}\n/**\n  Returns the value represented by the RecoilValue.\n  If the value is pending, it will throw a Promise to suspend the component,\n  if the value is an error it will throw it for the nearest React error boundary.\n  This will also subscribe the component for any updates in the value.\n  */ function useRecoilValue(recoilValue) {\n    _s15();\n    if (true) {\n        validateRecoilValue(recoilValue, \"useRecoilValue\");\n    }\n    const storeRef = useStoreRef$2();\n    const loadable = useRecoilValueLoadable(recoilValue);\n    return handleLoadable(loadable, recoilValue, storeRef);\n}\n_s15(useRecoilValue, \"gPJzoTxaOHcu42Q26alonm1jOcw=\", false, function() {\n    return [\n        useStoreRef$2,\n        useRecoilValueLoadable\n    ];\n});\n/**\n  Returns a function that allows the value of a RecoilState to be updated, but does\n  not subscribe the component to changes to that RecoilState.\n*/ function useSetRecoilState(recoilState) {\n    _s16();\n    if (true) {\n        validateRecoilValue(recoilState, \"useSetRecoilState\");\n    }\n    const storeRef = useStoreRef$2();\n    return useCallback$1((newValueOrUpdater)=>{\n        setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);\n    }, [\n        storeRef,\n        recoilState\n    ]);\n}\n_s16(useSetRecoilState, \"ODzo54Xgf96ah+FaQlIOi5w5BRk=\", false, function() {\n    return [\n        useStoreRef$2,\n        useCallback$1\n    ];\n});\n/**\n  Returns a function that will reset the value of a RecoilState to its default\n*/ function useResetRecoilState(recoilState) {\n    _s17();\n    if (true) {\n        validateRecoilValue(recoilState, \"useResetRecoilState\");\n    }\n    const storeRef = useStoreRef$2();\n    return useCallback$1(()=>{\n        setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);\n    }, [\n        storeRef,\n        recoilState\n    ]);\n}\n_s17(useResetRecoilState, \"ODzo54Xgf96ah+FaQlIOi5w5BRk=\", false, function() {\n    return [\n        useStoreRef$2,\n        useCallback$1\n    ];\n});\n/**\n  Equivalent to useState(). Allows the value of the RecoilState to be read and written.\n  Subsequent updates to the RecoilState will cause the component to re-render. If the\n  RecoilState is pending, this will suspend the component and initiate the\n  retrieval of the value. If evaluating the RecoilState resulted in an error, this will\n  throw the error so that the nearest React error boundary can catch it.\n*/ function useRecoilState(recoilState) {\n    _s18();\n    if (true) {\n        validateRecoilValue(recoilState, \"useRecoilState\");\n    }\n    return [\n        useRecoilValue(recoilState),\n        useSetRecoilState(recoilState)\n    ];\n}\n_s18(useRecoilState, \"msEl7ALZc52vkqN6X20sfA7eHpY=\", false, function() {\n    return [\n        useRecoilValue,\n        useSetRecoilState\n    ];\n});\n/**\n  Like useRecoilState(), but does not cause Suspense or React error handling. Returns\n  an object that indicates whether the RecoilState is available, pending, or\n  unavailable due to an error.\n*/ function useRecoilStateLoadable(recoilState) {\n    _s19();\n    if (true) {\n        validateRecoilValue(recoilState, \"useRecoilStateLoadable\");\n    }\n    return [\n        useRecoilValueLoadable(recoilState),\n        useSetRecoilState(recoilState)\n    ];\n}\n_s19(useRecoilStateLoadable, \"PDFziEpi0LwwYh1DiWL3VJrLfjI=\", false, function() {\n    return [\n        useRecoilValueLoadable,\n        useSetRecoilState\n    ];\n});\nfunction useSetUnvalidatedAtomValues() {\n    _s20();\n    const storeRef = useStoreRef$2();\n    return function(values) {\n        let transactionMetadata = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        batchUpdates$2(()=>{\n            storeRef.current.addTransactionMetadata(transactionMetadata);\n            values.forEach((value, key)=>setUnvalidatedRecoilValue$2(storeRef.current, new AbstractRecoilValue$3(key), value));\n        });\n    };\n}\n_s20(useSetUnvalidatedAtomValues, \"e+u6yYk4FB213A51nMg7OOealbM=\", false, function() {\n    return [\n        useStoreRef$2\n    ];\n});\n/**\n * Experimental variants of hooks with support for useTransition()\n */ function useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {\n    _s21();\n    if (true) {\n        validateRecoilValue(recoilValue, \"useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE\");\n        if (!reactMode$3().early) {\n            Recoil_recoverableViolation(\"Attepmt to use a hook with UNSTABLE_TRANSITION_SUPPORT in a rendering mode incompatible with concurrent rendering.  Try enabling the recoil_sync_external_store or recoil_transition_support GKs.\");\n        }\n    }\n    if (Recoil_gkx(\"recoil_memory_managament_2020\")) {\n        // eslint-disable-next-line fb-www/react-hooks\n        Recoil_useRetain(recoilValue);\n    }\n    return useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue);\n}\n_s21(useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE, \"s6zSXfz3Ez2wPqRpcNyDQ5q2T0Y=\", false, function() {\n    return [\n        useRecoilValueLoadable_TRANSITION_SUPPORT\n    ];\n});\nfunction useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {\n    _s22();\n    if (true) {\n        validateRecoilValue(recoilValue, \"useRecoilValue_TRANSITION_SUPPORT_UNSTABLE\");\n    }\n    const storeRef = useStoreRef$2();\n    const loadable = useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue);\n    return handleLoadable(loadable, recoilValue, storeRef);\n}\n_s22(useRecoilValue_TRANSITION_SUPPORT_UNSTABLE, \"+tkGdNIuUFExtPr7VDs0W62Hj3s=\", false, function() {\n    return [\n        useStoreRef$2,\n        useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE\n    ];\n});\nfunction useRecoilState_TRANSITION_SUPPORT_UNSTABLE(recoilState) {\n    _s23();\n    if (true) {\n        validateRecoilValue(recoilState, \"useRecoilState_TRANSITION_SUPPORT_UNSTABLE\");\n    }\n    return [\n        useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilState),\n        useSetRecoilState(recoilState)\n    ];\n}\n_s23(useRecoilState_TRANSITION_SUPPORT_UNSTABLE, \"Tpgu26fEAAo64dMksKt7e7OBXu0=\", false, function() {\n    return [\n        useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,\n        useSetRecoilState\n    ];\n});\nvar Recoil_Hooks = {\n    recoilComponentGetRecoilValueCount_FOR_TESTING,\n    useRecoilInterface: useRecoilInterface_DEPRECATED,\n    useRecoilState,\n    useRecoilStateLoadable,\n    useRecoilValue,\n    useRecoilValueLoadable,\n    useResetRecoilState,\n    useSetRecoilState,\n    useSetUnvalidatedAtomValues,\n    useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,\n    useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,\n    useRecoilState_TRANSITION_SUPPORT_UNSTABLE\n};\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * Returns a map containing all of the keys + values from the original map where\n * the given callback returned true.\n */ function filterMap(map, callback) {\n    const result = new Map();\n    for (const [key, value] of map){\n        if (callback(value, key)) {\n            result.set(key, value);\n        }\n    }\n    return result;\n}\nvar Recoil_filterMap = filterMap;\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * Returns a set containing all of the values from the original set where\n * the given callback returned true.\n */ function filterSet(set, callback) {\n    const result = new Set();\n    for (const value of set){\n        if (callback(value)) {\n            result.add(value);\n        }\n    }\n    return result;\n}\nvar Recoil_filterSet = filterSet;\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ function mergeMaps() {\n    for(var _len = arguments.length, maps = new Array(_len), _key = 0; _key < _len; _key++){\n        maps[_key] = arguments[_key];\n    }\n    const result = new Map();\n    for(let i = 0; i < maps.length; i++){\n        const iterator = maps[i].keys();\n        let nextKey;\n        while(!(nextKey = iterator.next()).done){\n            // $FlowIssue[incompatible-call] - map/iterator knows nothing about flow types\n            result.set(nextKey.value, maps[i].get(nextKey.value));\n        }\n    }\n    return result;\n}\nvar Recoil_mergeMaps = mergeMaps;\nconst { batchUpdates: batchUpdates$3 } = Recoil_Batching;\nconst { DEFAULT_VALUE: DEFAULT_VALUE$3, getNode: getNode$4, nodes: nodes$1 } = Recoil_Node;\nconst { useStoreRef: useStoreRef$3 } = Recoil_RecoilRoot;\nconst { AbstractRecoilValue: AbstractRecoilValue$4, setRecoilValueLoadable: setRecoilValueLoadable$1 } = Recoil_RecoilValueInterface;\nconst { SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$2 } = Recoil_Retention;\nconst { cloneSnapshot: cloneSnapshot$1 } = Recoil_Snapshot$1;\nconst { useCallback: useCallback$2, useEffect: useEffect$4, useRef: useRef$5, useState: useState$2 } = (react__WEBPACK_IMPORTED_MODULE_0___default());\nconst { isSSR: isSSR$4 } = Recoil_Environment;\nfunction useTransactionSubscription(callback) {\n    _s24();\n    const storeRef = useStoreRef$3();\n    useEffect$4(()=>{\n        const sub = storeRef.current.subscribeToTransactions(callback);\n        return sub.release;\n    }, [\n        callback,\n        storeRef\n    ]);\n}\n_s24(useTransactionSubscription, \"CDTzWCbrdtpsnTMd+K6uNwqEY6s=\", false, function() {\n    return [\n        useStoreRef$3,\n        useEffect$4\n    ];\n});\nfunction externallyVisibleAtomValuesInState(state) {\n    const atomValues = state.atomValues.toMap();\n    const persistedAtomContentsValues = Recoil_mapMap(Recoil_filterMap(atomValues, (v, k)=>{\n        const node = getNode$4(k);\n        const persistence = node.persistence_UNSTABLE;\n        return persistence != null && persistence.type !== \"none\" && v.state === \"hasValue\";\n    }), (v)=>v.contents); // Merge in nonvalidated atoms; we may not have defs for them but they will\n    // all have persistence on or they wouldn't be there in the first place.\n    return Recoil_mergeMaps(state.nonvalidatedAtoms.toMap(), persistedAtomContentsValues);\n}\n/**\n  Calls the given callback after any atoms have been modified and the consequent\n  component re-renders have been committed. This is intended for persisting\n  the values of the atoms to storage. The stored values can then be restored\n  using the useSetUnvalidatedAtomValues hook.\n\n  The callback receives the following info:\n\n  atomValues: The current value of every atom that is both persistable (persistence\n              type not set to 'none') and whose value is available (not in an\n              error or loading state).\n\n  previousAtomValues: The value of every persistable and available atom before\n               the transaction began.\n\n  atomInfo: A map containing the persistence settings for each atom. Every key\n            that exists in atomValues will also exist in atomInfo.\n\n  modifiedAtoms: The set of atoms that were written to during the transaction.\n\n  transactionMetadata: Arbitrary information that was added via the\n          useSetUnvalidatedAtomValues hook. Useful for ignoring the useSetUnvalidatedAtomValues\n          transaction, to avoid loops.\n*/ function useTransactionObservation_DEPRECATED(callback) {\n    _s25();\n    useTransactionSubscription(useCallback$2((store)=>{\n        let previousTree = store.getState().previousTree;\n        const currentTree = store.getState().currentTree;\n        if (!previousTree) {\n            Recoil_recoverableViolation(\"Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil\");\n            previousTree = store.getState().currentTree; // attempt to trundle on\n        }\n        const atomValues = externallyVisibleAtomValuesInState(currentTree);\n        const previousAtomValues = externallyVisibleAtomValuesInState(previousTree);\n        const atomInfo = Recoil_mapMap(nodes$1, (node)=>{\n            var _node$persistence_UNS, _node$persistence_UNS2, _node$persistence_UNS3, _node$persistence_UNS4;\n            return {\n                persistence_UNSTABLE: {\n                    type: (_node$persistence_UNS = (_node$persistence_UNS2 = node.persistence_UNSTABLE) === null || _node$persistence_UNS2 === void 0 ? void 0 : _node$persistence_UNS2.type) !== null && _node$persistence_UNS !== void 0 ? _node$persistence_UNS : \"none\",\n                    backButton: (_node$persistence_UNS3 = (_node$persistence_UNS4 = node.persistence_UNSTABLE) === null || _node$persistence_UNS4 === void 0 ? void 0 : _node$persistence_UNS4.backButton) !== null && _node$persistence_UNS3 !== void 0 ? _node$persistence_UNS3 : false\n                }\n            };\n        }); // Filter on existance in atomValues so that externally-visible rules\n        // are also applied to modified atoms (specifically exclude selectors):\n        const modifiedAtoms = Recoil_filterSet(currentTree.dirtyAtoms, (k)=>atomValues.has(k) || previousAtomValues.has(k));\n        callback({\n            atomValues,\n            previousAtomValues,\n            atomInfo,\n            modifiedAtoms,\n            transactionMetadata: {\n                ...currentTree.transactionMetadata\n            }\n        });\n    }, [\n        callback\n    ]));\n}\n_s25(useTransactionObservation_DEPRECATED, \"QoqPp7uYaRLhZAN5EOK+tmIR6RE=\", false, function() {\n    return [\n        useTransactionSubscription\n    ];\n});\nfunction useRecoilTransactionObserver(callback) {\n    _s26();\n    useTransactionSubscription(useCallback$2((store)=>{\n        const snapshot = cloneSnapshot$1(store, \"latest\");\n        const previousSnapshot = cloneSnapshot$1(store, \"previous\");\n        callback({\n            snapshot,\n            previousSnapshot\n        });\n    }, [\n        callback\n    ]));\n} // Return a snapshot of the current state and subscribe to all state changes\n_s26(useRecoilTransactionObserver, \"QoqPp7uYaRLhZAN5EOK+tmIR6RE=\", false, function() {\n    return [\n        useTransactionSubscription\n    ];\n});\nfunction useRecoilSnapshot() {\n    _s27();\n    const storeRef = useStoreRef$3();\n    const [snapshot, setSnapshot] = useState$2(()=>cloneSnapshot$1(storeRef.current));\n    const previousSnapshot = Recoil_usePrevious(snapshot);\n    const timeoutID = useRef$5();\n    const releaseRef = useRef$5();\n    useTransactionSubscription(useCallback$2((store)=>setSnapshot(cloneSnapshot$1(store)), [])); // Retain snapshot for duration component is mounted\n    useEffect$4(()=>{\n        const release = snapshot.retain(); // Release the retain from the rendering call\n        if (timeoutID.current && !isSSR$4) {\n            var _releaseRef$current;\n            window.clearTimeout(timeoutID.current);\n            timeoutID.current = null;\n            (_releaseRef$current = releaseRef.current) === null || _releaseRef$current === void 0 ? void 0 : _releaseRef$current.call(releaseRef);\n            releaseRef.current = null;\n        }\n        return ()=>{\n            // Defer the release.  If \"Fast Refresh\"\" is used then the component may\n            // re-render with the same state.  The previous cleanup will then run and\n            // then the new effect will run. We don't want the snapshot to be released\n            // by that cleanup before the new effect has a chance to retain it again.\n            // Use timeout of 10 to workaround Firefox issue: https://github.com/facebookexperimental/Recoil/issues/1936\n            window.setTimeout(release, 10);\n        };\n    }, [\n        snapshot\n    ]); // Retain snapshot until above effect is run.\n    // Release after a threshold in case component is suspended.\n    if (previousSnapshot !== snapshot && !isSSR$4) {\n        // Release the previous snapshot\n        if (timeoutID.current) {\n            var _releaseRef$current2;\n            window.clearTimeout(timeoutID.current);\n            timeoutID.current = null;\n            (_releaseRef$current2 = releaseRef.current) === null || _releaseRef$current2 === void 0 ? void 0 : _releaseRef$current2.call(releaseRef);\n            releaseRef.current = null;\n        }\n        releaseRef.current = snapshot.retain();\n        timeoutID.current = window.setTimeout(()=>{\n            var _releaseRef$current3;\n            timeoutID.current = null;\n            (_releaseRef$current3 = releaseRef.current) === null || _releaseRef$current3 === void 0 ? void 0 : _releaseRef$current3.call(releaseRef);\n            releaseRef.current = null;\n        }, SUSPENSE_TIMEOUT_MS$2);\n    }\n    return snapshot;\n}\n_s27(useRecoilSnapshot, \"x1twWOzA2SQLTFWWY7z5dwahJjQ=\", false, function() {\n    return [\n        useStoreRef$3,\n        useState$2,\n        useRef$5,\n        useRef$5,\n        useTransactionSubscription,\n        useEffect$4\n    ];\n});\nfunction gotoSnapshot(store, snapshot) {\n    var _storeState$nextTree;\n    const storeState = store.getState();\n    const prev = (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree;\n    const next = snapshot.getStore_INTERNAL().getState().currentTree;\n    batchUpdates$3(()=>{\n        const keysToUpdate = new Set();\n        for (const keys of [\n            prev.atomValues.keys(),\n            next.atomValues.keys()\n        ]){\n            for (const key of keys){\n                var _prev$atomValues$get, _next$atomValues$get;\n                if (((_prev$atomValues$get = prev.atomValues.get(key)) === null || _prev$atomValues$get === void 0 ? void 0 : _prev$atomValues$get.contents) !== ((_next$atomValues$get = next.atomValues.get(key)) === null || _next$atomValues$get === void 0 ? void 0 : _next$atomValues$get.contents) && getNode$4(key).shouldRestoreFromSnapshots) {\n                    keysToUpdate.add(key);\n                }\n            }\n        }\n        keysToUpdate.forEach((key)=>{\n            setRecoilValueLoadable$1(store, new AbstractRecoilValue$4(key), next.atomValues.has(key) ? Recoil_nullthrows(next.atomValues.get(key)) : DEFAULT_VALUE$3);\n        });\n        store.replaceState((state)=>({\n                ...state,\n                stateID: snapshot.getID()\n            }));\n    });\n}\nfunction useGotoRecoilSnapshot() {\n    _s28();\n    const storeRef = useStoreRef$3();\n    return useCallback$2((snapshot)=>gotoSnapshot(storeRef.current, snapshot), [\n        storeRef\n    ]);\n}\n_s28(useGotoRecoilSnapshot, \"tTPJbbAis+TO3OkHPUmPvHdKJTE=\", false, function() {\n    return [\n        useStoreRef$3,\n        useCallback$2\n    ];\n});\nvar Recoil_SnapshotHooks = {\n    useRecoilSnapshot,\n    gotoSnapshot,\n    useGotoRecoilSnapshot,\n    useRecoilTransactionObserver,\n    useTransactionObservation_DEPRECATED,\n    useTransactionSubscription_DEPRECATED: useTransactionSubscription\n};\nconst { peekNodeInfo: peekNodeInfo$2 } = Recoil_FunctionalCore;\nconst { useStoreRef: useStoreRef$4 } = Recoil_RecoilRoot;\nfunction useGetRecoilValueInfo() {\n    _s29();\n    const storeRef = useStoreRef$4(); // $FlowFixMe[incompatible-return]\n    return (param)=>{\n        let { key } = param;\n        return peekNodeInfo$2(storeRef.current, storeRef.current.getState().currentTree, key);\n    };\n}\n_s29(useGetRecoilValueInfo, \"i82/IJ2wJWj4h641TXd94KH9DeI=\", false, function() {\n    return [\n        useStoreRef$4\n    ];\n});\nvar Recoil_useGetRecoilValueInfo = useGetRecoilValueInfo;\nconst { reactMode: reactMode$4 } = Recoil_ReactMode;\nconst { RecoilRoot: RecoilRoot$1, useStoreRef: useStoreRef$5 } = Recoil_RecoilRoot;\nconst { useMemo: useMemo$2 } = (react__WEBPACK_IMPORTED_MODULE_0___default());\nfunction useRecoilBridgeAcrossReactRoots() {\n    _s30();\n    // The test fails when using useMutableSource(), but only if act() is used\n    // for the nested root.  So, this may only be a testing environment issue.\n    if (reactMode$4().mode === \"MUTABLE_SOURCE\") {\n        // eslint-disable-next-line fb-www/no-console\n        console.warn(\"Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.\");\n    }\n    const store = useStoreRef$5().current;\n    return useMemo$2(()=>{\n        // eslint-disable-next-line no-shadow\n        function RecoilBridge(param) {\n            let { children } = param;\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RecoilRoot$1, {\n                store_INTERNAL: store\n            }, children);\n        }\n        return RecoilBridge;\n    }, [\n        store\n    ]);\n}\n_s30(useRecoilBridgeAcrossReactRoots, \"zDlwjpEEA/O/fLJ/WfnylytVr98=\", false, function() {\n    return [\n        useStoreRef$5,\n        useMemo$2\n    ];\n});\nvar Recoil_useRecoilBridgeAcrossReactRoots = useRecoilBridgeAcrossReactRoots;\nconst { loadableWithValue: loadableWithValue$1 } = Recoil_Loadable$1;\nconst { initializeNode: initializeNode$3 } = Recoil_FunctionalCore;\nconst { DEFAULT_VALUE: DEFAULT_VALUE$4, getNode: getNode$5 } = Recoil_Node;\nconst { copyTreeState: copyTreeState$1, getRecoilValueAsLoadable: getRecoilValueAsLoadable$3, invalidateDownstreams: invalidateDownstreams$1, writeLoadableToTreeState: writeLoadableToTreeState$1 } = Recoil_RecoilValueInterface;\nfunction isAtom(recoilValue) {\n    return getNode$5(recoilValue.key).nodeType === \"atom\";\n}\nclass TransactionInterfaceImpl {\n    // eslint-disable-next-line fb-www/extra-arrow-initializer\n    newTreeState_INTERNAL() {\n        if (this._changes.size === 0) {\n            return this._treeState;\n        }\n        const newState = copyTreeState$1(this._treeState);\n        for (const [k, v] of this._changes){\n            writeLoadableToTreeState$1(newState, k, loadableWithValue$1(v));\n        }\n        invalidateDownstreams$1(this._store, newState);\n        return newState;\n    }\n    constructor(store, treeState){\n        _defineProperty(this, \"_store\", void 0);\n        _defineProperty(this, \"_treeState\", void 0);\n        _defineProperty(this, \"_changes\", void 0);\n        _defineProperty(this, \"get\", (recoilValue)=>{\n            if (this._changes.has(recoilValue.key)) {\n                // $FlowIssue[incompatible-return]\n                return this._changes.get(recoilValue.key);\n            }\n            if (!isAtom(recoilValue)) {\n                throw Recoil_err(\"Reading selectors within atomicUpdate is not supported\");\n            }\n            const loadable = getRecoilValueAsLoadable$3(this._store, recoilValue, this._treeState);\n            if (loadable.state === \"hasValue\") {\n                return loadable.contents;\n            } else if (loadable.state === \"hasError\") {\n                throw loadable.contents;\n            } else {\n                throw Recoil_err(\"Expected Recoil atom \".concat(recoilValue.key, \" to have a value, but it is in a loading state.\"));\n            }\n        });\n        _defineProperty(this, \"set\", (recoilState, valueOrUpdater)=>{\n            if (!isAtom(recoilState)) {\n                throw Recoil_err(\"Setting selectors within atomicUpdate is not supported\");\n            }\n            if (typeof valueOrUpdater === \"function\") {\n                const current = this.get(recoilState);\n                this._changes.set(recoilState.key, valueOrUpdater(current)); // flowlint-line unclear-type:off\n            } else {\n                // Initialize atom and run effects if not initialized yet\n                initializeNode$3(this._store, recoilState.key, \"set\");\n                this._changes.set(recoilState.key, valueOrUpdater);\n            }\n        });\n        _defineProperty(this, \"reset\", (recoilState)=>{\n            this.set(recoilState, DEFAULT_VALUE$4);\n        });\n        this._store = store;\n        this._treeState = treeState;\n        this._changes = new Map();\n    }\n}\nfunction atomicUpdater(store) {\n    return (fn)=>{\n        store.replaceState((treeState)=>{\n            const changeset = new TransactionInterfaceImpl(store, treeState);\n            fn(changeset);\n            return changeset.newTreeState_INTERNAL();\n        });\n    };\n}\nvar Recoil_AtomicUpdates = {\n    atomicUpdater\n};\nvar Recoil_AtomicUpdates_1 = Recoil_AtomicUpdates.atomicUpdater;\nvar Recoil_AtomicUpdates$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    atomicUpdater: Recoil_AtomicUpdates_1\n});\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ function invariant(condition, message) {\n    if (!condition) {\n        throw new Error(message);\n    }\n}\nvar invariant_1 = invariant;\n// @oss-only\nvar Recoil_invariant = invariant_1;\nconst { atomicUpdater: atomicUpdater$1 } = Recoil_AtomicUpdates$1;\nconst { batchUpdates: batchUpdates$4 } = Recoil_Batching;\nconst { DEFAULT_VALUE: DEFAULT_VALUE$5 } = Recoil_Node;\nconst { useStoreRef: useStoreRef$6 } = Recoil_RecoilRoot;\nconst { refreshRecoilValue: refreshRecoilValue$1, setRecoilValue: setRecoilValue$3 } = Recoil_RecoilValueInterface;\nconst { cloneSnapshot: cloneSnapshot$2 } = Recoil_Snapshot$1;\nconst { gotoSnapshot: gotoSnapshot$1 } = Recoil_SnapshotHooks;\nconst { useCallback: useCallback$3 } = (react__WEBPACK_IMPORTED_MODULE_0___default());\nclass Sentinel {\n}\nconst SENTINEL = new Sentinel();\nfunction recoilCallback(store, fn, args, extraInterface) {\n    let ret = SENTINEL;\n    let releaseSnapshot;\n    batchUpdates$4(()=>{\n        const errMsg = \"useRecoilCallback() expects a function that returns a function: \" + \"it accepts a function of the type (RecoilInterface) => (Args) => ReturnType \" + \"and returns a callback function (Args) => ReturnType, where RecoilInterface is \" + \"an object {snapshot, set, ...} and Args and ReturnType are the argument and return \" + \"types of the callback you want to create.  Please see the docs \" + \"at recoiljs.org for details.\";\n        if (typeof fn !== \"function\") {\n            throw Recoil_err(errMsg);\n        } // Clone the snapshot lazily to avoid overhead if the callback does not use it.\n        // Note that this means the snapshot may represent later state from when\n        // the callback was called if it first accesses the snapshot asynchronously.\n        const callbackInterface = Recoil_lazyProxy({\n            ...extraInterface !== null && extraInterface !== void 0 ? extraInterface : {},\n            // flowlint-line unclear-type:off\n            // $FlowFixMe[missing-local-annot]\n            set: (node, newValue)=>setRecoilValue$3(store, node, newValue),\n            // $FlowFixMe[missing-local-annot]\n            reset: (node)=>setRecoilValue$3(store, node, DEFAULT_VALUE$5),\n            // $FlowFixMe[missing-local-annot]\n            refresh: (node)=>refreshRecoilValue$1(store, node),\n            gotoSnapshot: (snapshot)=>gotoSnapshot$1(store, snapshot),\n            transact_UNSTABLE: (transaction)=>atomicUpdater$1(store)(transaction)\n        }, {\n            snapshot: ()=>{\n                const snapshot = cloneSnapshot$2(store);\n                releaseSnapshot = snapshot.retain();\n                return snapshot;\n            }\n        });\n        const callback = fn(callbackInterface);\n        if (typeof callback !== \"function\") {\n            throw Recoil_err(errMsg);\n        }\n        ret = callback(...args);\n    });\n    !!(ret instanceof Sentinel) ?  true ? Recoil_invariant(false, \"batchUpdates should return immediately\") : 0 : void 0;\n    if (Recoil_isPromise(ret)) {\n        ret = ret.finally(()=>{\n            var _releaseSnapshot;\n            (_releaseSnapshot = releaseSnapshot) === null || _releaseSnapshot === void 0 ? void 0 : _releaseSnapshot();\n        });\n    } else {\n        var _releaseSnapshot2;\n        (_releaseSnapshot2 = releaseSnapshot) === null || _releaseSnapshot2 === void 0 ? void 0 : _releaseSnapshot2();\n    }\n    return ret;\n}\nfunction useRecoilCallback(fn, deps) {\n    _s31();\n    const storeRef = useStoreRef$6();\n    return useCallback$3(function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return recoilCallback(storeRef.current, fn, args);\n    }, deps != null ? [\n        ...deps,\n        storeRef\n    ] : undefined // eslint-disable-line fb-www/react-hooks-deps\n    );\n}\n_s31(useRecoilCallback, \"/1NP+cImmnki+shaFBOuCRa8PJg=\", false, function() {\n    return [\n        useStoreRef$6,\n        useCallback$3\n    ];\n});\nvar Recoil_useRecoilCallback = {\n    recoilCallback,\n    useRecoilCallback\n};\nconst { useStoreRef: useStoreRef$7 } = Recoil_RecoilRoot;\nconst { refreshRecoilValue: refreshRecoilValue$2 } = Recoil_RecoilValueInterface;\nconst { useCallback: useCallback$4 } = (react__WEBPACK_IMPORTED_MODULE_0___default());\nfunction useRecoilRefresher(recoilValue) {\n    _s32();\n    const storeRef = useStoreRef$7();\n    return useCallback$4(()=>{\n        const store = storeRef.current;\n        refreshRecoilValue$2(store, recoilValue);\n    }, [\n        recoilValue,\n        storeRef\n    ]);\n}\n_s32(useRecoilRefresher, \"wn0+dsPvuPh1KxH2pc9AJzH4tLI=\", false, function() {\n    return [\n        useStoreRef$7,\n        useCallback$4\n    ];\n});\nvar Recoil_useRecoilRefresher = useRecoilRefresher;\nconst { atomicUpdater: atomicUpdater$2 } = Recoil_AtomicUpdates$1;\nconst { useStoreRef: useStoreRef$8 } = Recoil_RecoilRoot;\nconst { useMemo: useMemo$3 } = (react__WEBPACK_IMPORTED_MODULE_0___default());\nfunction useRecoilTransaction(fn, deps) {\n    _s33();\n    const storeRef = useStoreRef$8();\n    return useMemo$3(()=>function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            const atomicUpdate = atomicUpdater$2(storeRef.current);\n            atomicUpdate((transactionInterface)=>{\n                fn(transactionInterface)(...args);\n            });\n        }, deps != null ? [\n        ...deps,\n        storeRef\n    ] : undefined // eslint-disable-line fb-www/react-hooks-deps\n    );\n}\n_s33(useRecoilTransaction, \"o77TNcJyXZh0+PG3Dr6K7YKlO7s=\", false, function() {\n    return [\n        useStoreRef$8,\n        useMemo$3\n    ];\n});\nvar Recoil_useRecoilTransaction = useRecoilTransaction;\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ class WrappedValue {\n    constructor(value){\n        _defineProperty(this, \"value\", void 0);\n        this.value = value;\n    }\n}\nvar Recoil_Wrapper = {\n    WrappedValue\n};\nvar Recoil_Wrapper_1 = Recoil_Wrapper.WrappedValue;\nvar Recoil_Wrapper$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    WrappedValue: Recoil_Wrapper_1\n});\nconst { isFastRefreshEnabled: isFastRefreshEnabled$2 } = Recoil_ReactMode;\nclass ChangedPathError extends Error {\n}\nclass TreeCache {\n    size() {\n        return this._numLeafs;\n    }\n    root() {\n        return this._root;\n    }\n    get(getNodeValue, handlers) {\n        var _this$getLeafNode;\n        return (_this$getLeafNode = this.getLeafNode(getNodeValue, handlers)) === null || _this$getLeafNode === void 0 ? void 0 : _this$getLeafNode.value;\n    }\n    getLeafNode(getNodeValue, handlers) {\n        if (this._root == null) {\n            return undefined;\n        } // Iterate down the tree based on the current node values until we hit a leaf\n        // $FlowIssue[unclear-type]\n        let node = this._root;\n        while(node){\n            handlers === null || handlers === void 0 ? void 0 : handlers.onNodeVisit(node);\n            if (node.type === \"leaf\") {\n                this._onHit(node);\n                return node;\n            }\n            const nodeValue = this._mapNodeValue(getNodeValue(node.nodeKey));\n            node = node.branches.get(nodeValue);\n        }\n        return undefined;\n    }\n    set(route, value, handlers) {\n        const addLeaf = ()=>{\n            var _node2, _node3, _this$_root2, _handlers$onNodeVisit2;\n            // First, setup the branch nodes for the route:\n            // Iterate down the tree to find or add branch nodes following the route\n            let node;\n            let branchKey;\n            for (const [nodeKey, nodeValue] of route){\n                var _node, _handlers$onNodeVisit, _this$_root;\n                // If the previous root was a leaf, while we not have a get(), it means\n                // the selector has inconsistent values or implementation changed.\n                const root = this._root;\n                if ((root === null || root === void 0 ? void 0 : root.type) === \"leaf\") {\n                    throw this.invalidCacheError();\n                } // node now refers to the next node down in the tree\n                const parent = node; // $FlowFixMe[prop-missing]\n                // $FlowFixMe[incompatible-type]\n                node = parent ? parent.branches.get(branchKey) : root; // $FlowFixMe[prop-missing]\n                // $FlowFixMe[incompatible-type]\n                node = (_node = node) !== null && _node !== void 0 ? _node : {\n                    type: \"branch\",\n                    nodeKey,\n                    parent,\n                    branches: new Map(),\n                    branchKey\n                }; // If we found an existing node, confirm it has a consistent value\n                if (node.type !== \"branch\" || node.nodeKey !== nodeKey) {\n                    throw this.invalidCacheError();\n                } // Add the branch node to the tree\n                parent === null || parent === void 0 ? void 0 : parent.branches.set(branchKey, node);\n                handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit = handlers.onNodeVisit) === null || _handlers$onNodeVisit === void 0 ? void 0 : _handlers$onNodeVisit.call(handlers, node); // Prepare for next iteration and install root if it is new.\n                branchKey = this._mapNodeValue(nodeValue);\n                this._root = (_this$_root = this._root) !== null && _this$_root !== void 0 ? _this$_root : node;\n            } // Second, setup the leaf node:\n            // If there is an existing leaf for this route confirm it is consistent\n            const oldLeaf = node ? (_node2 = node) === null || _node2 === void 0 ? void 0 : _node2.branches.get(branchKey) : this._root;\n            if (oldLeaf != null && (oldLeaf.type !== \"leaf\" || oldLeaf.branchKey !== branchKey)) {\n                throw this.invalidCacheError();\n            } // Create a new or replacement leaf.\n            const leafNode = {\n                type: \"leaf\",\n                value,\n                parent: node,\n                branchKey\n            }; // Install the leaf and call handlers\n            (_node3 = node) === null || _node3 === void 0 ? void 0 : _node3.branches.set(branchKey, leafNode);\n            this._root = (_this$_root2 = this._root) !== null && _this$_root2 !== void 0 ? _this$_root2 : leafNode;\n            this._numLeafs++;\n            this._onSet(leafNode);\n            handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit2 = handlers.onNodeVisit) === null || _handlers$onNodeVisit2 === void 0 ? void 0 : _handlers$onNodeVisit2.call(handlers, leafNode);\n        };\n        try {\n            addLeaf();\n        } catch (error) {\n            // If the cache was stale or observed inconsistent values, such as with\n            // Fast Refresh, then clear it and rebuild with the new values.\n            if (error instanceof ChangedPathError) {\n                this.clear();\n                addLeaf();\n            } else {\n                throw error;\n            }\n        }\n    }\n    delete(leaf) {\n        const root = this.root();\n        if (!root) {\n            return false;\n        }\n        if (leaf === root) {\n            this._root = null;\n            this._numLeafs = 0;\n            return true;\n        } // Iterate up from the leaf deleteing it from it's parent's branches.\n        let node = leaf.parent;\n        let branchKey = leaf.branchKey;\n        while(node){\n            var _node4;\n            node.branches.delete(branchKey); // Stop iterating if we hit the root.\n            if (node === root) {\n                if (node.branches.size === 0) {\n                    this._root = null;\n                    this._numLeafs = 0;\n                } else {\n                    this._numLeafs--;\n                }\n                return true;\n            } // Stop iterating if there are other branches since we don't need to\n            // remove any more nodes.\n            if (node.branches.size > 0) {\n                break;\n            } // Iterate up to our parent\n            branchKey = (_node4 = node) === null || _node4 === void 0 ? void 0 : _node4.branchKey;\n            node = node.parent;\n        } // Confirm that the leaf we are deleting is actually attached to our tree\n        for(; node !== root; node = node.parent){\n            if (node == null) {\n                return false;\n            }\n        }\n        this._numLeafs--;\n        return true;\n    }\n    clear() {\n        this._numLeafs = 0;\n        this._root = null;\n    }\n    invalidCacheError() {\n        const CHANGED_PATH_ERROR_MESSAGE = isFastRefreshEnabled$2() ? \"Possible Fast Refresh module reload detected.  \" + \"This may also be caused by an selector returning inconsistent values. \" + \"Resetting cache.\" : \"Invalid cache values.  This happens when selectors do not return \" + \"consistent values for the same input dependency values.  That may also \" + \"be caused when using Fast Refresh to change a selector implementation.  \" + \"Resetting cache.\";\n        Recoil_recoverableViolation(CHANGED_PATH_ERROR_MESSAGE + (this._name != null ? \" - \".concat(this._name) : \"\"));\n        throw new ChangedPathError();\n    }\n    // $FlowIssue[unclear-type]\n    constructor(options){\n        var _options$onHit, _options$onSet, _options$mapNodeValue;\n        _defineProperty(this, \"_name\", void 0);\n        _defineProperty(this, \"_numLeafs\", void 0);\n        _defineProperty(this, \"_root\", void 0);\n        _defineProperty(this, \"_onHit\", void 0);\n        _defineProperty(this, \"_onSet\", void 0);\n        _defineProperty(this, \"_mapNodeValue\", void 0);\n        this._name = options === null || options === void 0 ? void 0 : options.name;\n        this._numLeafs = 0;\n        this._root = null;\n        this._onHit = (_options$onHit = options === null || options === void 0 ? void 0 : options.onHit) !== null && _options$onHit !== void 0 ? _options$onHit : ()=>{};\n        this._onSet = (_options$onSet = options === null || options === void 0 ? void 0 : options.onSet) !== null && _options$onSet !== void 0 ? _options$onSet : ()=>{};\n        this._mapNodeValue = (_options$mapNodeValue = options === null || options === void 0 ? void 0 : options.mapNodeValue) !== null && _options$mapNodeValue !== void 0 ? _options$mapNodeValue : (val)=>val;\n    }\n}\nvar Recoil_TreeCache = {\n    TreeCache\n};\nvar Recoil_TreeCache_1 = Recoil_TreeCache.TreeCache;\nvar Recoil_TreeCache$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    TreeCache: Recoil_TreeCache_1\n});\nclass LRUCache {\n    head() {\n        return this._head;\n    }\n    tail() {\n        return this._tail;\n    }\n    size() {\n        return this._size;\n    }\n    maxSize() {\n        return this._maxSize;\n    }\n    has(key) {\n        return this._map.has(this._keyMapper(key));\n    }\n    get(key) {\n        const mappedKey = this._keyMapper(key);\n        const node = this._map.get(mappedKey);\n        if (!node) {\n            return undefined;\n        }\n        this.set(key, node.value);\n        return node.value;\n    }\n    set(key, val) {\n        const mappedKey = this._keyMapper(key);\n        const existingNode = this._map.get(mappedKey);\n        if (existingNode) {\n            this.delete(key);\n        }\n        const head = this.head();\n        const node = {\n            key,\n            right: head,\n            left: null,\n            value: val\n        };\n        if (head) {\n            head.left = node;\n        } else {\n            this._tail = node;\n        }\n        this._map.set(mappedKey, node);\n        this._head = node;\n        this._size++;\n        this._maybeDeleteLRU();\n    }\n    _maybeDeleteLRU() {\n        if (this.size() > this.maxSize()) {\n            this.deleteLru();\n        }\n    }\n    deleteLru() {\n        const tail = this.tail();\n        if (tail) {\n            this.delete(tail.key);\n        }\n    }\n    delete(key) {\n        const mappedKey = this._keyMapper(key);\n        if (!this._size || !this._map.has(mappedKey)) {\n            return;\n        }\n        const node = Recoil_nullthrows(this._map.get(mappedKey));\n        const right = node.right;\n        const left = node.left;\n        if (right) {\n            right.left = node.left;\n        }\n        if (left) {\n            left.right = node.right;\n        }\n        if (node === this.head()) {\n            this._head = right;\n        }\n        if (node === this.tail()) {\n            this._tail = left;\n        }\n        this._map.delete(mappedKey);\n        this._size--;\n    }\n    clear() {\n        this._size = 0;\n        this._head = null;\n        this._tail = null;\n        this._map = new Map();\n    }\n    constructor(options){\n        var _options$mapKey;\n        _defineProperty(this, \"_maxSize\", void 0);\n        _defineProperty(this, \"_size\", void 0);\n        _defineProperty(this, \"_head\", void 0);\n        _defineProperty(this, \"_tail\", void 0);\n        _defineProperty(this, \"_map\", void 0);\n        _defineProperty(this, \"_keyMapper\", void 0);\n        this._maxSize = options.maxSize;\n        this._size = 0;\n        this._head = null;\n        this._tail = null;\n        this._map = new Map();\n        this._keyMapper = (_options$mapKey = options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : (v)=>v;\n    }\n}\nvar Recoil_LRUCache = {\n    LRUCache\n};\nvar Recoil_LRUCache_1 = Recoil_LRUCache.LRUCache;\nvar Recoil_LRUCache$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    LRUCache: Recoil_LRUCache_1\n});\nconst { LRUCache: LRUCache$1 } = Recoil_LRUCache$1;\nconst { TreeCache: TreeCache$1 } = Recoil_TreeCache$1;\nfunction treeCacheLRU(param) {\n    let { name, maxSize, mapNodeValue = (v)=>v } = param;\n    const lruCache = new LRUCache$1({\n        maxSize\n    });\n    const cache = new TreeCache$1({\n        name,\n        mapNodeValue,\n        onHit: (node)=>{\n            lruCache.set(node, true);\n        },\n        onSet: (node)=>{\n            const lruNode = lruCache.tail();\n            lruCache.set(node, true);\n            if (lruNode && cache.size() > maxSize) {\n                // $FlowFixMe[incompatible-call]\n                cache.delete(lruNode.key);\n            }\n        }\n    });\n    return cache;\n}\nvar Recoil_treeCacheLRU = treeCacheLRU;\nconst TIME_WARNING_THRESHOLD_MS = 15;\nfunction stringify(x, opt, key) {\n    // A optimization to avoid the more expensive JSON.stringify() for simple strings\n    // This may lose protection for u2028 and u2029, though.\n    if (typeof x === \"string\" && !x.includes('\"') && !x.includes(\"\\\\\")) {\n        return '\"'.concat(x, '\"');\n    } // Handle primitive types\n    switch(typeof x){\n        case \"undefined\":\n            return \"\";\n        // JSON.stringify(undefined) returns undefined, but we always want to return a string\n        case \"boolean\":\n            return x ? \"true\" : \"false\";\n        case \"number\":\n        case \"symbol\":\n            // case 'bigint': // BigInt is not supported in www\n            return String(x);\n        case \"string\":\n            // Add surrounding quotes and escape internal quotes\n            return JSON.stringify(x);\n        case \"function\":\n            if ((opt === null || opt === void 0 ? void 0 : opt.allowFunctions) !== true) {\n                throw Recoil_err(\"Attempt to serialize function in a Recoil cache key\");\n            }\n            return \"__FUNCTION(\".concat(x.name, \")__\");\n    }\n    if (x === null) {\n        return \"null\";\n    } // Fallback case for unknown types\n    if (typeof x !== \"object\") {\n        var _JSON$stringify;\n        return (_JSON$stringify = JSON.stringify(x)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : \"\";\n    } // Deal with all promises as equivalent for now.\n    if (Recoil_isPromise(x)) {\n        return \"__PROMISE__\";\n    } // Arrays handle recursive stringification\n    if (Array.isArray(x)) {\n        // $FlowFixMe[missing-local-annot]\n        return \"[\".concat(x.map((v, i)=>stringify(v, opt, i.toString())), \"]\");\n    } // If an object defines a toJSON() method, then use that to override the\n    // serialization.  This matches the behavior of JSON.stringify().\n    // Pass the key for compatibility.\n    // Immutable.js collections define this method to allow us to serialize them.\n    if (typeof x.toJSON === \"function\") {\n        // flowlint-next-line unclear-type: off\n        return stringify(x.toJSON(key), opt, key);\n    } // For built-in Maps, sort the keys in a stable order instead of the\n    // default insertion order.  Support non-string keys.\n    if (x instanceof Map) {\n        const obj = {};\n        for (const [k, v] of x){\n            // Stringify will escape any nested quotes\n            obj[typeof k === \"string\" ? k : stringify(k, opt)] = v;\n        }\n        return stringify(obj, opt, key);\n    } // For built-in Sets, sort the keys in a stable order instead of the\n    // default insertion order.\n    if (x instanceof Set) {\n        return stringify(Array.from(x).sort((a, b)=>stringify(a, opt).localeCompare(stringify(b, opt))), opt, key);\n    } // Anything else that is iterable serialize as an Array.\n    if (Symbol !== undefined && x[Symbol.iterator] != null && typeof x[Symbol.iterator] === \"function\") {\n        // flowlint-next-line unclear-type: off\n        return stringify(Array.from(x), opt, key);\n    } // For all other Objects, sort the keys in a stable order.\n    return \"{\".concat(Object.keys(x).filter((k)=>x[k] !== undefined).sort() // stringify the key to add quotes and escape any nested slashes or quotes.\n    .map((k)=>\"\".concat(stringify(k, opt), \":\").concat(stringify(x[k], opt, k))).join(\",\"), \"}\");\n} // Utility similar to JSON.stringify() except:\n// * Serialize built-in Sets as an Array\n// * Serialize built-in Maps as an Object.  Supports non-string keys.\n// * Serialize other iterables as arrays\n// * Sort the keys of Objects and Maps to have a stable order based on string conversion.\n//    This overrides their default insertion order.\n// * Still uses toJSON() of any object to override serialization\n// * Support Symbols (though don't guarantee uniqueness)\n// * We could support BigInt, but Flow doesn't seem to like it.\n// See Recoil_stableStringify-test.js for examples\nfunction stableStringify(x) {\n    let opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n        allowFunctions: false\n    };\n    if (true) {\n        if (true) {\n            const startTime = window.performance ? window.performance.now() : 0;\n            const str = stringify(x, opt);\n            const endTime = window.performance ? window.performance.now() : 0;\n            if (endTime - startTime > TIME_WARNING_THRESHOLD_MS) {\n                /* eslint-disable fb-www/no-console */ console.groupCollapsed(\"Recoil: Spent \".concat(endTime - startTime, \"ms computing a cache key\"));\n                console.warn(x, str);\n                console.groupEnd();\n            /* eslint-enable fb-www/no-console */ }\n            return str;\n        }\n    }\n    return stringify(x, opt);\n}\nvar Recoil_stableStringify = stableStringify;\nconst { TreeCache: TreeCache$2 } = Recoil_TreeCache$1;\nconst defaultPolicy = {\n    equality: \"reference\",\n    eviction: \"keep-all\",\n    maxSize: Infinity\n};\nfunction treeCacheFromPolicy() {\n    let { equality = defaultPolicy.equality, eviction = defaultPolicy.eviction, maxSize = defaultPolicy.maxSize } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultPolicy, name = arguments.length > 1 ? arguments[1] : void 0;\n    const valueMapper = getValueMapper(equality);\n    return getTreeCache(eviction, maxSize, valueMapper, name);\n}\nfunction getValueMapper(equality) {\n    switch(equality){\n        case \"reference\":\n            return (val)=>val;\n        case \"value\":\n            return (val)=>Recoil_stableStringify(val);\n    }\n    throw Recoil_err(\"Unrecognized equality policy \".concat(equality));\n}\nfunction getTreeCache(eviction, maxSize, mapNodeValue, name) {\n    switch(eviction){\n        case \"keep-all\":\n            return new TreeCache$2({\n                name,\n                mapNodeValue\n            });\n        case \"lru\":\n            return Recoil_treeCacheLRU({\n                name,\n                maxSize: Recoil_nullthrows(maxSize),\n                mapNodeValue\n            });\n        case \"most-recent\":\n            return Recoil_treeCacheLRU({\n                name,\n                maxSize: 1,\n                mapNodeValue\n            });\n    }\n    throw Recoil_err(\"Unrecognized eviction policy \".concat(eviction));\n}\nvar Recoil_treeCacheFromPolicy = treeCacheFromPolicy;\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ function isNode(object) {\n    var _ownerDocument, _doc$defaultView;\n    if (false) {}\n    const doc = object != null ? (_ownerDocument = object.ownerDocument) !== null && _ownerDocument !== void 0 ? _ownerDocument : object : document;\n    const defaultView = (_doc$defaultView = doc.defaultView) !== null && _doc$defaultView !== void 0 ? _doc$defaultView : window;\n    return !!(object != null && (typeof defaultView.Node === \"function\" ? object instanceof defaultView.Node : typeof object === \"object\" && typeof object.nodeType === \"number\" && typeof object.nodeName === \"string\"));\n}\nvar Recoil_isNode = isNode;\nconst { isReactNative: isReactNative$1, isWindow: isWindow$1 } = Recoil_Environment;\nfunction shouldNotBeFrozen(value) {\n    // Primitives and functions:\n    if (value === null || typeof value !== \"object\") {\n        return true;\n    } // React elements:\n    switch(typeof value.$$typeof){\n        case \"symbol\":\n            return true;\n        case \"number\":\n            return true;\n    } // Immutable structures:\n    if (value[\"@@__IMMUTABLE_ITERABLE__@@\"] != null || value[\"@@__IMMUTABLE_KEYED__@@\"] != null || value[\"@@__IMMUTABLE_INDEXED__@@\"] != null || value[\"@@__IMMUTABLE_ORDERED__@@\"] != null || value[\"@@__IMMUTABLE_RECORD__@@\"] != null) {\n        return true;\n    } // DOM nodes:\n    if (Recoil_isNode(value)) {\n        return true;\n    }\n    if (Recoil_isPromise(value)) {\n        return true;\n    }\n    if (value instanceof Error) {\n        return true;\n    }\n    if (ArrayBuffer.isView(value)) {\n        return true;\n    } // Some environments, just as Jest, don't work with the instanceof check\n    if (!isReactNative$1 && isWindow$1(value)) {\n        return true;\n    }\n    return false;\n} // Recursively freeze a value to enforce it is read-only.\n// This may also have minimal performance improvements for enumerating\n// objects (based on browser implementations, of course)\nfunction deepFreezeValue(value) {\n    if (typeof value !== \"object\" || shouldNotBeFrozen(value)) {\n        return;\n    }\n    Object.freeze(value); // Make all properties read-only\n    for(const key in value){\n        // $FlowIssue[method-unbinding] added when improving typing for this parameters\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\n            const prop = value[key]; // Prevent infinite recurssion for circular references.\n            if (typeof prop === \"object\" && prop != null && !Object.isFrozen(prop)) {\n                deepFreezeValue(prop);\n            }\n        }\n    }\n    Object.seal(value); // This also makes existing properties non-configurable.\n}\nvar Recoil_deepFreezeValue = deepFreezeValue;\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * This is a stub for some integration into FB internal stuff\n *\n * \n * @format\n * @oncall recoil\n */ function startPerfBlock(_id) {\n    return ()=>null;\n}\nvar Recoil_PerformanceTimings = {\n    startPerfBlock\n};\nconst { isLoadable: isLoadable$1, loadableWithError: loadableWithError$1, loadableWithPromise: loadableWithPromise$1, loadableWithValue: loadableWithValue$2 } = Recoil_Loadable$1;\nconst { WrappedValue: WrappedValue$1 } = Recoil_Wrapper$1;\nconst { getNodeLoadable: getNodeLoadable$2, peekNodeLoadable: peekNodeLoadable$1, setNodeValue: setNodeValue$3 } = Recoil_FunctionalCore;\nconst { saveDepsToStore: saveDepsToStore$1 } = Recoil_Graph;\nconst { DEFAULT_VALUE: DEFAULT_VALUE$6, getConfigDeletionHandler: getConfigDeletionHandler$1, getNode: getNode$6, registerNode: registerNode$1 } = Recoil_Node;\nconst { isRecoilValue: isRecoilValue$3 } = Recoil_RecoilValue$1;\nconst { markRecoilValueModified: markRecoilValueModified$1 } = Recoil_RecoilValueInterface;\nconst { retainedByOptionWithDefault: retainedByOptionWithDefault$1 } = Recoil_Retention;\nconst { recoilCallback: recoilCallback$1 } = Recoil_useRecoilCallback;\nconst { startPerfBlock: startPerfBlock$1 } = Recoil_PerformanceTimings;\nclass Canceled {\n}\nconst CANCELED = new Canceled();\n/**\n * An ExecutionID is an arbitrary ID that lets us distinguish executions from\n * each other. This is necessary as we need a way of solving this problem:\n * \"given 3 async executions, only update state for the 'latest' execution when\n * it finishes running regardless of when the other 2 finish\". ExecutionIDs\n * provide a convenient way of identifying executions so that we can track and\n * manage them over time.\n */ const dependencyStack = []; // for detecting circular dependencies.\nconst waitingStores = new Map();\nconst getNewExecutionID = (()=>{\n    let executionID = 0;\n    return ()=>executionID++;\n})();\n/* eslint-disable no-redeclare */ function selector(options) {\n    let recoilValue = null;\n    const { key, get, cachePolicy_UNSTABLE: cachePolicy } = options;\n    const set = options.set != null ? options.set : undefined; // flow\n    if (true) {\n        if (typeof key !== \"string\") {\n            throw Recoil_err(\"A key option with a unique string value must be provided when creating a selector.\");\n        }\n        if (typeof get !== \"function\") {\n            throw Recoil_err(\"Selectors must specify a get callback option to get the selector value.\");\n        }\n    } // This is every discovered dependency across all executions\n    const discoveredDependencyNodeKeys = new Set();\n    const cache = Recoil_treeCacheFromPolicy(cachePolicy !== null && cachePolicy !== void 0 ? cachePolicy : {\n        equality: \"reference\",\n        eviction: \"keep-all\"\n    }, key);\n    const retainedBy = retainedByOptionWithDefault$1(options.retainedBy_UNSTABLE);\n    const executionInfoMap = new Map();\n    let liveStoresCount = 0;\n    function selectorIsLive() {\n        return !Recoil_gkx(\"recoil_memory_managament_2020\") || liveStoresCount > 0;\n    }\n    function selectorInit(store) {\n        store.getState().knownSelectors.add(key);\n        liveStoresCount++;\n        return ()=>{\n            liveStoresCount--;\n        };\n    }\n    function selectorShouldDeleteConfigOnRelease() {\n        return getConfigDeletionHandler$1(key) !== undefined && !selectorIsLive();\n    }\n    function resolveAsync(store, state, executionID, loadable, depValues) {\n        setCache(state, loadable, depValues);\n        notifyStoresOfResolvedAsync(store, executionID);\n    }\n    function notifyStoresOfResolvedAsync(store, executionID) {\n        if (isLatestExecution(store, executionID)) {\n            clearExecutionInfo(store);\n        }\n        notifyWaitingStores(executionID, true);\n    }\n    /**\n   * Notify stores to pull the selector again if a new async dep was discovered.\n   * 1) Async selector adds a new dep but doesn't resolve yet.\n   *    Note that deps for an async selector are based on the state when the\n   *    evaluation started, in order to provide a consistent picture of state.\n   * 2) But, new value of dep based on the current state might cause the selector\n   *    to resolve or resolve differently.\n   * 3) Therefore, this notification will pull the selector based on the current\n   *    state for the components\n   */ function notifyStoresOfNewAsyncDep(store, executionID) {\n        if (isLatestExecution(store, executionID)) {\n            const executionInfo = Recoil_nullthrows(getExecutionInfo(store));\n            executionInfo.stateVersions.clear();\n            notifyWaitingStores(executionID, false);\n        }\n    }\n    function notifyWaitingStores(executionID, clearWaitlist) {\n        const stores = waitingStores.get(executionID);\n        if (stores != null) {\n            for (const waitingStore of stores){\n                markRecoilValueModified$1(waitingStore, Recoil_nullthrows(recoilValue));\n            }\n            if (clearWaitlist) {\n                waitingStores.delete(executionID);\n            }\n        }\n    }\n    function markStoreWaitingForResolvedAsync(store, executionID) {\n        let stores = waitingStores.get(executionID);\n        if (stores == null) {\n            waitingStores.set(executionID, stores = new Set());\n        }\n        stores.add(store);\n    }\n    /**\n   * This function attaches a then() and a catch() to a promise that was\n   * returned from a selector's get() (either explicitly or implicitly by\n   * running a function that uses the \"async\" keyword). If a selector's get()\n   * returns a promise, we have two possibilities:\n   *\n   * 1. The promise will resolve, in which case it will have completely finished\n   *    executing without any remaining pending dependencies. No more retries\n   *    are needed and we can proceed with updating the cache and notifying\n   *    subscribers (if it is the latest execution, otherwise only the cache\n   *    will be updated and subscriptions will not be fired). This is the case\n   *    handled by the attached then() handler.\n   *\n   * 2. The promise will throw because it either has an error or it came across\n   *    an async dependency that has not yet resolved, in which case we will\n   *    call wrapDepdencyPromise(), whose responsibility is to handle dependency\n   *    promises. This case is handled by the attached catch() handler.\n   *\n   * Both branches will eventually resolve to the final result of the selector\n   * (or an error if a real error occurred).\n   *\n   * The execution will run to completion even if it is stale, and its value\n   * will be cached. But stale executions will not update global state or update\n   * executionInfo as that is the responsibility of the 'latest' execution.\n   *\n   * Note this function should not be passed a promise that was thrown--AKA a\n   * dependency promise. Dependency promises should be passed to\n   * wrapPendingDependencyPromise()).\n   */ function wrapResultPromise(store, promise, state, depValues, executionID, loadingDepsState) {\n        return promise.then((value)=>{\n            if (!selectorIsLive()) {\n                // The selector was released since the request began; ignore the response.\n                clearExecutionInfo(store);\n                throw CANCELED;\n            }\n            const loadable = loadableWithValue$2(value);\n            resolveAsync(store, state, executionID, loadable, depValues);\n            return value;\n        }).catch((errorOrPromise)=>{\n            if (!selectorIsLive()) {\n                // The selector was released since the request began; ignore the response.\n                clearExecutionInfo(store);\n                throw CANCELED;\n            }\n            if (Recoil_isPromise(errorOrPromise)) {\n                return wrapPendingDependencyPromise(store, errorOrPromise, state, depValues, executionID, loadingDepsState);\n            }\n            const loadable = loadableWithError$1(errorOrPromise);\n            resolveAsync(store, state, executionID, loadable, depValues);\n            throw errorOrPromise;\n        });\n    }\n    /**\n   * This function attaches a then() and a catch() to a promise that was\n   * thrown from a selector's get(). If a selector's get() throws a promise,\n   * we have two possibilities:\n   *\n   * 1. The promise will resolve, meaning one of our selector's dependencies is\n   *    now available and we should \"retry\" our get() by running it again. This\n   *    is the case handled by the attached then() handler.\n   *\n   * 2. The promise will throw because something went wrong with the dependency\n   *    promise (in other words a real error occurred). This case is handled by\n   *    the attached catch() handler. If the dependency promise throws, it is\n   *    _always_ a real error and not another dependency promise (any dependency\n   *    promises would have been handled upstream).\n   *\n   * The then() branch will eventually resolve to the final result of the\n   * selector (or an error if a real error occurs), and the catch() will always\n   * resolve to an error because the dependency promise is a promise that was\n   * wrapped upstream, meaning it will only resolve to its real value or to a\n   * real error.\n   *\n   * The execution will run to completion even if it is stale, and its value\n   * will be cached. But stale executions will not update global state or update\n   * executionInfo as that is the responsibility of the 'latest' execution.\n   *\n   * Note this function should not be passed a promise that was returned from\n   * get(). The intention is that this function is only passed promises that\n   * were thrown due to a pending dependency. Promises returned by get() should\n   * be passed to wrapResultPromise() instead.\n   */ function wrapPendingDependencyPromise(store, promise, state, existingDeps, executionID, loadingDepsState) {\n        return promise.then((resolvedDep)=>{\n            if (!selectorIsLive()) {\n                // The selector was released since the request began; ignore the response.\n                clearExecutionInfo(store);\n                throw CANCELED;\n            } // Check if we are handling a pending Recoil dependency or if the user\n            // threw their own Promise to \"suspend\" a selector evaluation.  We need\n            // to check that the loadingDepPromise actually matches the promise that\n            // we caught in case the selector happened to catch the promise we threw\n            // for a pending Recoil dependency from `getRecoilValue()` and threw\n            // their own promise instead.\n            if (loadingDepsState.loadingDepKey != null && loadingDepsState.loadingDepPromise === promise) {\n                /**\n         * Note for async atoms, this means we are changing the atom's value\n         * in the store for the given version. This should be alright because\n         * the version of state is now stale and a new version will have\n         * already been triggered by the atom being resolved (see this logic\n         * in Recoil_atom.js)\n         */ state.atomValues.set(loadingDepsState.loadingDepKey, loadableWithValue$2(resolvedDep));\n            } else {\n                /**\n         * If resolvedDepKey is not defined, the promise was a user-thrown\n         * promise. User-thrown promises are an advanced feature and they\n         * should be avoided in almost all cases. Using `loadable.map()` inside\n         * of selectors for loading loadables and then throwing that mapped\n         * loadable's promise is an example of a user-thrown promise.\n         *\n         * When we hit a user-thrown promise, we have to bail out of an optimization\n         * where we bypass calculating selector cache keys for selectors that\n         * have been previously seen for a given state (these selectors are saved in\n         * state.atomValues) to avoid stale state as we have no way of knowing\n         * what state changes happened (if any) in result to the promise resolving.\n         *\n         * Ideally we would only bail out selectors that are in the chain of\n         * dependencies for this selector, but there's currently no way to get\n         * a full list of a selector's downstream nodes because the state that\n         * is executing may be a discarded tree (so store.getGraph(state.version)\n         * will be empty), and the full dep tree may not be in the selector\n         * caches in the case where the selector's cache was cleared. To solve\n         * for this we would have to keep track of all running selector\n         * executions and their downstream deps. Because this only covers edge\n         * cases, that complexity might not be justifyable.\n         */ store.getState().knownSelectors.forEach((nodeKey)=>{\n                    state.atomValues.delete(nodeKey);\n                });\n            }\n            /**\n       * Optimization: Now that the dependency has resolved, let's try hitting\n       * the cache in case the dep resolved to a value we have previously seen.\n       *\n       * TODO:\n       * Note this optimization is not perfect because it only prevents re-executions\n       * _after_ the point where an async dependency is found. Any code leading\n       * up to the async dependency may have run unnecessarily. The ideal case\n       * would be to wait for the async dependency to resolve first, check the\n       * cache, and prevent _any_ execution of the selector if the resulting\n       * value of the dependency leads to a path that is found in the cache.\n       * The ideal case is more difficult to implement as it would require that\n       * we capture and wait for the the async dependency right after checking\n       * the cache. The current approach takes advantage of the fact that running\n       * the selector already has a code path that lets us exit early when\n       * an async dep resolves.\n       */ const cachedLoadable = getLoadableFromCacheAndUpdateDeps(store, state);\n            if (cachedLoadable && cachedLoadable.state !== \"loading\") {\n                /**\n         * This has to notify stores of a resolved async, even if there is no\n         * current pending execution for the following case:\n         * 1) A component renders with this pending loadable.\n         * 2) The upstream dependency resolves.\n         * 3) While processing some other selector it reads this one, such as\n         *    while traversing its dependencies.  At this point it gets the\n         *    new resolved value synchronously and clears the current\n         *    execution ID.  The component wasn't getting the value itself,\n         *    though, so it still has the pending loadable.\n         * 4) When this code executes the current execution id was cleared\n         *    and it wouldn't notify the component of the new value.\n         *\n         * I think this is only an issue with \"early\" rendering since the\n         * components got their value using the in-progress execution.\n         * We don't have a unit test for this case yet.  I'm not sure it is\n         * necessary with recoil_transition_support mode.\n         */ if (isLatestExecution(store, executionID) || getExecutionInfo(store) == null) {\n                    notifyStoresOfResolvedAsync(store, executionID);\n                }\n                if (cachedLoadable.state === \"hasValue\") {\n                    return cachedLoadable.contents;\n                } else {\n                    throw cachedLoadable.contents;\n                }\n            }\n            /**\n       * If this execution is stale, let's check to see if there is some in\n       * progress execution with a matching state. If we find a match, then\n       * we can take the value from that in-progress execution. Note this may\n       * sound like an edge case, but may be very common in cases where a\n       * loading dependency resolves from loading to having a value (thus\n       * possibly triggering a re-render), and React re-renders before the\n       * chained .then() functions run, thus starting a new execution as the\n       * dep has changed value. Without this check we will run the selector\n       * twice (once in the new execution and once again in this .then(), so\n       * this check is necessary to keep unnecessary re-executions to a\n       * minimum).\n       *\n       * Also note this code does not check across all executions that may be\n       * running. It only optimizes for the _latest_ execution per store as\n       * we currently do not maintain a list of all currently running executions.\n       * This means in some cases we may run selectors more than strictly\n       * necessary when there are multiple executions running for the same\n       * selector. This may be a valid tradeoff as checking for dep changes\n       * across all in-progress executions may take longer than just\n       * re-running the selector. This will be app-dependent, and maybe in the\n       * future we can make the behavior configurable. An ideal fix may be\n       * to extend the tree cache to support caching loading states.\n       */ if (!isLatestExecution(store, executionID)) {\n                const executionInfo = getInProgressExecutionInfo(store, state);\n                if (executionInfo != null) {\n                    /**\n           * Returning promise here without wrapping as the wrapper logic was\n           * already done upstream when this promise was generated.\n           */ return executionInfo.loadingLoadable.contents;\n                }\n            } // Retry the selector evaluation now that the dependency has resolved\n            const [loadable, depValues] = evaluateSelectorGetter(store, state, executionID);\n            if (loadable.state !== \"loading\") {\n                resolveAsync(store, state, executionID, loadable, depValues);\n            }\n            if (loadable.state === \"hasError\") {\n                throw loadable.contents;\n            }\n            return loadable.contents;\n        }).catch((error)=>{\n            // The selector was released since the request began; ignore the response.\n            if (error instanceof Canceled) {\n                throw CANCELED;\n            }\n            if (!selectorIsLive()) {\n                clearExecutionInfo(store);\n                throw CANCELED;\n            }\n            const loadable = loadableWithError$1(error);\n            resolveAsync(store, state, executionID, loadable, existingDeps);\n            throw error;\n        });\n    }\n    function updateDeps(store, state, deps, executionID) {\n        var _store$getState, _store$getState$curre, _store$getState2, _store$getState2$next;\n        if (isLatestExecution(store, executionID) || state.version === ((_store$getState = store.getState()) === null || _store$getState === void 0 ? void 0 : (_store$getState$curre = _store$getState.currentTree) === null || _store$getState$curre === void 0 ? void 0 : _store$getState$curre.version) || state.version === ((_store$getState2 = store.getState()) === null || _store$getState2 === void 0 ? void 0 : (_store$getState2$next = _store$getState2.nextTree) === null || _store$getState2$next === void 0 ? void 0 : _store$getState2$next.version)) {\n            var _store$getState$nextT, _store$getState3, _store$getState3$next;\n            saveDepsToStore$1(key, deps, store, (_store$getState$nextT = (_store$getState3 = store.getState()) === null || _store$getState3 === void 0 ? void 0 : (_store$getState3$next = _store$getState3.nextTree) === null || _store$getState3$next === void 0 ? void 0 : _store$getState3$next.version) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree.version);\n        }\n        for (const nodeKey of deps){\n            discoveredDependencyNodeKeys.add(nodeKey);\n        }\n    }\n    function evaluateSelectorGetter(store, state, executionID) {\n        const endPerfBlock = startPerfBlock$1(key); // TODO T63965866: use execution ID here\n        let duringSynchronousExecution = true;\n        let duringAsynchronousExecution = true;\n        const finishEvaluation = ()=>{\n            endPerfBlock();\n            duringAsynchronousExecution = false;\n        };\n        let result;\n        let resultIsError = false;\n        let loadable;\n        const loadingDepsState = {\n            loadingDepKey: null,\n            loadingDepPromise: null\n        };\n        /**\n     * Starting a fresh set of deps that we'll be using to update state. We're\n     * starting a new set versus adding it in existing state deps because\n     * the version of state that we update deps for may be a more recent version\n     * than the version the selector was called with. This is because the latest\n     * execution will update the deps of the current/latest version of state\n     * (This is safe to do because the fact that the selector is the latest\n     * execution means the deps we discover below are our best guess at the\n     * deps for the current/latest state in the store)\n     */ const depValues = new Map();\n        function getRecoilValue(param) {\n            let { key: depKey } = param;\n            const depLoadable = getNodeLoadable$2(store, state, depKey);\n            depValues.set(depKey, depLoadable); // We need to update asynchronous dependencies as we go so the selector\n            // knows if it has to restart evaluation if one of them is updated before\n            // the asynchronous selector completely resolves.\n            if (!duringSynchronousExecution) {\n                updateDeps(store, state, new Set(depValues.keys()), executionID);\n                notifyStoresOfNewAsyncDep(store, executionID);\n            }\n            switch(depLoadable.state){\n                case \"hasValue\":\n                    return depLoadable.contents;\n                case \"hasError\":\n                    throw depLoadable.contents;\n                case \"loading\":\n                    loadingDepsState.loadingDepKey = depKey;\n                    loadingDepsState.loadingDepPromise = depLoadable.contents;\n                    throw depLoadable.contents;\n            }\n            throw Recoil_err(\"Invalid Loadable state\");\n        }\n        const getCallback = (fn)=>{\n            return function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                if (duringAsynchronousExecution) {\n                    throw Recoil_err(\"Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.\");\n                }\n                !(recoilValue != null) ?  true ? Recoil_invariant(false, \"Recoil Value can never be null\") : 0 : void 0;\n                return recoilCallback$1(store, fn, args, {\n                    node: recoilValue\n                } // flowlint-line unclear-type:off\n                );\n            };\n        };\n        try {\n            result = get({\n                get: getRecoilValue,\n                getCallback\n            });\n            result = isRecoilValue$3(result) ? getRecoilValue(result) : result;\n            if (isLoadable$1(result)) {\n                if (result.state === \"hasError\") {\n                    resultIsError = true;\n                }\n                result = result.contents;\n            }\n            if (Recoil_isPromise(result)) {\n                result = wrapResultPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);\n            } else {\n                finishEvaluation();\n            }\n            result = result instanceof WrappedValue$1 ? result.value : result;\n        } catch (errorOrDepPromise) {\n            result = errorOrDepPromise;\n            if (Recoil_isPromise(result)) {\n                result = wrapPendingDependencyPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);\n            } else {\n                resultIsError = true;\n                finishEvaluation();\n            }\n        }\n        if (resultIsError) {\n            loadable = loadableWithError$1(result);\n        } else if (Recoil_isPromise(result)) {\n            loadable = loadableWithPromise$1(result);\n        } else {\n            loadable = loadableWithValue$2(result);\n        }\n        duringSynchronousExecution = false;\n        updateExecutionInfoDepValues(store, executionID, depValues);\n        updateDeps(store, state, new Set(depValues.keys()), executionID);\n        return [\n            loadable,\n            depValues\n        ];\n    }\n    function getLoadableFromCacheAndUpdateDeps(store, state) {\n        // First, look up in the state cache\n        // If it's here, then the deps in the store should already be valid.\n        let cachedLoadable = state.atomValues.get(key);\n        if (cachedLoadable != null) {\n            return cachedLoadable;\n        } // Second, look up in the selector cache and update the deps in the store\n        const depsAfterCacheLookup = new Set();\n        try {\n            cachedLoadable = cache.get((nodeKey)=>{\n                !(typeof nodeKey === \"string\") ?  true ? Recoil_invariant(false, \"Cache nodeKey is type string\") : 0 : void 0;\n                return getNodeLoadable$2(store, state, nodeKey).contents;\n            }, {\n                onNodeVisit: (node)=>{\n                    if (node.type === \"branch\" && node.nodeKey !== key) {\n                        depsAfterCacheLookup.add(node.nodeKey);\n                    }\n                }\n            });\n        } catch (error) {\n            throw Recoil_err('Problem with cache lookup for selector \"'.concat(key, '\": ').concat(error.message));\n        }\n        if (cachedLoadable) {\n            var _getExecutionInfo;\n            // Cache the results in the state to allow for cheaper lookup than\n            // iterating the tree cache of dependencies.\n            state.atomValues.set(key, cachedLoadable);\n            /**\n       * Ensure store contains correct dependencies if we hit the cache so that\n       * the store deps and cache are in sync for a given state. This is important\n       * because store deps are normally updated when new executions are created,\n       * but cache hits don't trigger new executions but they still _may_ signify\n       * a change in deps in the store if the store deps for this state are empty\n       * or stale.\n       */ updateDeps(store, state, depsAfterCacheLookup, (_getExecutionInfo = getExecutionInfo(store)) === null || _getExecutionInfo === void 0 ? void 0 : _getExecutionInfo.executionID);\n        }\n        return cachedLoadable;\n    }\n    /**\n   * Given a tree state, this function returns a Loadable of the current state.\n   *\n   * The selector's get() function will only be re-evaluated if _both_ of the\n   * following statements are true:\n   *\n   * 1. The current dep values from the given state produced a cache key that\n   *    was not found in the cache.\n   * 2. There is no currently running async execution OR there is an\n   *    async execution that is running, but after comparing the dep values in\n   *    the given state with the dep values that the execution has discovered so\n   *    far we find that at least one dep value has changed, in which case we\n   *    start a new execution (the previously running execution will continue to\n   *    run to completion, but only the new execution will be deemed the\n   *    'latest' execution, meaning it will be the only execution that will\n   *    update global state when it is finished. Any non-latest executions will\n   *    run to completion and update the selector cache but not global state).\n   */ function getSelectorLoadableAndUpdateDeps(store, state) {\n        // First, see if our current state is cached\n        const cachedVal = getLoadableFromCacheAndUpdateDeps(store, state);\n        if (cachedVal != null) {\n            clearExecutionInfo(store);\n            return cachedVal;\n        } // Second, check if there is already an ongoing execution based on the current state\n        const inProgressExecutionInfo = getInProgressExecutionInfo(store, state);\n        if (inProgressExecutionInfo != null) {\n            var _inProgressExecutionI;\n            if (((_inProgressExecutionI = inProgressExecutionInfo.loadingLoadable) === null || _inProgressExecutionI === void 0 ? void 0 : _inProgressExecutionI.state) === \"loading\") {\n                markStoreWaitingForResolvedAsync(store, inProgressExecutionInfo.executionID);\n            } // FIXME: check after the fact to see if we made the right choice by waiting\n            return inProgressExecutionInfo.loadingLoadable;\n        } // Third, start a new evaluation of the selector\n        const newExecutionID = getNewExecutionID();\n        const [loadable, newDepValues] = evaluateSelectorGetter(store, state, newExecutionID);\n        /**\n     * Conditionally updates the cache with a given loadable.\n     *\n     * We only cache loadables that are not loading because our cache keys are\n     * based on dep values, which are in an unfinished state for loadables that\n     * have a 'loading' state (new deps may be discovered while the selector\n     * runs its async code). We never want to cache partial dependencies b/c it\n     * could lead to errors, such as prematurely returning the result based on a\n     * partial list of deps-- we need the full list of deps to ensure that we\n     * are returning the correct result from cache.\n     */ if (loadable.state === \"loading\") {\n            setExecutionInfo(store, newExecutionID, loadable, newDepValues, state);\n            markStoreWaitingForResolvedAsync(store, newExecutionID);\n        } else {\n            clearExecutionInfo(store);\n            setCache(state, loadable, newDepValues);\n        }\n        return loadable;\n    }\n    /**\n   * Searches execution info across all stores to see if there is an in-progress\n   * execution whose dependency values match the values of the requesting store.\n   */ function getInProgressExecutionInfo(store, state) {\n        // Sort the pending executions so that our current store is checked first.\n        const pendingExecutions = Recoil_concatIterables([\n            executionInfoMap.has(store) ? [\n                Recoil_nullthrows(executionInfoMap.get(store))\n            ] : [],\n            Recoil_mapIterable(Recoil_filterIterable(executionInfoMap, (param)=>{\n                let [s] = param;\n                return s !== store;\n            }), (param)=>{\n                let [, execInfo] = param;\n                return execInfo;\n            })\n        ]);\n        function anyDepChanged(execDepValues) {\n            for (const [depKey, execLoadable] of execDepValues){\n                if (!getNodeLoadable$2(store, state, depKey).is(execLoadable)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        for (const execInfo of pendingExecutions){\n            if (// of state, then let's use it!\n            execInfo.stateVersions.get(state.version) || // If the deps for the execution match our current state, then it's valid\n            !anyDepChanged(execInfo.depValuesDiscoveredSoFarDuringAsyncWork)) {\n                execInfo.stateVersions.set(state.version, true);\n                return execInfo;\n            } else {\n                execInfo.stateVersions.set(state.version, false);\n            }\n        }\n        return undefined;\n    }\n    function getExecutionInfo(store) {\n        return executionInfoMap.get(store);\n    }\n    /**\n   * This function will update the selector's execution info when the selector\n   * has either finished running an execution or has started a new execution. If\n   * the given loadable is in a 'loading' state, the intention is that a new\n   * execution has started. Otherwise, the intention is that an execution has\n   * just finished.\n   */ function setExecutionInfo(store, newExecutionID, loadable, depValues, state) {\n        executionInfoMap.set(store, {\n            depValuesDiscoveredSoFarDuringAsyncWork: depValues,\n            executionID: newExecutionID,\n            loadingLoadable: loadable,\n            stateVersions: new Map([\n                [\n                    state.version,\n                    true\n                ]\n            ])\n        });\n    }\n    function updateExecutionInfoDepValues(store, executionID, depValues) {\n        // We only need to bother updating the deps for the latest execution because\n        // that's all getInProgressExecutionInfo() will be looking for.\n        if (isLatestExecution(store, executionID)) {\n            const executionInfo = getExecutionInfo(store);\n            if (executionInfo != null) {\n                executionInfo.depValuesDiscoveredSoFarDuringAsyncWork = depValues;\n            }\n        }\n    }\n    function clearExecutionInfo(store) {\n        executionInfoMap.delete(store);\n    }\n    function isLatestExecution(store, executionID) {\n        var _getExecutionInfo2;\n        return executionID === ((_getExecutionInfo2 = getExecutionInfo(store)) === null || _getExecutionInfo2 === void 0 ? void 0 : _getExecutionInfo2.executionID);\n    }\n    /**\n   * FIXME: dep keys should take into account the state of the loadable to\n   * prevent the edge case where a loadable with an error and a loadable with\n   * an error as a value are treated as the same thing incorrectly. For example\n   * these two should be treated differently:\n   *\n   * selector({key: '', get: () => new Error('hi')});\n   * selector({key: '', get () => {throw new Error('hi')}});\n   *\n   * With current implementation they are treated the same\n   */ function depValuesToDepRoute(depValues) {\n        return Array.from(depValues.entries()).map((param)=>{\n            let [depKey, valLoadable] = param;\n            return [\n                depKey,\n                valLoadable.contents\n            ];\n        });\n    }\n    function setCache(state, loadable, depValues) {\n        if (true) {\n            if (loadable.state !== \"loading\" && Boolean(options.dangerouslyAllowMutability) === false) {\n                Recoil_deepFreezeValue(loadable.contents);\n            }\n        }\n        state.atomValues.set(key, loadable);\n        try {\n            cache.set(depValuesToDepRoute(depValues), loadable);\n        } catch (error) {\n            throw Recoil_err('Problem with setting cache for selector \"'.concat(key, '\": ').concat(error.message));\n        }\n    }\n    function detectCircularDependencies(fn) {\n        if (dependencyStack.includes(key)) {\n            const message = \"Recoil selector has circular dependencies: \".concat(dependencyStack.slice(dependencyStack.indexOf(key)).join(\"  \"));\n            return loadableWithError$1(Recoil_err(message));\n        }\n        dependencyStack.push(key);\n        try {\n            return fn();\n        } finally{\n            dependencyStack.pop();\n        }\n    }\n    function selectorPeek(store, state) {\n        const cachedLoadable = state.atomValues.get(key);\n        if (cachedLoadable != null) {\n            return cachedLoadable;\n        }\n        return cache.get((nodeKey)=>{\n            var _peekNodeLoadable;\n            !(typeof nodeKey === \"string\") ?  true ? Recoil_invariant(false, \"Cache nodeKey is type string\") : 0 : void 0;\n            return (_peekNodeLoadable = peekNodeLoadable$1(store, state, nodeKey)) === null || _peekNodeLoadable === void 0 ? void 0 : _peekNodeLoadable.contents;\n        });\n    }\n    function selectorGet(store, state) {\n        return detectCircularDependencies(()=>getSelectorLoadableAndUpdateDeps(store, state));\n    }\n    function invalidateSelector(state) {\n        state.atomValues.delete(key);\n    }\n    function clearSelectorCache(store, treeState) {\n        !(recoilValue != null) ?  true ? Recoil_invariant(false, \"Recoil Value can never be null\") : 0 : void 0;\n        for (const nodeKey of discoveredDependencyNodeKeys){\n            var _node$clearCache;\n            const node = getNode$6(nodeKey);\n            (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, treeState);\n        }\n        discoveredDependencyNodeKeys.clear();\n        invalidateSelector(treeState);\n        cache.clear();\n        markRecoilValueModified$1(store, recoilValue);\n    }\n    if (set != null) {\n        /**\n     * ES5 strict mode prohibits defining non-top-level function declarations,\n     * so don't use function declaration syntax here\n     */ const selectorSet = (store, state, newValue)=>{\n            let syncSelectorSetFinished = false;\n            const writes = new Map();\n            function getRecoilValue(param) {\n                let { key: depKey } = param;\n                if (syncSelectorSetFinished) {\n                    throw Recoil_err(\"Recoil: Async selector sets are not currently supported.\");\n                }\n                const loadable = getNodeLoadable$2(store, state, depKey);\n                if (loadable.state === \"hasValue\") {\n                    return loadable.contents;\n                } else if (loadable.state === \"loading\") {\n                    const msg = 'Getting value of asynchronous atom or selector \"'.concat(depKey, '\" in a pending state while setting selector \"').concat(key, '\" is not yet supported.');\n                    Recoil_recoverableViolation(msg);\n                    throw Recoil_err(msg);\n                } else {\n                    throw loadable.contents;\n                }\n            }\n            function setRecoilState(recoilState, valueOrUpdater // $FlowFixMe[missing-local-annot]\n            ) {\n                if (syncSelectorSetFinished) {\n                    const msg = \"Recoil: Async selector sets are not currently supported.\";\n                    Recoil_recoverableViolation(msg);\n                    throw Recoil_err(msg);\n                }\n                const setValue = typeof valueOrUpdater === \"function\" ? // flowlint-next-line unclear-type:off\n                valueOrUpdater(getRecoilValue(recoilState)) : valueOrUpdater;\n                const upstreamWrites = setNodeValue$3(store, state, recoilState.key, setValue);\n                upstreamWrites.forEach((v, k)=>writes.set(k, v));\n            }\n            function resetRecoilState(recoilState) {\n                setRecoilState(recoilState, DEFAULT_VALUE$6);\n            }\n            const ret = set({\n                set: setRecoilState,\n                get: getRecoilValue,\n                reset: resetRecoilState\n            }, newValue); // set should be a void method, but if the user makes it `async`, then it\n            // will return a Promise, which we don't currently support.\n            if (ret !== undefined) {\n                throw Recoil_isPromise(ret) ? Recoil_err(\"Recoil: Async selector sets are not currently supported.\") : Recoil_err(\"Recoil: selector set should be a void function.\");\n            }\n            syncSelectorSetFinished = true;\n            return writes;\n        };\n        return recoilValue = registerNode$1({\n            key,\n            nodeType: \"selector\",\n            peek: selectorPeek,\n            get: selectorGet,\n            set: selectorSet,\n            init: selectorInit,\n            invalidate: invalidateSelector,\n            clearCache: clearSelectorCache,\n            shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,\n            dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n            shouldRestoreFromSnapshots: false,\n            retainedBy\n        });\n    } else {\n        return recoilValue = registerNode$1({\n            key,\n            nodeType: \"selector\",\n            peek: selectorPeek,\n            get: selectorGet,\n            init: selectorInit,\n            invalidate: invalidateSelector,\n            clearCache: clearSelectorCache,\n            shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,\n            dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n            shouldRestoreFromSnapshots: false,\n            retainedBy\n        });\n    }\n}\n/* eslint-enable no-redeclare */ // $FlowIssue[incompatible-use]\n// $FlowFixMe[missing-local-annot]\nselector.value = (value)=>new WrappedValue$1(value);\nvar Recoil_selector = selector;\n// @fb-only: import type {ScopeRules} from 'Recoil_ScopedAtom';\n// @fb-only: const {scopedAtom} = require('Recoil_ScopedAtom');\nconst { isLoadable: isLoadable$2, loadableWithError: loadableWithError$2, loadableWithPromise: loadableWithPromise$2, loadableWithValue: loadableWithValue$3 } = Recoil_Loadable$1;\nconst { WrappedValue: WrappedValue$2 } = Recoil_Wrapper$1;\nconst { peekNodeInfo: peekNodeInfo$3 } = Recoil_FunctionalCore;\nconst { DEFAULT_VALUE: DEFAULT_VALUE$7, DefaultValue: DefaultValue$2, getConfigDeletionHandler: getConfigDeletionHandler$2, registerNode: registerNode$2, setConfigDeletionHandler: setConfigDeletionHandler$1 } = Recoil_Node;\nconst { isRecoilValue: isRecoilValue$4 } = Recoil_RecoilValue$1;\nconst { getRecoilValueAsLoadable: getRecoilValueAsLoadable$4, markRecoilValueModified: markRecoilValueModified$2, setRecoilValue: setRecoilValue$4, setRecoilValueLoadable: setRecoilValueLoadable$2 } = Recoil_RecoilValueInterface;\nconst { retainedByOptionWithDefault: retainedByOptionWithDefault$2 } = Recoil_Retention;\nconst unwrap = (x)=>x instanceof WrappedValue$2 ? x.value : x;\nfunction baseAtom(options) {\n    const { key, persistence_UNSTABLE: persistence } = options;\n    const retainedBy = retainedByOptionWithDefault$2(options.retainedBy_UNSTABLE);\n    let liveStoresCount = 0;\n    function unwrapPromise(promise) {\n        return loadableWithPromise$2(promise.then((value)=>{\n            defaultLoadable = loadableWithValue$3(value);\n            return value;\n        }).catch((error)=>{\n            defaultLoadable = loadableWithError$2(error);\n            throw error;\n        }));\n    }\n    let defaultLoadable = Recoil_isPromise(options.default) ? unwrapPromise(options.default) : isLoadable$2(options.default) ? options.default.state === \"loading\" ? unwrapPromise(options.default.contents) : options.default : loadableWithValue$3(unwrap(options.default));\n    maybeFreezeValueOrPromise(defaultLoadable.contents);\n    let cachedAnswerForUnvalidatedValue = undefined; // Cleanup handlers for this atom\n    // Rely on stable reference equality of the store to use it as a key per <RecoilRoot>\n    const cleanupEffectsByStore = new Map();\n    function maybeFreezeValueOrPromise(valueOrPromise) {\n        if (true) {\n            if (options.dangerouslyAllowMutability !== true) {\n                if (Recoil_isPromise(valueOrPromise)) {\n                    return valueOrPromise.then((value)=>{\n                        Recoil_deepFreezeValue(value);\n                        return value;\n                    });\n                } else {\n                    Recoil_deepFreezeValue(valueOrPromise);\n                    return valueOrPromise;\n                }\n            }\n        }\n        return valueOrPromise;\n    }\n    function wrapPendingPromise(store, promise) {\n        const wrappedPromise = promise.then((value)=>{\n            var _store$getState$nextT, _state$atomValues$get;\n            const state = (_store$getState$nextT = store.getState().nextTree) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree;\n            if (((_state$atomValues$get = state.atomValues.get(key)) === null || _state$atomValues$get === void 0 ? void 0 : _state$atomValues$get.contents) === wrappedPromise) {\n                setRecoilValue$4(store, node, value);\n            }\n            return value;\n        }).catch((error)=>{\n            var _store$getState$nextT2, _state$atomValues$get2;\n            const state = (_store$getState$nextT2 = store.getState().nextTree) !== null && _store$getState$nextT2 !== void 0 ? _store$getState$nextT2 : store.getState().currentTree;\n            if (((_state$atomValues$get2 = state.atomValues.get(key)) === null || _state$atomValues$get2 === void 0 ? void 0 : _state$atomValues$get2.contents) === wrappedPromise) {\n                setRecoilValueLoadable$2(store, node, loadableWithError$2(error));\n            }\n            throw error;\n        });\n        return wrappedPromise;\n    }\n    function initAtom(store, initState, trigger) {\n        var _options$effects;\n        liveStoresCount++;\n        const cleanupAtom = ()=>{\n            var _cleanupEffectsByStor;\n            liveStoresCount--;\n            (_cleanupEffectsByStor = cleanupEffectsByStore.get(store)) === null || _cleanupEffectsByStor === void 0 ? void 0 : _cleanupEffectsByStor.forEach((cleanup)=>cleanup());\n            cleanupEffectsByStore.delete(store);\n        };\n        store.getState().knownAtoms.add(key); // Setup async defaults to notify subscribers when they resolve\n        if (defaultLoadable.state === \"loading\") {\n            const notifyDefaultSubscribers = ()=>{\n                var _store$getState$nextT3;\n                const state = (_store$getState$nextT3 = store.getState().nextTree) !== null && _store$getState$nextT3 !== void 0 ? _store$getState$nextT3 : store.getState().currentTree;\n                if (!state.atomValues.has(key)) {\n                    markRecoilValueModified$2(store, node);\n                }\n            };\n            defaultLoadable.contents.finally(notifyDefaultSubscribers);\n        } ///////////////////\n        // Run Atom Effects\n        ///////////////////\n        const effects = (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE;\n        if (effects != null) {\n            // This state is scoped by Store, since this is in the initAtom() closure\n            let initValue = DEFAULT_VALUE$7;\n            let isDuringInit = true;\n            let isInitError = false;\n            let pendingSetSelf = null;\n            function getLoadable(recoilValue) {\n                // Normally we can just get the current value of another atom.\n                // But for our own value we need to check if there is a pending\n                // initialized value or get the fallback default value.\n                if (isDuringInit && recoilValue.key === key) {\n                    // Cast T to S\n                    const retValue = initValue; // flowlint-line unclear-type:off\n                    return retValue instanceof DefaultValue$2 ? peekAtom(store, initState) // flowlint-line unclear-type:off\n                     : Recoil_isPromise(retValue) ? loadableWithPromise$2(retValue.then((v)=>v instanceof DefaultValue$2 ? defaultLoadable.toPromise() // flowlint-line unclear-type:off\n                         : v)) : loadableWithValue$3(retValue);\n                }\n                return getRecoilValueAsLoadable$4(store, recoilValue);\n            }\n            function getPromise(recoilValue) {\n                return getLoadable(recoilValue).toPromise();\n            }\n            function getInfo_UNSTABLE(recoilValue) {\n                var _store$getState$nextT4;\n                const info = peekNodeInfo$3(store, (_store$getState$nextT4 = store.getState().nextTree) !== null && _store$getState$nextT4 !== void 0 ? _store$getState$nextT4 : store.getState().currentTree, recoilValue.key);\n                return isDuringInit && recoilValue.key === key && !(initValue instanceof DefaultValue$2) ? {\n                    ...info,\n                    isSet: true,\n                    loadable: getLoadable(recoilValue)\n                } : info;\n            }\n            const setSelf = (effect)=>(valueOrUpdater)=>{\n                    if (isDuringInit) {\n                        const currentLoadable = getLoadable(node);\n                        const currentValue = currentLoadable.state === \"hasValue\" ? currentLoadable.contents : DEFAULT_VALUE$7;\n                        initValue = typeof valueOrUpdater === \"function\" ? valueOrUpdater(currentValue) // flowlint-line unclear-type:off\n                         : valueOrUpdater;\n                        if (Recoil_isPromise(initValue)) {\n                            initValue = initValue.then((value)=>{\n                                // Avoid calling onSet() when setSelf() initializes with a Promise\n                                pendingSetSelf = {\n                                    effect,\n                                    value\n                                };\n                                return value;\n                            });\n                        }\n                    } else {\n                        if (Recoil_isPromise(valueOrUpdater)) {\n                            throw Recoil_err(\"Setting atoms to async values is not implemented.\");\n                        }\n                        if (typeof valueOrUpdater !== \"function\") {\n                            pendingSetSelf = {\n                                effect,\n                                value: unwrap(valueOrUpdater)\n                            };\n                        }\n                        setRecoilValue$4(store, node, typeof valueOrUpdater === \"function\" ? (currentValue)=>{\n                            const newValue = unwrap(valueOrUpdater(currentValue) // flowlint-line unclear-type:off\n                            ); // $FlowFixMe[incompatible-type]\n                            pendingSetSelf = {\n                                effect,\n                                value: newValue\n                            };\n                            return newValue;\n                        } : unwrap(valueOrUpdater));\n                    }\n                };\n            const resetSelf = (effect)=>()=>setSelf(effect)(DEFAULT_VALUE$7);\n            const onSet = (effect)=>(handler)=>{\n                    var _cleanupEffectsByStor2;\n                    const { release } = store.subscribeToTransactions((currentStore)=>{\n                        var _currentTree$atomValu;\n                        // eslint-disable-next-line prefer-const\n                        let { currentTree, previousTree } = currentStore.getState();\n                        if (!previousTree) {\n                            Recoil_recoverableViolation(\"Transaction subscribers notified without a next tree being present -- this is a bug in Recoil\");\n                            previousTree = currentTree; // attempt to trundle on\n                        }\n                        const newLoadable = (_currentTree$atomValu = currentTree.atomValues.get(key)) !== null && _currentTree$atomValu !== void 0 ? _currentTree$atomValu : defaultLoadable;\n                        if (newLoadable.state === \"hasValue\") {\n                            var _previousTree$atomVal, _pendingSetSelf, _pendingSetSelf2, _pendingSetSelf3;\n                            const newValue = newLoadable.contents;\n                            const oldLoadable = (_previousTree$atomVal = previousTree.atomValues.get(key)) !== null && _previousTree$atomVal !== void 0 ? _previousTree$atomVal : defaultLoadable;\n                            const oldValue = oldLoadable.state === \"hasValue\" ? oldLoadable.contents : DEFAULT_VALUE$7; // TODO This isn't actually valid, use as a placeholder for now.\n                            // Ignore atom value changes that were set via setSelf() in the same effect.\n                            // We will still properly call the handler if there was a subsequent\n                            // set from something other than an atom effect which was batched\n                            // with the `setSelf()` call.  However, we may incorrectly ignore\n                            // the handler if the subsequent batched call happens to set the\n                            // atom to the exact same value as the `setSelf()`.   But, in that\n                            // case, it was kind of a noop, so the semantics are debatable..\n                            if (((_pendingSetSelf = pendingSetSelf) === null || _pendingSetSelf === void 0 ? void 0 : _pendingSetSelf.effect) !== effect || ((_pendingSetSelf2 = pendingSetSelf) === null || _pendingSetSelf2 === void 0 ? void 0 : _pendingSetSelf2.value) !== newValue) {\n                                handler(newValue, oldValue, !currentTree.atomValues.has(key));\n                            } else if (((_pendingSetSelf3 = pendingSetSelf) === null || _pendingSetSelf3 === void 0 ? void 0 : _pendingSetSelf3.effect) === effect) {\n                                pendingSetSelf = null;\n                            }\n                        }\n                    }, key);\n                    cleanupEffectsByStore.set(store, [\n                        ...(_cleanupEffectsByStor2 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor2 !== void 0 ? _cleanupEffectsByStor2 : [],\n                        release\n                    ]);\n                };\n            for (const effect of effects){\n                try {\n                    const cleanup = effect({\n                        node,\n                        storeID: store.storeID,\n                        parentStoreID_UNSTABLE: store.parentStoreID,\n                        trigger,\n                        setSelf: setSelf(effect),\n                        resetSelf: resetSelf(effect),\n                        onSet: onSet(effect),\n                        getPromise,\n                        getLoadable,\n                        getInfo_UNSTABLE\n                    });\n                    if (cleanup != null) {\n                        var _cleanupEffectsByStor3;\n                        cleanupEffectsByStore.set(store, [\n                            ...(_cleanupEffectsByStor3 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor3 !== void 0 ? _cleanupEffectsByStor3 : [],\n                            cleanup\n                        ]);\n                    }\n                } catch (error) {\n                    initValue = error;\n                    isInitError = true;\n                }\n            }\n            isDuringInit = false; // Mutate initial state in place since we know there are no other subscribers\n            // since we are the ones initializing on first use.\n            if (!(initValue instanceof DefaultValue$2)) {\n                var _store$getState$nextT5;\n                const initLoadable = isInitError ? loadableWithError$2(initValue) : Recoil_isPromise(initValue) ? loadableWithPromise$2(wrapPendingPromise(store, initValue)) : loadableWithValue$3(unwrap(initValue));\n                maybeFreezeValueOrPromise(initLoadable.contents);\n                initState.atomValues.set(key, initLoadable); // If there is a pending transaction, then also mutate the next state tree.\n                // This could happen if the atom was first initialized in an action that\n                // also updated some other atom's state.\n                (_store$getState$nextT5 = store.getState().nextTree) === null || _store$getState$nextT5 === void 0 ? void 0 : _store$getState$nextT5.atomValues.set(key, initLoadable);\n            }\n        }\n        return cleanupAtom;\n    }\n    function peekAtom(_store, state) {\n        var _ref, _state$atomValues$get3;\n        return (_ref = (_state$atomValues$get3 = state.atomValues.get(key)) !== null && _state$atomValues$get3 !== void 0 ? _state$atomValues$get3 : cachedAnswerForUnvalidatedValue) !== null && _ref !== void 0 ? _ref : defaultLoadable;\n    }\n    function getAtom(_store, state) {\n        if (state.atomValues.has(key)) {\n            // Atom value is stored in state:\n            return Recoil_nullthrows(state.atomValues.get(key));\n        } else if (state.nonvalidatedAtoms.has(key)) {\n            // Atom value is stored but needs validation before use.\n            // We might have already validated it and have a cached validated value:\n            if (cachedAnswerForUnvalidatedValue != null) {\n                return cachedAnswerForUnvalidatedValue;\n            }\n            if (persistence == null) {\n                Recoil_expectationViolation(\"Tried to restore a persisted value for atom \".concat(key, \" but it has no persistence settings.\"));\n                return defaultLoadable;\n            }\n            const nonvalidatedValue = state.nonvalidatedAtoms.get(key);\n            const validatorResult = persistence.validator(nonvalidatedValue, DEFAULT_VALUE$7);\n            const validatedValueLoadable = validatorResult instanceof DefaultValue$2 ? defaultLoadable : loadableWithValue$3(validatorResult);\n            cachedAnswerForUnvalidatedValue = validatedValueLoadable;\n            return cachedAnswerForUnvalidatedValue;\n        } else {\n            return defaultLoadable;\n        }\n    }\n    function invalidateAtom() {\n        cachedAnswerForUnvalidatedValue = undefined;\n    }\n    function setAtom(_store, state, newValue) {\n        // Bail out if we're being set to the existing value, or if we're being\n        // reset but have no stored value (validated or unvalidated) to reset from:\n        if (state.atomValues.has(key)) {\n            const existing = Recoil_nullthrows(state.atomValues.get(key));\n            if (existing.state === \"hasValue\" && newValue === existing.contents) {\n                return new Map();\n            }\n        } else if (!state.nonvalidatedAtoms.has(key) && newValue instanceof DefaultValue$2) {\n            return new Map();\n        }\n        maybeFreezeValueOrPromise(newValue);\n        cachedAnswerForUnvalidatedValue = undefined; // can be released now if it was previously in use\n        return new Map().set(key, loadableWithValue$3(newValue));\n    }\n    function shouldDeleteConfigOnReleaseAtom() {\n        return getConfigDeletionHandler$2(key) !== undefined && liveStoresCount <= 0;\n    }\n    const node = registerNode$2({\n        key,\n        nodeType: \"atom\",\n        peek: peekAtom,\n        get: getAtom,\n        set: setAtom,\n        init: initAtom,\n        invalidate: invalidateAtom,\n        shouldDeleteConfigOnRelease: shouldDeleteConfigOnReleaseAtom,\n        dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n        persistence_UNSTABLE: options.persistence_UNSTABLE ? {\n            type: options.persistence_UNSTABLE.type,\n            backButton: options.persistence_UNSTABLE.backButton\n        } : undefined,\n        shouldRestoreFromSnapshots: true,\n        retainedBy\n    });\n    return node;\n} // prettier-ignore\nfunction atom(options) {\n    if (true) {\n        if (typeof options.key !== \"string\") {\n            throw Recoil_err(\"A key option with a unique string value must be provided when creating an atom.\");\n        }\n    }\n    const { ...restOptions } = options;\n    const optionsDefault = \"default\" in options ? options.default : new Promise(()=>{});\n    if (isRecoilValue$4(optionsDefault) // Continue to use atomWithFallback for promise defaults for scoped atoms\n    ) {\n        return atomWithFallback({\n            ...restOptions,\n            default: optionsDefault // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n        }); // @fb-only: } else if (scopeRules_APPEND_ONLY_READ_THE_DOCS\n    // @fb-only: && !isPromise(optionsDefault)\n    // @fb-only: && !isLoadable(optionsDefault)\n    // @fb-only: ) {\n    // @fb-only: return scopedAtom<T>({\n    // @fb-only: ...restOptions,\n    // @fb-only: default: unwrap<T>(optionsDefault),\n    // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n    // @fb-only: });\n    } else {\n        return baseAtom({\n            ...restOptions,\n            default: optionsDefault\n        });\n    }\n}\nfunction atomWithFallback(options) {\n    const base = atom({\n        ...options,\n        default: DEFAULT_VALUE$7,\n        persistence_UNSTABLE: options.persistence_UNSTABLE === undefined ? undefined : {\n            ...options.persistence_UNSTABLE,\n            validator: (storedValue)=>storedValue instanceof DefaultValue$2 ? storedValue : Recoil_nullthrows(options.persistence_UNSTABLE).validator(storedValue, DEFAULT_VALUE$7)\n        },\n        // TODO Hack for now.\n        effects: options.effects,\n        // flowlint-line unclear-type: off\n        effects_UNSTABLE: options.effects_UNSTABLE // flowlint-line unclear-type: off\n    }); // $FlowFixMe[incompatible-call]\n    const sel = Recoil_selector({\n        key: \"\".concat(options.key, \"__withFallback\"),\n        get: (param)=>{\n            let { get } = param;\n            const baseValue = get(base);\n            return baseValue instanceof DefaultValue$2 ? options.default : baseValue;\n        },\n        // $FlowFixMe[incompatible-call]\n        set: (param, newValue)=>{\n            let { set } = param;\n            return set(base, newValue);\n        },\n        // This selector does not need to cache as it is a wrapper selector\n        // and the selector within the wrapper selector will have a cache\n        // option by default\n        cachePolicy_UNSTABLE: {\n            eviction: \"most-recent\"\n        },\n        dangerouslyAllowMutability: options.dangerouslyAllowMutability\n    });\n    setConfigDeletionHandler$1(sel.key, getConfigDeletionHandler$2(options.key));\n    return sel;\n} // $FlowFixMe[missing-local-annot]\natom.value = (value)=>new WrappedValue$2(value);\nvar Recoil_atom = atom;\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ class MapCache {\n    size() {\n        return this._map.size;\n    }\n    has(key) {\n        return this._map.has(this._keyMapper(key));\n    }\n    get(key) {\n        return this._map.get(this._keyMapper(key));\n    }\n    set(key, val) {\n        this._map.set(this._keyMapper(key), val);\n    }\n    delete(key) {\n        this._map.delete(this._keyMapper(key));\n    }\n    clear() {\n        this._map.clear();\n    }\n    constructor(options){\n        var _options$mapKey;\n        _defineProperty(this, \"_map\", void 0);\n        _defineProperty(this, \"_keyMapper\", void 0);\n        this._map = new Map();\n        this._keyMapper = (_options$mapKey = options === null || options === void 0 ? void 0 : options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : (v)=>v;\n    }\n}\nvar Recoil_MapCache = {\n    MapCache\n};\nvar Recoil_MapCache_1 = Recoil_MapCache.MapCache;\nvar Recoil_MapCache$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    MapCache: Recoil_MapCache_1\n});\nconst { LRUCache: LRUCache$2 } = Recoil_LRUCache$1;\nconst { MapCache: MapCache$1 } = Recoil_MapCache$1;\nconst defaultPolicy$1 = {\n    equality: \"reference\",\n    eviction: \"none\",\n    maxSize: Infinity\n};\nfunction cacheFromPolicy() {\n    let { equality = defaultPolicy$1.equality, eviction = defaultPolicy$1.eviction, maxSize = defaultPolicy$1.maxSize } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultPolicy$1;\n    const valueMapper = getValueMapper$1(equality);\n    const cache = getCache(eviction, maxSize, valueMapper);\n    return cache;\n}\nfunction getValueMapper$1(equality) {\n    switch(equality){\n        case \"reference\":\n            return (val)=>val;\n        case \"value\":\n            return (val)=>Recoil_stableStringify(val);\n    }\n    throw Recoil_err(\"Unrecognized equality policy \".concat(equality));\n}\nfunction getCache(eviction, maxSize, mapKey) {\n    switch(eviction){\n        case \"keep-all\":\n            return new MapCache$1({\n                mapKey\n            });\n        case \"lru\":\n            return new LRUCache$2({\n                mapKey,\n                maxSize: Recoil_nullthrows(maxSize)\n            });\n        case \"most-recent\":\n            return new LRUCache$2({\n                mapKey,\n                maxSize: 1\n            });\n    }\n    throw Recoil_err(\"Unrecognized eviction policy \".concat(eviction));\n}\nvar Recoil_cacheFromPolicy = cacheFromPolicy;\n// @fb-only: import type {ScopeRules} from 'Recoil_ScopedAtom';\nconst { setConfigDeletionHandler: setConfigDeletionHandler$2 } = Recoil_Node;\n// Process scopeRules to handle any entries which are functions taking parameters\n// prettier-ignore\n// @fb-only: function mapScopeRules<P>(\n// @fb-only: scopeRules?: ParameterizedScopeRules<P>,\n// @fb-only: param: P,\n// @fb-only: ): ScopeRules | void {\n// @fb-only: return scopeRules?.map(rule =>\n// @fb-only: Array.isArray(rule)\n// @fb-only: ? rule.map(entry => (typeof entry === 'function' ? entry(param) : entry))\n// @fb-only: : rule,\n// @fb-only: );\n// @fb-only: }\n/*\nA function which returns an atom based on the input parameter.\n\nEach unique parameter returns a unique atom. E.g.,\n\n  const f = atomFamily(...);\n  f({a: 1}) => an atom\n  f({a: 2}) => a different atom\n\nThis allows components to persist local, private state using atoms.  Each\ninstance of the component may have a different key, which it uses as the\nparameter for a family of atoms; in this way, each component will have\nits own atom not shared by other instances.  These state keys may be composed\ninto children's state keys as well.\n*/ function atomFamily(options) {\n    var _options$cachePolicyF, _options$cachePolicyF2;\n    const atomCache = Recoil_cacheFromPolicy({\n        equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : \"value\",\n        eviction: \"keep-all\"\n    }); // Simple atomFamily implementation to cache individual atoms based\n    // on the parameter value equality.\n    return (params)=>{\n        var _stableStringify, _options$effects;\n        const cachedAtom = atomCache.get(params);\n        if (cachedAtom != null) {\n            return cachedAtom;\n        }\n        const { cachePolicyForParams_UNSTABLE, ...atomOptions } = options;\n        const optionsDefault = \"default\" in options ? options.default : new Promise(()=>{});\n        const newAtom = Recoil_atom({\n            ...atomOptions,\n            key: \"\".concat(options.key, \"__\").concat((_stableStringify = Recoil_stableStringify(params)) !== null && _stableStringify !== void 0 ? _stableStringify : \"void\"),\n            default: typeof optionsDefault === \"function\" ? // Flow doesn't know that T isn't a function, so we need to case to any\n            // $FlowIssue[incompatible-use]\n            optionsDefault(params) : optionsDefault,\n            retainedBy_UNSTABLE: typeof options.retainedBy_UNSTABLE === \"function\" ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE,\n            effects: typeof options.effects === \"function\" ? options.effects(params) : typeof options.effects_UNSTABLE === \"function\" ? options.effects_UNSTABLE(params) : (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE // prettier-ignore\n        });\n        atomCache.set(params, newAtom);\n        setConfigDeletionHandler$2(newAtom.key, ()=>{\n            atomCache.delete(params);\n        });\n        return newAtom;\n    };\n}\nvar Recoil_atomFamily = atomFamily;\nconst { setConfigDeletionHandler: setConfigDeletionHandler$3 } = Recoil_Node;\n// Keep in mind the parameter needs to be serializable as a cahche key\n// using Recoil_stableStringify\n// Add a unique index to each selector in case the cache implementation allows\n// duplicate keys based on equivalent stringified parameters\nlet nextIndex = 0;\n/* eslint-disable no-redeclare */ // Return a function that returns members of a family of selectors of the same type\n// E.g.,\n//\n// const s = selectorFamily(...);\n// s({a: 1}) => a selector\n// s({a: 2}) => a different selector\n//\n// By default, the selectors are distinguished by distinct values of the\n// parameter based on value equality, not reference equality.  This allows using\n// object literals or other equivalent objects at callsites to not create\n// duplicate cache entries.  This behavior may be overridden with the\n// cacheImplementationForParams option.\nfunction selectorFamily(options) {\n    var _options$cachePolicyF, _options$cachePolicyF2;\n    const selectorCache = Recoil_cacheFromPolicy({\n        equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : \"value\",\n        eviction: \"keep-all\"\n    });\n    return (params)=>{\n        var _stableStringify;\n        // Throw an error with selector key so that it is clear which\n        // selector is causing an error\n        let cachedSelector;\n        try {\n            cachedSelector = selectorCache.get(params);\n        } catch (error) {\n            throw Recoil_err(\"Problem with cache lookup for selector \".concat(options.key, \": \").concat(error.message));\n        }\n        if (cachedSelector != null) {\n            return cachedSelector;\n        }\n        const myKey = \"\".concat(options.key, \"__selectorFamily/\").concat((_stableStringify = Recoil_stableStringify(params, {\n            // It is possible to use functions in parameters if the user uses\n            // a cache with reference equality thanks to the incrementing index.\n            allowFunctions: true\n        })) !== null && _stableStringify !== void 0 ? _stableStringify : \"void\", \"/\").concat(nextIndex++); // Append index in case values serialize to the same key string\n        const myGet = (callbacks)=>options.get(params)(callbacks);\n        const myCachePolicy = options.cachePolicy_UNSTABLE;\n        const retainedBy = typeof options.retainedBy_UNSTABLE === \"function\" ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE;\n        let newSelector;\n        if (options.set != null) {\n            const set = options.set;\n            const mySet = (callbacks, newValue)=>set(params)(callbacks, newValue);\n            newSelector = Recoil_selector({\n                key: myKey,\n                get: myGet,\n                set: mySet,\n                cachePolicy_UNSTABLE: myCachePolicy,\n                dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n                retainedBy_UNSTABLE: retainedBy\n            });\n        } else {\n            newSelector = Recoil_selector({\n                key: myKey,\n                get: myGet,\n                cachePolicy_UNSTABLE: myCachePolicy,\n                dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n                retainedBy_UNSTABLE: retainedBy\n            });\n        }\n        selectorCache.set(params, newSelector);\n        setConfigDeletionHandler$3(newSelector.key, ()=>{\n            selectorCache.delete(params);\n        });\n        return newSelector;\n    };\n}\n/* eslint-enable no-redeclare */ var Recoil_selectorFamily = selectorFamily;\n// flowlint-next-line unclear-type:off\nconst constantSelector = Recoil_selectorFamily({\n    key: \"__constant\",\n    get: (constant)=>()=>constant,\n    cachePolicyForParams_UNSTABLE: {\n        equality: \"reference\"\n    }\n}); // Function that returns a selector which always produces the\n// same constant value.  It may be called multiple times with the\n// same value, based on reference equality, and will provide the\n// same selector.\nfunction constSelector(constant) {\n    return constantSelector(constant);\n}\nvar Recoil_constSelector = constSelector;\n// flowlint-next-line unclear-type:off\nconst throwingSelector = Recoil_selectorFamily({\n    key: \"__error\",\n    get: (message)=>()=>{\n            throw Recoil_err(message);\n        },\n    // TODO Why?\n    cachePolicyForParams_UNSTABLE: {\n        equality: \"reference\"\n    }\n}); // Function that returns a selector which always throws an error\n// with the provided message.\nfunction errorSelector(message) {\n    return throwingSelector(message);\n}\nvar Recoil_errorSelector = errorSelector;\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Wraps another recoil value and prevents writing to it.\n *\n * \n * @format\n * @oncall recoil\n */ function readOnlySelector(atom) {\n    // flowlint-next-line unclear-type: off\n    return atom;\n}\nvar Recoil_readOnlySelector = readOnlySelector;\nconst { loadableWithError: loadableWithError$3, loadableWithPromise: loadableWithPromise$3, loadableWithValue: loadableWithValue$4 } = Recoil_Loadable$1;\n/////////////////\n//  TRUTH TABLE\n/////////////////\n// Dependencies        waitForNone         waitForAny        waitForAll       waitForAllSettled\n//  [loading, loading]  [Promise, Promise]  Promise           Promise         Promise\n//  [value, loading]    [value, Promise]    [value, Promise]  Promise         Promise\n//  [value, value]      [value, value]      [value, value]    [value, value]  [value, value]\n//\n//  [error, loading]    [Error, Promise]    [Error, Promise]  Error           Promise\n//  [error, error]      [Error, Error]      [Error, Error]    Error           [error, error]\n//  [value, error]      [value, Error]      [value, Error]    Error           [value, error]\n// Issue parallel requests for all dependencies and return the current\n// status if they have results, have some error, or are still pending.\nfunction concurrentRequests(getRecoilValue, deps) {\n    const results = Array(deps.length).fill(undefined);\n    const exceptions = Array(deps.length).fill(undefined);\n    for (const [i, dep] of deps.entries()){\n        try {\n            results[i] = getRecoilValue(dep);\n        } catch (e) {\n            // exceptions can either be Promises of pending results or real errors\n            exceptions[i] = e;\n        }\n    }\n    return [\n        results,\n        exceptions\n    ];\n}\nfunction isError(exp) {\n    return exp != null && !Recoil_isPromise(exp);\n}\nfunction unwrapDependencies(dependencies) {\n    return Array.isArray(dependencies) ? dependencies : Object.getOwnPropertyNames(dependencies).map((key)=>dependencies[key]);\n}\nfunction wrapResults(dependencies, /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n * LTI update could not be added via codemod */ results) {\n    return Array.isArray(dependencies) ? results : Object.getOwnPropertyNames(dependencies).reduce((out, key, idx)=>({\n            ...out,\n            [key]: results[idx]\n        }), {});\n}\nfunction wrapLoadables(dependencies, results, exceptions) {\n    const output = exceptions.map((exception, idx)=>exception == null ? loadableWithValue$4(results[idx]) : Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));\n    return wrapResults(dependencies, output);\n}\nfunction combineAsyncResultsWithSyncResults(syncResults, asyncResults) {\n    return asyncResults.map((result, idx)=>/**\n   * it's important we use === undefined as opposed to == null, because the\n   * resolved value of the async promise could be `null`, in which case we\n   * don't want to use syncResults[idx], which would be undefined. If async\n   * promise resolves to `undefined`, that's ok because `syncResults[idx]`\n   * will also be `undefined`. That's a little hacky, but it works.\n   */ result === undefined ? syncResults[idx] : result);\n} // Selector that requests all dependencies in parallel and immediately returns\n// current results without waiting.\nconst waitForNone = Recoil_selectorFamily({\n    key: \"__waitForNone\",\n    get: (dependencies)=>(param)=>{\n            let { get } = param;\n            // Issue requests for all dependencies in parallel.\n            const deps = unwrapDependencies(dependencies);\n            const [results, exceptions] = concurrentRequests(get, deps); // Always return the current status of the results; never block.\n            return wrapLoadables(dependencies, results, exceptions);\n        },\n    dangerouslyAllowMutability: true\n}); // Selector that requests all dependencies in parallel and waits for at least\n// one to be available before returning results.  It will only error if all\n// dependencies have errors.\nconst waitForAny = Recoil_selectorFamily({\n    key: \"__waitForAny\",\n    get: (dependencies)=>(param)=>{\n            let { get } = param;\n            // Issue requests for all dependencies in parallel.\n            // Exceptions can either be Promises of pending results or real errors\n            const deps = unwrapDependencies(dependencies);\n            const [results, exceptions] = concurrentRequests(get, deps); // If any results are available, value or error, return the current status\n            if (exceptions.some((exp)=>!Recoil_isPromise(exp))) {\n                return wrapLoadables(dependencies, results, exceptions);\n            } // Otherwise, return a promise that will resolve when the next result is\n            // available, whichever one happens to be next.  But, if all pending\n            // dependencies end up with errors, then reject the promise.\n            return new Promise((resolve)=>{\n                for (const [i, exp] of exceptions.entries()){\n                    if (Recoil_isPromise(exp)) {\n                        exp.then((result)=>{\n                            results[i] = result;\n                            exceptions[i] = undefined;\n                            resolve(wrapLoadables(dependencies, results, exceptions));\n                        }).catch((error)=>{\n                            exceptions[i] = error;\n                            resolve(wrapLoadables(dependencies, results, exceptions));\n                        });\n                    }\n                }\n            });\n        },\n    dangerouslyAllowMutability: true\n}); // Selector that requests all dependencies in parallel and waits for all to be\n// available before returning a value.  It will error if any dependencies error.\nconst waitForAll = Recoil_selectorFamily({\n    key: \"__waitForAll\",\n    get: (dependencies)=>(param)=>{\n            let { get } = param;\n            // Issue requests for all dependencies in parallel.\n            // Exceptions can either be Promises of pending results or real errors\n            const deps = unwrapDependencies(dependencies);\n            const [results, exceptions] = concurrentRequests(get, deps); // If all results are available, return the results\n            if (exceptions.every((exp)=>exp == null)) {\n                return wrapResults(dependencies, results);\n            } // If we have any errors, throw the first error\n            const error = exceptions.find(isError);\n            if (error != null) {\n                throw error;\n            } // Otherwise, return a promise that will resolve when all results are available\n            return Promise.all(exceptions).then((exceptionResults)=>wrapResults(dependencies, combineAsyncResultsWithSyncResults(results, exceptionResults)));\n        },\n    dangerouslyAllowMutability: true\n});\nconst waitForAllSettled = Recoil_selectorFamily({\n    key: \"__waitForAllSettled\",\n    get: (dependencies)=>(param)=>{\n            let { get } = param;\n            // Issue requests for all dependencies in parallel.\n            // Exceptions can either be Promises of pending results or real errors\n            const deps = unwrapDependencies(dependencies);\n            const [results, exceptions] = concurrentRequests(get, deps); // If all results are available, return the results\n            if (exceptions.every((exp)=>!Recoil_isPromise(exp))) {\n                return wrapLoadables(dependencies, results, exceptions);\n            } // Wait for all results to settle\n            return Promise.all(exceptions.map((exp, i)=>Recoil_isPromise(exp) ? exp.then((result)=>{\n                    results[i] = result;\n                    exceptions[i] = undefined;\n                }).catch((error)=>{\n                    results[i] = undefined;\n                    exceptions[i] = error;\n                }) : null)) // Then wrap them as loadables\n            .then(()=>wrapLoadables(dependencies, results, exceptions));\n        },\n    dangerouslyAllowMutability: true\n});\nconst noWait = Recoil_selectorFamily({\n    key: \"__noWait\",\n    get: (dependency)=>(param)=>{\n            let { get } = param;\n            try {\n                return Recoil_selector.value(loadableWithValue$4(get(dependency)));\n            } catch (exception) {\n                return Recoil_selector.value(Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));\n            }\n        },\n    dangerouslyAllowMutability: true\n});\nvar Recoil_WaitFor = {\n    waitForNone,\n    waitForAny,\n    waitForAll,\n    waitForAllSettled,\n    noWait\n};\nconst { RecoilLoadable } = Recoil_Loadable$1;\nconst { DefaultValue: DefaultValue$3 } = Recoil_Node;\nconst { RecoilRoot: RecoilRoot$2, useRecoilStoreID: useRecoilStoreID$1 } = Recoil_RecoilRoot;\nconst { isRecoilValue: isRecoilValue$5 } = Recoil_RecoilValue$1;\nconst { retentionZone: retentionZone$1 } = Recoil_RetentionZone;\nconst { freshSnapshot: freshSnapshot$2 } = Recoil_Snapshot$1;\nconst { useRecoilState: useRecoilState$1, useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1, useRecoilStateLoadable: useRecoilStateLoadable$1, useRecoilValue: useRecoilValue$1, useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1, useRecoilValueLoadable: useRecoilValueLoadable$1, useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1, useResetRecoilState: useResetRecoilState$1, useSetRecoilState: useSetRecoilState$1 } = Recoil_Hooks;\nconst { useGotoRecoilSnapshot: useGotoRecoilSnapshot$1, useRecoilSnapshot: useRecoilSnapshot$1, useRecoilTransactionObserver: useRecoilTransactionObserver$1 } = Recoil_SnapshotHooks;\nconst { useRecoilCallback: useRecoilCallback$1 } = Recoil_useRecoilCallback;\nconst { noWait: noWait$1, waitForAll: waitForAll$1, waitForAllSettled: waitForAllSettled$1, waitForAny: waitForAny$1, waitForNone: waitForNone$1 } = Recoil_WaitFor;\nvar Recoil_index = {\n    // Types\n    DefaultValue: DefaultValue$3,\n    isRecoilValue: isRecoilValue$5,\n    RecoilLoadable,\n    // Global Recoil environment settiongs\n    RecoilEnv: Recoil_RecoilEnv,\n    // Recoil Root\n    RecoilRoot: RecoilRoot$2,\n    useRecoilStoreID: useRecoilStoreID$1,\n    useRecoilBridgeAcrossReactRoots_UNSTABLE: Recoil_useRecoilBridgeAcrossReactRoots,\n    // Atoms/Selectors\n    atom: Recoil_atom,\n    selector: Recoil_selector,\n    // Convenience Atoms/Selectors\n    atomFamily: Recoil_atomFamily,\n    selectorFamily: Recoil_selectorFamily,\n    constSelector: Recoil_constSelector,\n    errorSelector: Recoil_errorSelector,\n    readOnlySelector: Recoil_readOnlySelector,\n    // Concurrency Helpers for Atoms/Selectors\n    noWait: noWait$1,\n    waitForNone: waitForNone$1,\n    waitForAny: waitForAny$1,\n    waitForAll: waitForAll$1,\n    waitForAllSettled: waitForAllSettled$1,\n    // Hooks for Atoms/Selectors\n    useRecoilValue: useRecoilValue$1,\n    useRecoilValueLoadable: useRecoilValueLoadable$1,\n    useRecoilState: useRecoilState$1,\n    useRecoilStateLoadable: useRecoilStateLoadable$1,\n    useSetRecoilState: useSetRecoilState$1,\n    useResetRecoilState: useResetRecoilState$1,\n    useGetRecoilValueInfo_UNSTABLE: Recoil_useGetRecoilValueInfo,\n    useRecoilRefresher_UNSTABLE: Recoil_useRecoilRefresher,\n    useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,\n    useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,\n    useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,\n    // Hooks for complex operations\n    useRecoilCallback: useRecoilCallback$1,\n    useRecoilTransaction_UNSTABLE: Recoil_useRecoilTransaction,\n    // Snapshots\n    useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,\n    useRecoilSnapshot: useRecoilSnapshot$1,\n    useRecoilTransactionObserver_UNSTABLE: useRecoilTransactionObserver$1,\n    snapshot_UNSTABLE: freshSnapshot$2,\n    // Memory Management\n    useRetain: Recoil_useRetain,\n    retentionZone: retentionZone$1\n};\nvar Recoil_index_1 = Recoil_index.DefaultValue;\nvar Recoil_index_2 = Recoil_index.isRecoilValue;\nvar Recoil_index_3 = Recoil_index.RecoilLoadable;\nvar Recoil_index_4 = Recoil_index.RecoilEnv;\nvar Recoil_index_5 = Recoil_index.RecoilRoot;\nvar Recoil_index_6 = Recoil_index.useRecoilStoreID;\nvar Recoil_index_7 = Recoil_index.useRecoilBridgeAcrossReactRoots_UNSTABLE;\nvar Recoil_index_8 = Recoil_index.atom;\nvar Recoil_index_9 = Recoil_index.selector;\nvar Recoil_index_10 = Recoil_index.atomFamily;\nvar Recoil_index_11 = Recoil_index.selectorFamily;\nvar Recoil_index_12 = Recoil_index.constSelector;\nvar Recoil_index_13 = Recoil_index.errorSelector;\nvar Recoil_index_14 = Recoil_index.readOnlySelector;\nvar Recoil_index_15 = Recoil_index.noWait;\nvar Recoil_index_16 = Recoil_index.waitForNone;\nvar Recoil_index_17 = Recoil_index.waitForAny;\nvar Recoil_index_18 = Recoil_index.waitForAll;\nvar Recoil_index_19 = Recoil_index.waitForAllSettled;\nvar Recoil_index_20 = Recoil_index.useRecoilValue;\nvar Recoil_index_21 = Recoil_index.useRecoilValueLoadable;\nvar Recoil_index_22 = Recoil_index.useRecoilState;\nvar Recoil_index_23 = Recoil_index.useRecoilStateLoadable;\nvar Recoil_index_24 = Recoil_index.useSetRecoilState;\nvar Recoil_index_25 = Recoil_index.useResetRecoilState;\nvar Recoil_index_26 = Recoil_index.useGetRecoilValueInfo_UNSTABLE;\nvar Recoil_index_27 = Recoil_index.useRecoilRefresher_UNSTABLE;\nvar Recoil_index_28 = Recoil_index.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_29 = Recoil_index.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_30 = Recoil_index.useRecoilState_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_31 = Recoil_index.useRecoilCallback;\nvar Recoil_index_32 = Recoil_index.useRecoilTransaction_UNSTABLE;\nvar Recoil_index_33 = Recoil_index.useGotoRecoilSnapshot;\nvar Recoil_index_34 = Recoil_index.useRecoilSnapshot;\nvar Recoil_index_35 = Recoil_index.useRecoilTransactionObserver_UNSTABLE;\nvar Recoil_index_36 = Recoil_index.snapshot_UNSTABLE;\nvar Recoil_index_37 = Recoil_index.useRetain;\nvar Recoil_index_38 = Recoil_index.retentionZone;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Recoil_index);\n\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"Recoil_gkx_OSS\");\n$RefreshReg$(_c1, \"Batcher\");\n$RefreshReg$(_c2, \"RecoilRoot_INTERNAL\");\n$RefreshReg$(_c3, \"RecoilRoot\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWNvaWwvZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQjtBQUNPO0FBRWpDOzs7Ozs7Ozs7Q0FTQyxHQUVELFNBQVNFLElBQUlDLE9BQU87SUFDbEIsTUFBTUMsUUFBUSxJQUFJQyxNQUFNRixVQUFVLG9FQUFvRTtJQUN0RyxrQ0FBa0M7SUFFbEMsSUFBSUMsTUFBTUUsS0FBSyxLQUFLQyxXQUFXO1FBQzdCLDRDQUE0QztRQUM1QyxJQUFJO1lBQ0YsTUFBTUg7UUFDUixFQUFFLE9BQU9JLEdBQUcsQ0FBQyxFQUFFLGdFQUFnRTtJQUVqRjtJQUVBLE9BQU9KO0FBQ1Q7QUFFQSxJQUFJSyxRQUFRUDtBQUVaLFlBQVk7QUFHWixJQUFJUSxhQUFhRDtBQUVqQjs7Ozs7Ozs7O0NBU0MsR0FFRCw0RUFBNEU7QUFDNUUsMEVBQTBFO0FBQzFFLFVBQVU7QUFDVix3Q0FBd0M7QUFDeEMsU0FBU0UsVUFBVUMsQ0FBQztJQUNsQixPQUFPLENBQUMsQ0FBQ0EsS0FBSyxPQUFPQSxFQUFFQyxJQUFJLEtBQUs7QUFDbEM7QUFFQSxJQUFJQyxtQkFBbUJIO0FBRXZCLFNBQVNJLFdBQVdDLENBQUMsRUFBRWIsT0FBTztJQUM1QixJQUFJYSxLQUFLLE1BQU07UUFDYixPQUFPQTtJQUNUO0lBRUEsTUFBTU4sV0FBV1AsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSUEsVUFBVTtBQUN0RTtBQUVBLElBQUljLG9CQUFvQkY7QUFFeEIsU0FBU0csZ0JBQWdCQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsS0FBSztJQUN0QyxJQUFJRCxPQUFPRCxLQUFLO1FBQ2RHLE9BQU9DLGNBQWMsQ0FBQ0osS0FBS0MsS0FBSztZQUM5QkMsT0FBT0E7WUFDUEcsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7UUFDWjtJQUNGLE9BQU87UUFDTFAsR0FBRyxD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QkFBaUI7QUFDcEQsSUFBSXNtQixrQkFBa0JoQyxhQUFhcmtCLG1CQUFtQjtBQUN0RCxJQUFJc21CLGtCQUFrQmpDLGFBQWFHLDhCQUE4QjtBQUNqRSxJQUFJK0Isa0JBQWtCbEMsYUFBYUksMkJBQTJCO0FBQzlELElBQUkrQixrQkFBa0JuQyxhQUFhN2hCLGtEQUFrRDtBQUNyRixJQUFJaWtCLGtCQUFrQnBDLGFBQWE1aEIsMENBQTBDO0FBQzdFLElBQUlpa0Isa0JBQWtCckMsYUFBYTNoQiwwQ0FBMEM7QUFDN0UsSUFBSWlrQixrQkFBa0J0QyxhQUFhNWEsaUJBQWlCO0FBQ3BELElBQUltZCxrQkFBa0J2QyxhQUFhSyw2QkFBNkI7QUFDaEUsSUFBSW1DLGtCQUFrQnhDLGFBQWF0ZSxxQkFBcUI7QUFDeEQsSUFBSStnQixrQkFBa0J6QyxhQUFhbGYsaUJBQWlCO0FBQ3BELElBQUk0aEIsa0JBQWtCMUMsYUFBYU0scUNBQXFDO0FBQ3hFLElBQUlxQyxrQkFBa0IzQyxhQUFhTyxpQkFBaUI7QUFDcEQsSUFBSXFDLGtCQUFrQjVDLGFBQWFubkIsU0FBUztBQUM1QyxJQUFJZ3FCLGtCQUFrQjdDLGFBQWF2K0IsYUFBYTtBQUVoRCwrREFBZXUrQixZQUFZQSxFQUFDO0FBQ284QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVjb2lsL2VzL2luZGV4LmpzPzNhNjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCByZWFjdERvbSBmcm9tICdyZWFjdC1kb20nO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmZ1bmN0aW9uIGVycihtZXNzYWdlKSB7XG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpOyAvLyBJbiBWOCwgRXJyb3Igb2JqZWN0cyBrZWVwIHRoZSBjbG9zdXJlIHNjb3BlIGNoYWluIGFsaXZlIHVudGlsIHRoZVxuICAvLyBlcnIuc3RhY2sgcHJvcGVydHkgaXMgYWNjZXNzZWQuXG5cbiAgaWYgKGVycm9yLnN0YWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBJRSBzZXRzIHRoZSBzdGFjayBvbmx5IGlmIGVycm9yIGlzIHRocm93blxuICAgIHRyeSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGNhdGNoIChfKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZiLXd3dy9uby11bnVzZWQtY2F0Y2gtYmluZGluZ3MsIG5vLWVtcHR5XG5cbiAgfVxuXG4gIHJldHVybiBlcnJvcjtcbn1cblxudmFyIGVycl8xID0gZXJyO1xuXG4vLyBAb3NzLW9ubHlcblxuXG52YXIgUmVjb2lsX2VyciA9IGVycl8xO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbi8vIFNwbGl0IGRlY2xhcmF0aW9uIGFuZCBpbXBsZW1lbnRhdGlvbiB0byBhbGxvdyB0aGlzIGZ1bmN0aW9uIHRvIHByZXRlbmQgdG9cbi8vIGNoZWNrIGZvciBhY3R1YWwgaW5zdGFuY2Ugb2YgUHJvbWlzZSBpbnN0ZWFkIG9mIHNvbWV0aGluZyB3aXRoIGEgYHRoZW5gXG4vLyBtZXRob2QuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5mdW5jdGlvbiBpc1Byb21pc2UocCkge1xuICByZXR1cm4gISFwICYmIHR5cGVvZiBwLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5cbnZhciBSZWNvaWxfaXNQcm9taXNlID0gaXNQcm9taXNlO1xuXG5mdW5jdGlvbiBudWxsdGhyb3dzKHgsIG1lc3NhZ2UpIHtcbiAgaWYgKHggIT0gbnVsbCkge1xuICAgIHJldHVybiB4O1xuICB9XG5cbiAgdGhyb3cgUmVjb2lsX2VycihtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAnR290IHVuZXhwZWN0ZWQgbnVsbCBvciB1bmRlZmluZWQnKTtcbn1cblxudmFyIFJlY29pbF9udWxsdGhyb3dzID0gbnVsbHRocm93cztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmNsYXNzIEJhc2VMb2FkYWJsZSB7XG4gIGdldFZhbHVlKCkge1xuICAgIHRocm93IFJlY29pbF9lcnIoJ0Jhc2VMb2FkYWJsZScpO1xuICB9XG5cbiAgdG9Qcm9taXNlKCkge1xuICAgIHRocm93IFJlY29pbF9lcnIoJ0Jhc2VMb2FkYWJsZScpO1xuICB9XG5cbiAgdmFsdWVNYXliZSgpIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdCYXNlTG9hZGFibGUnKTtcbiAgfVxuXG4gIHZhbHVlT3JUaHJvdygpIHtcbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICB0aHJvdyBSZWNvaWxfZXJyKGBMb2FkYWJsZSBleHBlY3RlZCB2YWx1ZSwgYnV0IGluIFwiJHt0aGlzLnN0YXRlfVwiIHN0YXRlYCk7XG4gIH1cblxuICBwcm9taXNlTWF5YmUoKSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycignQmFzZUxvYWRhYmxlJyk7XG4gIH1cblxuICBwcm9taXNlT3JUaHJvdygpIHtcbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICB0aHJvdyBSZWNvaWxfZXJyKGBMb2FkYWJsZSBleHBlY3RlZCBwcm9taXNlLCBidXQgaW4gXCIke3RoaXMuc3RhdGV9XCIgc3RhdGVgKTtcbiAgfVxuXG4gIGVycm9yTWF5YmUoKSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycignQmFzZUxvYWRhYmxlJyk7XG4gIH1cblxuICBlcnJvck9yVGhyb3coKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgdGhyb3cgUmVjb2lsX2VycihgTG9hZGFibGUgZXhwZWN0ZWQgZXJyb3IsIGJ1dCBpbiBcIiR7dGhpcy5zdGF0ZX1cIiBzdGF0ZWApO1xuICB9XG5cbiAgaXMob3RoZXIpIHtcbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICByZXR1cm4gb3RoZXIuc3RhdGUgPT09IHRoaXMuc3RhdGUgJiYgb3RoZXIuY29udGVudHMgPT09IHRoaXMuY29udGVudHM7XG4gIH1cblxuICBtYXAoX21hcCkge1xuICAgIHRocm93IFJlY29pbF9lcnIoJ0Jhc2VMb2FkYWJsZScpO1xuICB9XG5cbn1cblxuY2xhc3MgVmFsdWVMb2FkYWJsZSBleHRlbmRzIEJhc2VMb2FkYWJsZSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsICdoYXNWYWx1ZScpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udGVudHNcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuY29udGVudHMgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzO1xuICB9XG5cbiAgdG9Qcm9taXNlKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5jb250ZW50cyk7XG4gIH1cblxuICB2YWx1ZU1heWJlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzO1xuICB9XG5cbiAgdmFsdWVPclRocm93KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzO1xuICB9XG5cbiAgcHJvbWlzZU1heWJlKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBlcnJvck1heWJlKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBtYXAobWFwKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5leHQgPSBtYXAodGhpcy5jb250ZW50cyk7XG4gICAgICByZXR1cm4gUmVjb2lsX2lzUHJvbWlzZShuZXh0KSA/IGxvYWRhYmxlV2l0aFByb21pc2UobmV4dCkgOiBpc0xvYWRhYmxlKG5leHQpID8gbmV4dCA6IGxvYWRhYmxlV2l0aFZhbHVlKG5leHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBSZWNvaWxfaXNQcm9taXNlKGUpID8gLy8gSWYgd2UgXCJzdXNwZW5kZWRcIiwgdGhlbiB0cnkgYWdhaW4uXG4gICAgICAvLyBlcnJvcnMgYW5kIHN1YnNlcXVlbnQgcmV0cmllcyB3aWxsIGJlIGhhbmRsZWQgaW4gJ2xvYWRpbmcnIGNhc2VcbiAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgbG9hZGFibGVXaXRoUHJvbWlzZShlLm5leHQoKCkgPT4gdGhpcy5tYXAobWFwKSkpIDogbG9hZGFibGVXaXRoRXJyb3IoZSk7XG4gICAgfVxuICB9XG5cbn1cblxuY2xhc3MgRXJyb3JMb2FkYWJsZSBleHRlbmRzIEJhc2VMb2FkYWJsZSB7XG4gIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsICdoYXNFcnJvcicpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udGVudHNcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuY29udGVudHMgPSBlcnJvcjtcbiAgfVxuXG4gIGdldFZhbHVlKCkge1xuICAgIHRocm93IHRoaXMuY29udGVudHM7XG4gIH1cblxuICB0b1Byb21pc2UoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuY29udGVudHMpO1xuICB9XG5cbiAgdmFsdWVNYXliZSgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcHJvbWlzZU1heWJlKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBlcnJvck1heWJlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzO1xuICB9XG5cbiAgZXJyb3JPclRocm93KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzO1xuICB9XG5cbiAgbWFwKF9tYXApIHtcbiAgICAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufVxuXG5jbGFzcyBMb2FkaW5nTG9hZGFibGUgZXh0ZW5kcyBCYXNlTG9hZGFibGUge1xuICBjb25zdHJ1Y3Rvcihwcm9taXNlKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsICdsb2FkaW5nJyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250ZW50c1wiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5jb250ZW50cyA9IHByb21pc2U7XG4gIH1cblxuICBnZXRWYWx1ZSgpIHtcbiAgICB0aHJvdyB0aGlzLmNvbnRlbnRzO1xuICB9XG5cbiAgdG9Qcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzO1xuICB9XG5cbiAgdmFsdWVNYXliZSgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcHJvbWlzZU1heWJlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzO1xuICB9XG5cbiAgcHJvbWlzZU9yVGhyb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICBlcnJvck1heWJlKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBtYXAobWFwKSB7XG4gICAgcmV0dXJuIGxvYWRhYmxlV2l0aFByb21pc2UodGhpcy5jb250ZW50cy50aGVuKHZhbHVlID0+IHtcbiAgICAgIGNvbnN0IG5leHQgPSBtYXAodmFsdWUpO1xuXG4gICAgICBpZiAoaXNMb2FkYWJsZShuZXh0KSkge1xuICAgICAgICBjb25zdCBuZXh0TG9hZGFibGUgPSBuZXh0O1xuXG4gICAgICAgIHN3aXRjaCAobmV4dExvYWRhYmxlLnN0YXRlKSB7XG4gICAgICAgICAgY2FzZSAnaGFzVmFsdWUnOlxuICAgICAgICAgICAgcmV0dXJuIG5leHRMb2FkYWJsZS5jb250ZW50cztcblxuICAgICAgICAgIGNhc2UgJ2hhc0Vycm9yJzpcbiAgICAgICAgICAgIHRocm93IG5leHRMb2FkYWJsZS5jb250ZW50cztcblxuICAgICAgICAgIGNhc2UgJ2xvYWRpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIG5leHRMb2FkYWJsZS5jb250ZW50cztcbiAgICAgICAgfVxuICAgICAgfSAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cblxuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfSkgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF1cbiAgICAuY2F0Y2goZSA9PiB7XG4gICAgICBpZiAoUmVjb2lsX2lzUHJvbWlzZShlKSkge1xuICAgICAgICAvLyB3ZSB3ZXJlIFwic3VzcGVuZGVkLFwiIHRyeSBhZ2FpblxuICAgICAgICByZXR1cm4gZS50aGVuKCgpID0+IHRoaXMubWFwKG1hcCkuY29udGVudHMpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBlO1xuICAgIH0pKTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGxvYWRhYmxlV2l0aFZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG5ldyBWYWx1ZUxvYWRhYmxlKHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIGxvYWRhYmxlV2l0aEVycm9yKGVycm9yKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG5ldyBFcnJvckxvYWRhYmxlKGVycm9yKSk7XG59XG5cbmZ1bmN0aW9uIGxvYWRhYmxlV2l0aFByb21pc2UocHJvbWlzZSkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuZXcgTG9hZGluZ0xvYWRhYmxlKHByb21pc2UpKTtcbn1cblxuZnVuY3Rpb24gbG9hZGFibGVMb2FkaW5nKCkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuZXcgTG9hZGluZ0xvYWRhYmxlKG5ldyBQcm9taXNlKCgpID0+IHt9KSkpO1xufVxuXG5mdW5jdGlvbiBsb2FkYWJsZUFsbEFycmF5KGlucHV0cykge1xuICByZXR1cm4gaW5wdXRzLmV2ZXJ5KGkgPT4gaS5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJykgPyBsb2FkYWJsZVdpdGhWYWx1ZShpbnB1dHMubWFwKGkgPT4gaS5jb250ZW50cykpIDogaW5wdXRzLnNvbWUoaSA9PiBpLnN0YXRlID09PSAnaGFzRXJyb3InKSA/IGxvYWRhYmxlV2l0aEVycm9yKFJlY29pbF9udWxsdGhyb3dzKGlucHV0cy5maW5kKGkgPT4gaS5zdGF0ZSA9PT0gJ2hhc0Vycm9yJyksICdJbnZhbGlkIGxvYWRhYmxlIHBhc3NlZCB0byBsb2FkYWJsZUFsbCcpLmNvbnRlbnRzKSA6IGxvYWRhYmxlV2l0aFByb21pc2UoUHJvbWlzZS5hbGwoaW5wdXRzLm1hcChpID0+IGkuY29udGVudHMpKSk7XG59XG5cbmZ1bmN0aW9uIGxvYWRhYmxlQWxsKGlucHV0cykge1xuICBjb25zdCB1bndyYXBlZElucHV0cyA9IEFycmF5LmlzQXJyYXkoaW5wdXRzKSA/IGlucHV0cyA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGlucHV0cykubWFwKGtleSA9PiBpbnB1dHNba2V5XSk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRJbnB1dHMgPSB1bndyYXBlZElucHV0cy5tYXAoeCA9PiBpc0xvYWRhYmxlKHgpID8geCA6IFJlY29pbF9pc1Byb21pc2UoeCkgPyBsb2FkYWJsZVdpdGhQcm9taXNlKHgpIDogbG9hZGFibGVXaXRoVmFsdWUoeCkpO1xuICBjb25zdCBvdXRwdXQgPSBsb2FkYWJsZUFsbEFycmF5KG5vcm1hbGl6ZWRJbnB1dHMpO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dHMpID8gLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICBvdXRwdXQgOiAvLyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcygpIGhhcyBjb25zaXN0ZW50IGtleSBvcmRlcmluZyB3aXRoIEVTNlxuICAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS1jYWxsXVxuICBvdXRwdXQubWFwKG91dHB1dHMgPT4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5wdXRzKS5yZWR1Y2UoIC8vICRGbG93Rml4TWVbaW52YWxpZC1jb21wdXRlZC1wcm9wXVxuICAob3V0LCBrZXksIGlkeCkgPT4gKHsgLi4ub3V0LFxuICAgIFtrZXldOiBvdXRwdXRzW2lkeF1cbiAgfSksIHt9KSk7XG59XG5cbmZ1bmN0aW9uIGlzTG9hZGFibGUoeCkge1xuICByZXR1cm4geCBpbnN0YW5jZW9mIEJhc2VMb2FkYWJsZTtcbn1cblxuY29uc3QgTG9hZGFibGVTdGF0aWNJbnRlcmZhY2UgPSB7XG4gIG9mOiB2YWx1ZSA9PiBSZWNvaWxfaXNQcm9taXNlKHZhbHVlKSA/IGxvYWRhYmxlV2l0aFByb21pc2UodmFsdWUpIDogaXNMb2FkYWJsZSh2YWx1ZSkgPyB2YWx1ZSA6IGxvYWRhYmxlV2l0aFZhbHVlKHZhbHVlKSxcbiAgZXJyb3I6IGVycm9yID0+IGxvYWRhYmxlV2l0aEVycm9yKGVycm9yKSxcbiAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICBsb2FkaW5nOiAoKSA9PiBsb2FkYWJsZUxvYWRpbmcoKSxcbiAgLy8gJEZsb3dJc3N1ZVt1bmNsZWFyLXR5cGVdXG4gIGFsbDogbG9hZGFibGVBbGwsXG4gIGlzTG9hZGFibGVcbn07XG52YXIgUmVjb2lsX0xvYWRhYmxlID0ge1xuICBsb2FkYWJsZVdpdGhWYWx1ZSxcbiAgbG9hZGFibGVXaXRoRXJyb3IsXG4gIGxvYWRhYmxlV2l0aFByb21pc2UsXG4gIGxvYWRhYmxlTG9hZGluZyxcbiAgbG9hZGFibGVBbGwsXG4gIGlzTG9hZGFibGUsXG4gIFJlY29pbExvYWRhYmxlOiBMb2FkYWJsZVN0YXRpY0ludGVyZmFjZVxufTtcblxudmFyIFJlY29pbF9Mb2FkYWJsZV8xID0gUmVjb2lsX0xvYWRhYmxlLmxvYWRhYmxlV2l0aFZhbHVlO1xudmFyIFJlY29pbF9Mb2FkYWJsZV8yID0gUmVjb2lsX0xvYWRhYmxlLmxvYWRhYmxlV2l0aEVycm9yO1xudmFyIFJlY29pbF9Mb2FkYWJsZV8zID0gUmVjb2lsX0xvYWRhYmxlLmxvYWRhYmxlV2l0aFByb21pc2U7XG52YXIgUmVjb2lsX0xvYWRhYmxlXzQgPSBSZWNvaWxfTG9hZGFibGUubG9hZGFibGVMb2FkaW5nO1xudmFyIFJlY29pbF9Mb2FkYWJsZV81ID0gUmVjb2lsX0xvYWRhYmxlLmxvYWRhYmxlQWxsO1xudmFyIFJlY29pbF9Mb2FkYWJsZV82ID0gUmVjb2lsX0xvYWRhYmxlLmlzTG9hZGFibGU7XG52YXIgUmVjb2lsX0xvYWRhYmxlXzcgPSBSZWNvaWxfTG9hZGFibGUuUmVjb2lsTG9hZGFibGU7XG5cbnZhciBSZWNvaWxfTG9hZGFibGUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBsb2FkYWJsZVdpdGhWYWx1ZTogUmVjb2lsX0xvYWRhYmxlXzEsXG4gIGxvYWRhYmxlV2l0aEVycm9yOiBSZWNvaWxfTG9hZGFibGVfMixcbiAgbG9hZGFibGVXaXRoUHJvbWlzZTogUmVjb2lsX0xvYWRhYmxlXzMsXG4gIGxvYWRhYmxlTG9hZGluZzogUmVjb2lsX0xvYWRhYmxlXzQsXG4gIGxvYWRhYmxlQWxsOiBSZWNvaWxfTG9hZGFibGVfNSxcbiAgaXNMb2FkYWJsZTogUmVjb2lsX0xvYWRhYmxlXzYsXG4gIFJlY29pbExvYWRhYmxlOiBSZWNvaWxfTG9hZGFibGVfN1xufSk7XG5cbmNvbnN0IGVudiA9IHtcbiAgUkVDT0lMX0RVUExJQ0FURV9BVE9NX0tFWV9DSEVDS0lOR19FTkFCTEVEOiB0cnVlLFxuICAvLyBOb3RlOiBSRUNPSUxfR0tTX0VOQUJMRUQgc2V0dGluZ3Mgd2lsbCBvbmx5IGJlIGhvbm9yZWQgaW4gT1NTIGJ1aWxkcyBvZiBSZWNvaWxcbiAgUkVDT0lMX0dLU19FTkFCTEVEOiBuZXcgU2V0KFsncmVjb2lsX2hhbXRfMjAyMCcsICdyZWNvaWxfc3luY19leHRlcm5hbF9zdG9yZScsICdyZWNvaWxfc3VwcHJlc3NfcmVyZW5kZXJfaW5fY2FsbGJhY2snLCAncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnXSlcbn07XG5cbmZ1bmN0aW9uIHJlYWRQcm9jZXNzRW52Qm9vbGVhbkZsYWcobmFtZSwgc2V0KSB7XG4gIHZhciBfcHJvY2VzcyRlbnYkbmFtZSwgX3Byb2Nlc3MkZW52JG5hbWUkdG9MO1xuXG4gIGNvbnN0IHNhbml0aXplZFZhbHVlID0gKF9wcm9jZXNzJGVudiRuYW1lID0gcHJvY2Vzcy5lbnZbbmFtZV0pID09PSBudWxsIHx8IF9wcm9jZXNzJGVudiRuYW1lID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3Byb2Nlc3MkZW52JG5hbWUkdG9MID0gX3Byb2Nlc3MkZW52JG5hbWUudG9Mb3dlckNhc2UoKSkgPT09IG51bGwgfHwgX3Byb2Nlc3MkZW52JG5hbWUkdG9MID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcHJvY2VzcyRlbnYkbmFtZSR0b0wudHJpbSgpO1xuXG4gIGlmIChzYW5pdGl6ZWRWYWx1ZSA9PSBudWxsIHx8IHNhbml0aXplZFZhbHVlID09PSAnJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGFsbG93ZWRWYWx1ZXMgPSBbJ3RydWUnLCAnZmFsc2UnXTtcblxuICBpZiAoIWFsbG93ZWRWYWx1ZXMuaW5jbHVkZXMoc2FuaXRpemVkVmFsdWUpKSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycihgcHJvY2Vzcy5lbnYuJHtuYW1lfSB2YWx1ZSBtdXN0IGJlICd0cnVlJywgJ2ZhbHNlJywgb3IgZW1wdHk6ICR7c2FuaXRpemVkVmFsdWV9YCk7XG4gIH1cblxuICBzZXQoc2FuaXRpemVkVmFsdWUgPT09ICd0cnVlJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRQcm9jZXNzRW52U3RyaW5nQXJyYXlGbGFnKG5hbWUsIHNldCkge1xuICB2YXIgX3Byb2Nlc3MkZW52JG5hbWUyO1xuXG4gIGNvbnN0IHNhbml0aXplZFZhbHVlID0gKF9wcm9jZXNzJGVudiRuYW1lMiA9IHByb2Nlc3MuZW52W25hbWVdKSA9PT0gbnVsbCB8fCBfcHJvY2VzcyRlbnYkbmFtZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wcm9jZXNzJGVudiRuYW1lMi50cmltKCk7XG5cbiAgaWYgKHNhbml0aXplZFZhbHVlID09IG51bGwgfHwgc2FuaXRpemVkVmFsdWUgPT09ICcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc2V0KHNhbml0aXplZFZhbHVlLnNwbGl0KC9cXHMqLFxccyp8XFxzKy8pKTtcbn1cbi8qKlxuICogQWxsb3cgTm9kZUpTL05leHRKUy9ldGMgdG8gc2V0IHRoZSBpbml0aWFsIHN0YXRlIHRocm91Z2ggcHJvY2Vzcy5lbnYgdmFyaWFibGVcbiAqIE5vdGU6ICB3ZSBkb24ndCBhc3N1bWUgJ3Byb2Nlc3MnIGlzIGF2YWlsYWJsZSBpbiBhbGwgcnVudGltZSBlbnZpcm9ubWVudHNcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2V4cGVyaW1lbnRhbC9SZWNvaWwvaXNzdWVzLzczM1xuICovXG5cblxuZnVuY3Rpb24gYXBwbHlQcm9jZXNzRW52RmxhZ092ZXJyaWRlcygpIHtcbiAgdmFyIF9wcm9jZXNzO1xuXG4gIC8vIG5vdGU6IHRoaXMgY2hlY2sgaXMgbmVlZGVkIGluIGFkZGl0aW9uIHRvIHRoZSBjaGVjayBiZWxvdywgcnVudGltZSBlcnJvciB3aWxsIG9jY3VyIHdpdGhvdXQgaXQhXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvdHlwZW9mLXVuZGVmaW5lZFxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCgoX3Byb2Nlc3MgPSBwcm9jZXNzKSA9PT0gbnVsbCB8fCBfcHJvY2VzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3Byb2Nlc3MuZW52KSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmVhZFByb2Nlc3NFbnZCb29sZWFuRmxhZygnUkVDT0lMX0RVUExJQ0FURV9BVE9NX0tFWV9DSEVDS0lOR19FTkFCTEVEJywgdmFsdWUgPT4ge1xuICAgIGVudi5SRUNPSUxfRFVQTElDQVRFX0FUT01fS0VZX0NIRUNLSU5HX0VOQUJMRUQgPSB2YWx1ZTtcbiAgfSk7XG4gIHJlYWRQcm9jZXNzRW52U3RyaW5nQXJyYXlGbGFnKCdSRUNPSUxfR0tTX0VOQUJMRUQnLCB2YWx1ZSA9PiB7XG4gICAgdmFsdWUuZm9yRWFjaChnayA9PiB7XG4gICAgICBlbnYuUkVDT0lMX0dLU19FTkFCTEVELmFkZChnayk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5hcHBseVByb2Nlc3NFbnZGbGFnT3ZlcnJpZGVzKCk7XG52YXIgUmVjb2lsX1JlY29pbEVudiA9IGVudjtcblxuZnVuY3Rpb24gUmVjb2lsX2dreF9PU1MoZ2spIHtcbiAgcmV0dXJuIFJlY29pbF9SZWNvaWxFbnYuUkVDT0lMX0dLU19FTkFCTEVELmhhcyhnayk7XG59XG5cblJlY29pbF9na3hfT1NTLnNldFBhc3MgPSBnayA9PiB7XG4gIFJlY29pbF9SZWNvaWxFbnYuUkVDT0lMX0dLU19FTkFCTEVELmFkZChnayk7XG59O1xuXG5SZWNvaWxfZ2t4X09TUy5zZXRGYWlsID0gZ2sgPT4ge1xuICBSZWNvaWxfUmVjb2lsRW52LlJFQ09JTF9HS1NfRU5BQkxFRC5kZWxldGUoZ2spO1xufTtcblxuUmVjb2lsX2dreF9PU1MuY2xlYXIgPSAoKSA9PiB7XG4gIFJlY29pbF9SZWNvaWxFbnYuUkVDT0lMX0dLU19FTkFCTEVELmNsZWFyKCk7XG59O1xuXG52YXIgUmVjb2lsX2dreCA9IFJlY29pbF9na3hfT1NTOyAvLyBAb3NzLW9ubHlcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiByZWNvdmVyYWJsZVZpb2xhdGlvbihtZXNzYWdlLCBfcHJvamVjdE5hbWUsIHtcbiAgZXJyb3Jcbn0gPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCBlcnJvcik7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIHJlY292ZXJhYmxlVmlvbGF0aW9uXzEgPSByZWNvdmVyYWJsZVZpb2xhdGlvbjtcblxuLy8gQG9zcy1vbmx5XG5cblxudmFyIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbiA9IHJlY292ZXJhYmxlVmlvbGF0aW9uXzE7XG5cbnZhciBfY3JlYXRlTXV0YWJsZVNvdXJjZSwgX3VzZU11dGFibGVTb3VyY2UsIF91c2VTeW5jRXh0ZXJuYWxTdG9yZTtcblxuXG5cblxuXG5cblxuY29uc3QgY3JlYXRlTXV0YWJsZVNvdXJjZSA9IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4oX2NyZWF0ZU11dGFibGVTb3VyY2UgPSByZWFjdC5jcmVhdGVNdXRhYmxlU291cmNlKSAhPT0gbnVsbCAmJiBfY3JlYXRlTXV0YWJsZVNvdXJjZSAhPT0gdm9pZCAwID8gX2NyZWF0ZU11dGFibGVTb3VyY2UgOiByZWFjdC51bnN0YWJsZV9jcmVhdGVNdXRhYmxlU291cmNlO1xuY29uc3QgdXNlTXV0YWJsZVNvdXJjZSA9IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4oX3VzZU11dGFibGVTb3VyY2UgPSByZWFjdC51c2VNdXRhYmxlU291cmNlKSAhPT0gbnVsbCAmJiBfdXNlTXV0YWJsZVNvdXJjZSAhPT0gdm9pZCAwID8gX3VzZU11dGFibGVTb3VyY2UgOiByZWFjdC51bnN0YWJsZV91c2VNdXRhYmxlU291cmNlOyAvLyBodHRwczovL2dpdGh1Yi5jb20vcmVhY3R3Zy9yZWFjdC0xOC9kaXNjdXNzaW9ucy84NlxuXG5jb25zdCB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4oX3VzZVN5bmNFeHRlcm5hbFN0b3JlID0gcmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUpICE9PSBudWxsICYmIF91c2VTeW5jRXh0ZXJuYWxTdG9yZSAhPT0gdm9pZCAwID8gX3VzZVN5bmNFeHRlcm5hbFN0b3JlIDogLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbnJlYWN0LnVuc3RhYmxlX3VzZVN5bmNFeHRlcm5hbFN0b3JlO1xubGV0IFJlYWN0UmVuZGVyZXJWZXJzaW9uTWlzbWF0Y2hXYXJuT25jZSA9IGZhbHNlOyAvLyBDaGVjayBpZiB0aGUgY3VycmVudCByZW5kZXJlciBzdXBwb3J0cyBgdXNlU3luY0V4dGVybmFsU3RvcmUoKWAuXG4vLyBTaW5jZSBSZWFjdCBnb2VzIHRocm91Z2ggYSBwcm94eSBkaXNwYXRjaGVyIGFuZCB0aGUgY3VycmVudCByZW5kZXJlciBjYW5cbi8vIGNoYW5nZSB3ZSBjYW4ndCBzaW1wbHkgY2hlY2sgaWYgYFJlYWN0LnVzZVN5bmNFeHRlcm5hbFN0b3JlKClgIGlzIGRlZmluZWQuXG5cbmZ1bmN0aW9uIGN1cnJlbnRSZW5kZXJlclN1cHBvcnRzVXNlU3luY0V4dGVybmFsU3RvcmUoKSB7XG4gIHZhciBfUmVhY3RDdXJyZW50RGlzcGF0Y2g7XG5cbiAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXVxuICBjb25zdCB7XG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcbiAgICBSZWFjdEN1cnJlbnRPd25lclxuICB9ID1cbiAgLyogJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIFRoaXMgd29ya2Fyb3VuZCB3YXMgYXBwcm92ZWQgYXMgYSBzYWZlciBtZWNoYW5pc21cbiAgICogdG8gZGV0ZWN0IGlmIHRoZSBjdXJyZW50IHJlbmRlcmVyIHN1cHBvcnRzIHVzZVN5bmNFeHRlcm5hbFN0b3JlKClcbiAgICogaHR0cHM6Ly9mYi53b3JrcGxhY2UuY29tL2dyb3Vwcy9yZWFjdGpzL3Bvc3RzLzk1NTg2ODIzMzA4NDY5NjMvICovXG4gIHJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuICBjb25zdCBkaXNwYXRjaGVyID0gKF9SZWFjdEN1cnJlbnREaXNwYXRjaCA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPT09IG51bGwgfHwgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50KSAhPT0gbnVsbCAmJiBfUmVhY3RDdXJyZW50RGlzcGF0Y2ggIT09IHZvaWQgMCA/IF9SZWFjdEN1cnJlbnREaXNwYXRjaCA6IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnREaXNwYXRjaGVyO1xuICBjb25zdCBpc1VzZVN5bmNFeHRlcm5hbFN0b3JlU3VwcG9ydGVkID0gZGlzcGF0Y2hlci51c2VTeW5jRXh0ZXJuYWxTdG9yZSAhPSBudWxsO1xuXG4gIGlmICh1c2VTeW5jRXh0ZXJuYWxTdG9yZSAmJiAhaXNVc2VTeW5jRXh0ZXJuYWxTdG9yZVN1cHBvcnRlZCAmJiAhUmVhY3RSZW5kZXJlclZlcnNpb25NaXNtYXRjaFdhcm5PbmNlKSB7XG4gICAgUmVhY3RSZW5kZXJlclZlcnNpb25NaXNtYXRjaFdhcm5PbmNlID0gdHJ1ZTtcbiAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ0EgUmVhY3QgcmVuZGVyZXIgd2l0aG91dCBSZWFjdCAxOCsgQVBJIHN1cHBvcnQgaXMgYmVpbmcgdXNlZCB3aXRoIFJlYWN0IDE4Ky4nKTtcbiAgfVxuXG4gIHJldHVybiBpc1VzZVN5bmNFeHRlcm5hbFN0b3JlU3VwcG9ydGVkO1xufVxuXG4vKipcbiAqIG1vZGU6IFRoZSBSZWFjdCBBUEkgYW5kIGFwcHJvYWNoIHRvIHVzZSBmb3Igc3luY2luZyBzdGF0ZSB3aXRoIFJlYWN0XG4gKiBlYXJseTogUmUtcmVuZGVycyBmcm9tIFJlY29pbCB1cGRhdGVzIG9jY3VyOlxuICogICAgMSkgZWFybGllclxuICogICAgMikgaW4gc3luYyB3aXRoIFJlYWN0IHVwZGF0ZXMgaW4gdGhlIHNhbWUgYmF0Y2hcbiAqICAgIDMpIGJlZm9yZSB0cmFuc2FjdGlvbiBvYnNlcnZlcnMgaW5zdGVhZCBvZiBhZnRlci5cbiAqIGNvbmN1cnJlbnQ6IElzIHRoZSBjdXJyZW50IG1vZGUgY29tcGF0aWJsZSB3aXRoIENvbmN1cnJlbnQgTW9kZSBhbmQgdXNlVHJhbnNpdGlvbigpXG4gKi9cbmZ1bmN0aW9uIHJlYWN0TW9kZSgpIHtcbiAgLy8gTk9URTogVGhpcyBtb2RlIGlzIGN1cnJlbnRseSBicm9rZW4gd2l0aCBzb21lIFN1c3BlbnNlIGNhc2VzXG4gIC8vIHNlZSBSZWNvaWxfc2VsZWN0b3ItdGVzdC5qc1xuICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX3RyYW5zaXRpb25fc3VwcG9ydCcpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGU6ICdUUkFOU0lUSU9OX1NVUFBPUlQnLFxuICAgICAgZWFybHk6IHRydWUsXG4gICAgICBjb25jdXJyZW50OiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfc3luY19leHRlcm5hbF9zdG9yZScpICYmIHVzZVN5bmNFeHRlcm5hbFN0b3JlICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kZTogJ1NZTkNfRVhURVJOQUxfU1RPUkUnLFxuICAgICAgZWFybHk6IHRydWUsXG4gICAgICBjb25jdXJyZW50OiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX211dGFibGVfc291cmNlJykgJiYgdXNlTXV0YWJsZVNvdXJjZSAhPSBudWxsICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICF3aW5kb3cuJGRpc2FibGVSZWNvaWxWYWx1ZU11dGFibGVTb3VyY2VfVEVNUF9IQUNLX0RPX05PVF9VU0UpIHtcbiAgICByZXR1cm4gUmVjb2lsX2dreCgncmVjb2lsX3N1cHByZXNzX3JlcmVuZGVyX2luX2NhbGxiYWNrJykgPyB7XG4gICAgICBtb2RlOiAnTVVUQUJMRV9TT1VSQ0UnLFxuICAgICAgZWFybHk6IHRydWUsXG4gICAgICBjb25jdXJyZW50OiB0cnVlXG4gICAgfSA6IHtcbiAgICAgIG1vZGU6ICdNVVRBQkxFX1NPVVJDRScsXG4gICAgICBlYXJseTogZmFsc2UsXG4gICAgICBjb25jdXJyZW50OiBmYWxzZVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gUmVjb2lsX2dreCgncmVjb2lsX3N1cHByZXNzX3JlcmVuZGVyX2luX2NhbGxiYWNrJykgPyB7XG4gICAgbW9kZTogJ0xFR0FDWScsXG4gICAgZWFybHk6IHRydWUsXG4gICAgY29uY3VycmVudDogZmFsc2VcbiAgfSA6IHtcbiAgICBtb2RlOiAnTEVHQUNZJyxcbiAgICBlYXJseTogZmFsc2UsXG4gICAgY29uY3VycmVudDogZmFsc2VcbiAgfTtcbn0gLy8gVE9ETyBOZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhlcmUgaXMgYSBzdGFuZGFyZC9vcGVuLXNvdXJjZSBlcXVpdmFsZW50IHRvIHNlZSBpZiBob3QgbW9kdWxlIHJlcGxhY2VtZW50IGlzIGhhcHBlbmluZzpcblxuXG5mdW5jdGlvbiBpc0Zhc3RSZWZyZXNoRW5hYmxlZCgpIHtcbiAgLy8gQGZiLW9ubHk6IGNvbnN0IHtpc0FjY2VwdGluZ1VwZGF0ZX0gPSByZXF1aXJlKCdfX2RlYnVnJyk7XG4gIC8vIEBmYi1vbmx5OiByZXR1cm4gdHlwZW9mIGlzQWNjZXB0aW5nVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGlzQWNjZXB0aW5nVXBkYXRlKCk7XG4gIHJldHVybiBmYWxzZTsgLy8gQG9zcy1vbmx5XG59XG5cbnZhciBSZWNvaWxfUmVhY3RNb2RlID0ge1xuICBjcmVhdGVNdXRhYmxlU291cmNlLFxuICB1c2VNdXRhYmxlU291cmNlLFxuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZSxcbiAgY3VycmVudFJlbmRlcmVyU3VwcG9ydHNVc2VTeW5jRXh0ZXJuYWxTdG9yZSxcbiAgcmVhY3RNb2RlLFxuICBpc0Zhc3RSZWZyZXNoRW5hYmxlZFxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbmNsYXNzIEFic3RyYWN0UmVjb2lsVmFsdWUge1xuICBjb25zdHJ1Y3RvcihuZXdLZXkpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJrZXlcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMua2V5ID0gbmV3S2V5O1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IHRoaXMua2V5XG4gICAgfTtcbiAgfVxuXG59XG5cbmNsYXNzIFJlY29pbFN0YXRlIGV4dGVuZHMgQWJzdHJhY3RSZWNvaWxWYWx1ZSB7fVxuXG5jbGFzcyBSZWNvaWxWYWx1ZVJlYWRPbmx5IGV4dGVuZHMgQWJzdHJhY3RSZWNvaWxWYWx1ZSB7fVxuXG5mdW5jdGlvbiBpc1JlY29pbFZhbHVlKHgpIHtcbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWNvaWxTdGF0ZSB8fCB4IGluc3RhbmNlb2YgUmVjb2lsVmFsdWVSZWFkT25seTtcbn1cblxudmFyIFJlY29pbF9SZWNvaWxWYWx1ZSA9IHtcbiAgQWJzdHJhY3RSZWNvaWxWYWx1ZSxcbiAgUmVjb2lsU3RhdGUsXG4gIFJlY29pbFZhbHVlUmVhZE9ubHksXG4gIGlzUmVjb2lsVmFsdWVcbn07XG5cbnZhciBSZWNvaWxfUmVjb2lsVmFsdWVfMSA9IFJlY29pbF9SZWNvaWxWYWx1ZS5BYnN0cmFjdFJlY29pbFZhbHVlO1xudmFyIFJlY29pbF9SZWNvaWxWYWx1ZV8yID0gUmVjb2lsX1JlY29pbFZhbHVlLlJlY29pbFN0YXRlO1xudmFyIFJlY29pbF9SZWNvaWxWYWx1ZV8zID0gUmVjb2lsX1JlY29pbFZhbHVlLlJlY29pbFZhbHVlUmVhZE9ubHk7XG52YXIgUmVjb2lsX1JlY29pbFZhbHVlXzQgPSBSZWNvaWxfUmVjb2lsVmFsdWUuaXNSZWNvaWxWYWx1ZTtcblxudmFyIFJlY29pbF9SZWNvaWxWYWx1ZSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEFic3RyYWN0UmVjb2lsVmFsdWU6IFJlY29pbF9SZWNvaWxWYWx1ZV8xLFxuICBSZWNvaWxTdGF0ZTogUmVjb2lsX1JlY29pbFZhbHVlXzIsXG4gIFJlY29pbFZhbHVlUmVhZE9ubHk6IFJlY29pbF9SZWNvaWxWYWx1ZV8zLFxuICBpc1JlY29pbFZhbHVlOiBSZWNvaWxfUmVjb2lsVmFsdWVfNFxufSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gc3ByaW50Zihmb3JtYXQsIC4uLmFyZ3MpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgcmV0dXJuIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCAoKSA9PiBTdHJpbmcoYXJnc1tpbmRleCsrXSkpO1xufVxuXG52YXIgc3ByaW50Zl8xID0gc3ByaW50ZjtcblxuZnVuY3Rpb24gZXhwZWN0YXRpb25WaW9sYXRpb24oZm9ybWF0LCAuLi5hcmdzKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gc3ByaW50Zl8xLmNhbGwobnVsbCwgZm9ybWF0LCAuLi5hcmdzKTtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBlcnJvci5uYW1lID0gJ0V4cGVjdGF0aW9uIFZpb2xhdGlvbic7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gIH1cbn1cblxudmFyIGV4cGVjdGF0aW9uVmlvbGF0aW9uXzEgPSBleHBlY3RhdGlvblZpb2xhdGlvbjtcblxuLy8gQG9zcy1vbmx5XG5cblxudmFyIFJlY29pbF9leHBlY3RhdGlvblZpb2xhdGlvbiA9IGV4cGVjdGF0aW9uVmlvbGF0aW9uXzE7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpdGVyYWJsZSB3aG9zZSBvdXRwdXQgaXMgZ2VuZXJhdGVkIGJ5IHBhc3NpbmcgdGhlIGlucHV0XG4gKiBpdGVyYWJsZSdzIHZhbHVlcyB0aHJvdWdoIHRoZSBtYXBwZXIgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gbWFwSXRlcmFibGUoaXRlcmFibGUsIGNhbGxiYWNrKSB7XG4gIC8vIFVzZSBnZW5lcmF0b3IgdG8gY3JlYXRlIGl0ZXJhYmxlL2l0ZXJhdG9yXG4gIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgIGxldCBpbmRleCA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGl0ZXJhYmxlKSB7XG4gICAgICB5aWVsZCBjYWxsYmFjayh2YWx1ZSwgaW5kZXgrKyk7XG4gICAgfVxuICB9KCk7XG59XG5cbnZhciBSZWNvaWxfbWFwSXRlcmFibGUgPSBtYXBJdGVyYWJsZTtcblxuY29uc3Qge1xuICBpc0Zhc3RSZWZyZXNoRW5hYmxlZDogaXNGYXN0UmVmcmVzaEVuYWJsZWQkMVxufSA9IFJlY29pbF9SZWFjdE1vZGU7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jbGFzcyBEZWZhdWx0VmFsdWUge31cblxuY29uc3QgREVGQVVMVF9WQUxVRSA9IG5ldyBEZWZhdWx0VmFsdWUoKTtcbi8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5jb25zdCBub2RlcyA9IG5ldyBNYXAoKTsgLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcblxuY29uc3QgcmVjb2lsVmFsdWVzID0gbmV3IE1hcCgpO1xuLyogZXNsaW50LWRpc2FibGUgbm8tcmVkZWNsYXJlICovXG5cbmZ1bmN0aW9uIHJlY29pbFZhbHVlc0ZvcktleXMoa2V5cykge1xuICByZXR1cm4gUmVjb2lsX21hcEl0ZXJhYmxlKGtleXMsIGtleSA9PiBSZWNvaWxfbnVsbHRocm93cyhyZWNvaWxWYWx1ZXMuZ2V0KGtleSkpKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JEdXBsaWNhdGVBdG9tS2V5KGtleSkge1xuICBpZiAobm9kZXMuaGFzKGtleSkpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYER1cGxpY2F0ZSBhdG9tIGtleSBcIiR7a2V5fVwiLiBUaGlzIGlzIGEgRkFUQUwgRVJST1IgaW5cbiAgICAgIHByb2R1Y3Rpb24uIEJ1dCBpdCBpcyBzYWZlIHRvIGlnbm9yZSB0aGlzIHdhcm5pbmcgaWYgaXQgb2NjdXJyZWQgYmVjYXVzZSBvZlxuICAgICAgaG90IG1vZHVsZSByZXBsYWNlbWVudC5gO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgLy8gVE9ETyBGaWd1cmUgdGhpcyBvdXQgZm9yIG9wZW4tc291cmNlXG4gICAgICBpZiAoIWlzRmFzdFJlZnJlc2hFbmFibGVkJDEoKSkge1xuICAgICAgICBSZWNvaWxfZXhwZWN0YXRpb25WaW9sYXRpb24obWVzc2FnZSwgJ3JlY29pbCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAZmItb25seTogcmVjb3ZlcmFibGVWaW9sYXRpb24obWVzc2FnZSwgJ3JlY29pbCcpO1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpOyAvLyBAb3NzLW9ubHlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJOb2RlKG5vZGUpIHtcbiAgaWYgKFJlY29pbF9SZWNvaWxFbnYuUkVDT0lMX0RVUExJQ0FURV9BVE9NX0tFWV9DSEVDS0lOR19FTkFCTEVEKSB7XG4gICAgY2hlY2tGb3JEdXBsaWNhdGVBdG9tS2V5KG5vZGUua2V5KTtcbiAgfVxuXG4gIG5vZGVzLnNldChub2RlLmtleSwgbm9kZSk7XG4gIGNvbnN0IHJlY29pbFZhbHVlID0gbm9kZS5zZXQgPT0gbnVsbCA/IG5ldyBSZWNvaWxfUmVjb2lsVmFsdWUkMS5SZWNvaWxWYWx1ZVJlYWRPbmx5KG5vZGUua2V5KSA6IG5ldyBSZWNvaWxfUmVjb2lsVmFsdWUkMS5SZWNvaWxTdGF0ZShub2RlLmtleSk7XG4gIHJlY29pbFZhbHVlcy5zZXQobm9kZS5rZXksIHJlY29pbFZhbHVlKTtcbiAgcmV0dXJuIHJlY29pbFZhbHVlO1xufVxuLyogZXNsaW50LWVuYWJsZSBuby1yZWRlY2xhcmUgKi9cblxuXG5jbGFzcyBOb2RlTWlzc2luZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige30gLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcblxuXG5mdW5jdGlvbiBnZXROb2RlKGtleSkge1xuICBjb25zdCBub2RlID0gbm9kZXMuZ2V0KGtleSk7XG5cbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBOb2RlTWlzc2luZ0Vycm9yKGBNaXNzaW5nIGRlZmluaXRpb24gZm9yIFJlY29pbFZhbHVlOiBcIiR7a2V5fVwiXCJgKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufSAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuXG5cbmZ1bmN0aW9uIGdldE5vZGVNYXliZShrZXkpIHtcbiAgcmV0dXJuIG5vZGVzLmdldChrZXkpO1xufVxuXG5jb25zdCBjb25maWdEZWxldGlvbkhhbmRsZXJzID0gbmV3IE1hcCgpO1xuXG5mdW5jdGlvbiBkZWxldGVOb2RlQ29uZmlnSWZQb3NzaWJsZShrZXkpIHtcbiAgdmFyIF9ub2RlJHNob3VsZERlbGV0ZUNvbjtcblxuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBub2RlID0gbm9kZXMuZ2V0KGtleSk7XG5cbiAgaWYgKG5vZGUgIT09IG51bGwgJiYgbm9kZSAhPT0gdm9pZCAwICYmIChfbm9kZSRzaG91bGREZWxldGVDb24gPSBub2RlLnNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZSkgIT09IG51bGwgJiYgX25vZGUkc2hvdWxkRGVsZXRlQ29uICE9PSB2b2lkIDAgJiYgX25vZGUkc2hvdWxkRGVsZXRlQ29uLmNhbGwobm9kZSkpIHtcbiAgICB2YXIgX2dldENvbmZpZ0RlbGV0aW9uSGFuO1xuXG4gICAgbm9kZXMuZGVsZXRlKGtleSk7XG4gICAgKF9nZXRDb25maWdEZWxldGlvbkhhbiA9IGdldENvbmZpZ0RlbGV0aW9uSGFuZGxlcihrZXkpKSA9PT0gbnVsbCB8fCBfZ2V0Q29uZmlnRGVsZXRpb25IYW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRDb25maWdEZWxldGlvbkhhbigpO1xuICAgIGNvbmZpZ0RlbGV0aW9uSGFuZGxlcnMuZGVsZXRlKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyKGtleSwgZm4pIHtcbiAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGZuID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25maWdEZWxldGlvbkhhbmRsZXJzLmRlbGV0ZShrZXkpO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZ0RlbGV0aW9uSGFuZGxlcnMuc2V0KGtleSwgZm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldENvbmZpZ0RlbGV0aW9uSGFuZGxlcihrZXkpIHtcbiAgcmV0dXJuIGNvbmZpZ0RlbGV0aW9uSGFuZGxlcnMuZ2V0KGtleSk7XG59XG5cbnZhciBSZWNvaWxfTm9kZSA9IHtcbiAgbm9kZXMsXG4gIHJlY29pbFZhbHVlcyxcbiAgcmVnaXN0ZXJOb2RlLFxuICBnZXROb2RlLFxuICBnZXROb2RlTWF5YmUsXG4gIGRlbGV0ZU5vZGVDb25maWdJZlBvc3NpYmxlLFxuICBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIsXG4gIGdldENvbmZpZ0RlbGV0aW9uSGFuZGxlcixcbiAgcmVjb2lsVmFsdWVzRm9yS2V5cyxcbiAgTm9kZU1pc3NpbmdFcnJvcixcbiAgRGVmYXVsdFZhbHVlLFxuICBERUZBVUxUX1ZBTFVFXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmZ1bmN0aW9uIGVucXVldWVFeGVjdXRpb24ocywgZikge1xuICBmKCk7XG59XG5cbnZhciBSZWNvaWxfUXVldWUgPSB7XG4gIGVucXVldWVFeGVjdXRpb25cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG52YXIgaGFtdF8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbi8qKlxuICAgIEBmaWxlT3ZlcnZpZXcgSGFzaCBBcnJheSBNYXBwZWQgVHJpZS5cblxuICAgIENvZGUgYmFzZWQgb246IGh0dHBzOi8vZ2l0aHViLmNvbS9leGNsaXB5L3BkYXRhXG4qL1xuXG5cbnZhciBoYW10ID0ge307IC8vIGV4cG9ydFxuXG4vKiBDb25maWd1cmF0aW9uXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgU0laRSA9IDU7XG52YXIgQlVDS0VUX1NJWkUgPSBNYXRoLnBvdygyLCBTSVpFKTtcbnZhciBNQVNLID0gQlVDS0VUX1NJWkUgLSAxO1xudmFyIE1BWF9JTkRFWF9OT0RFID0gQlVDS0VUX1NJWkUgLyAyO1xudmFyIE1JTl9BUlJBWV9OT0RFID0gQlVDS0VUX1NJWkUgLyA0O1xuLypcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBub3RoaW5nID0ge307XG5cbnZhciBjb25zdGFudCA9IGZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn07XG4vKipcbiAgICBHZXQgMzIgYml0IGhhc2ggb2Ygc3RyaW5nLlxuXG4gICAgQmFzZWQgb246XG4gICAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NjE2NDYxL2dlbmVyYXRlLWEtaGFzaC1mcm9tLXN0cmluZy1pbi1qYXZhc2NyaXB0LWpxdWVyeVxuKi9cblxuXG52YXIgaGFzaCA9IGhhbXQuaGFzaCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihzdHIpO1xuICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHJldHVybiBzdHI7XG4gIGlmICh0eXBlICE9PSAnc3RyaW5nJykgc3RyICs9ICcnO1xuICB2YXIgaGFzaCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIGMgfCAwO1xuICB9XG5cbiAgcmV0dXJuIGhhc2g7XG59O1xuLyogQml0IE9wc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gICAgSGFtbWluZyB3ZWlnaHQuXG5cbiAgICBUYWtlbiBmcm9tOiBodHRwOi8vanNwZXJmLmNvbS9oYW1taW5nLXdlaWdodFxuKi9cblxuXG52YXIgcG9wY291bnQgPSBmdW5jdGlvbiBwb3Bjb3VudCh4KSB7XG4gIHggLT0geCA+PiAxICYgMHg1NTU1NTU1NTtcbiAgeCA9ICh4ICYgMHgzMzMzMzMzMykgKyAoeCA+PiAyICYgMHgzMzMzMzMzMyk7XG4gIHggPSB4ICsgKHggPj4gNCkgJiAweDBmMGYwZjBmO1xuICB4ICs9IHggPj4gODtcbiAgeCArPSB4ID4+IDE2O1xuICByZXR1cm4geCAmIDB4N2Y7XG59O1xuXG52YXIgaGFzaEZyYWdtZW50ID0gZnVuY3Rpb24gaGFzaEZyYWdtZW50KHNoaWZ0LCBoKSB7XG4gIHJldHVybiBoID4+PiBzaGlmdCAmIE1BU0s7XG59O1xuXG52YXIgdG9CaXRtYXAgPSBmdW5jdGlvbiB0b0JpdG1hcCh4KSB7XG4gIHJldHVybiAxIDw8IHg7XG59O1xuXG52YXIgZnJvbUJpdG1hcCA9IGZ1bmN0aW9uIGZyb21CaXRtYXAoYml0bWFwLCBiaXQpIHtcbiAgcmV0dXJuIHBvcGNvdW50KGJpdG1hcCAmIGJpdCAtIDEpO1xufTtcbi8qIEFycmF5IE9wc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gICAgU2V0IGEgdmFsdWUgaW4gYW4gYXJyYXkuXG5cbiAgICBAcGFyYW0gbXV0YXRlIFNob3VsZCB0aGUgaW5wdXQgYXJyYXkgYmUgbXV0YXRlZD9cbiAgICBAcGFyYW0gYXQgSW5kZXggdG8gY2hhbmdlLlxuICAgIEBwYXJhbSB2IE5ldyB2YWx1ZVxuICAgIEBwYXJhbSBhcnIgQXJyYXkuXG4qL1xuXG5cbnZhciBhcnJheVVwZGF0ZSA9IGZ1bmN0aW9uIGFycmF5VXBkYXRlKG11dGF0ZSwgYXQsIHYsIGFycikge1xuICB2YXIgb3V0ID0gYXJyO1xuXG4gIGlmICghbXV0YXRlKSB7XG4gICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgb3V0ID0gbmV3IEFycmF5KGxlbik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBvdXRbaV0gPSBhcnJbaV07XG4gICAgfVxuICB9XG5cbiAgb3V0W2F0XSA9IHY7XG4gIHJldHVybiBvdXQ7XG59O1xuLyoqXG4gICAgUmVtb3ZlIGEgdmFsdWUgZnJvbSBhbiBhcnJheS5cblxuICAgIEBwYXJhbSBtdXRhdGUgU2hvdWxkIHRoZSBpbnB1dCBhcnJheSBiZSBtdXRhdGVkP1xuICAgIEBwYXJhbSBhdCBJbmRleCB0byByZW1vdmUuXG4gICAgQHBhcmFtIGFyciBBcnJheS5cbiovXG5cblxudmFyIGFycmF5U3BsaWNlT3V0ID0gZnVuY3Rpb24gYXJyYXlTcGxpY2VPdXQobXV0YXRlLCBhdCwgYXJyKSB7XG4gIHZhciBuZXdMZW4gPSBhcnIubGVuZ3RoIC0gMTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgZyA9IDA7XG4gIHZhciBvdXQgPSBhcnI7XG5cbiAgaWYgKG11dGF0ZSkge1xuICAgIGkgPSBnID0gYXQ7XG4gIH0gZWxzZSB7XG4gICAgb3V0ID0gbmV3IEFycmF5KG5ld0xlbik7XG5cbiAgICB3aGlsZSAoaSA8IGF0KSB7XG4gICAgICBvdXRbZysrXSA9IGFycltpKytdO1xuICAgIH1cbiAgfVxuXG4gICsraTtcblxuICB3aGlsZSAoaSA8PSBuZXdMZW4pIHtcbiAgICBvdXRbZysrXSA9IGFycltpKytdO1xuICB9XG5cbiAgaWYgKG11dGF0ZSkge1xuICAgIG91dC5sZW5ndGggPSBuZXdMZW47XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcbi8qKlxuICAgIEluc2VydCBhIHZhbHVlIGludG8gYW4gYXJyYXkuXG5cbiAgICBAcGFyYW0gbXV0YXRlIFNob3VsZCB0aGUgaW5wdXQgYXJyYXkgYmUgbXV0YXRlZD9cbiAgICBAcGFyYW0gYXQgSW5kZXggdG8gaW5zZXJ0IGF0LlxuICAgIEBwYXJhbSB2IFZhbHVlIHRvIGluc2VydCxcbiAgICBAcGFyYW0gYXJyIEFycmF5LlxuKi9cblxuXG52YXIgYXJyYXlTcGxpY2VJbiA9IGZ1bmN0aW9uIGFycmF5U3BsaWNlSW4obXV0YXRlLCBhdCwgdiwgYXJyKSB7XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGlmIChtdXRhdGUpIHtcbiAgICB2YXIgX2kgPSBsZW47XG5cbiAgICB3aGlsZSAoX2kgPj0gYXQpIHtcbiAgICAgIGFycltfaS0tXSA9IGFycltfaV07XG4gICAgfVxuXG4gICAgYXJyW2F0XSA9IHY7XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIHZhciBpID0gMCxcbiAgICAgIGcgPSAwO1xuICB2YXIgb3V0ID0gbmV3IEFycmF5KGxlbiArIDEpO1xuXG4gIHdoaWxlIChpIDwgYXQpIHtcbiAgICBvdXRbZysrXSA9IGFycltpKytdO1xuICB9XG5cbiAgb3V0W2F0XSA9IHY7XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBvdXRbKytnXSA9IGFycltpKytdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG4vKiBOb2RlIFN0cnVjdHVyZXNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxudmFyIExFQUYgPSAxO1xudmFyIENPTExJU0lPTiA9IDI7XG52YXIgSU5ERVggPSAzO1xudmFyIEFSUkFZID0gNDtcbi8qKlxuICAgIEVtcHR5IG5vZGUuXG4qL1xuXG52YXIgZW1wdHkgPSB7XG4gIF9faGFtdF9pc0VtcHR5OiB0cnVlXG59O1xuXG52YXIgaXNFbXB0eU5vZGUgPSBmdW5jdGlvbiBpc0VtcHR5Tm9kZSh4KSB7XG4gIHJldHVybiB4ID09PSBlbXB0eSB8fCB4ICYmIHguX19oYW10X2lzRW1wdHk7XG59O1xuLyoqXG4gICAgTGVhZiBob2xkaW5nIGEgdmFsdWUuXG5cbiAgICBAbWVtYmVyIGVkaXQgRWRpdCBvZiB0aGUgbm9kZS5cbiAgICBAbWVtYmVyIGhhc2ggSGFzaCBvZiBrZXkuXG4gICAgQG1lbWJlciBrZXkgS2V5LlxuICAgIEBtZW1iZXIgdmFsdWUgVmFsdWUgc3RvcmVkLlxuKi9cblxuXG52YXIgTGVhZiA9IGZ1bmN0aW9uIExlYWYoZWRpdCwgaGFzaCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IExFQUYsXG4gICAgZWRpdDogZWRpdCxcbiAgICBoYXNoOiBoYXNoLFxuICAgIGtleToga2V5LFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBfbW9kaWZ5OiBMZWFmX19tb2RpZnlcbiAgfTtcbn07XG4vKipcbiAgICBMZWFmIGhvbGRpbmcgbXVsdGlwbGUgdmFsdWVzIHdpdGggdGhlIHNhbWUgaGFzaCBidXQgZGlmZmVyZW50IGtleXMuXG5cbiAgICBAbWVtYmVyIGVkaXQgRWRpdCBvZiB0aGUgbm9kZS5cbiAgICBAbWVtYmVyIGhhc2ggSGFzaCBvZiBrZXkuXG4gICAgQG1lbWJlciBjaGlsZHJlbiBBcnJheSBvZiBjb2xsaXNpb24gY2hpbGRyZW4gbm9kZS5cbiovXG5cblxudmFyIENvbGxpc2lvbiA9IGZ1bmN0aW9uIENvbGxpc2lvbihlZGl0LCBoYXNoLCBjaGlsZHJlbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IENPTExJU0lPTixcbiAgICBlZGl0OiBlZGl0LFxuICAgIGhhc2g6IGhhc2gsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIF9tb2RpZnk6IENvbGxpc2lvbl9fbW9kaWZ5XG4gIH07XG59O1xuLyoqXG4gICAgSW50ZXJuYWwgbm9kZSB3aXRoIGEgc3BhcnNlIHNldCBvZiBjaGlsZHJlbi5cblxuICAgIFVzZXMgYSBiaXRtYXAgYW5kIGFycmF5IHRvIHBhY2sgY2hpbGRyZW4uXG5cbiAgQG1lbWJlciBlZGl0IEVkaXQgb2YgdGhlIG5vZGUuXG4gICAgQG1lbWJlciBtYXNrIEJpdG1hcCB0aGF0IGVuY29kZSB0aGUgcG9zaXRpb25zIG9mIGNoaWxkcmVuIGluIHRoZSBhcnJheS5cbiAgICBAbWVtYmVyIGNoaWxkcmVuIEFycmF5IG9mIGNoaWxkIG5vZGVzLlxuKi9cblxuXG52YXIgSW5kZXhlZE5vZGUgPSBmdW5jdGlvbiBJbmRleGVkTm9kZShlZGl0LCBtYXNrLCBjaGlsZHJlbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IElOREVYLFxuICAgIGVkaXQ6IGVkaXQsXG4gICAgbWFzazogbWFzayxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgX21vZGlmeTogSW5kZXhlZE5vZGVfX21vZGlmeVxuICB9O1xufTtcbi8qKlxuICAgIEludGVybmFsIG5vZGUgd2l0aCBtYW55IGNoaWxkcmVuLlxuXG4gICAgQG1lbWJlciBlZGl0IEVkaXQgb2YgdGhlIG5vZGUuXG4gICAgQG1lbWJlciBzaXplIE51bWJlciBvZiBjaGlsZHJlbi5cbiAgICBAbWVtYmVyIGNoaWxkcmVuIEFycmF5IG9mIGNoaWxkIG5vZGVzLlxuKi9cblxuXG52YXIgQXJyYXlOb2RlID0gZnVuY3Rpb24gQXJyYXlOb2RlKGVkaXQsIHNpemUsIGNoaWxkcmVuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQVJSQVksXG4gICAgZWRpdDogZWRpdCxcbiAgICBzaXplOiBzaXplLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBfbW9kaWZ5OiBBcnJheU5vZGVfX21vZGlmeVxuICB9O1xufTtcbi8qKlxuICAgIElzIGBub2RlYCBhIGxlYWYgbm9kZT9cbiovXG5cblxudmFyIGlzTGVhZiA9IGZ1bmN0aW9uIGlzTGVhZihub2RlKSB7XG4gIHJldHVybiBub2RlID09PSBlbXB0eSB8fCBub2RlLnR5cGUgPT09IExFQUYgfHwgbm9kZS50eXBlID09PSBDT0xMSVNJT047XG59O1xuLyogSW50ZXJuYWwgbm9kZSBvcGVyYXRpb25zLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gICAgRXhwYW5kIGFuIGluZGV4ZWQgbm9kZSBpbnRvIGFuIGFycmF5IG5vZGUuXG5cbiAgQHBhcmFtIGVkaXQgQ3VycmVudCBlZGl0LlxuICAgIEBwYXJhbSBmcmFnIEluZGV4IG9mIGFkZGVkIGNoaWxkLlxuICAgIEBwYXJhbSBjaGlsZCBBZGRlZCBjaGlsZC5cbiAgICBAcGFyYW0gbWFzayBJbmRleCBub2RlIG1hc2sgYmVmb3JlIGNoaWxkIGFkZGVkLlxuICAgIEBwYXJhbSBzdWJOb2RlcyBJbmRleCBub2RlIGNoaWxkcmVuIGJlZm9yZSBjaGlsZCBhZGRlZC5cbiovXG5cblxudmFyIGV4cGFuZCA9IGZ1bmN0aW9uIGV4cGFuZChlZGl0LCBmcmFnLCBjaGlsZCwgYml0bWFwLCBzdWJOb2Rlcykge1xuICB2YXIgYXJyID0gW107XG4gIHZhciBiaXQgPSBiaXRtYXA7XG4gIHZhciBjb3VudCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGJpdDsgKytpKSB7XG4gICAgaWYgKGJpdCAmIDEpIGFycltpXSA9IHN1Yk5vZGVzW2NvdW50KytdO1xuICAgIGJpdCA+Pj49IDE7XG4gIH1cblxuICBhcnJbZnJhZ10gPSBjaGlsZDtcbiAgcmV0dXJuIEFycmF5Tm9kZShlZGl0LCBjb3VudCArIDEsIGFycik7XG59O1xuLyoqXG4gICAgQ29sbGFwc2UgYW4gYXJyYXkgbm9kZSBpbnRvIGEgaW5kZXhlZCBub2RlLlxuXG4gIEBwYXJhbSBlZGl0IEN1cnJlbnQgZWRpdC5cbiAgICBAcGFyYW0gY291bnQgTnVtYmVyIG9mIGVsZW1lbnRzIGluIG5ldyBhcnJheS5cbiAgICBAcGFyYW0gcmVtb3ZlZCBJbmRleCBvZiByZW1vdmVkIGVsZW1lbnQuXG4gICAgQHBhcmFtIGVsZW1lbnRzIEFycmF5IG5vZGUgY2hpbGRyZW4gYmVmb3JlIHJlbW92ZS5cbiovXG5cblxudmFyIHBhY2sgPSBmdW5jdGlvbiBwYWNrKGVkaXQsIGNvdW50LCByZW1vdmVkLCBlbGVtZW50cykge1xuICB2YXIgY2hpbGRyZW4gPSBuZXcgQXJyYXkoY291bnQgLSAxKTtcbiAgdmFyIGcgPSAwO1xuICB2YXIgYml0bWFwID0gMDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoaSAhPT0gcmVtb3ZlZCkge1xuICAgICAgdmFyIGVsZW0gPSBlbGVtZW50c1tpXTtcblxuICAgICAgaWYgKGVsZW0gJiYgIWlzRW1wdHlOb2RlKGVsZW0pKSB7XG4gICAgICAgIGNoaWxkcmVuW2crK10gPSBlbGVtO1xuICAgICAgICBiaXRtYXAgfD0gMSA8PCBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBJbmRleGVkTm9kZShlZGl0LCBiaXRtYXAsIGNoaWxkcmVuKTtcbn07XG4vKipcbiAgICBNZXJnZSB0d28gbGVhZiBub2Rlcy5cblxuICAgIEBwYXJhbSBzaGlmdCBDdXJyZW50IHNoaWZ0LlxuICAgIEBwYXJhbSBoMSBOb2RlIDEgaGFzaC5cbiAgICBAcGFyYW0gbjEgTm9kZSAxLlxuICAgIEBwYXJhbSBoMiBOb2RlIDIgaGFzaC5cbiAgICBAcGFyYW0gbjIgTm9kZSAyLlxuKi9cblxuXG52YXIgbWVyZ2VMZWF2ZXMgPSBmdW5jdGlvbiBtZXJnZUxlYXZlcyhlZGl0LCBzaGlmdCwgaDEsIG4xLCBoMiwgbjIpIHtcbiAgaWYgKGgxID09PSBoMikgcmV0dXJuIENvbGxpc2lvbihlZGl0LCBoMSwgW24yLCBuMV0pO1xuICB2YXIgc3ViSDEgPSBoYXNoRnJhZ21lbnQoc2hpZnQsIGgxKTtcbiAgdmFyIHN1YkgyID0gaGFzaEZyYWdtZW50KHNoaWZ0LCBoMik7XG4gIHJldHVybiBJbmRleGVkTm9kZShlZGl0LCB0b0JpdG1hcChzdWJIMSkgfCB0b0JpdG1hcChzdWJIMiksIHN1YkgxID09PSBzdWJIMiA/IFttZXJnZUxlYXZlcyhlZGl0LCBzaGlmdCArIFNJWkUsIGgxLCBuMSwgaDIsIG4yKV0gOiBzdWJIMSA8IHN1YkgyID8gW24xLCBuMl0gOiBbbjIsIG4xXSk7XG59O1xuLyoqXG4gICAgVXBkYXRlIGFuIGVudHJ5IGluIGEgY29sbGlzaW9uIGxpc3QuXG5cbiAgICBAcGFyYW0gbXV0YXRlIFNob3VsZCBtdXRhdGlvbiBiZSB1c2VkP1xuICAgIEBwYXJhbSBlZGl0IEN1cnJlbnQgZWRpdC5cbiAgICBAcGFyYW0ga2V5RXEgS2V5IGNvbXBhcmUgZnVuY3Rpb24uXG4gICAgQHBhcmFtIGhhc2ggSGFzaCBvZiBjb2xsaXNpb24uXG4gICAgQHBhcmFtIGxpc3QgQ29sbGlzaW9uIGxpc3QuXG4gICAgQHBhcmFtIGYgVXBkYXRlIGZ1bmN0aW9uLlxuICAgIEBwYXJhbSBrIEtleSB0byB1cGRhdGUuXG4gICAgQHBhcmFtIHNpemUgU2l6ZSByZWYuXG4qL1xuXG5cbnZhciB1cGRhdGVDb2xsaXNpb25MaXN0ID0gZnVuY3Rpb24gdXBkYXRlQ29sbGlzaW9uTGlzdChtdXRhdGUsIGVkaXQsIGtleUVxLCBoLCBsaXN0LCBmLCBrLCBzaXplKSB7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIGNoaWxkID0gbGlzdFtpXTtcblxuICAgIGlmIChrZXlFcShrLCBjaGlsZC5rZXkpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBjaGlsZC52YWx1ZTtcblxuICAgICAgdmFyIF9uZXdWYWx1ZSA9IGYodmFsdWUpO1xuXG4gICAgICBpZiAoX25ld1ZhbHVlID09PSB2YWx1ZSkgcmV0dXJuIGxpc3Q7XG5cbiAgICAgIGlmIChfbmV3VmFsdWUgPT09IG5vdGhpbmcpIHtcbiAgICAgICAgLS1zaXplLnZhbHVlO1xuICAgICAgICByZXR1cm4gYXJyYXlTcGxpY2VPdXQobXV0YXRlLCBpLCBsaXN0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycmF5VXBkYXRlKG11dGF0ZSwgaSwgTGVhZihlZGl0LCBoLCBrLCBfbmV3VmFsdWUpLCBsaXN0KTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV3VmFsdWUgPSBmKCk7XG4gIGlmIChuZXdWYWx1ZSA9PT0gbm90aGluZykgcmV0dXJuIGxpc3Q7XG4gICsrc2l6ZS52YWx1ZTtcbiAgcmV0dXJuIGFycmF5VXBkYXRlKG11dGF0ZSwgbGVuLCBMZWFmKGVkaXQsIGgsIGssIG5ld1ZhbHVlKSwgbGlzdCk7XG59O1xuXG52YXIgY2FuRWRpdE5vZGUgPSBmdW5jdGlvbiBjYW5FZGl0Tm9kZShlZGl0LCBub2RlKSB7XG4gIHJldHVybiBlZGl0ID09PSBub2RlLmVkaXQ7XG59O1xuLyogRWRpdGluZ1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG52YXIgTGVhZl9fbW9kaWZ5ID0gZnVuY3Rpb24gTGVhZl9fbW9kaWZ5KGVkaXQsIGtleUVxLCBzaGlmdCwgZiwgaCwgaywgc2l6ZSkge1xuICBpZiAoa2V5RXEoaywgdGhpcy5rZXkpKSB7XG4gICAgdmFyIF92ID0gZih0aGlzLnZhbHVlKTtcblxuICAgIGlmIChfdiA9PT0gdGhpcy52YWx1ZSkgcmV0dXJuIHRoaXM7ZWxzZSBpZiAoX3YgPT09IG5vdGhpbmcpIHtcbiAgICAgIC0tc2l6ZS52YWx1ZTtcbiAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9XG5cbiAgICBpZiAoY2FuRWRpdE5vZGUoZWRpdCwgdGhpcykpIHtcbiAgICAgIHRoaXMudmFsdWUgPSBfdjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBMZWFmKGVkaXQsIGgsIGssIF92KTtcbiAgfVxuXG4gIHZhciB2ID0gZigpO1xuICBpZiAodiA9PT0gbm90aGluZykgcmV0dXJuIHRoaXM7XG4gICsrc2l6ZS52YWx1ZTtcbiAgcmV0dXJuIG1lcmdlTGVhdmVzKGVkaXQsIHNoaWZ0LCB0aGlzLmhhc2gsIHRoaXMsIGgsIExlYWYoZWRpdCwgaCwgaywgdikpO1xufTtcblxudmFyIENvbGxpc2lvbl9fbW9kaWZ5ID0gZnVuY3Rpb24gQ29sbGlzaW9uX19tb2RpZnkoZWRpdCwga2V5RXEsIHNoaWZ0LCBmLCBoLCBrLCBzaXplKSB7XG4gIGlmIChoID09PSB0aGlzLmhhc2gpIHtcbiAgICB2YXIgY2FuRWRpdCA9IGNhbkVkaXROb2RlKGVkaXQsIHRoaXMpO1xuICAgIHZhciBsaXN0ID0gdXBkYXRlQ29sbGlzaW9uTGlzdChjYW5FZGl0LCBlZGl0LCBrZXlFcSwgdGhpcy5oYXNoLCB0aGlzLmNoaWxkcmVuLCBmLCBrLCBzaXplKTtcbiAgICBpZiAobGlzdCA9PT0gdGhpcy5jaGlsZHJlbikgcmV0dXJuIHRoaXM7XG4gICAgcmV0dXJuIGxpc3QubGVuZ3RoID4gMSA/IENvbGxpc2lvbihlZGl0LCB0aGlzLmhhc2gsIGxpc3QpIDogbGlzdFswXTsgLy8gY29sbGFwc2Ugc2luZ2xlIGVsZW1lbnQgY29sbGlzaW9uIGxpc3RcbiAgfVxuXG4gIHZhciB2ID0gZigpO1xuICBpZiAodiA9PT0gbm90aGluZykgcmV0dXJuIHRoaXM7XG4gICsrc2l6ZS52YWx1ZTtcbiAgcmV0dXJuIG1lcmdlTGVhdmVzKGVkaXQsIHNoaWZ0LCB0aGlzLmhhc2gsIHRoaXMsIGgsIExlYWYoZWRpdCwgaCwgaywgdikpO1xufTtcblxudmFyIEluZGV4ZWROb2RlX19tb2RpZnkgPSBmdW5jdGlvbiBJbmRleGVkTm9kZV9fbW9kaWZ5KGVkaXQsIGtleUVxLCBzaGlmdCwgZiwgaCwgaywgc2l6ZSkge1xuICB2YXIgbWFzayA9IHRoaXMubWFzaztcbiAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgdmFyIGZyYWcgPSBoYXNoRnJhZ21lbnQoc2hpZnQsIGgpO1xuICB2YXIgYml0ID0gdG9CaXRtYXAoZnJhZyk7XG4gIHZhciBpbmR4ID0gZnJvbUJpdG1hcChtYXNrLCBiaXQpO1xuICB2YXIgZXhpc3RzID0gbWFzayAmIGJpdDtcbiAgdmFyIGN1cnJlbnQgPSBleGlzdHMgPyBjaGlsZHJlbltpbmR4XSA6IGVtcHR5O1xuXG4gIHZhciBjaGlsZCA9IGN1cnJlbnQuX21vZGlmeShlZGl0LCBrZXlFcSwgc2hpZnQgKyBTSVpFLCBmLCBoLCBrLCBzaXplKTtcblxuICBpZiAoY3VycmVudCA9PT0gY2hpbGQpIHJldHVybiB0aGlzO1xuICB2YXIgY2FuRWRpdCA9IGNhbkVkaXROb2RlKGVkaXQsIHRoaXMpO1xuICB2YXIgYml0bWFwID0gbWFzaztcbiAgdmFyIG5ld0NoaWxkcmVuID0gdm9pZCAwO1xuXG4gIGlmIChleGlzdHMgJiYgaXNFbXB0eU5vZGUoY2hpbGQpKSB7XG4gICAgLy8gcmVtb3ZlXG4gICAgYml0bWFwICY9IH5iaXQ7XG4gICAgaWYgKCFiaXRtYXApIHJldHVybiBlbXB0eTtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoIDw9IDIgJiYgaXNMZWFmKGNoaWxkcmVuW2luZHggXiAxXSkpIHJldHVybiBjaGlsZHJlbltpbmR4IF4gMV07IC8vIGNvbGxhcHNlXG5cbiAgICBuZXdDaGlsZHJlbiA9IGFycmF5U3BsaWNlT3V0KGNhbkVkaXQsIGluZHgsIGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmICghZXhpc3RzICYmICFpc0VtcHR5Tm9kZShjaGlsZCkpIHtcbiAgICAvLyBhZGRcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID49IE1BWF9JTkRFWF9OT0RFKSByZXR1cm4gZXhwYW5kKGVkaXQsIGZyYWcsIGNoaWxkLCBtYXNrLCBjaGlsZHJlbik7XG4gICAgYml0bWFwIHw9IGJpdDtcbiAgICBuZXdDaGlsZHJlbiA9IGFycmF5U3BsaWNlSW4oY2FuRWRpdCwgaW5keCwgY2hpbGQsIGNoaWxkcmVuKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtb2RpZnlcbiAgICBuZXdDaGlsZHJlbiA9IGFycmF5VXBkYXRlKGNhbkVkaXQsIGluZHgsIGNoaWxkLCBjaGlsZHJlbik7XG4gIH1cblxuICBpZiAoY2FuRWRpdCkge1xuICAgIHRoaXMubWFzayA9IGJpdG1hcDtcbiAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXR1cm4gSW5kZXhlZE5vZGUoZWRpdCwgYml0bWFwLCBuZXdDaGlsZHJlbik7XG59O1xuXG52YXIgQXJyYXlOb2RlX19tb2RpZnkgPSBmdW5jdGlvbiBBcnJheU5vZGVfX21vZGlmeShlZGl0LCBrZXlFcSwgc2hpZnQsIGYsIGgsIGssIHNpemUpIHtcbiAgdmFyIGNvdW50ID0gdGhpcy5zaXplO1xuICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICB2YXIgZnJhZyA9IGhhc2hGcmFnbWVudChzaGlmdCwgaCk7XG4gIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ZyYWddO1xuXG4gIHZhciBuZXdDaGlsZCA9IChjaGlsZCB8fCBlbXB0eSkuX21vZGlmeShlZGl0LCBrZXlFcSwgc2hpZnQgKyBTSVpFLCBmLCBoLCBrLCBzaXplKTtcblxuICBpZiAoY2hpbGQgPT09IG5ld0NoaWxkKSByZXR1cm4gdGhpcztcbiAgdmFyIGNhbkVkaXQgPSBjYW5FZGl0Tm9kZShlZGl0LCB0aGlzKTtcbiAgdmFyIG5ld0NoaWxkcmVuID0gdm9pZCAwO1xuXG4gIGlmIChpc0VtcHR5Tm9kZShjaGlsZCkgJiYgIWlzRW1wdHlOb2RlKG5ld0NoaWxkKSkge1xuICAgIC8vIGFkZFxuICAgICsrY291bnQ7XG4gICAgbmV3Q2hpbGRyZW4gPSBhcnJheVVwZGF0ZShjYW5FZGl0LCBmcmFnLCBuZXdDaGlsZCwgY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKCFpc0VtcHR5Tm9kZShjaGlsZCkgJiYgaXNFbXB0eU5vZGUobmV3Q2hpbGQpKSB7XG4gICAgLy8gcmVtb3ZlXG4gICAgLS1jb3VudDtcbiAgICBpZiAoY291bnQgPD0gTUlOX0FSUkFZX05PREUpIHJldHVybiBwYWNrKGVkaXQsIGNvdW50LCBmcmFnLCBjaGlsZHJlbik7XG4gICAgbmV3Q2hpbGRyZW4gPSBhcnJheVVwZGF0ZShjYW5FZGl0LCBmcmFnLCBlbXB0eSwgY2hpbGRyZW4pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1vZGlmeVxuICAgIG5ld0NoaWxkcmVuID0gYXJyYXlVcGRhdGUoY2FuRWRpdCwgZnJhZywgbmV3Q2hpbGQsIGNoaWxkcmVuKTtcbiAgfVxuXG4gIGlmIChjYW5FZGl0KSB7XG4gICAgdGhpcy5zaXplID0gY291bnQ7XG4gICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIEFycmF5Tm9kZShlZGl0LCBjb3VudCwgbmV3Q2hpbGRyZW4pO1xufTtcblxuZW1wdHkuX21vZGlmeSA9IGZ1bmN0aW9uIChlZGl0LCBrZXlFcSwgc2hpZnQsIGYsIGgsIGssIHNpemUpIHtcbiAgdmFyIHYgPSBmKCk7XG4gIGlmICh2ID09PSBub3RoaW5nKSByZXR1cm4gZW1wdHk7XG4gICsrc2l6ZS52YWx1ZTtcbiAgcmV0dXJuIExlYWYoZWRpdCwgaCwgaywgdik7XG59O1xuLypcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuZnVuY3Rpb24gTWFwKGVkaXRhYmxlLCBlZGl0LCBjb25maWcsIHJvb3QsIHNpemUpIHtcbiAgdGhpcy5fZWRpdGFibGUgPSBlZGl0YWJsZTtcbiAgdGhpcy5fZWRpdCA9IGVkaXQ7XG4gIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gIHRoaXMuX3NpemUgPSBzaXplO1xufVxuXG5NYXAucHJvdG90eXBlLnNldFRyZWUgPSBmdW5jdGlvbiAobmV3Um9vdCwgbmV3U2l6ZSkge1xuICBpZiAodGhpcy5fZWRpdGFibGUpIHtcbiAgICB0aGlzLl9yb290ID0gbmV3Um9vdDtcbiAgICB0aGlzLl9zaXplID0gbmV3U2l6ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJldHVybiBuZXdSb290ID09PSB0aGlzLl9yb290ID8gdGhpcyA6IG5ldyBNYXAodGhpcy5fZWRpdGFibGUsIHRoaXMuX2VkaXQsIHRoaXMuX2NvbmZpZywgbmV3Um9vdCwgbmV3U2l6ZSk7XG59O1xuLyogUXVlcmllc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gICAgTG9va3VwIHRoZSB2YWx1ZSBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgYSBjdXN0b20gYGhhc2hgLlxuXG4gICAgUmV0dXJucyB0aGUgdmFsdWUgb3IgYGFsdGAgaWYgbm9uZS5cbiovXG5cblxudmFyIHRyeUdldEhhc2ggPSBoYW10LnRyeUdldEhhc2ggPSBmdW5jdGlvbiAoYWx0LCBoYXNoLCBrZXksIG1hcCkge1xuICB2YXIgbm9kZSA9IG1hcC5fcm9vdDtcbiAgdmFyIHNoaWZ0ID0gMDtcbiAgdmFyIGtleUVxID0gbWFwLl9jb25maWcua2V5RXE7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBMRUFGOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGtleUVxKGtleSwgbm9kZS5rZXkpID8gbm9kZS52YWx1ZSA6IGFsdDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIENPTExJU0lPTjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChoYXNoID09PSBub2RlLmhhc2gpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgaWYgKGtleUVxKGtleSwgY2hpbGQua2V5KSkgcmV0dXJuIGNoaWxkLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhbHQ7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBJTkRFWDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBmcmFnID0gaGFzaEZyYWdtZW50KHNoaWZ0LCBoYXNoKTtcbiAgICAgICAgICB2YXIgYml0ID0gdG9CaXRtYXAoZnJhZyk7XG5cbiAgICAgICAgICBpZiAobm9kZS5tYXNrICYgYml0KSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlbltmcm9tQml0bWFwKG5vZGUubWFzaywgYml0KV07XG4gICAgICAgICAgICBzaGlmdCArPSBTSVpFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFsdDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEFSUkFZOlxuICAgICAgICB7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5baGFzaEZyYWdtZW50KHNoaWZ0LCBoYXNoKV07XG5cbiAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgc2hpZnQgKz0gU0laRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhbHQ7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFsdDtcbiAgICB9XG4gIH1cbn07XG5cbk1hcC5wcm90b3R5cGUudHJ5R2V0SGFzaCA9IGZ1bmN0aW9uIChhbHQsIGhhc2gsIGtleSkge1xuICByZXR1cm4gdHJ5R2V0SGFzaChhbHQsIGhhc2gsIGtleSwgdGhpcyk7XG59O1xuLyoqXG4gICAgTG9va3VwIHRoZSB2YWx1ZSBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgaW50ZXJuYWwgaGFzaCBmdW5jdGlvbi5cblxuICAgIEBzZWUgYHRyeUdldEhhc2hgXG4qL1xuXG5cbnZhciB0cnlHZXQgPSBoYW10LnRyeUdldCA9IGZ1bmN0aW9uIChhbHQsIGtleSwgbWFwKSB7XG4gIHJldHVybiB0cnlHZXRIYXNoKGFsdCwgbWFwLl9jb25maWcuaGFzaChrZXkpLCBrZXksIG1hcCk7XG59O1xuXG5NYXAucHJvdG90eXBlLnRyeUdldCA9IGZ1bmN0aW9uIChhbHQsIGtleSkge1xuICByZXR1cm4gdHJ5R2V0KGFsdCwga2V5LCB0aGlzKTtcbn07XG4vKipcbiAgICBMb29rdXAgdGhlIHZhbHVlIGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBhIGN1c3RvbSBgaGFzaGAuXG5cbiAgICBSZXR1cm5zIHRoZSB2YWx1ZSBvciBgdW5kZWZpbmVkYCBpZiBub25lLlxuKi9cblxuXG52YXIgZ2V0SGFzaCA9IGhhbXQuZ2V0SGFzaCA9IGZ1bmN0aW9uIChoYXNoLCBrZXksIG1hcCkge1xuICByZXR1cm4gdHJ5R2V0SGFzaCh1bmRlZmluZWQsIGhhc2gsIGtleSwgbWFwKTtcbn07XG5cbk1hcC5wcm90b3R5cGUuZ2V0SGFzaCA9IGZ1bmN0aW9uIChoYXNoLCBrZXkpIHtcbiAgcmV0dXJuIGdldEhhc2goaGFzaCwga2V5LCB0aGlzKTtcbn07XG4vKipcbiAgICBMb29rdXAgdGhlIHZhbHVlIGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBpbnRlcm5hbCBoYXNoIGZ1bmN0aW9uLlxuXG4gICAgQHNlZSBgZ2V0YFxuKi9cblxuXG52YXIgZ2V0ID0gaGFtdC5nZXQgPSBmdW5jdGlvbiAoa2V5LCBtYXApIHtcbiAgcmV0dXJuIHRyeUdldEhhc2godW5kZWZpbmVkLCBtYXAuX2NvbmZpZy5oYXNoKGtleSksIGtleSwgbWFwKTtcbn07XG5cbk1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSwgYWx0KSB7XG4gIHJldHVybiB0cnlHZXQoYWx0LCBrZXksIHRoaXMpO1xufTtcbi8qKlxuICAgIERvZXMgYW4gZW50cnkgZXhpc3QgZm9yIGBrZXlgIGluIGBtYXBgPyBVc2VzIGN1c3RvbSBgaGFzaGAuXG4qL1xuXG5cbnZhciBoYXNIYXNoID0gaGFtdC5oYXMgPSBmdW5jdGlvbiAoaGFzaCwga2V5LCBtYXApIHtcbiAgcmV0dXJuIHRyeUdldEhhc2gobm90aGluZywgaGFzaCwga2V5LCBtYXApICE9PSBub3RoaW5nO1xufTtcblxuTWFwLnByb3RvdHlwZS5oYXNIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSkge1xuICByZXR1cm4gaGFzSGFzaChoYXNoLCBrZXksIHRoaXMpO1xufTtcbi8qKlxuICAgIERvZXMgYW4gZW50cnkgZXhpc3QgZm9yIGBrZXlgIGluIGBtYXBgPyBVc2VzIGludGVybmFsIGhhc2ggZnVuY3Rpb24uXG4qL1xuXG5cbnZhciBoYXMgPSBoYW10LmhhcyA9IGZ1bmN0aW9uIChrZXksIG1hcCkge1xuICByZXR1cm4gaGFzSGFzaChtYXAuX2NvbmZpZy5oYXNoKGtleSksIGtleSwgbWFwKTtcbn07XG5cbk1hcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gaGFzKGtleSwgdGhpcyk7XG59O1xuXG52YXIgZGVmS2V5Q29tcGFyZSA9IGZ1bmN0aW9uIGRlZktleUNvbXBhcmUoeCwgeSkge1xuICByZXR1cm4geCA9PT0geTtcbn07XG4vKipcbiAgICBDcmVhdGUgYW4gZW1wdHkgbWFwLlxuXG4gICAgQHBhcmFtIGNvbmZpZyBDb25maWd1cmF0aW9uLlxuKi9cblxuXG5oYW10Lm1ha2UgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgTWFwKDAsIDAsIHtcbiAgICBrZXlFcTogY29uZmlnICYmIGNvbmZpZy5rZXlFcSB8fCBkZWZLZXlDb21wYXJlLFxuICAgIGhhc2g6IGNvbmZpZyAmJiBjb25maWcuaGFzaCB8fCBoYXNoXG4gIH0sIGVtcHR5LCAwKTtcbn07XG4vKipcbiAgICBFbXB0eSBtYXAuXG4qL1xuXG5cbmhhbXQuZW1wdHkgPSBoYW10Lm1ha2UoKTtcbi8qKlxuICAgIERvZXMgYG1hcGAgY29udGFpbiBhbnkgZWxlbWVudHM/XG4qL1xuXG52YXIgaXNFbXB0eSA9IGhhbXQuaXNFbXB0eSA9IGZ1bmN0aW9uIChtYXApIHtcbiAgcmV0dXJuIG1hcCAmJiAhIWlzRW1wdHlOb2RlKG1hcC5fcm9vdCk7XG59O1xuXG5NYXAucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0VtcHR5KHRoaXMpO1xufTtcbi8qIFVwZGF0ZXNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICAgIEFsdGVyIHRoZSB2YWx1ZSBzdG9yZWQgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGZ1bmN0aW9uIGBmYCB1c2luZ1xuICAgIGN1c3RvbSBoYXNoLlxuXG4gICAgYGZgIGlzIGludm9rZWQgd2l0aCB0aGUgY3VycmVudCB2YWx1ZSBmb3IgYGtgIGlmIGl0IGV4aXN0cyxcbiAgICBvciBubyBhcmd1bWVudHMgaWYgbm8gc3VjaCB2YWx1ZSBleGlzdHMuIGBtb2RpZnlgIHdpbGwgYWx3YXlzIGVpdGhlclxuICAgIHVwZGF0ZSBvciBpbnNlcnQgYSB2YWx1ZSBpbnRvIHRoZSBtYXAuXG5cbiAgICBSZXR1cm5zIGEgbWFwIHdpdGggdGhlIG1vZGlmaWVkIHZhbHVlLiBEb2VzIG5vdCBhbHRlciBgbWFwYC5cbiovXG5cblxudmFyIG1vZGlmeUhhc2ggPSBoYW10Lm1vZGlmeUhhc2ggPSBmdW5jdGlvbiAoZiwgaGFzaCwga2V5LCBtYXApIHtcbiAgdmFyIHNpemUgPSB7XG4gICAgdmFsdWU6IG1hcC5fc2l6ZVxuICB9O1xuXG4gIHZhciBuZXdSb290ID0gbWFwLl9yb290Ll9tb2RpZnkobWFwLl9lZGl0YWJsZSA/IG1hcC5fZWRpdCA6IE5hTiwgbWFwLl9jb25maWcua2V5RXEsIDAsIGYsIGhhc2gsIGtleSwgc2l6ZSk7XG5cbiAgcmV0dXJuIG1hcC5zZXRUcmVlKG5ld1Jvb3QsIHNpemUudmFsdWUpO1xufTtcblxuTWFwLnByb3RvdHlwZS5tb2RpZnlIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSwgZikge1xuICByZXR1cm4gbW9kaWZ5SGFzaChmLCBoYXNoLCBrZXksIHRoaXMpO1xufTtcbi8qKlxuICAgIEFsdGVyIHRoZSB2YWx1ZSBzdG9yZWQgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGZ1bmN0aW9uIGBmYCB1c2luZ1xuICAgIGludGVybmFsIGhhc2ggZnVuY3Rpb24uXG5cbiAgICBAc2VlIGBtb2RpZnlIYXNoYFxuKi9cblxuXG52YXIgbW9kaWZ5ID0gaGFtdC5tb2RpZnkgPSBmdW5jdGlvbiAoZiwga2V5LCBtYXApIHtcbiAgcmV0dXJuIG1vZGlmeUhhc2goZiwgbWFwLl9jb25maWcuaGFzaChrZXkpLCBrZXksIG1hcCk7XG59O1xuXG5NYXAucHJvdG90eXBlLm1vZGlmeSA9IGZ1bmN0aW9uIChrZXksIGYpIHtcbiAgcmV0dXJuIG1vZGlmeShmLCBrZXksIHRoaXMpO1xufTtcbi8qKlxuICAgIFN0b3JlIGB2YWx1ZWAgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGN1c3RvbSBgaGFzaGAuXG5cbiAgICBSZXR1cm5zIGEgbWFwIHdpdGggdGhlIG1vZGlmaWVkIHZhbHVlLiBEb2VzIG5vdCBhbHRlciBgbWFwYC5cbiovXG5cblxudmFyIHNldEhhc2ggPSBoYW10LnNldEhhc2ggPSBmdW5jdGlvbiAoaGFzaCwga2V5LCB2YWx1ZSwgbWFwKSB7XG4gIHJldHVybiBtb2RpZnlIYXNoKGNvbnN0YW50KHZhbHVlKSwgaGFzaCwga2V5LCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5zZXRIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHNldEhhc2goaGFzaCwga2V5LCB2YWx1ZSwgdGhpcyk7XG59O1xuLyoqXG4gICAgU3RvcmUgYHZhbHVlYCBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgaW50ZXJuYWwgaGFzaCBmdW5jdGlvbi5cblxuICAgIEBzZWUgYHNldEhhc2hgXG4qL1xuXG5cbnZhciBzZXQgPSBoYW10LnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBtYXApIHtcbiAgcmV0dXJuIHNldEhhc2gobWFwLl9jb25maWcuaGFzaChrZXkpLCBrZXksIHZhbHVlLCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc2V0KGtleSwgdmFsdWUsIHRoaXMpO1xufTtcbi8qKlxuICAgIFJlbW92ZSB0aGUgZW50cnkgZm9yIGBrZXlgIGluIGBtYXBgLlxuXG4gICAgUmV0dXJucyBhIG1hcCB3aXRoIHRoZSB2YWx1ZSByZW1vdmVkLiBEb2VzIG5vdCBhbHRlciBgbWFwYC5cbiovXG5cblxudmFyIGRlbCA9IGNvbnN0YW50KG5vdGhpbmcpO1xuXG52YXIgcmVtb3ZlSGFzaCA9IGhhbXQucmVtb3ZlSGFzaCA9IGZ1bmN0aW9uIChoYXNoLCBrZXksIG1hcCkge1xuICByZXR1cm4gbW9kaWZ5SGFzaChkZWwsIGhhc2gsIGtleSwgbWFwKTtcbn07XG5cbk1hcC5wcm90b3R5cGUucmVtb3ZlSGFzaCA9IE1hcC5wcm90b3R5cGUuZGVsZXRlSGFzaCA9IGZ1bmN0aW9uIChoYXNoLCBrZXkpIHtcbiAgcmV0dXJuIHJlbW92ZUhhc2goaGFzaCwga2V5LCB0aGlzKTtcbn07XG4vKipcbiAgICBSZW1vdmUgdGhlIGVudHJ5IGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBpbnRlcm5hbCBoYXNoIGZ1bmN0aW9uLlxuXG4gICAgQHNlZSBgcmVtb3ZlSGFzaGBcbiovXG5cblxudmFyIHJlbW92ZSA9IGhhbXQucmVtb3ZlID0gZnVuY3Rpb24gKGtleSwgbWFwKSB7XG4gIHJldHVybiByZW1vdmVIYXNoKG1hcC5fY29uZmlnLmhhc2goa2V5KSwga2V5LCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBNYXAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHJlbW92ZShrZXksIHRoaXMpO1xufTtcbi8qIE11dGF0aW9uXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBNYXJrIGBtYXBgIGFzIG11dGFibGUuXG4gKi9cblxuXG52YXIgYmVnaW5NdXRhdGlvbiA9IGhhbXQuYmVnaW5NdXRhdGlvbiA9IGZ1bmN0aW9uIChtYXApIHtcbiAgcmV0dXJuIG5ldyBNYXAobWFwLl9lZGl0YWJsZSArIDEsIG1hcC5fZWRpdCArIDEsIG1hcC5fY29uZmlnLCBtYXAuX3Jvb3QsIG1hcC5fc2l6ZSk7XG59O1xuXG5NYXAucHJvdG90eXBlLmJlZ2luTXV0YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBiZWdpbk11dGF0aW9uKHRoaXMpO1xufTtcbi8qKlxuICAgIE1hcmsgYG1hcGAgYXMgaW1tdXRhYmxlLlxuICovXG5cblxudmFyIGVuZE11dGF0aW9uID0gaGFtdC5lbmRNdXRhdGlvbiA9IGZ1bmN0aW9uIChtYXApIHtcbiAgbWFwLl9lZGl0YWJsZSA9IG1hcC5fZWRpdGFibGUgJiYgbWFwLl9lZGl0YWJsZSAtIDE7XG4gIHJldHVybiBtYXA7XG59O1xuXG5NYXAucHJvdG90eXBlLmVuZE11dGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZW5kTXV0YXRpb24odGhpcyk7XG59O1xuLyoqXG4gICAgTXV0YXRlIGBtYXBgIHdpdGhpbiB0aGUgY29udGV4dCBvZiBgZmAuXG4gICAgQHBhcmFtIGZcbiAgICBAcGFyYW0gbWFwIEhBTVRcbiovXG5cblxudmFyIG11dGF0ZSA9IGhhbXQubXV0YXRlID0gZnVuY3Rpb24gKGYsIG1hcCkge1xuICB2YXIgdHJhbnNpZW50ID0gYmVnaW5NdXRhdGlvbihtYXApO1xuICBmKHRyYW5zaWVudCk7XG4gIHJldHVybiBlbmRNdXRhdGlvbih0cmFuc2llbnQpO1xufTtcblxuTWFwLnByb3RvdHlwZS5tdXRhdGUgPSBmdW5jdGlvbiAoZikge1xuICByZXR1cm4gbXV0YXRlKGYsIHRoaXMpO1xufTtcbi8qIFRyYXZlcnNhbFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gICAgQXBwbHkgYSBjb250aW51YXRpb24uXG4qL1xuXG5cbnZhciBhcHBrID0gZnVuY3Rpb24gYXBwayhrKSB7XG4gIHJldHVybiBrICYmIGxhenlWaXNpdENoaWxkcmVuKGtbMF0sIGtbMV0sIGtbMl0sIGtbM10sIGtbNF0pO1xufTtcbi8qKlxuICAgIFJlY3Vyc2l2ZWx5IHZpc2l0IGFsbCB2YWx1ZXMgc3RvcmVkIGluIGFuIGFycmF5IG9mIG5vZGVzIGxhemlseS5cbiovXG5cblxudmFyIGxhenlWaXNpdENoaWxkcmVuID0gZnVuY3Rpb24gbGF6eVZpc2l0Q2hpbGRyZW4obGVuLCBjaGlsZHJlbiwgaSwgZiwgaykge1xuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2krK107XG4gICAgaWYgKGNoaWxkICYmICFpc0VtcHR5Tm9kZShjaGlsZCkpIHJldHVybiBsYXp5VmlzaXQoY2hpbGQsIGYsIFtsZW4sIGNoaWxkcmVuLCBpLCBmLCBrXSk7XG4gIH1cblxuICByZXR1cm4gYXBwayhrKTtcbn07XG4vKipcbiAgICBSZWN1cnNpdmVseSB2aXNpdCBhbGwgdmFsdWVzIHN0b3JlZCBpbiBgbm9kZWAgbGF6aWx5LlxuKi9cblxuXG52YXIgbGF6eVZpc2l0ID0gZnVuY3Rpb24gbGF6eVZpc2l0KG5vZGUsIGYsIGspIHtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIExFQUY6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogZihub2RlKSxcbiAgICAgICAgcmVzdDoga1xuICAgICAgfTtcblxuICAgIGNhc2UgQ09MTElTSU9OOlxuICAgIGNhc2UgQVJSQVk6XG4gICAgY2FzZSBJTkRFWDpcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICByZXR1cm4gbGF6eVZpc2l0Q2hpbGRyZW4oY2hpbGRyZW4ubGVuZ3RoLCBjaGlsZHJlbiwgMCwgZiwgayk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGFwcGsoayk7XG4gIH1cbn07XG5cbnZhciBET05FID0ge1xuICBkb25lOiB0cnVlXG59O1xuLyoqXG4gICAgSmF2YXNjcmlwdCBpdGVyYXRvciBvdmVyIGEgbWFwLlxuKi9cblxuZnVuY3Rpb24gTWFwSXRlcmF0b3Iodikge1xuICB0aGlzLnYgPSB2O1xufVxuXG5NYXBJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnYpIHJldHVybiBET05FO1xuICB2YXIgdjAgPSB0aGlzLnY7XG4gIHRoaXMudiA9IGFwcGsodjAucmVzdCk7XG4gIHJldHVybiB2MDtcbn07XG5cbk1hcEl0ZXJhdG9yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAgICBMYXppbHkgdmlzaXQgZWFjaCB2YWx1ZSBpbiBtYXAgd2l0aCBmdW5jdGlvbiBgZmAuXG4qL1xuXG5cbnZhciB2aXNpdCA9IGZ1bmN0aW9uIHZpc2l0KG1hcCwgZikge1xuICByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKGxhenlWaXNpdChtYXAuX3Jvb3QsIGYpKTtcbn07XG4vKipcbiAgICBHZXQgYSBKYXZhc2NzcmlwdCBpdGVyYXRvciBvZiBgbWFwYC5cblxuICAgIEl0ZXJhdGVzIG92ZXIgYFtrZXksIHZhbHVlXWAgYXJyYXlzLlxuKi9cblxuXG52YXIgYnVpbGRQYWlycyA9IGZ1bmN0aW9uIGJ1aWxkUGFpcnMoeCkge1xuICByZXR1cm4gW3gua2V5LCB4LnZhbHVlXTtcbn07XG5cbnZhciBlbnRyaWVzID0gaGFtdC5lbnRyaWVzID0gZnVuY3Rpb24gKG1hcCkge1xuICByZXR1cm4gdmlzaXQobWFwLCBidWlsZFBhaXJzKTtcbn07XG5cbk1hcC5wcm90b3R5cGUuZW50cmllcyA9IE1hcC5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGVudHJpZXModGhpcyk7XG59O1xuLyoqXG4gICAgR2V0IGFycmF5IG9mIGFsbCBrZXlzIGluIGBtYXBgLlxuXG4gICAgT3JkZXIgaXMgbm90IGd1YXJhbnRlZWQuXG4qL1xuXG5cbnZhciBidWlsZEtleXMgPSBmdW5jdGlvbiBidWlsZEtleXMoeCkge1xuICByZXR1cm4geC5rZXk7XG59O1xuXG52YXIga2V5cyA9IGhhbXQua2V5cyA9IGZ1bmN0aW9uIChtYXApIHtcbiAgcmV0dXJuIHZpc2l0KG1hcCwgYnVpbGRLZXlzKTtcbn07XG5cbk1hcC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGtleXModGhpcyk7XG59O1xuLyoqXG4gICAgR2V0IGFycmF5IG9mIGFsbCB2YWx1ZXMgaW4gYG1hcGAuXG5cbiAgICBPcmRlciBpcyBub3QgZ3VhcmFudGVlZCwgZHVwbGljYXRlcyBhcmUgcHJlc2VydmVkLlxuKi9cblxuXG52YXIgYnVpbGRWYWx1ZXMgPSBmdW5jdGlvbiBidWlsZFZhbHVlcyh4KSB7XG4gIHJldHVybiB4LnZhbHVlO1xufTtcblxudmFyIHZhbHVlcyA9IGhhbXQudmFsdWVzID0gTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAobWFwKSB7XG4gIHJldHVybiB2aXNpdChtYXAsIGJ1aWxkVmFsdWVzKTtcbn07XG5cbk1hcC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdmFsdWVzKHRoaXMpO1xufTtcbi8qIEZvbGRcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICAgIFZpc2l0IGV2ZXJ5IGVudHJ5IGluIHRoZSBtYXAsIGFnZ3JlZ2F0aW5nIGRhdGEuXG5cbiAgICBPcmRlciBvZiBub2RlcyBpcyBub3QgZ3VhcmFudGVlZC5cblxuICAgIEBwYXJhbSBmIEZ1bmN0aW9uIG1hcHBpbmcgYWNjdW11bGF0ZWQgdmFsdWUsIHZhbHVlLCBhbmQga2V5IHRvIG5ldyB2YWx1ZS5cbiAgICBAcGFyYW0geiBTdGFydGluZyB2YWx1ZS5cbiAgICBAcGFyYW0gbSBIQU1UXG4qL1xuXG5cbnZhciBmb2xkID0gaGFtdC5mb2xkID0gZnVuY3Rpb24gKGYsIHosIG0pIHtcbiAgdmFyIHJvb3QgPSBtLl9yb290O1xuICBpZiAocm9vdC50eXBlID09PSBMRUFGKSByZXR1cm4gZih6LCByb290LnZhbHVlLCByb290LmtleSk7XG4gIHZhciB0b1Zpc2l0ID0gW3Jvb3QuY2hpbGRyZW5dO1xuICB2YXIgY2hpbGRyZW4gPSB2b2lkIDA7XG5cbiAgd2hpbGUgKGNoaWxkcmVuID0gdG9WaXNpdC5wb3AoKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47KSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpKytdO1xuXG4gICAgICBpZiAoY2hpbGQgJiYgY2hpbGQudHlwZSkge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gTEVBRikgeiA9IGYoeiwgY2hpbGQudmFsdWUsIGNoaWxkLmtleSk7ZWxzZSB0b1Zpc2l0LnB1c2goY2hpbGQuY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB6O1xufTtcblxuTWFwLnByb3RvdHlwZS5mb2xkID0gZnVuY3Rpb24gKGYsIHopIHtcbiAgcmV0dXJuIGZvbGQoZiwgeiwgdGhpcyk7XG59O1xuLyoqXG4gICAgVmlzaXQgZXZlcnkgZW50cnkgaW4gdGhlIG1hcCwgYWdncmVnYXRpbmcgZGF0YS5cblxuICAgIE9yZGVyIG9mIG5vZGVzIGlzIG5vdCBndWFyYW50ZWVkLlxuXG4gICAgQHBhcmFtIGYgRnVuY3Rpb24gaW52b2tlZCB3aXRoIHZhbHVlIGFuZCBrZXlcbiAgICBAcGFyYW0gbWFwIEhBTVRcbiovXG5cblxudmFyIGZvckVhY2ggPSBoYW10LmZvckVhY2ggPSBmdW5jdGlvbiAoZiwgbWFwKSB7XG4gIHJldHVybiBmb2xkKGZ1bmN0aW9uIChfLCB2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIGYodmFsdWUsIGtleSwgbWFwKTtcbiAgfSwgbnVsbCwgbWFwKTtcbn07XG5cbk1hcC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmKSB7XG4gIHJldHVybiBmb3JFYWNoKGYsIHRoaXMpO1xufTtcbi8qIEFnZ3JlZ2F0ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gICAgR2V0IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiBgbWFwYC5cbiovXG5cblxudmFyIGNvdW50ID0gaGFtdC5jb3VudCA9IGZ1bmN0aW9uIChtYXApIHtcbiAgcmV0dXJuIG1hcC5fc2l6ZTtcbn07XG5cbk1hcC5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjb3VudCh0aGlzKTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXAucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgZ2V0OiBNYXAucHJvdG90eXBlLmNvdW50XG59KTtcbi8qIEV4cG9ydFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuaWYgKCBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGhhbXQ7XG59IGVsc2Uge1xuICB1bmRlZmluZWQuaGFtdCA9IGhhbXQ7XG59XG59KTtcblxuY2xhc3MgQnVpbHRJbk1hcCB7XG4gIGNvbnN0cnVjdG9yKGV4aXN0aW5nKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX21hcFwiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcChleGlzdGluZyA9PT0gbnVsbCB8fCBleGlzdGluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhpc3RpbmcuZW50cmllcygpKTtcbiAgfVxuXG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5rZXlzKCk7XG4gIH1cblxuICBlbnRyaWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuZW50cmllcygpO1xuICB9XG5cbiAgZ2V0KGspIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmdldChrKTtcbiAgfVxuXG4gIGhhcyhrKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoayk7XG4gIH1cblxuICBzZXQoaywgdikge1xuICAgIHRoaXMuX21hcC5zZXQoaywgdik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRlbGV0ZShrKSB7XG4gICAgdGhpcy5fbWFwLmRlbGV0ZShrKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIHBlcnNpc3RlbnRNYXAodGhpcyk7XG4gIH1cblxuICB0b01hcCgpIHtcbiAgICByZXR1cm4gbmV3IE1hcCh0aGlzLl9tYXApO1xuICB9XG5cbn1cblxuY2xhc3MgSGFzaEFycmF5TWFwcGVkVHJpZU1hcCB7XG4gIC8vIEJlY2F1c2UgaGFtdC5lbXB0eSBpcyBub3QgYSBmdW5jdGlvbiB0aGVyZSBpcyBubyB3YXkgdG8gaW50cm9kdWNlIHR5cGVcbiAgLy8gcGFyYW1ldGVycyBvbiBpdCwgc28gZW1wdHkgaXMgdHlwZWQgYXMgSEFNVFBsdXNNYXA8c3RyaW5nLCBtaXhlZD4uXG4gIC8vICRGbG93SXNzdWVcbiAgY29uc3RydWN0b3IoZXhpc3RpbmcpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaGFtdFwiLCBoYW10XzEuZW1wdHkuYmVnaW5NdXRhdGlvbigpKTtcblxuICAgIGlmIChleGlzdGluZyBpbnN0YW5jZW9mIEhhc2hBcnJheU1hcHBlZFRyaWVNYXApIHtcbiAgICAgIGNvbnN0IGggPSBleGlzdGluZy5faGFtdC5lbmRNdXRhdGlvbigpO1xuXG4gICAgICBleGlzdGluZy5faGFtdCA9IGguYmVnaW5NdXRhdGlvbigpO1xuICAgICAgdGhpcy5faGFtdCA9IGguYmVnaW5NdXRhdGlvbigpO1xuICAgIH0gZWxzZSBpZiAoZXhpc3RpbmcpIHtcbiAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIGV4aXN0aW5nLmVudHJpZXMoKSkge1xuICAgICAgICB0aGlzLl9oYW10LnNldChrLCB2KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLl9oYW10LmtleXMoKTtcbiAgfVxuXG4gIGVudHJpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhbXQuZW50cmllcygpO1xuICB9XG5cbiAgZ2V0KGspIHtcbiAgICByZXR1cm4gdGhpcy5faGFtdC5nZXQoayk7XG4gIH1cblxuICBoYXMoaykge1xuICAgIHJldHVybiB0aGlzLl9oYW10LmhhcyhrKTtcbiAgfVxuXG4gIHNldChrLCB2KSB7XG4gICAgdGhpcy5faGFtdC5zZXQoaywgdik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRlbGV0ZShrKSB7XG4gICAgdGhpcy5faGFtdC5kZWxldGUoayk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBwZXJzaXN0ZW50TWFwKHRoaXMpO1xuICB9XG5cbiAgdG9NYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAodGhpcy5faGFtdCk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBwZXJzaXN0ZW50TWFwKGV4aXN0aW5nKSB7XG4gIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfaGFtdF8yMDIwJykpIHtcbiAgICByZXR1cm4gbmV3IEhhc2hBcnJheU1hcHBlZFRyaWVNYXAoZXhpc3RpbmcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgQnVpbHRJbk1hcChleGlzdGluZyk7XG4gIH1cbn1cblxudmFyIFJlY29pbF9QZXJzaXN0ZW50TWFwID0ge1xuICBwZXJzaXN0ZW50TWFwXG59O1xuXG52YXIgUmVjb2lsX1BlcnNpc3RlbnRNYXBfMSA9IFJlY29pbF9QZXJzaXN0ZW50TWFwLnBlcnNpc3RlbnRNYXA7XG5cbnZhciBSZWNvaWxfUGVyc2lzdGVudE1hcCQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHBlcnNpc3RlbnRNYXA6IFJlY29pbF9QZXJzaXN0ZW50TWFwXzFcbn0pO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vKipcbiAqIFJldHVybnMgYSBzZXQgY29udGFpbmluZyBhbGwgb2YgdGhlIHZhbHVlcyBmcm9tIHRoZSBmaXJzdCBzZXQgdGhhdCBhcmUgbm90XG4gKiBwcmVzZW50IGluIGFueSBvZiB0aGUgc3Vic2VxdWVudCBzZXRzLlxuICpcbiAqIE5vdGU6IHRoaXMgaXMgd3JpdHRlbiBwcm9jZWR1cmFsbHkgKGkuZS4sIHdpdGhvdXQgZmlsdGVyU2V0KSBmb3IgcGVyZm9ybWFudFxuICogdXNlIGluIHRpZ2h0IGxvb3BzLlxuICovXG5cbmZ1bmN0aW9uIGRpZmZlcmVuY2VTZXRzKHNldCwgLi4uc2V0c1dpdGhWYWx1ZXNUb1JlbW92ZSkge1xuICBjb25zdCByZXQgPSBuZXcgU2V0KCk7XG5cbiAgRklSU1Q6IGZvciAoY29uc3QgdmFsdWUgb2Ygc2V0KSB7XG4gICAgZm9yIChjb25zdCBvdGhlclNldCBvZiBzZXRzV2l0aFZhbHVlc1RvUmVtb3ZlKSB7XG4gICAgICBpZiAob3RoZXJTZXQuaGFzKHZhbHVlKSkge1xuICAgICAgICBjb250aW51ZSBGSVJTVDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXQuYWRkKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbnZhciBSZWNvaWxfZGlmZmVyZW5jZVNldHMgPSBkaWZmZXJlbmNlU2V0cztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IE1hcCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIHRoZSBvcmlnaW5hbCwgYnV0IHdpdGggdGhlXG4gKiB2YWx1ZXMgcmVwbGFjZWQgd2l0aCB0aGUgb3V0cHV0IG9mIHRoZSBnaXZlbiBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBtYXBNYXAobWFwLCBjYWxsYmFjaykge1xuICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gIG1hcC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgcmVzdWx0LnNldChrZXksIGNhbGxiYWNrKHZhbHVlLCBrZXkpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBSZWNvaWxfbWFwTWFwID0gbWFwTWFwO1xuXG5mdW5jdGlvbiBtYWtlR3JhcGgoKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZURlcHM6IG5ldyBNYXAoKSxcbiAgICBub2RlVG9Ob2RlU3Vic2NyaXB0aW9uczogbmV3IE1hcCgpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsb25lR3JhcGgoZ3JhcGgpIHtcbiAgcmV0dXJuIHtcbiAgICBub2RlRGVwczogUmVjb2lsX21hcE1hcChncmFwaC5ub2RlRGVwcywgcyA9PiBuZXcgU2V0KHMpKSxcbiAgICBub2RlVG9Ob2RlU3Vic2NyaXB0aW9uczogUmVjb2lsX21hcE1hcChncmFwaC5ub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucywgcyA9PiBuZXcgU2V0KHMpKVxuICB9O1xufSAvLyBOb3RlIHRoYXQgdGhpcyBvdmVyd3JpdGVzIHRoZSBkZXBzIG9mIGV4aXN0aW5nIG5vZGVzLCByYXRoZXIgdGhhbiB1bmlvbmluZ1xuLy8gdGhlIG5ldyBkZXBzIHdpdGggdGhlIG9sZCBkZXBzLlxuXG5cbmZ1bmN0aW9uIG1lcmdlRGVwc0ludG9HcmFwaChrZXksIG5ld0RlcHMsIGdyYXBoLCAvLyBJZiBvbGRlckdyYXBoIGlzIGdpdmVuIHRoZW4gd2Ugd2lsbCBub3Qgb3ZlcndyaXRlIGNoYW5nZXMgbWFkZSB0byB0aGUgZ2l2ZW5cbi8vIGdyYXBoIGNvbXBhcmVkIHdpdGggb2xkZXJHcmFwaDpcbm9sZGVyR3JhcGgpIHtcbiAgY29uc3Qge1xuICAgIG5vZGVEZXBzLFxuICAgIG5vZGVUb05vZGVTdWJzY3JpcHRpb25zXG4gIH0gPSBncmFwaDtcbiAgY29uc3Qgb2xkRGVwcyA9IG5vZGVEZXBzLmdldChrZXkpO1xuXG4gIGlmIChvbGREZXBzICYmIG9sZGVyR3JhcGggJiYgb2xkRGVwcyAhPT0gb2xkZXJHcmFwaC5ub2RlRGVwcy5nZXQoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBVcGRhdGUgbm9kZURlcHM6XG5cblxuICBub2RlRGVwcy5zZXQoa2V5LCBuZXdEZXBzKTsgLy8gQWRkIG5ldyBkZXBzIHRvIG5vZGVUb05vZGVTdWJzY3JpcHRpb25zOlxuXG4gIGNvbnN0IGFkZGVkRGVwcyA9IG9sZERlcHMgPT0gbnVsbCA/IG5ld0RlcHMgOiBSZWNvaWxfZGlmZmVyZW5jZVNldHMobmV3RGVwcywgb2xkRGVwcyk7XG5cbiAgZm9yIChjb25zdCBkZXAgb2YgYWRkZWREZXBzKSB7XG4gICAgaWYgKCFub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5oYXMoZGVwKSkge1xuICAgICAgbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMuc2V0KGRlcCwgbmV3IFNldCgpKTtcbiAgICB9XG5cbiAgICBjb25zdCBleGlzdGluZyA9IFJlY29pbF9udWxsdGhyb3dzKG5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmdldChkZXApKTtcbiAgICBleGlzdGluZy5hZGQoa2V5KTtcbiAgfSAvLyBSZW1vdmUgcmVtb3ZlZCBkZXBzIGZyb20gbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnM6XG5cblxuICBpZiAob2xkRGVwcykge1xuICAgIGNvbnN0IHJlbW92ZWREZXBzID0gUmVjb2lsX2RpZmZlcmVuY2VTZXRzKG9sZERlcHMsIG5ld0RlcHMpO1xuXG4gICAgZm9yIChjb25zdCBkZXAgb2YgcmVtb3ZlZERlcHMpIHtcbiAgICAgIGlmICghbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMuaGFzKGRlcCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBleGlzdGluZyA9IFJlY29pbF9udWxsdGhyb3dzKG5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmdldChkZXApKTtcbiAgICAgIGV4aXN0aW5nLmRlbGV0ZShrZXkpO1xuXG4gICAgICBpZiAoZXhpc3Rpbmcuc2l6ZSA9PT0gMCkge1xuICAgICAgICBub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5kZWxldGUoZGVwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2F2ZURlcHNUb1N0b3JlKGtleSwgZGVwcywgc3RvcmUsIHZlcnNpb24pIHtcbiAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlLCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QsIF9zdG9yZVN0YXRlJHByZXZpb3VzVDIsIF9zdG9yZVN0YXRlJHByZXZpb3VzVDM7XG5cbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgaWYgKCEodmVyc2lvbiA9PT0gc3RvcmVTdGF0ZS5jdXJyZW50VHJlZS52ZXJzaW9uIHx8IHZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkbmV4dFRyZWUgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkbmV4dFRyZWUudmVyc2lvbikgfHwgdmVyc2lvbiA9PT0gKChfc3RvcmVTdGF0ZSRwcmV2aW91c1QgPSBzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkcHJldmlvdXNUID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRwcmV2aW91c1QudmVyc2lvbikpKSB7XG4gICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdUcmllZCB0byBzYXZlIGRlcGVuZGVuY2llcyB0byBhIGRpc2NhcmRlZCB0cmVlJyk7XG4gIH0gLy8gTWVyZ2UgdGhlIGRlcGVuZGVuY2llcyBkaXNjb3ZlcmVkIGludG8gdGhlIHN0b3JlJ3MgZGVwZW5kZW5jeSBtYXBcbiAgLy8gZm9yIHRoZSB2ZXJzaW9uIHRoYXQgd2FzIHJlYWQ6XG5cblxuICBjb25zdCBncmFwaCA9IHN0b3JlLmdldEdyYXBoKHZlcnNpb24pO1xuICBtZXJnZURlcHNJbnRvR3JhcGgoa2V5LCBkZXBzLCBncmFwaCk7IC8vIElmIHRoaXMgdmVyc2lvbiBpcyBub3QgdGhlIGxhdGVzdCB2ZXJzaW9uLCBhbHNvIHdyaXRlIHRoZXNlIGRlcGVuZGVuY2llc1xuICAvLyBpbnRvIGxhdGVyIHZlcnNpb25zIGlmIHRoZXkgZG9uJ3QgYWxyZWFkeSBoYXZlIHRoZWlyIG93bjpcblxuICBpZiAodmVyc2lvbiA9PT0gKChfc3RvcmVTdGF0ZSRwcmV2aW91c1QyID0gc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUpID09PSBudWxsIHx8IF9zdG9yZVN0YXRlJHByZXZpb3VzVDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZVN0YXRlJHByZXZpb3VzVDIudmVyc2lvbikpIHtcbiAgICBjb25zdCBjdXJyZW50R3JhcGggPSBzdG9yZS5nZXRHcmFwaChzdG9yZVN0YXRlLmN1cnJlbnRUcmVlLnZlcnNpb24pO1xuICAgIG1lcmdlRGVwc0ludG9HcmFwaChrZXksIGRlcHMsIGN1cnJlbnRHcmFwaCwgZ3JhcGgpO1xuICB9XG5cbiAgaWYgKHZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkcHJldmlvdXNUMyA9IHN0b3JlU3RhdGUucHJldmlvdXNUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRwcmV2aW91c1QzLnZlcnNpb24pIHx8IHZlcnNpb24gPT09IHN0b3JlU3RhdGUuY3VycmVudFRyZWUudmVyc2lvbikge1xuICAgIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZTI7XG5cbiAgICBjb25zdCBuZXh0VmVyc2lvbiA9IChfc3RvcmVTdGF0ZSRuZXh0VHJlZTIgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRuZXh0VHJlZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZVN0YXRlJG5leHRUcmVlMi52ZXJzaW9uO1xuXG4gICAgaWYgKG5leHRWZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IG5leHRHcmFwaCA9IHN0b3JlLmdldEdyYXBoKG5leHRWZXJzaW9uKTtcbiAgICAgIG1lcmdlRGVwc0ludG9HcmFwaChrZXksIGRlcHMsIG5leHRHcmFwaCwgZ3JhcGgpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVjb2lsX0dyYXBoID0ge1xuICBjbG9uZUdyYXBoLFxuICBncmFwaDogbWFrZUdyYXBoLFxuICBzYXZlRGVwc1RvU3RvcmVcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxubGV0IG5leHRUcmVlU3RhdGVWZXJzaW9uID0gMDtcblxuY29uc3QgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24gPSAoKSA9PiBuZXh0VHJlZVN0YXRlVmVyc2lvbisrO1xuXG5sZXQgbmV4dFN0b3JlSUQgPSAwO1xuXG5jb25zdCBnZXROZXh0U3RvcmVJRCA9ICgpID0+IG5leHRTdG9yZUlEKys7XG5cbmxldCBuZXh0Q29tcG9uZW50SUQgPSAwO1xuXG5jb25zdCBnZXROZXh0Q29tcG9uZW50SUQgPSAoKSA9PiBuZXh0Q29tcG9uZW50SUQrKztcblxudmFyIFJlY29pbF9LZXlzID0ge1xuICBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbixcbiAgZ2V0TmV4dFN0b3JlSUQsXG4gIGdldE5leHRDb21wb25lbnRJRFxufTtcblxuY29uc3Qge1xuICBwZXJzaXN0ZW50TWFwOiBwZXJzaXN0ZW50TWFwJDFcbn0gPSBSZWNvaWxfUGVyc2lzdGVudE1hcCQxO1xuXG5jb25zdCB7XG4gIGdyYXBoXG59ID0gUmVjb2lsX0dyYXBoO1xuXG5jb25zdCB7XG4gIGdldE5leHRUcmVlU3RhdGVWZXJzaW9uOiBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQxXG59ID0gUmVjb2lsX0tleXM7XG5cbmZ1bmN0aW9uIG1ha2VFbXB0eVRyZWVTdGF0ZSgpIHtcbiAgY29uc3QgdmVyc2lvbiA9IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDEoKTtcbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uLFxuICAgIHN0YXRlSUQ6IHZlcnNpb24sXG4gICAgdHJhbnNhY3Rpb25NZXRhZGF0YToge30sXG4gICAgZGlydHlBdG9tczogbmV3IFNldCgpLFxuICAgIGF0b21WYWx1ZXM6IHBlcnNpc3RlbnRNYXAkMSgpLFxuICAgIG5vbnZhbGlkYXRlZEF0b21zOiBwZXJzaXN0ZW50TWFwJDEoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlRW1wdHlTdG9yZVN0YXRlKCkge1xuICBjb25zdCBjdXJyZW50VHJlZSA9IG1ha2VFbXB0eVRyZWVTdGF0ZSgpO1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnRUcmVlLFxuICAgIG5leHRUcmVlOiBudWxsLFxuICAgIHByZXZpb3VzVHJlZTogbnVsbCxcbiAgICBjb21taXREZXB0aDogMCxcbiAgICBrbm93bkF0b21zOiBuZXcgU2V0KCksXG4gICAga25vd25TZWxlY3RvcnM6IG5ldyBTZXQoKSxcbiAgICB0cmFuc2FjdGlvblN1YnNjcmlwdGlvbnM6IG5ldyBNYXAoKSxcbiAgICBub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zOiBuZXcgTWFwKCksXG4gICAgbm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9uczogbmV3IE1hcCgpLFxuICAgIHF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVEOiBbXSxcbiAgICBzdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnM6IG5ldyBTZXQoKSxcbiAgICBncmFwaHNCeVZlcnNpb246IG5ldyBNYXAoKS5zZXQoY3VycmVudFRyZWUudmVyc2lvbiwgZ3JhcGgoKSksXG4gICAgcmV0ZW50aW9uOiB7XG4gICAgICByZWZlcmVuY2VDb3VudHM6IG5ldyBNYXAoKSxcbiAgICAgIG5vZGVzUmV0YWluZWRCeVpvbmU6IG5ldyBNYXAoKSxcbiAgICAgIHJldGFpbmFibGVzVG9DaGVja0ZvclJlbGVhc2U6IG5ldyBTZXQoKVxuICAgIH0sXG4gICAgbm9kZUNsZWFudXBGdW5jdGlvbnM6IG5ldyBNYXAoKVxuICB9O1xufVxuXG52YXIgUmVjb2lsX1N0YXRlID0ge1xuICBtYWtlRW1wdHlUcmVlU3RhdGUsXG4gIG1ha2VFbXB0eVN0b3JlU3RhdGUsXG4gIGdldE5leHRUcmVlU3RhdGVWZXJzaW9uOiBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQxXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmNsYXNzIFJldGVudGlvblpvbmUge31cblxuZnVuY3Rpb24gcmV0ZW50aW9uWm9uZSgpIHtcbiAgcmV0dXJuIG5ldyBSZXRlbnRpb25ab25lKCk7XG59XG5cbnZhciBSZWNvaWxfUmV0ZW50aW9uWm9uZSA9IHtcbiAgUmV0ZW50aW9uWm9uZSxcbiAgcmV0ZW50aW9uWm9uZVxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFV0aWxpdGllcyBmb3Igd29ya2luZyB3aXRoIGJ1aWx0LWluIE1hcHMgYW5kIFNldHMgd2l0aG91dCBtdXRhdGluZyB0aGVtLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiBzZXRCeUFkZGluZ1RvU2V0KHNldCwgdikge1xuICBjb25zdCBuZXh0ID0gbmV3IFNldChzZXQpO1xuICBuZXh0LmFkZCh2KTtcbiAgcmV0dXJuIG5leHQ7XG59XG5cbmZ1bmN0aW9uIHNldEJ5RGVsZXRpbmdGcm9tU2V0KHNldCwgdikge1xuICBjb25zdCBuZXh0ID0gbmV3IFNldChzZXQpO1xuICBuZXh0LmRlbGV0ZSh2KTtcbiAgcmV0dXJuIG5leHQ7XG59XG5cbmZ1bmN0aW9uIG1hcEJ5U2V0dGluZ0luTWFwKG1hcCwgaywgdikge1xuICBjb25zdCBuZXh0ID0gbmV3IE1hcChtYXApO1xuICBuZXh0LnNldChrLCB2KTtcbiAgcmV0dXJuIG5leHQ7XG59XG5cbmZ1bmN0aW9uIG1hcEJ5VXBkYXRpbmdJbk1hcChtYXAsIGssIHVwZGF0ZXIpIHtcbiAgY29uc3QgbmV4dCA9IG5ldyBNYXAobWFwKTtcbiAgbmV4dC5zZXQoaywgdXBkYXRlcihuZXh0LmdldChrKSkpO1xuICByZXR1cm4gbmV4dDtcbn1cblxuZnVuY3Rpb24gbWFwQnlEZWxldGluZ0Zyb21NYXAobWFwLCBrKSB7XG4gIGNvbnN0IG5leHQgPSBuZXcgTWFwKG1hcCk7XG4gIG5leHQuZGVsZXRlKGspO1xuICByZXR1cm4gbmV4dDtcbn1cblxuZnVuY3Rpb24gbWFwQnlEZWxldGluZ011bHRpcGxlRnJvbU1hcChtYXAsIGtzKSB7XG4gIGNvbnN0IG5leHQgPSBuZXcgTWFwKG1hcCk7XG4gIGtzLmZvckVhY2goayA9PiBuZXh0LmRlbGV0ZShrKSk7XG4gIHJldHVybiBuZXh0O1xufVxuXG52YXIgUmVjb2lsX0NvcHlPbldyaXRlID0ge1xuICBzZXRCeUFkZGluZ1RvU2V0LFxuICBzZXRCeURlbGV0aW5nRnJvbVNldCxcbiAgbWFwQnlTZXR0aW5nSW5NYXAsXG4gIG1hcEJ5VXBkYXRpbmdJbk1hcCxcbiAgbWFwQnlEZWxldGluZ0Zyb21NYXAsXG4gIG1hcEJ5RGVsZXRpbmdNdWx0aXBsZUZyb21NYXBcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpdGVyYWJsZSB3aG9zZSBvdXRwdXQgaXMgZ2VuZXJhdGVkIGJ5IHBhc3NpbmcgdGhlIGlucHV0XG4gKiBpdGVyYWJsZSdzIHZhbHVlcyB0aHJvdWdoIHRoZSBmaWx0ZXIgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24qIGZpbHRlckl0ZXJhYmxlKGl0ZXJhYmxlLCBwcmVkaWNhdGUpIHtcbiAgLy8gVXNlIGdlbmVyYXRvciB0byBjcmVhdGUgaXRlcmFibGUvaXRlcmF0b3JcbiAgbGV0IGluZGV4ID0gMDtcblxuICBmb3IgKGNvbnN0IHZhbHVlIG9mIGl0ZXJhYmxlKSB7XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgrKykpIHtcbiAgICAgIHlpZWxkIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVjb2lsX2ZpbHRlckl0ZXJhYmxlID0gZmlsdGVySXRlcmFibGU7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogUmV0dXJuIGEgcHJveHkgb2JqZWN0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBiYXNlIGFuZCBmYWN0b3JpZXMgb2JqZWN0cy5cbiAqIFRoZSBwcm94eSB3aWxsIGluY2x1ZGUgYWxsIHByb3BlcnRpZXMgb2YgdGhlIGJhc2Ugb2JqZWN0IGFzLWlzLlxuICogVGhlIGZhY3RvcmllcyBvYmplY3QgY29udGFpbnMgY2FsbGJhY2tzIHRvIG9idGFpbiB0aGUgdmFsdWVzIG9mIHRoZSBwcm9wZXJpZXNcbiAqIGZvciBpdHMga2V5cy5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgcHJvdmlkaW5nIHVzZXJzIGFuIG9iamVjdCB3aGVyZSBzb21lIHByb3BlcnRpZXMgbWF5IGJlXG4gKiBsYXppbHkgY29tcHV0ZWQgb25seSBvbiBmaXJzdCBhY2Nlc3MuXG4gKi9cbi8vICRGbG93SXNzdWVbdW5jbGVhci10eXBlXVxuXG5mdW5jdGlvbiBsYXp5UHJveHkoYmFzZSwgZmFjdG9yaWVzKSB7XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KGJhc2UsIHtcbiAgICAvLyBDb21wdXRlIGFuZCBjYWNoZSBsYXp5IHByb3BlcnR5IGlmIG5vdCBhbHJlYWR5IGRvbmUuXG4gICAgZ2V0OiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICBpZiAoIShwcm9wIGluIHRhcmdldCkgJiYgcHJvcCBpbiBmYWN0b3JpZXMpIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gZmFjdG9yaWVzW3Byb3BdKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgfSxcbiAgICAvLyBUaGlzIG1ldGhvZCBhbGxvd3MgdXNlciB0byBpdGVyYXRlIGtleXMgYXMgbm9ybWFsXG4gICAgb3duS2V5czogdGFyZ2V0ID0+IHtcblxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCk7XG4gICAgfVxuICB9KTsgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gIHJldHVybiBwcm94eTtcbn1cblxudmFyIFJlY29pbF9sYXp5UHJveHkgPSBsYXp5UHJveHk7XG5cbmNvbnN0IHtcbiAgZ2V0Tm9kZTogZ2V0Tm9kZSQxLFxuICBnZXROb2RlTWF5YmU6IGdldE5vZGVNYXliZSQxLFxuICByZWNvaWxWYWx1ZXNGb3JLZXlzOiByZWNvaWxWYWx1ZXNGb3JLZXlzJDFcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICBSZXRlbnRpb25ab25lOiBSZXRlbnRpb25ab25lJDFcbn0gPSBSZWNvaWxfUmV0ZW50aW9uWm9uZTtcblxuY29uc3Qge1xuICBzZXRCeUFkZGluZ1RvU2V0OiBzZXRCeUFkZGluZ1RvU2V0JDFcbn0gPSBSZWNvaWxfQ29weU9uV3JpdGU7XG5cblxuXG5cblxuXG5cbiAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuXG5cbmNvbnN0IGVtcHR5U2V0ID0gT2JqZWN0LmZyZWV6ZShuZXcgU2V0KCkpO1xuXG5jbGFzcyBSZWFkT25seVJlY29pbFZhbHVlRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG5mdW5jdGlvbiBpbml0aWFsaXplUmV0ZW50aW9uRm9yTm9kZShzdG9yZSwgbm9kZUtleSwgcmV0YWluZWRCeSkge1xuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICByZXR1cm4gKCkgPT4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIG5vZGVzUmV0YWluZWRCeVpvbmVcbiAgfSA9IHN0b3JlLmdldFN0YXRlKCkucmV0ZW50aW9uO1xuXG4gIGZ1bmN0aW9uIGFkZFRvWm9uZSh6b25lKSB7XG4gICAgbGV0IHNldCA9IG5vZGVzUmV0YWluZWRCeVpvbmUuZ2V0KHpvbmUpO1xuXG4gICAgaWYgKCFzZXQpIHtcbiAgICAgIG5vZGVzUmV0YWluZWRCeVpvbmUuc2V0KHpvbmUsIHNldCA9IG5ldyBTZXQoKSk7XG4gICAgfVxuXG4gICAgc2V0LmFkZChub2RlS2V5KTtcbiAgfVxuXG4gIGlmIChyZXRhaW5lZEJ5IGluc3RhbmNlb2YgUmV0ZW50aW9uWm9uZSQxKSB7XG4gICAgYWRkVG9ab25lKHJldGFpbmVkQnkpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmV0YWluZWRCeSkpIHtcbiAgICBmb3IgKGNvbnN0IHpvbmUgb2YgcmV0YWluZWRCeSkge1xuICAgICAgYWRkVG9ab25lKHpvbmUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgcmV0ZW50aW9uXG4gICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICBmdW5jdGlvbiBkZWxldGVGcm9tWm9uZSh6b25lKSB7XG4gICAgICBjb25zdCBzZXQgPSByZXRlbnRpb24ubm9kZXNSZXRhaW5lZEJ5Wm9uZS5nZXQoem9uZSk7XG4gICAgICBzZXQgPT09IG51bGwgfHwgc2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXQuZGVsZXRlKG5vZGVLZXkpO1xuXG4gICAgICBpZiAoc2V0ICYmIHNldC5zaXplID09PSAwKSB7XG4gICAgICAgIHJldGVudGlvbi5ub2Rlc1JldGFpbmVkQnlab25lLmRlbGV0ZSh6b25lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmV0YWluZWRCeSBpbnN0YW5jZW9mIFJldGVudGlvblpvbmUkMSkge1xuICAgICAgZGVsZXRlRnJvbVpvbmUocmV0YWluZWRCeSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJldGFpbmVkQnkpKSB7XG4gICAgICBmb3IgKGNvbnN0IHpvbmUgb2YgcmV0YWluZWRCeSkge1xuICAgICAgICBkZWxldGVGcm9tWm9uZSh6b25lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVOb2RlSWZOZXdUb1N0b3JlKHN0b3JlLCB0cmVlU3RhdGUsIGtleSwgdHJpZ2dlcikge1xuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICBpZiAoc3RvcmVTdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5oYXMoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG5vZGUgPSBnZXROb2RlJDEoa2V5KTtcbiAgY29uc3QgcmV0ZW50aW9uQ2xlYW51cCA9IGluaXRpYWxpemVSZXRlbnRpb25Gb3JOb2RlKHN0b3JlLCBrZXksIG5vZGUucmV0YWluZWRCeSk7XG4gIGNvbnN0IG5vZGVDbGVhbnVwID0gbm9kZS5pbml0KHN0b3JlLCB0cmVlU3RhdGUsIHRyaWdnZXIpO1xuICBzdG9yZVN0YXRlLm5vZGVDbGVhbnVwRnVuY3Rpb25zLnNldChrZXksICgpID0+IHtcbiAgICBub2RlQ2xlYW51cCgpO1xuICAgIHJldGVudGlvbkNsZWFudXAoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVOb2RlKHN0b3JlLCBrZXksIHRyaWdnZXIpIHtcbiAgaW5pdGlhbGl6ZU5vZGVJZk5ld1RvU3RvcmUoc3RvcmUsIHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUsIGtleSwgdHJpZ2dlcik7XG59XG5cbmZ1bmN0aW9uIGNsZWFuVXBOb2RlKHN0b3JlLCBrZXkpIHtcbiAgdmFyIF9zdGF0ZSRub2RlQ2xlYW51cEZ1bjtcblxuICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIChfc3RhdGUkbm9kZUNsZWFudXBGdW4gPSBzdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5nZXQoa2V5KSkgPT09IG51bGwgfHwgX3N0YXRlJG5vZGVDbGVhbnVwRnVuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGUkbm9kZUNsZWFudXBGdW4oKTtcbiAgc3RhdGUubm9kZUNsZWFudXBGdW5jdGlvbnMuZGVsZXRlKGtleSk7XG59IC8vIEdldCB0aGUgY3VycmVudCB2YWx1ZSBsb2FkYWJsZSBvZiBhIG5vZGUgYW5kIHVwZGF0ZSB0aGUgc3RhdGUuXG4vLyBVcGRhdGUgZGVwZW5kZW5jaWVzIGFuZCBzdWJzY3JpcHRpb25zIGZvciBzZWxlY3RvcnMuXG4vLyBVcGRhdGUgc2F2ZWQgdmFsdWUgdmFsaWRhdGlvbiBmb3IgYXRvbXMuXG5cblxuZnVuY3Rpb24gZ2V0Tm9kZUxvYWRhYmxlKHN0b3JlLCBzdGF0ZSwga2V5KSB7XG4gIGluaXRpYWxpemVOb2RlSWZOZXdUb1N0b3JlKHN0b3JlLCBzdGF0ZSwga2V5LCAnZ2V0Jyk7XG4gIHJldHVybiBnZXROb2RlJDEoa2V5KS5nZXQoc3RvcmUsIHN0YXRlKTtcbn0gLy8gUGVlayBhdCB0aGUgY3VycmVudCB2YWx1ZSBsb2FkYWJsZSBmb3IgYSBub2RlIHdpdGhvdXQgYW55IGV2YWx1YXRpb24gb3Igc3RhdGUgY2hhbmdlXG5cblxuZnVuY3Rpb24gcGVla05vZGVMb2FkYWJsZShzdG9yZSwgc3RhdGUsIGtleSkge1xuICByZXR1cm4gZ2V0Tm9kZSQxKGtleSkucGVlayhzdG9yZSwgc3RhdGUpO1xufSAvLyBXcml0ZSB2YWx1ZSBkaXJlY3RseSB0byBzdGF0ZSBieXBhc3NpbmcgdGhlIE5vZGUgaW50ZXJmYWNlIGFzIHRoZSBub2RlXG4vLyBkZWZpbml0aW9ucyBtYXkgbm90IGhhdmUgYmVlbiBsb2FkZWQgeWV0IHdoZW4gcHJvY2Vzc2luZyB0aGUgaW5pdGlhbCBzbmFwc2hvdC5cblxuXG5mdW5jdGlvbiBzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZV9ERVBSRUNBVEVEKHN0YXRlLCBrZXksIG5ld1ZhbHVlKSB7XG4gIHZhciBfbm9kZSRpbnZhbGlkYXRlO1xuXG4gIGNvbnN0IG5vZGUgPSBnZXROb2RlTWF5YmUkMShrZXkpO1xuICBub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfbm9kZSRpbnZhbGlkYXRlID0gbm9kZS5pbnZhbGlkYXRlKSA9PT0gbnVsbCB8fCBfbm9kZSRpbnZhbGlkYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRpbnZhbGlkYXRlLmNhbGwobm9kZSwgc3RhdGUpO1xuICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICBhdG9tVmFsdWVzOiBzdGF0ZS5hdG9tVmFsdWVzLmNsb25lKCkuZGVsZXRlKGtleSksXG4gICAgbm9udmFsaWRhdGVkQXRvbXM6IHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLmNsb25lKCkuc2V0KGtleSwgbmV3VmFsdWUpLFxuICAgIGRpcnR5QXRvbXM6IHNldEJ5QWRkaW5nVG9TZXQkMShzdGF0ZS5kaXJ0eUF0b21zLCBrZXkpXG4gIH07XG59IC8vIFJldHVybiB0aGUgZGlzY292ZXJlZCBkZXBlbmRlbmNpZXMgYW5kIHZhbHVlcyB0byBiZSB3cml0dGVuIGJ5IHNldHRpbmdcbi8vIGEgbm9kZSB2YWx1ZS4gKE11bHRpcGxlIHZhbHVlcyBtYXkgYmUgd3JpdHRlbiBkdWUgdG8gc2VsZWN0b3JzIGdldHRpbmcgdG9cbi8vIHNldCB1cHN0cmVhbXM7IGRlcHMgbWF5IGJlIGRpc2NvdmVyZWQgYmVjYXVzZSBvZiByZWFkcyBpbiB1cGRhdGVyIGZ1bmN0aW9ucy4pXG5cblxuZnVuY3Rpb24gc2V0Tm9kZVZhbHVlKHN0b3JlLCBzdGF0ZSwga2V5LCBuZXdWYWx1ZSkge1xuICBjb25zdCBub2RlID0gZ2V0Tm9kZSQxKGtleSk7XG5cbiAgaWYgKG5vZGUuc2V0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgUmVhZE9ubHlSZWNvaWxWYWx1ZUVycm9yKGBBdHRlbXB0IHRvIHNldCByZWFkLW9ubHkgUmVjb2lsVmFsdWU6ICR7a2V5fWApO1xuICB9XG5cbiAgY29uc3Qgc2V0ID0gbm9kZS5zZXQ7IC8vIHNvIGZsb3cgZG9lc24ndCBsb3NlIHRoZSBhYm92ZSByZWZpbmVtZW50LlxuXG4gIGluaXRpYWxpemVOb2RlSWZOZXdUb1N0b3JlKHN0b3JlLCBzdGF0ZSwga2V5LCAnc2V0Jyk7XG4gIHJldHVybiBzZXQoc3RvcmUsIHN0YXRlLCBuZXdWYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHBlZWtOb2RlSW5mbyhzdG9yZSwgc3RhdGUsIGtleSkge1xuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgY29uc3QgZ3JhcGggPSBzdG9yZS5nZXRHcmFwaChzdGF0ZS52ZXJzaW9uKTtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGUkMShrZXkpLm5vZGVUeXBlO1xuICByZXR1cm4gUmVjb2lsX2xhenlQcm94eSh7XG4gICAgdHlwZVxuICB9LCB7XG4gICAgLy8gJEZsb3dGaXhNZVt1bmRlcmNvbnN0cmFpbmVkLWltcGxpY2l0LWluc3RhbnRpYXRpb25dXG4gICAgbG9hZGFibGU6ICgpID0+IHBlZWtOb2RlTG9hZGFibGUoc3RvcmUsIHN0YXRlLCBrZXkpLFxuICAgIGlzQWN0aXZlOiAoKSA9PiBzdG9yZVN0YXRlLmtub3duQXRvbXMuaGFzKGtleSkgfHwgc3RvcmVTdGF0ZS5rbm93blNlbGVjdG9ycy5oYXMoa2V5KSxcbiAgICBpc1NldDogKCkgPT4gdHlwZSA9PT0gJ3NlbGVjdG9yJyA/IGZhbHNlIDogc3RhdGUuYXRvbVZhbHVlcy5oYXMoa2V5KSxcbiAgICBpc01vZGlmaWVkOiAoKSA9PiBzdGF0ZS5kaXJ0eUF0b21zLmhhcyhrZXkpLFxuICAgIC8vIFJlcG9ydCBjdXJyZW50IGRlcGVuZGVuY2llcy4gIElmIHRoZSBub2RlIGhhc24ndCBiZWVuIGV2YWx1YXRlZCwgdGhlblxuICAgIC8vIGRlcGVuZGVuY2llcyBtYXkgYmUgbWlzc2luZyBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICBkZXBzOiAoKSA9PiB7XG4gICAgICB2YXIgX2dyYXBoJG5vZGVEZXBzJGdldDtcblxuICAgICAgcmV0dXJuIHJlY29pbFZhbHVlc0ZvcktleXMkMSgoX2dyYXBoJG5vZGVEZXBzJGdldCA9IGdyYXBoLm5vZGVEZXBzLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfZ3JhcGgkbm9kZURlcHMkZ2V0ICE9PSB2b2lkIDAgPyBfZ3JhcGgkbm9kZURlcHMkZ2V0IDogW10pO1xuICAgIH0sXG4gICAgLy8gUmVwb3J0cyBhbGwgXCJjdXJyZW50XCIgc3Vic2NyaWJlcnMuICBFdmFsdWF0aW5nIG90aGVyIG5vZGVzIG9yXG4gICAgLy8gcHJldmlvdXMgaW4tcHJvZ3Jlc3MgYXN5bmMgZXZhbHVhdGlvbnMgbWF5IGludHJvZHVjZSBuZXcgc3Vic2NyaWJlcnMuXG4gICAgc3Vic2NyaWJlcnM6ICgpID0+IHtcbiAgICAgIHZhciBfc3RvcmVTdGF0ZSRub2RlVG9Db20sIF9zdG9yZVN0YXRlJG5vZGVUb0NvbTI7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVzOiByZWNvaWxWYWx1ZXNGb3JLZXlzJDEoUmVjb2lsX2ZpbHRlckl0ZXJhYmxlKGdldERvd25zdHJlYW1Ob2RlcyhzdG9yZSwgc3RhdGUsIG5ldyBTZXQoW2tleV0pKSwgbm9kZUtleSA9PiBub2RlS2V5ICE9PSBrZXkpKSxcbiAgICAgICAgY29tcG9uZW50czogUmVjb2lsX21hcEl0ZXJhYmxlKChfc3RvcmVTdGF0ZSRub2RlVG9Db20gPSAoX3N0b3JlU3RhdGUkbm9kZVRvQ29tMiA9IHN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5nZXQoa2V5KSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkbm9kZVRvQ29tMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkbm9kZVRvQ29tMi52YWx1ZXMoKSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkbm9kZVRvQ29tICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRub2RlVG9Db20gOiBbXSwgKFtuYW1lXSkgPT4gKHtcbiAgICAgICAgICBuYW1lXG4gICAgICAgIH0pKVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufSAvLyBGaW5kIGFsbCBvZiB0aGUgcmVjdXJzaXZlbHkgZGVwZW5kZW50IG5vZGVzXG5cblxuZnVuY3Rpb24gZ2V0RG93bnN0cmVhbU5vZGVzKHN0b3JlLCBzdGF0ZSwga2V5cykge1xuICBjb25zdCB2aXNpdGVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IHZpc2l0aW5nTm9kZXMgPSBBcnJheS5mcm9tKGtleXMpO1xuICBjb25zdCBncmFwaCA9IHN0b3JlLmdldEdyYXBoKHN0YXRlLnZlcnNpb24pO1xuXG4gIGZvciAobGV0IGtleSA9IHZpc2l0aW5nTm9kZXMucG9wKCk7IGtleTsga2V5ID0gdmlzaXRpbmdOb2Rlcy5wb3AoKSkge1xuICAgIHZhciBfZ3JhcGgkbm9kZVRvTm9kZVN1YnM7XG5cbiAgICB2aXNpdGVkTm9kZXMuYWRkKGtleSk7XG4gICAgY29uc3Qgc3Vic2NyaWJlZE5vZGVzID0gKF9ncmFwaCRub2RlVG9Ob2RlU3VicyA9IGdyYXBoLm5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfZ3JhcGgkbm9kZVRvTm9kZVN1YnMgIT09IHZvaWQgMCA/IF9ncmFwaCRub2RlVG9Ob2RlU3VicyA6IGVtcHR5U2V0O1xuXG4gICAgZm9yIChjb25zdCBkb3duc3RyZWFtTm9kZSBvZiBzdWJzY3JpYmVkTm9kZXMpIHtcbiAgICAgIGlmICghdmlzaXRlZE5vZGVzLmhhcyhkb3duc3RyZWFtTm9kZSkpIHtcbiAgICAgICAgdmlzaXRpbmdOb2Rlcy5wdXNoKGRvd25zdHJlYW1Ob2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmlzaXRlZE5vZGVzO1xufVxuXG52YXIgUmVjb2lsX0Z1bmN0aW9uYWxDb3JlID0ge1xuICBnZXROb2RlTG9hZGFibGUsXG4gIHBlZWtOb2RlTG9hZGFibGUsXG4gIHNldE5vZGVWYWx1ZSxcbiAgaW5pdGlhbGl6ZU5vZGUsXG4gIGNsZWFuVXBOb2RlLFxuICBzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZV9ERVBSRUNBVEVELFxuICBwZWVrTm9kZUluZm8sXG4gIGdldERvd25zdHJlYW1Ob2Rlc1xufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5sZXQgX2ludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90ID0gbnVsbDtcblxuZnVuY3Rpb24gc2V0SW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QoaW52YWxpZGF0ZSkge1xuICBfaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QgPSBpbnZhbGlkYXRlO1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCgpIHtcbiAgdmFyIF9pbnZhbGlkYXRlTWVtb2l6ZWRTbjtcblxuICAoX2ludmFsaWRhdGVNZW1vaXplZFNuID0gX2ludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90KSA9PT0gbnVsbCB8fCBfaW52YWxpZGF0ZU1lbW9pemVkU24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9pbnZhbGlkYXRlTWVtb2l6ZWRTbigpO1xufVxuXG52YXIgUmVjb2lsX1NuYXBzaG90Q2FjaGUgPSB7XG4gIHNldEludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90LFxuICBpbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdFxufTtcblxuY29uc3Qge1xuICBnZXREb3duc3RyZWFtTm9kZXM6IGdldERvd25zdHJlYW1Ob2RlcyQxLFxuICBnZXROb2RlTG9hZGFibGU6IGdldE5vZGVMb2FkYWJsZSQxLFxuICBzZXROb2RlVmFsdWU6IHNldE5vZGVWYWx1ZSQxXG59ID0gUmVjb2lsX0Z1bmN0aW9uYWxDb3JlO1xuXG5jb25zdCB7XG4gIGdldE5leHRDb21wb25lbnRJRDogZ2V0TmV4dENvbXBvbmVudElEJDFcbn0gPSBSZWNvaWxfS2V5cztcblxuY29uc3Qge1xuICBnZXROb2RlOiBnZXROb2RlJDIsXG4gIGdldE5vZGVNYXliZTogZ2V0Tm9kZU1heWJlJDJcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICBEZWZhdWx0VmFsdWU6IERlZmF1bHRWYWx1ZSQxXG59ID0gUmVjb2lsX05vZGU7XG5cbmNvbnN0IHtcbiAgcmVhY3RNb2RlOiByZWFjdE1vZGUkMVxufSA9IFJlY29pbF9SZWFjdE1vZGU7XG5cbmNvbnN0IHtcbiAgQWJzdHJhY3RSZWNvaWxWYWx1ZTogQWJzdHJhY3RSZWNvaWxWYWx1ZSQxLFxuICBSZWNvaWxTdGF0ZTogUmVjb2lsU3RhdGUkMSxcbiAgUmVjb2lsVmFsdWVSZWFkT25seTogUmVjb2lsVmFsdWVSZWFkT25seSQxLFxuICBpc1JlY29pbFZhbHVlOiBpc1JlY29pbFZhbHVlJDFcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWUkMTtcblxuY29uc3Qge1xuICBpbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdDogaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMVxufSA9IFJlY29pbF9TbmFwc2hvdENhY2hlO1xuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUoc3RvcmUsIHtcbiAga2V5XG59LCB0cmVlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlKSB7XG4gIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZSwgX3N0b3JlU3RhdGUkcHJldmlvdXNUO1xuXG4gIC8vIFJlYWRpbmcgZnJvbSBhbiBvbGRlciB0cmVlIGNhbiBjYXVzZSBidWdzIGJlY2F1c2UgdGhlIGRlcGVuZGVuY2llcyB0aGF0IHdlXG4gIC8vIGRpc2NvdmVyIGR1cmluZyB0aGUgcmVhZCBhcmUgbG9zdC5cbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgaWYgKCEodHJlZVN0YXRlLnZlcnNpb24gPT09IHN0b3JlU3RhdGUuY3VycmVudFRyZWUudmVyc2lvbiB8fCB0cmVlU3RhdGUudmVyc2lvbiA9PT0gKChfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9IHN0b3JlU3RhdGUubmV4dFRyZWUpID09PSBudWxsIHx8IF9zdG9yZVN0YXRlJG5leHRUcmVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRuZXh0VHJlZS52ZXJzaW9uKSB8fCB0cmVlU3RhdGUudmVyc2lvbiA9PT0gKChfc3RvcmVTdGF0ZSRwcmV2aW91c1QgPSBzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkcHJldmlvdXNUID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRwcmV2aW91c1QudmVyc2lvbikpKSB7XG4gICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdUcmllZCB0byByZWFkIGZyb20gYSBkaXNjYXJkZWQgdHJlZScpO1xuICB9XG5cbiAgY29uc3QgbG9hZGFibGUgPSBnZXROb2RlTG9hZGFibGUkMShzdG9yZSwgdHJlZVN0YXRlLCBrZXkpO1xuXG4gIGlmIChsb2FkYWJsZS5zdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgbG9hZGFibGUuY29udGVudHMuY2F0Y2goKCkgPT4ge1xuICAgICAgLyoqXG4gICAgICAgKiBIQUNLOiBpbnRlcmNlcHQgdGhyb3duIGVycm9yIGhlcmUgdG8gcHJldmVudCBhbiB1bmNhdWdodCBwcm9taXNlIGV4Y2VwdGlvbi4gSWRlYWxseSB0aGlzIHdvdWxkIGhhcHBlbiBjbG9zZXIgdG8gc2VsZWN0b3JcbiAgICAgICAqIGV4ZWN1dGlvbiAocGVyaGFwcyBpbnRyb2R1Y2luZyBhIG5ldyBFUlJPUiBjbGFzcyB0byBiZSByZXNvbHZlZCBieSBhc3luYyBzZWxlY3RvcnMgdGhhdCBhcmUgaW4gYW4gZXJyb3Igc3RhdGUpXG4gICAgICAgKi9cbiAgICAgIHJldHVybjtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBsb2FkYWJsZTtcbn1cblxuZnVuY3Rpb24gYXBwbHlBdG9tVmFsdWVXcml0ZXMoYXRvbVZhbHVlcywgd3JpdGVzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGF0b21WYWx1ZXMuY2xvbmUoKTtcbiAgd3JpdGVzLmZvckVhY2goKHYsIGspID0+IHtcbiAgICBpZiAodi5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJyAmJiB2LmNvbnRlbnRzIGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDEpIHtcbiAgICAgIHJlc3VsdC5kZWxldGUoayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5zZXQoaywgdik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gdmFsdWVGcm9tVmFsdWVPclVwZGF0ZXIoc3RvcmUsIHN0YXRlLCB7XG4gIGtleVxufSwgdmFsdWVPclVwZGF0ZXIpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZU9yVXBkYXRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVwZGF0ZXIgZm9ybTogcGFzcyBpbiB0aGUgY3VycmVudCB2YWx1ZS4gVGhyb3cgaWYgdGhlIGN1cnJlbnQgdmFsdWVcbiAgICAvLyBpcyB1bmF2YWlsYWJsZSAobmFtZWx5IHdoZW4gdXBkYXRpbmcgYW4gYXN5bmMgc2VsZWN0b3IgdGhhdCdzXG4gICAgLy8gcGVuZGluZyBvciBlcnJvcmVkKTpcbiAgICBjb25zdCBjdXJyZW50ID0gZ2V0Tm9kZUxvYWRhYmxlJDEoc3RvcmUsIHN0YXRlLCBrZXkpO1xuXG4gICAgaWYgKGN1cnJlbnQuc3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgY29uc3QgbXNnID0gYFRyaWVkIHRvIHNldCBhdG9tIG9yIHNlbGVjdG9yIFwiJHtrZXl9XCIgdXNpbmcgYW4gdXBkYXRlciBmdW5jdGlvbiB3aGlsZSB0aGUgY3VycmVudCBzdGF0ZSBpcyBwZW5kaW5nLCB0aGlzIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLmA7XG4gICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24obXNnKTtcbiAgICAgIHRocm93IFJlY29pbF9lcnIobXNnKTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQuc3RhdGUgPT09ICdoYXNFcnJvcicpIHtcbiAgICAgIHRocm93IGN1cnJlbnQuY29udGVudHM7XG4gICAgfSAvLyBUIGl0c2VsZiBtYXkgYmUgYSBmdW5jdGlvbiwgc28gb3VyIHJlZmluZW1lbnQgaXMgbm90IHN1ZmZpY2llbnQ6XG5cblxuICAgIHJldHVybiB2YWx1ZU9yVXBkYXRlcihjdXJyZW50LmNvbnRlbnRzKTsgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlT3JVcGRhdGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5QWN0aW9uKHN0b3JlLCBzdGF0ZSwgYWN0aW9uKSB7XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ3NldCcpIHtcbiAgICBjb25zdCB7XG4gICAgICByZWNvaWxWYWx1ZSxcbiAgICAgIHZhbHVlT3JVcGRhdGVyXG4gICAgfSA9IGFjdGlvbjtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlRnJvbVZhbHVlT3JVcGRhdGVyKHN0b3JlLCBzdGF0ZSwgcmVjb2lsVmFsdWUsIHZhbHVlT3JVcGRhdGVyKTtcbiAgICBjb25zdCB3cml0ZXMgPSBzZXROb2RlVmFsdWUkMShzdG9yZSwgc3RhdGUsIHJlY29pbFZhbHVlLmtleSwgbmV3VmFsdWUpO1xuXG4gICAgZm9yIChjb25zdCBba2V5LCBsb2FkYWJsZV0gb2Ygd3JpdGVzLmVudHJpZXMoKSkge1xuICAgICAgd3JpdGVMb2FkYWJsZVRvVHJlZVN0YXRlKHN0YXRlLCBrZXksIGxvYWRhYmxlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYWN0aW9uLnR5cGUgPT09ICdzZXRMb2FkYWJsZScpIHtcbiAgICBjb25zdCB7XG4gICAgICByZWNvaWxWYWx1ZToge1xuICAgICAgICBrZXlcbiAgICAgIH0sXG4gICAgICBsb2FkYWJsZVxuICAgIH0gPSBhY3Rpb247XG4gICAgd3JpdGVMb2FkYWJsZVRvVHJlZVN0YXRlKHN0YXRlLCBrZXksIGxvYWRhYmxlKTtcbiAgfSBlbHNlIGlmIChhY3Rpb24udHlwZSA9PT0gJ21hcmtNb2RpZmllZCcpIHtcbiAgICBjb25zdCB7XG4gICAgICByZWNvaWxWYWx1ZToge1xuICAgICAgICBrZXlcbiAgICAgIH1cbiAgICB9ID0gYWN0aW9uO1xuICAgIHN0YXRlLmRpcnR5QXRvbXMuYWRkKGtleSk7XG4gIH0gZWxzZSBpZiAoYWN0aW9uLnR5cGUgPT09ICdzZXRVbnZhbGlkYXRlZCcpIHtcbiAgICB2YXIgX25vZGUkaW52YWxpZGF0ZTtcblxuICAgIC8vIFdyaXRlIHZhbHVlIGRpcmVjdGx5IHRvIHN0YXRlIGJ5cGFzc2luZyB0aGUgTm9kZSBpbnRlcmZhY2UgYXMgdGhlIG5vZGVcbiAgICAvLyBkZWZpbml0aW9ucyBtYXkgbm90IGhhdmUgYmVlbiBsb2FkZWQgeWV0IHdoZW4gcHJvY2Vzc2luZyB0aGUgaW5pdGlhbCBzbmFwc2hvdC5cbiAgICBjb25zdCB7XG4gICAgICByZWNvaWxWYWx1ZToge1xuICAgICAgICBrZXlcbiAgICAgIH0sXG4gICAgICB1bnZhbGlkYXRlZFZhbHVlXG4gICAgfSA9IGFjdGlvbjtcbiAgICBjb25zdCBub2RlID0gZ2V0Tm9kZU1heWJlJDIoa2V5KTtcbiAgICBub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfbm9kZSRpbnZhbGlkYXRlID0gbm9kZS5pbnZhbGlkYXRlKSA9PT0gbnVsbCB8fCBfbm9kZSRpbnZhbGlkYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRpbnZhbGlkYXRlLmNhbGwobm9kZSwgc3RhdGUpO1xuICAgIHN0YXRlLmF0b21WYWx1ZXMuZGVsZXRlKGtleSk7XG4gICAgc3RhdGUubm9udmFsaWRhdGVkQXRvbXMuc2V0KGtleSwgdW52YWxpZGF0ZWRWYWx1ZSk7XG4gICAgc3RhdGUuZGlydHlBdG9tcy5hZGQoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oYFVua25vd24gYWN0aW9uICR7YWN0aW9uLnR5cGV9YCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd3JpdGVMb2FkYWJsZVRvVHJlZVN0YXRlKHN0YXRlLCBrZXksIGxvYWRhYmxlKSB7XG4gIGlmIChsb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJyAmJiBsb2FkYWJsZS5jb250ZW50cyBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQxKSB7XG4gICAgc3RhdGUuYXRvbVZhbHVlcy5kZWxldGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5hdG9tVmFsdWVzLnNldChrZXksIGxvYWRhYmxlKTtcbiAgfVxuXG4gIHN0YXRlLmRpcnR5QXRvbXMuYWRkKGtleSk7XG4gIHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLmRlbGV0ZShrZXkpO1xufVxuXG5mdW5jdGlvbiBhcHBseUFjdGlvbnNUb1N0b3JlKHN0b3JlLCBhY3Rpb25zKSB7XG4gIHN0b3JlLnJlcGxhY2VTdGF0ZShzdGF0ZSA9PiB7XG4gICAgY29uc3QgbmV3U3RhdGUgPSBjb3B5VHJlZVN0YXRlKHN0YXRlKTtcblxuICAgIGZvciAoY29uc3QgYWN0aW9uIG9mIGFjdGlvbnMpIHtcbiAgICAgIGFwcGx5QWN0aW9uKHN0b3JlLCBuZXdTdGF0ZSwgYWN0aW9uKTtcbiAgICB9XG5cbiAgICBpbnZhbGlkYXRlRG93bnN0cmVhbXMoc3RvcmUsIG5ld1N0YXRlKTtcbiAgICBpbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQxKCk7XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcXVldWVPclBlcmZvcm1TdGF0ZVVwZGF0ZShzdG9yZSwgYWN0aW9uKSB7XG4gIGlmIChiYXRjaFN0YWNrLmxlbmd0aCkge1xuICAgIGNvbnN0IGFjdGlvbnNCeVN0b3JlID0gYmF0Y2hTdGFja1tiYXRjaFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGxldCBhY3Rpb25zID0gYWN0aW9uc0J5U3RvcmUuZ2V0KHN0b3JlKTtcblxuICAgIGlmICghYWN0aW9ucykge1xuICAgICAgYWN0aW9uc0J5U3RvcmUuc2V0KHN0b3JlLCBhY3Rpb25zID0gW10pO1xuICAgIH1cblxuICAgIGFjdGlvbnMucHVzaChhY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIGFwcGx5QWN0aW9uc1RvU3RvcmUoc3RvcmUsIFthY3Rpb25dKTtcbiAgfVxufVxuXG5jb25zdCBiYXRjaFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIGJhdGNoU3RhcnQoKSB7XG4gIGNvbnN0IGFjdGlvbnNCeVN0b3JlID0gbmV3IE1hcCgpO1xuICBiYXRjaFN0YWNrLnB1c2goYWN0aW9uc0J5U3RvcmUpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGZvciAoY29uc3QgW3N0b3JlLCBhY3Rpb25zXSBvZiBhY3Rpb25zQnlTdG9yZSkge1xuICAgICAgYXBwbHlBY3Rpb25zVG9TdG9yZShzdG9yZSwgYWN0aW9ucyk7XG4gICAgfVxuXG4gICAgY29uc3QgcG9wcGVkID0gYmF0Y2hTdGFjay5wb3AoKTtcblxuICAgIGlmIChwb3BwZWQgIT09IGFjdGlvbnNCeVN0b3JlKSB7XG4gICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ0luY29ycmVjdCBvcmRlciBvZiBiYXRjaCBwb3BwaW5nJyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb3B5VHJlZVN0YXRlKHN0YXRlKSB7XG4gIHJldHVybiB7IC4uLnN0YXRlLFxuICAgIGF0b21WYWx1ZXM6IHN0YXRlLmF0b21WYWx1ZXMuY2xvbmUoKSxcbiAgICBub252YWxpZGF0ZWRBdG9tczogc3RhdGUubm9udmFsaWRhdGVkQXRvbXMuY2xvbmUoKSxcbiAgICBkaXJ0eUF0b21zOiBuZXcgU2V0KHN0YXRlLmRpcnR5QXRvbXMpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmFsaWRhdGVEb3duc3RyZWFtcyhzdG9yZSwgc3RhdGUpIHtcbiAgLy8gSW5mb3JtIGFueSBub2RlcyB0aGF0IHdlcmUgY2hhbmdlZCBvciBkb3duc3RyZWFtIG9mIGNoYW5nZXMgc28gdGhhdCB0aGV5XG4gIC8vIGNhbiBjbGVhciBvdXQgYW55IGNhY2hlcyBhcyBuZWVkZWQgZHVlIHRvIHRoZSB1cGRhdGU6XG4gIGNvbnN0IGRvd25zdHJlYW1zID0gZ2V0RG93bnN0cmVhbU5vZGVzJDEoc3RvcmUsIHN0YXRlLCBzdGF0ZS5kaXJ0eUF0b21zKTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBkb3duc3RyZWFtcykge1xuICAgIHZhciBfZ2V0Tm9kZU1heWJlLCBfZ2V0Tm9kZU1heWJlJGludmFsaWQ7XG5cbiAgICAoX2dldE5vZGVNYXliZSA9IGdldE5vZGVNYXliZSQyKGtleSkpID09PSBudWxsIHx8IF9nZXROb2RlTWF5YmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfZ2V0Tm9kZU1heWJlJGludmFsaWQgPSBfZ2V0Tm9kZU1heWJlLmludmFsaWRhdGUpID09PSBudWxsIHx8IF9nZXROb2RlTWF5YmUkaW52YWxpZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldE5vZGVNYXliZSRpbnZhbGlkLmNhbGwoX2dldE5vZGVNYXliZSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldFJlY29pbFZhbHVlKHN0b3JlLCByZWNvaWxWYWx1ZSwgdmFsdWVPclVwZGF0ZXIpIHtcbiAgcXVldWVPclBlcmZvcm1TdGF0ZVVwZGF0ZShzdG9yZSwge1xuICAgIHR5cGU6ICdzZXQnLFxuICAgIHJlY29pbFZhbHVlLFxuICAgIHZhbHVlT3JVcGRhdGVyXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlKHN0b3JlLCByZWNvaWxWYWx1ZSwgbG9hZGFibGUpIHtcbiAgaWYgKGxvYWRhYmxlIGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDEpIHtcbiAgICByZXR1cm4gc2V0UmVjb2lsVmFsdWUoc3RvcmUsIHJlY29pbFZhbHVlLCBsb2FkYWJsZSk7XG4gIH1cblxuICBxdWV1ZU9yUGVyZm9ybVN0YXRlVXBkYXRlKHN0b3JlLCB7XG4gICAgdHlwZTogJ3NldExvYWRhYmxlJyxcbiAgICByZWNvaWxWYWx1ZSxcbiAgICBsb2FkYWJsZTogbG9hZGFibGVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkKHN0b3JlLCByZWNvaWxWYWx1ZSkge1xuICBxdWV1ZU9yUGVyZm9ybVN0YXRlVXBkYXRlKHN0b3JlLCB7XG4gICAgdHlwZTogJ21hcmtNb2RpZmllZCcsXG4gICAgcmVjb2lsVmFsdWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUoc3RvcmUsIHJlY29pbFZhbHVlLCB1bnZhbGlkYXRlZFZhbHVlKSB7XG4gIHF1ZXVlT3JQZXJmb3JtU3RhdGVVcGRhdGUoc3RvcmUsIHtcbiAgICB0eXBlOiAnc2V0VW52YWxpZGF0ZWQnLFxuICAgIHJlY29pbFZhbHVlLFxuICAgIHVudmFsaWRhdGVkVmFsdWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZVRvUmVjb2lsVmFsdWUoc3RvcmUsIHtcbiAga2V5XG59LCBjYWxsYmFjaywgY29tcG9uZW50RGVidWdOYW1lID0gbnVsbCkge1xuICBjb25zdCBzdWJJRCA9IGdldE5leHRDb21wb25lbnRJRCQxKCk7XG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gIGlmICghc3RvcmVTdGF0ZS5ub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zLmhhcyhrZXkpKSB7XG4gICAgc3RvcmVTdGF0ZS5ub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zLnNldChrZXksIG5ldyBNYXAoKSk7XG4gIH1cblxuICBSZWNvaWxfbnVsbHRocm93cyhzdG9yZVN0YXRlLm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMuZ2V0KGtleSkpLnNldChzdWJJRCwgW2NvbXBvbmVudERlYnVnTmFtZSAhPT0gbnVsbCAmJiBjb21wb25lbnREZWJ1Z05hbWUgIT09IHZvaWQgMCA/IGNvbXBvbmVudERlYnVnTmFtZSA6ICc8bm90IGNhcHR1cmVkPicsIGNhbGxiYWNrXSk7IC8vIEhhbmRsZSB0aGUgY2FzZSB0aGF0LCBkdXJpbmcgdGhlIHNhbWUgdGljayB0aGF0IHdlIGFyZSBzdWJzY3JpYmluZywgYW4gYXRvbVxuICAvLyBoYXMgYmVlbiB1cGRhdGVkIGJ5IHNvbWUgZWZmZWN0IGhhbmRsZXIuIE90aGVyd2lzZSB3ZSB3aWxsIG1pc3MgdGhlIHVwZGF0ZS5cblxuICBjb25zdCBtb2RlID0gcmVhY3RNb2RlJDEoKTtcblxuICBpZiAobW9kZS5lYXJseSAmJiAobW9kZS5tb2RlID09PSAnTEVHQUNZJyB8fCBtb2RlLm1vZGUgPT09ICdNVVRBQkxFX1NPVVJDRScpKSB7XG4gICAgY29uc3QgbmV4dFRyZWUgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlO1xuXG4gICAgaWYgKG5leHRUcmVlICYmIG5leHRUcmVlLmRpcnR5QXRvbXMuaGFzKGtleSkpIHtcbiAgICAgIGNhbGxiYWNrKG5leHRUcmVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlbGVhc2U6ICgpID0+IHtcbiAgICAgIGNvbnN0IHJlbGVhc2VTdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGNvbnN0IHN1YnMgPSByZWxlYXNlU3RvcmVTdGF0ZS5ub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zLmdldChrZXkpO1xuXG4gICAgICBpZiAoc3VicyA9PT0gdW5kZWZpbmVkIHx8ICFzdWJzLmhhcyhzdWJJRCkpIHtcbiAgICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKGBTdWJzY3JpcHRpb24gbWlzc2luZyBhdCByZWxlYXNlIHRpbWUgZm9yIGF0b20gJHtrZXl9LiBUaGlzIGlzIGEgYnVnIGluIFJlY29pbC5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzdWJzLmRlbGV0ZShzdWJJRCk7XG5cbiAgICAgIGlmIChzdWJzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmVsZWFzZVN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlZnJlc2hSZWNvaWxWYWx1ZShzdG9yZSwgcmVjb2lsVmFsdWUpIHtcbiAgdmFyIF9ub2RlJGNsZWFyQ2FjaGU7XG5cbiAgY29uc3Qge1xuICAgIGN1cnJlbnRUcmVlXG4gIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBjb25zdCBub2RlID0gZ2V0Tm9kZSQyKHJlY29pbFZhbHVlLmtleSk7XG4gIChfbm9kZSRjbGVhckNhY2hlID0gbm9kZS5jbGVhckNhY2hlKSA9PT0gbnVsbCB8fCBfbm9kZSRjbGVhckNhY2hlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRjbGVhckNhY2hlLmNhbGwobm9kZSwgc3RvcmUsIGN1cnJlbnRUcmVlKTtcbn1cblxudmFyIFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZSA9IHtcbiAgUmVjb2lsVmFsdWVSZWFkT25seTogUmVjb2lsVmFsdWVSZWFkT25seSQxLFxuICBBYnN0cmFjdFJlY29pbFZhbHVlOiBBYnN0cmFjdFJlY29pbFZhbHVlJDEsXG4gIFJlY29pbFN0YXRlOiBSZWNvaWxTdGF0ZSQxLFxuICBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUsXG4gIHNldFJlY29pbFZhbHVlLFxuICBzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlLFxuICBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCxcbiAgc2V0VW52YWxpZGF0ZWRSZWNvaWxWYWx1ZSxcbiAgc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSxcbiAgaXNSZWNvaWxWYWx1ZTogaXNSZWNvaWxWYWx1ZSQxLFxuICBhcHBseUF0b21WYWx1ZVdyaXRlcyxcbiAgLy8gVE9ETyBSZW1vdmUgZXhwb3J0IHdoZW4gZGVwcmVjYXRpbmcgaW5pdGlhbFN0b3JlU3RhdGVfREVQUkVDQVRFRCBpbiBSZWNvaWxSb290XG4gIGJhdGNoU3RhcnQsXG4gIHdyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZSxcbiAgaW52YWxpZGF0ZURvd25zdHJlYW1zLFxuICBjb3B5VHJlZVN0YXRlLFxuICByZWZyZXNoUmVjb2lsVmFsdWVcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogVGhlIHNvbWVTZXQoKSBtZXRob2QgdGVzdHMgd2hldGhlciBzb21lIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBTZXQgcGFzcyB0aGVcbiAqIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIHNvbWVTZXQoc2V0LCBjYWxsYmFjaywgY29udGV4dCkge1xuICBjb25zdCBpdGVyYXRvciA9IHNldC5lbnRyaWVzKCk7XG4gIGxldCBjdXJyZW50ID0gaXRlcmF0b3IubmV4dCgpO1xuXG4gIHdoaWxlICghY3VycmVudC5kb25lKSB7XG4gICAgY29uc3QgZW50cnkgPSBjdXJyZW50LnZhbHVlO1xuXG4gICAgaWYgKGNhbGxiYWNrLmNhbGwoY29udGV4dCwgZW50cnlbMV0sIGVudHJ5WzBdLCBzZXQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjdXJyZW50ID0gaXRlcmF0b3IubmV4dCgpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgUmVjb2lsX3NvbWVTZXQgPSBzb21lU2V0O1xuXG5jb25zdCB7XG4gIGNsZWFuVXBOb2RlOiBjbGVhblVwTm9kZSQxXG59ID0gUmVjb2lsX0Z1bmN0aW9uYWxDb3JlO1xuXG5jb25zdCB7XG4gIGRlbGV0ZU5vZGVDb25maWdJZlBvc3NpYmxlOiBkZWxldGVOb2RlQ29uZmlnSWZQb3NzaWJsZSQxLFxuICBnZXROb2RlOiBnZXROb2RlJDNcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICBSZXRlbnRpb25ab25lOiBSZXRlbnRpb25ab25lJDJcbn0gPSBSZWNvaWxfUmV0ZW50aW9uWm9uZTtcblxuXG5cblxuXG5cblxuIC8vIENvbXBvbmVudHMgdGhhdCBhcmVuJ3QgbW91bnRlZCBhZnRlciBzdXNwZW5kaW5nIGZvciB0aGlzIGxvbmcgd2lsbCBiZSBhc3N1bWVkXG4vLyB0byBiZSBkaXNjYXJkZWQgYW5kIHRoZWlyIHJlc291cmNlcyByZWxlYXNlZC5cblxuXG5jb25zdCBTVVNQRU5TRV9USU1FT1VUX01TID0gMTIwMDAwO1xuY29uc3QgZW1wdHlTZXQkMSA9IG5ldyBTZXQoKTtcblxuZnVuY3Rpb24gcmVsZWFzZVJldGFpbmFibGVzTm93T25DdXJyZW50VHJlZShzdG9yZSwgcmV0YWluYWJsZXMpIHtcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGNvbnN0IHRyZWVTdGF0ZSA9IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XG5cbiAgaWYgKHN0b3JlU3RhdGUubmV4dFRyZWUpIHtcbiAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ3JlbGVhc2VOb2Rlc05vd09uQ3VycmVudFRyZWUgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGF0IHRoZSBlbmQgb2YgYSBiYXRjaCcpO1xuICAgIHJldHVybjsgLy8gbGVhayBtZW1vcnkgcmF0aGVyIHRoYW4gZXJhc2Ugc29tZXRoaW5nIHRoYXQncyBhYm91dCB0byBiZSB1c2VkLlxuICB9XG5cbiAgY29uc3Qgbm9kZXMgPSBuZXcgU2V0KCk7XG5cbiAgZm9yIChjb25zdCByIG9mIHJldGFpbmFibGVzKSB7XG4gICAgaWYgKHIgaW5zdGFuY2VvZiBSZXRlbnRpb25ab25lJDIpIHtcbiAgICAgIGZvciAoY29uc3QgbiBvZiBub2Rlc1JldGFpbmVkQnlab25lKHN0b3JlU3RhdGUsIHIpKSB7XG4gICAgICAgIG5vZGVzLmFkZChuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZXMuYWRkKHIpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlbGVhc2FibGVOb2RlcyA9IGZpbmRSZWxlYXNhYmxlTm9kZXMoc3RvcmUsIG5vZGVzKTtcblxuICBmb3IgKGNvbnN0IG5vZGUgb2YgcmVsZWFzYWJsZU5vZGVzKSB7XG4gICAgcmVsZWFzZU5vZGUoc3RvcmUsIHRyZWVTdGF0ZSwgbm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFJlbGVhc2FibGVOb2RlcyhzdG9yZSwgc2VhcmNoRnJvbU5vZGVzKSB7XG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBjb25zdCB0cmVlU3RhdGUgPSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xuICBjb25zdCBncmFwaCA9IHN0b3JlLmdldEdyYXBoKHRyZWVTdGF0ZS52ZXJzaW9uKTtcbiAgY29uc3QgcmVsZWFzYWJsZU5vZGVzID0gbmV3IFNldCgpOyAvLyBtdXRhdGVkIHRvIGNvbGxlY3QgYW5zd2VyXG5cbiAgY29uc3Qgbm9uUmVsZWFzYWJsZU5vZGVzID0gbmV3IFNldCgpO1xuICBmaW5kUmVsZWFzYWJsZU5vZGVzSW5uZXIoc2VhcmNoRnJvbU5vZGVzKTtcbiAgcmV0dXJuIHJlbGVhc2FibGVOb2RlcztcblxuICBmdW5jdGlvbiBmaW5kUmVsZWFzYWJsZU5vZGVzSW5uZXIoc2VhcmNoRnJvbU5vZGVzKSB7XG4gICAgY29uc3QgcmVsZWFzYWJsZU5vZGVzRm91bmRUaGlzSXRlcmF0aW9uID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGRvd25zdHJlYW1zID0gZ2V0RG93bnN0cmVhbU5vZGVzSW5Ub3BvbG9naWNhbE9yZGVyKHN0b3JlLCB0cmVlU3RhdGUsIHNlYXJjaEZyb21Ob2RlcywgcmVsZWFzYWJsZU5vZGVzLCAvLyBkb24ndCBkZXNjZW5kIGludG8gdGhlc2VcbiAgICBub25SZWxlYXNhYmxlTm9kZXMgLy8gZG9uJ3QgZGVzY2VuZCBpbnRvIHRoZXNlXG4gICAgKTsgLy8gRmluZCB3aGljaCBvZiB0aGUgZG93bnN0cmVhbSBub2RlcyBhcmUgcmVsZWFzYWJsZSBhbmQgd2hpY2ggYXJlIG5vdDpcblxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBkb3duc3RyZWFtcykge1xuICAgICAgdmFyIF9zdG9yZVN0YXRlJHJldGVudGlvbjtcblxuICAgICAgLy8gTm90IHJlbGVhc2FibGUgaWYgY29uZmlndXJlZCB0byBiZSByZXRhaW5lZCBmb3JldmVyOlxuICAgICAgaWYgKGdldE5vZGUkMyhub2RlKS5yZXRhaW5lZEJ5ID09PSAncmVjb2lsUm9vdCcpIHtcbiAgICAgICAgbm9uUmVsZWFzYWJsZU5vZGVzLmFkZChub2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIE5vdCByZWxlYXNhYmxlIGlmIHJldGFpbmVkIGRpcmVjdGx5IGJ5IGEgY29tcG9uZW50OlxuXG5cbiAgICAgIGlmICgoKF9zdG9yZVN0YXRlJHJldGVudGlvbiA9IHN0b3JlU3RhdGUucmV0ZW50aW9uLnJlZmVyZW5jZUNvdW50cy5nZXQobm9kZSkpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJHJldGVudGlvbiAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkcmV0ZW50aW9uIDogMCkgPiAwKSB7XG4gICAgICAgIG5vblJlbGVhc2FibGVOb2Rlcy5hZGQobm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBOb3QgcmVsZWFzYWJsZSBpZiByZXRhaW5lZCBieSBhIHpvbmU6XG5cblxuICAgICAgaWYgKHpvbmVzVGhhdENvdWxkUmV0YWluTm9kZShub2RlKS5zb21lKHogPT4gc3RvcmVTdGF0ZS5yZXRlbnRpb24ucmVmZXJlbmNlQ291bnRzLmdldCh6KSkpIHtcbiAgICAgICAgbm9uUmVsZWFzYWJsZU5vZGVzLmFkZChub2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIE5vdCByZWxlYXNhYmxlIGlmIGl0IGhhcyBhIG5vbi1yZWxlYXNhYmxlIGNoaWxkICh3aGljaCB3aWxsIGFscmVhZHkgYmUgaW5cbiAgICAgIC8vIG5vblJlbGVhc2FibGVOb2RlcyBiZWNhdXNlIHdlIGFyZSBnb2luZyBpbiB0b3BvbG9naWNhbCBvcmRlcik6XG5cblxuICAgICAgY29uc3Qgbm9kZUNoaWxkcmVuID0gZ3JhcGgubm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMuZ2V0KG5vZGUpO1xuXG4gICAgICBpZiAobm9kZUNoaWxkcmVuICYmIFJlY29pbF9zb21lU2V0KG5vZGVDaGlsZHJlbiwgY2hpbGQgPT4gbm9uUmVsZWFzYWJsZU5vZGVzLmhhcyhjaGlsZCkpKSB7XG4gICAgICAgIG5vblJlbGVhc2FibGVOb2Rlcy5hZGQobm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZWxlYXNhYmxlTm9kZXMuYWRkKG5vZGUpO1xuICAgICAgcmVsZWFzYWJsZU5vZGVzRm91bmRUaGlzSXRlcmF0aW9uLmFkZChub2RlKTtcbiAgICB9IC8vIElmIHdlIGZvdW5kIGFueSByZWxlYXNhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIHdhbGsgVVAgZnJvbSB0aG9zZSBub2RlcyB0b1xuICAgIC8vIGZpbmQgd2hldGhlciB0aGVpciBwYXJlbnRzIGNhbiBub3cgYmUgcmVsZWFzZWQgYXMgd2VsbDpcblxuXG4gICAgY29uc3QgcGFyZW50cyA9IG5ldyBTZXQoKTtcblxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiByZWxlYXNhYmxlTm9kZXNGb3VuZFRoaXNJdGVyYXRpb24pIHtcbiAgICAgIGZvciAoY29uc3QgcGFyZW50IG9mIChfZ3JhcGgkbm9kZURlcHMkZ2V0ID0gZ3JhcGgubm9kZURlcHMuZ2V0KG5vZGUpKSAhPT0gbnVsbCAmJiBfZ3JhcGgkbm9kZURlcHMkZ2V0ICE9PSB2b2lkIDAgPyBfZ3JhcGgkbm9kZURlcHMkZ2V0IDogZW1wdHlTZXQkMSkge1xuICAgICAgICB2YXIgX2dyYXBoJG5vZGVEZXBzJGdldDtcblxuICAgICAgICBpZiAoIXJlbGVhc2FibGVOb2Rlcy5oYXMocGFyZW50KSkge1xuICAgICAgICAgIHBhcmVudHMuYWRkKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFyZW50cy5zaXplKSB7XG4gICAgICBmaW5kUmVsZWFzYWJsZU5vZGVzSW5uZXIocGFyZW50cyk7XG4gICAgfVxuICB9XG59IC8vIENoaWxkcmVuIGJlZm9yZSBwYXJlbnRzXG5cblxuZnVuY3Rpb24gZ2V0RG93bnN0cmVhbU5vZGVzSW5Ub3BvbG9naWNhbE9yZGVyKHN0b3JlLCB0cmVlU3RhdGUsIG5vZGVzLCAvLyBNdXRhYmxlIHNldCBpcyBkZXN0cm95ZWQgaW4gcGxhY2VcbmRvTm90RGVzY2VuZEludG8xLCBkb05vdERlc2NlbmRJbnRvMikge1xuICBjb25zdCBncmFwaCA9IHN0b3JlLmdldEdyYXBoKHRyZWVTdGF0ZS52ZXJzaW9uKTtcbiAgY29uc3QgYW5zd2VyID0gW107XG4gIGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG5cbiAgd2hpbGUgKG5vZGVzLnNpemUgPiAwKSB7XG4gICAgdmlzaXQoUmVjb2lsX251bGx0aHJvd3Mobm9kZXMudmFsdWVzKCkubmV4dCgpLnZhbHVlKSk7XG4gIH1cblxuICByZXR1cm4gYW5zd2VyO1xuXG4gIGZ1bmN0aW9uIHZpc2l0KG5vZGUpIHtcbiAgICBpZiAoZG9Ob3REZXNjZW5kSW50bzEuaGFzKG5vZGUpIHx8IGRvTm90RGVzY2VuZEludG8yLmhhcyhub2RlKSkge1xuICAgICAgbm9kZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh2aXNpdGVkLmhhcyhub2RlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNoaWxkcmVuID0gZ3JhcGgubm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgIHZpc2l0KGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2aXNpdGVkLmFkZChub2RlKTtcbiAgICBub2Rlcy5kZWxldGUobm9kZSk7XG4gICAgYW5zd2VyLnB1c2gobm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVsZWFzZU5vZGUoc3RvcmUsIHRyZWVTdGF0ZSwgbm9kZSkge1xuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gQXRvbSBlZmZlY3RzLCBpbi1jbG9zdXJlIGNhY2hlcywgZXRjLjpcblxuXG4gIGNsZWFuVXBOb2RlJDEoc3RvcmUsIG5vZGUpOyAvLyBEZWxldGUgZnJvbSBzdG9yZSBzdGF0ZTpcblxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgc3RvcmVTdGF0ZS5rbm93bkF0b21zLmRlbGV0ZShub2RlKTtcbiAgc3RvcmVTdGF0ZS5rbm93blNlbGVjdG9ycy5kZWxldGUobm9kZSk7XG4gIHN0b3JlU3RhdGUubm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5kZWxldGUobm9kZSk7XG4gIHN0b3JlU3RhdGUucmV0ZW50aW9uLnJlZmVyZW5jZUNvdW50cy5kZWxldGUobm9kZSk7XG4gIGNvbnN0IHpvbmVzID0gem9uZXNUaGF0Q291bGRSZXRhaW5Ob2RlKG5vZGUpO1xuXG4gIGZvciAoY29uc3Qgem9uZSBvZiB6b25lcykge1xuICAgIHZhciBfc3RvcmVTdGF0ZSRyZXRlbnRpb24yO1xuXG4gICAgKF9zdG9yZVN0YXRlJHJldGVudGlvbjIgPSBzdG9yZVN0YXRlLnJldGVudGlvbi5ub2Rlc1JldGFpbmVkQnlab25lLmdldCh6b25lKSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkcmV0ZW50aW9uMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkcmV0ZW50aW9uMi5kZWxldGUobm9kZSk7XG4gIH0gLy8gTm90ZSB0aGF0IHdlIERPIE5PVCBkZWxldGUgZnJvbSBub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zIGJlY2F1c2UgdGhpc1xuICAvLyBhbHJlYWR5IGhhcHBlbnMgd2hlbiB0aGUgbGFzdCBjb21wb25lbnQgdGhhdCB3YXMgcmV0YWluaW5nIHRoZSBub2RlIHVubW91bnRzLFxuICAvLyBhbmQgdGhpcyBjb3VsZCBoYXBwZW4gZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGF0LlxuICAvLyBEZWxldGUgZnJvbSBUcmVlU3RhdGUgYW5kIGRlcCBncmFwaDpcblxuXG4gIHRyZWVTdGF0ZS5hdG9tVmFsdWVzLmRlbGV0ZShub2RlKTtcbiAgdHJlZVN0YXRlLmRpcnR5QXRvbXMuZGVsZXRlKG5vZGUpO1xuICB0cmVlU3RhdGUubm9udmFsaWRhdGVkQXRvbXMuZGVsZXRlKG5vZGUpO1xuICBjb25zdCBncmFwaCA9IHN0b3JlU3RhdGUuZ3JhcGhzQnlWZXJzaW9uLmdldCh0cmVlU3RhdGUudmVyc2lvbik7XG5cbiAgaWYgKGdyYXBoKSB7XG4gICAgY29uc3QgZGVwcyA9IGdyYXBoLm5vZGVEZXBzLmdldChub2RlKTtcblxuICAgIGlmIChkZXBzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGdyYXBoLm5vZGVEZXBzLmRlbGV0ZShub2RlKTtcblxuICAgICAgZm9yIChjb25zdCBkZXAgb2YgZGVwcykge1xuICAgICAgICB2YXIgX2dyYXBoJG5vZGVUb05vZGVTdWJzO1xuXG4gICAgICAgIChfZ3JhcGgkbm9kZVRvTm9kZVN1YnMgPSBncmFwaC5ub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQoZGVwKSkgPT09IG51bGwgfHwgX2dyYXBoJG5vZGVUb05vZGVTdWJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ3JhcGgkbm9kZVRvTm9kZVN1YnMuZGVsZXRlKG5vZGUpO1xuICAgICAgfVxuICAgIH0gLy8gTm8gbmVlZCB0byBkZWxldGUgc3ViJ3MgZGVwcyBhcyB0aGVyZSBzaG91bGQgYmUgbm8gc3VicyBhdCB0aGlzIHBvaW50LlxuICAgIC8vIEJ1dCBhbiBpbnZhcmlhbnQgd291bGQgcmVxdWlyZSBkZWxldGluZyBub2RlcyBpbiB0b3BvbG9naWNhbCBvcmRlci5cblxuXG4gICAgZ3JhcGgubm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMuZGVsZXRlKG5vZGUpO1xuICB9IC8vIE5vZGUgY29uZmlnIChmb3IgZmFtaWx5IG1lbWJlcnMgb25seSBhcyB0aGVpciBjb25maWdzIGNhbiBiZSByZWNyZWF0ZWQsIGFuZFxuICAvLyBvbmx5IGlmIHRoZXkgYXJlIG5vdCByZXRhaW5lZCB3aXRoaW4gYW55IG90aGVyIFN0b3Jlcyk6XG5cblxuICBkZWxldGVOb2RlQ29uZmlnSWZQb3NzaWJsZSQxKG5vZGUpO1xufVxuXG5mdW5jdGlvbiBub2Rlc1JldGFpbmVkQnlab25lKHN0b3JlU3RhdGUsIHpvbmUpIHtcbiAgdmFyIF9zdG9yZVN0YXRlJHJldGVudGlvbjM7XG5cbiAgcmV0dXJuIChfc3RvcmVTdGF0ZSRyZXRlbnRpb24zID0gc3RvcmVTdGF0ZS5yZXRlbnRpb24ubm9kZXNSZXRhaW5lZEJ5Wm9uZS5nZXQoem9uZSkpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJHJldGVudGlvbjMgIT09IHZvaWQgMCA/IF9zdG9yZVN0YXRlJHJldGVudGlvbjMgOiBlbXB0eVNldCQxO1xufVxuXG5mdW5jdGlvbiB6b25lc1RoYXRDb3VsZFJldGFpbk5vZGUobm9kZSkge1xuICBjb25zdCByZXRhaW5lZEJ5ID0gZ2V0Tm9kZSQzKG5vZGUpLnJldGFpbmVkQnk7XG5cbiAgaWYgKHJldGFpbmVkQnkgPT09IHVuZGVmaW5lZCB8fCByZXRhaW5lZEJ5ID09PSAnY29tcG9uZW50cycgfHwgcmV0YWluZWRCeSA9PT0gJ3JlY29pbFJvb3QnKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IGVsc2UgaWYgKHJldGFpbmVkQnkgaW5zdGFuY2VvZiBSZXRlbnRpb25ab25lJDIpIHtcbiAgICByZXR1cm4gW3JldGFpbmVkQnldO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXRhaW5lZEJ5OyAvLyBpdCdzIGFuIGFycmF5IG9mIHpvbmVzXG4gIH1cbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVPclBlcmZvcm1Qb3NzaWJsZVJlbGVhc2VPZlJldGFpbmFibGUoc3RvcmUsIHJldGFpbmFibGUpIHtcbiAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gIGlmIChzdGF0ZS5uZXh0VHJlZSkge1xuICAgIHN0YXRlLnJldGVudGlvbi5yZXRhaW5hYmxlc1RvQ2hlY2tGb3JSZWxlYXNlLmFkZChyZXRhaW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICByZWxlYXNlUmV0YWluYWJsZXNOb3dPbkN1cnJlbnRUcmVlKHN0b3JlLCBuZXcgU2V0KFtyZXRhaW5hYmxlXSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJldGFpbkNvdW50KHN0b3JlLCByZXRhaW5hYmxlLCBkZWx0YSkge1xuICB2YXIgX21hcCRnZXQ7XG5cbiAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgbWFwID0gc3RvcmUuZ2V0U3RhdGUoKS5yZXRlbnRpb24ucmVmZXJlbmNlQ291bnRzO1xuICBjb25zdCBuZXdDb3VudCA9ICgoX21hcCRnZXQgPSBtYXAuZ2V0KHJldGFpbmFibGUpKSAhPT0gbnVsbCAmJiBfbWFwJGdldCAhPT0gdm9pZCAwID8gX21hcCRnZXQgOiAwKSArIGRlbHRhO1xuXG4gIGlmIChuZXdDb3VudCA9PT0gMCkge1xuICAgIHVwZGF0ZVJldGFpbkNvdW50VG9aZXJvKHN0b3JlLCByZXRhaW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICBtYXAuc2V0KHJldGFpbmFibGUsIG5ld0NvdW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVSZXRhaW5Db3VudFRvWmVybyhzdG9yZSwgcmV0YWluYWJsZSkge1xuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBtYXAgPSBzdG9yZS5nZXRTdGF0ZSgpLnJldGVudGlvbi5yZWZlcmVuY2VDb3VudHM7XG4gIG1hcC5kZWxldGUocmV0YWluYWJsZSk7XG4gIHNjaGVkdWxlT3JQZXJmb3JtUG9zc2libGVSZWxlYXNlT2ZSZXRhaW5hYmxlKHN0b3JlLCByZXRhaW5hYmxlKTtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZVNjaGVkdWxlZFJldGFpbmFibGVzTm93KHN0b3JlKSB7XG4gIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgcmVsZWFzZVJldGFpbmFibGVzTm93T25DdXJyZW50VHJlZShzdG9yZSwgc3RhdGUucmV0ZW50aW9uLnJldGFpbmFibGVzVG9DaGVja0ZvclJlbGVhc2UpO1xuICBzdGF0ZS5yZXRlbnRpb24ucmV0YWluYWJsZXNUb0NoZWNrRm9yUmVsZWFzZS5jbGVhcigpO1xufVxuXG5mdW5jdGlvbiByZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHQocikge1xuICAvLyBUaGUgZGVmYXVsdCB3aWxsIGNoYW5nZSBmcm9tICdyZWNvaWxSb290JyB0byAnY29tcG9uZW50cycgaW4gdGhlIGZ1dHVyZS5cbiAgcmV0dXJuIHIgPT09IHVuZGVmaW5lZCA/ICdyZWNvaWxSb290JyA6IHI7XG59XG5cbnZhciBSZWNvaWxfUmV0ZW50aW9uID0ge1xuICBTVVNQRU5TRV9USU1FT1VUX01TLFxuICB1cGRhdGVSZXRhaW5Db3VudCxcbiAgdXBkYXRlUmV0YWluQ291bnRUb1plcm8sXG4gIHJlbGVhc2VTY2hlZHVsZWRSZXRhaW5hYmxlc05vdyxcbiAgcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0XG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogVGhpcyBpcyB0byBleHBvcnQgZXNzdGllbnRpYWwgZnVuY3Rpb25zIGZyb20gcmVhY3QtZG9tXG4gKiBmb3Igb3VyIHdlYiBidWlsZFxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuY29uc3Qge1xuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlc1xufSA9IHJlYWN0RG9tO1xuXG52YXIgUmVhY3RCYXRjaGVkVXBkYXRlcyA9IHtcbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXNcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBUaGlzIGlzIHRvIGV4cG9ydCBlc3N0aWVudGlhbCBmdW5jdGlvbnMgZnJvbSByZWFjdC1kb21cbiAqIGZvciBvdXIgd2ViIGJ1aWxkXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vLyBAZmItb25seTogY29uc3Qge3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzfSA9IHJlcXVpcmUoJ1JlYWN0RE9NQ29tZXQnKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3Qge1xuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMkMVxufSA9IFJlYWN0QmF0Y2hlZFVwZGF0ZXM7IC8vIEBvc3Mtb25seVxuXG5cbnZhciBSZWNvaWxfUmVhY3RCYXRjaGVkVXBkYXRlcyA9IHtcbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzJDFcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbmNvbnN0IHtcbiAgYmF0Y2hTdGFydDogYmF0Y2hTdGFydCQxXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5jb25zdCB7XG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyQyXG59ID0gUmVjb2lsX1JlYWN0QmF0Y2hlZFVwZGF0ZXM7IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5cblxuLypcbiAqIER1cmluZyBTU1IsIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIG1heSBiZSB1bmRlZmluZWQgc28gdGhpc1xuICogZmFsbHMgYmFjayB0byBhIGJhc2ljIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgdGhlIGJhdGNoXG4gKi9cbmxldCBiYXRjaGVyID0gdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMkMiB8fCAoYmF0Y2hGbiA9PiBiYXRjaEZuKCkpO1xuLyoqXG4gKiBTZXRzIHRoZSBwcm92aWRlZCBiYXRjaGVyIGZ1bmN0aW9uIGFzIHRoZSBiYXRjaGVyIGZ1bmN0aW9uIHVzZWQgYnkgUmVjb2lsLlxuICpcbiAqIFNldCB0aGUgYmF0Y2hlciB0byBhIGN1c3RvbSBiYXRjaGVyIGZvciB5b3VyIHJlbmRlcmVyLFxuICogaWYgeW91IHVzZSBhIHJlbmRlcmVyIG90aGVyIHRoYW4gUmVhY3QgRE9NIG9yIFJlYWN0IE5hdGl2ZS5cbiAqL1xuXG5cbmNvbnN0IHNldEJhdGNoZXIgPSBuZXdCYXRjaGVyID0+IHtcbiAgYmF0Y2hlciA9IG5ld0JhdGNoZXI7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGJhdGNoZXIgZnVuY3Rpb24uXG4gKi9cblxuXG5jb25zdCBnZXRCYXRjaGVyID0gKCkgPT4gYmF0Y2hlcjtcbi8qKlxuICogQ2FsbHMgdGhlIGN1cnJlbnQgYmF0Y2hlciBmdW5jdGlvbiBhbmQgcGFzc2VzIHRoZVxuICogcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cblxuXG5jb25zdCBiYXRjaFVwZGF0ZXMgPSBjYWxsYmFjayA9PiB7XG4gIGJhdGNoZXIoKCkgPT4ge1xuICAgIGxldCBiYXRjaEVuZCA9ICgpID0+IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBiYXRjaEVuZCA9IGJhdGNoU3RhcnQkMSgpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYmF0Y2hFbmQoKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIFJlY29pbF9CYXRjaGluZyA9IHtcbiAgZ2V0QmF0Y2hlcixcbiAgc2V0QmF0Y2hlcixcbiAgYmF0Y2hVcGRhdGVzXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vKipcbiAqIENvbWJpbmVzIG11bHRpcGxlIEl0ZXJhYmxlcyBpbnRvIGEgc2luZ2xlIEl0ZXJhYmxlLlxuICogVHJhdmVyc2VzIHRoZSBpbnB1dCBJdGVyYWJsZXMgaW4gdGhlIG9yZGVyIHByb3ZpZGVkIGFuZCBtYWludGFpbnMgdGhlIG9yZGVyXG4gKiBvZiB0aGVpciBlbGVtZW50cy5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgXG4gKiBjb25zdCByID0gQXJyYXkuZnJvbShjb25jYXRJdGVyYWJsZXMoWydhJywgJ2InXSwgWydjJ10sIFsnZCcsICdlJywgJ2YnXSkpO1xuICogciA9PSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJ107XG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiogY29uY2F0SXRlcmFibGVzKGl0ZXJzKSB7XG4gIGZvciAoY29uc3QgaXRlciBvZiBpdGVycykge1xuICAgIGZvciAoY29uc3QgdmFsIG9mIGl0ZXIpIHtcbiAgICAgIHlpZWxkIHZhbDtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlY29pbF9jb25jYXRJdGVyYWJsZXMgPSBjb25jYXRJdGVyYWJsZXM7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbmNvbnN0IGlzU1NSID0gLy8gJEZsb3dGaXhNZShzaXRlPXJlY29pbCkgV2luZG93IGRvZXMgbm90IGhhdmUgYSBGbG93VHlwZSBkZWZpbml0aW9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy82NzA5XG50eXBlb2YgV2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcbi8qIGVzbGludC1lbmFibGUgZmItd3d3L3R5cGVvZi11bmRlZmluZWQgKi9cblxuY29uc3QgaXNXaW5kb3cgPSB2YWx1ZSA9PiAhaXNTU1IgJiYgKCAvLyAkRmxvd0ZpeE1lKHNpdGU9cmVjb2lsKSBXaW5kb3cgZG9lcyBub3QgaGF2ZSBhIEZsb3dUeXBlIGRlZmluaXRpb24gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzY3MDlcbnZhbHVlID09PSB3aW5kb3cgfHwgdmFsdWUgaW5zdGFuY2VvZiBXaW5kb3cpO1xuXG5jb25zdCBpc1JlYWN0TmF0aXZlID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZSc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZmItd3d3L3R5cGVvZi11bmRlZmluZWRcblxudmFyIFJlY29pbF9FbnZpcm9ubWVudCA9IHtcbiAgaXNTU1IsXG4gIGlzUmVhY3ROYXRpdmUsXG4gIGlzV2luZG93XG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vKipcbiAqIENhY2hlcyBhIGZ1bmN0aW9uJ3MgcmVzdWx0cyBiYXNlZCBvbiB0aGUga2V5IHJldHVybmVkIGJ5IHRoZSBwYXNzZWRcbiAqIGhhc2hGdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBtZW1vaXplV2l0aEFyZ3NIYXNoKGZuLCBoYXNoRnVuY3Rpb24pIHtcbiAgbGV0IGNhY2hlO1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoIWNhY2hlKSB7XG4gICAgICBjYWNoZSA9IHt9O1xuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IGhhc2hGdW5jdGlvbiguLi5hcmdzKTtcblxuICAgIGlmICghT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIGtleSkpIHtcbiAgICAgIGNhY2hlW2tleV0gPSBmbiguLi5hcmdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGVba2V5XTtcbiAgfTtcbn1cbi8qKlxuICogQ2FjaGVzIGEgZnVuY3Rpb24ncyByZXN1bHRzIGJhc2VkIG9uIGEgY29tcGFyaXNvbiBvZiB0aGUgYXJndW1lbnRzLlxuICogT25seSBjYWNoZXMgdGhlIGxhc3QgcmV0dXJuIG9mIHRoZSBmdW5jdGlvbi5cbiAqIERlZmF1bHRzIHRvIHJlZmVyZW5jZSBlcXVhbGl0eVxuICovXG5cblxuZnVuY3Rpb24gbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaChmbiwgaGFzaEZ1bmN0aW9uKSB7XG4gIGxldCBsYXN0S2V5O1xuICBsZXQgbGFzdFJlc3VsdDsgLy8gYnJlYWtpbmcgY2FjaGUgd2hlbiBhcmd1bWVudHMgY2hhbmdlXG5cbiAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gaGFzaEZ1bmN0aW9uKC4uLmFyZ3MpO1xuXG4gICAgaWYgKGxhc3RLZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgfVxuXG4gICAgbGFzdEtleSA9IGtleTtcbiAgICBsYXN0UmVzdWx0ID0gZm4oLi4uYXJncyk7XG4gICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gIH07XG59XG4vKipcbiAqIENhY2hlcyBhIGZ1bmN0aW9uJ3MgcmVzdWx0cyBiYXNlZCBvbiBhIGNvbXBhcmlzb24gb2YgdGhlIGFyZ3VtZW50cy5cbiAqIE9ubHkgY2FjaGVzIHRoZSBsYXN0IHJldHVybiBvZiB0aGUgZnVuY3Rpb24uXG4gKiBEZWZhdWx0cyB0byByZWZlcmVuY2UgZXF1YWxpdHlcbiAqL1xuXG5cbmZ1bmN0aW9uIG1lbW9pemVPbmVXaXRoQXJnc0hhc2hBbmRJbnZhbGlkYXRpb24oZm4sIGhhc2hGdW5jdGlvbikge1xuICBsZXQgbGFzdEtleTtcbiAgbGV0IGxhc3RSZXN1bHQ7IC8vIGJyZWFraW5nIGNhY2hlIHdoZW4gYXJndW1lbnRzIGNoYW5nZVxuXG4gIGNvbnN0IG1lbW9pemVkRm4gPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGtleSA9IGhhc2hGdW5jdGlvbiguLi5hcmdzKTtcblxuICAgIGlmIChsYXN0S2V5ID09PSBrZXkpIHtcbiAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgIH1cblxuICAgIGxhc3RLZXkgPSBrZXk7XG4gICAgbGFzdFJlc3VsdCA9IGZuKC4uLmFyZ3MpO1xuICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICB9O1xuXG4gIGNvbnN0IGludmFsaWRhdGUgPSAoKSA9PiB7XG4gICAgbGFzdEtleSA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFttZW1vaXplZEZuLCBpbnZhbGlkYXRlXTtcbn1cblxudmFyIFJlY29pbF9NZW1vaXplID0ge1xuICBtZW1vaXplV2l0aEFyZ3NIYXNoLFxuICBtZW1vaXplT25lV2l0aEFyZ3NIYXNoLFxuICBtZW1vaXplT25lV2l0aEFyZ3NIYXNoQW5kSW52YWxpZGF0aW9uXG59O1xuXG5jb25zdCB7XG4gIGJhdGNoVXBkYXRlczogYmF0Y2hVcGRhdGVzJDFcbn0gPSBSZWNvaWxfQmF0Y2hpbmc7XG5cbmNvbnN0IHtcbiAgaW5pdGlhbGl6ZU5vZGU6IGluaXRpYWxpemVOb2RlJDEsXG4gIHBlZWtOb2RlSW5mbzogcGVla05vZGVJbmZvJDFcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XG5cbmNvbnN0IHtcbiAgZ3JhcGg6IGdyYXBoJDFcbn0gPSBSZWNvaWxfR3JhcGg7XG5cbmNvbnN0IHtcbiAgZ2V0TmV4dFN0b3JlSUQ6IGdldE5leHRTdG9yZUlEJDFcbn0gPSBSZWNvaWxfS2V5cztcblxuY29uc3Qge1xuICBERUZBVUxUX1ZBTFVFOiBERUZBVUxUX1ZBTFVFJDEsXG4gIHJlY29pbFZhbHVlczogcmVjb2lsVmFsdWVzJDEsXG4gIHJlY29pbFZhbHVlc0ZvcktleXM6IHJlY29pbFZhbHVlc0ZvcktleXMkMlxufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIEFic3RyYWN0UmVjb2lsVmFsdWU6IEFic3RyYWN0UmVjb2lsVmFsdWUkMixcbiAgZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlOiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMSxcbiAgc2V0UmVjb2lsVmFsdWU6IHNldFJlY29pbFZhbHVlJDEsXG4gIHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWU6IHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUkMVxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcblxuY29uc3Qge1xuICB1cGRhdGVSZXRhaW5Db3VudDogdXBkYXRlUmV0YWluQ291bnQkMVxufSA9IFJlY29pbF9SZXRlbnRpb247XG5cbmNvbnN0IHtcbiAgc2V0SW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3Q6IHNldEludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDFcbn0gPSBSZWNvaWxfU25hcHNob3RDYWNoZTtcblxuY29uc3Qge1xuICBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbjogZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMixcbiAgbWFrZUVtcHR5U3RvcmVTdGF0ZTogbWFrZUVtcHR5U3RvcmVTdGF0ZSQxXG59ID0gUmVjb2lsX1N0YXRlO1xuXG5cblxuY29uc3Qge1xuICBpc1NTUjogaXNTU1IkMVxufSA9IFJlY29pbF9FbnZpcm9ubWVudDtcblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IHtcbiAgbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaEFuZEludmFsaWRhdGlvbjogbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaEFuZEludmFsaWRhdGlvbiQxXG59ID0gUmVjb2lsX01lbW9pemU7XG5cblxuXG4gLy8gT3BhcXVlIGF0IHRoaXMgc3VyZmFjZSBiZWNhdXNlIGl0J3MgcGFydCBvZiB0aGUgcHVibGljIEFQSSBmcm9tIGhlcmUuXG5cblxuY29uc3QgcmV0YWluV2FybmluZyA9IGBcblJlY29pbCBTbmFwc2hvdHMgb25seSBsYXN0IGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGNhbGxiYWNrIHRoZXkgYXJlIHByb3ZpZGVkIHRvLiBUbyBrZWVwIGEgU25hcHNob3QgbG9uZ2VyLCBkbyB0aGlzOlxuXG4gIGNvbnN0IHJlbGVhc2UgPSBzbmFwc2hvdC5yZXRhaW4oKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBkb1NvbWV0aGluZ1dpdGhTbmFwc2hvdChzbmFwc2hvdCk7XG4gIH0gZmluYWxseSB7XG4gICAgcmVsZWFzZSgpO1xuICB9XG5cblRoaXMgaXMgY3VycmVudGx5IGEgREVWLW9ubHkgd2FybmluZyBidXQgd2lsbCBiZWNvbWUgYSB0aHJvd24gZXhjZXB0aW9uIGluIHRoZSBuZXh0IHJlbGVhc2Ugb2YgUmVjb2lsLlxuYDsgLy8gQSBcIlNuYXBzaG90XCIgaXMgXCJyZWFkLW9ubHlcIiBhbmQgY2FwdHVyZXMgYSBzcGVjaWZpYyBzZXQgb2YgdmFsdWVzIG9mIGF0b21zLlxuLy8gSG93ZXZlciwgdGhlIGRhdGEtZmxvdy1ncmFwaCBhbmQgc2VsZWN0b3IgdmFsdWVzIG1heSBldm9sdmUgYXMgc2VsZWN0b3Jcbi8vIGV2YWx1YXRpb24gZnVuY3Rpb25zIGFyZSBleGVjdXRlZCBhbmQgYXN5bmMgc2VsZWN0b3JzIHJlc29sdmUuXG5cbmNsYXNzIFNuYXBzaG90IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9uby11bmluaXRpYWxpemVkLXByb3BlcnRpZXNcbiAgY29uc3RydWN0b3Ioc3RvcmVTdGF0ZSwgcGFyZW50U3RvcmVJRCkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdG9yZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3JlZkNvdW50XCIsIDEpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0TG9hZGFibGVcIiwgcmVjb2lsVmFsdWUgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgICByZXR1cm4gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDEodGhpcy5fc3RvcmUsIHJlY29pbFZhbHVlKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFByb21pc2VcIiwgcmVjb2lsVmFsdWUgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRMb2FkYWJsZShyZWNvaWxWYWx1ZSkudG9Qcm9taXNlKCk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXROb2Rlc19VTlNUQUJMRVwiLCBvcHQgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7IC8vIFRPRE8gRGVhbCB3aXRoIG1vZGlmaWVkIHNlbGVjdG9yc1xuXG4gICAgICBpZiAoKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5pc01vZGlmaWVkKSA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5pc0luaXRpYWxpemVkKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWU7XG5cbiAgICAgICAgcmV0dXJuIHJlY29pbFZhbHVlc0ZvcktleXMkMihzdGF0ZS5kaXJ0eUF0b21zKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qga25vd25BdG9tcyA9IHRoaXMuX3N0b3JlLmdldFN0YXRlKCkua25vd25BdG9tcztcblxuICAgICAgY29uc3Qga25vd25TZWxlY3RvcnMgPSB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLmtub3duU2VsZWN0b3JzO1xuXG4gICAgICByZXR1cm4gKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5pc0luaXRpYWxpemVkKSA9PSBudWxsID8gcmVjb2lsVmFsdWVzJDEudmFsdWVzKCkgOiBvcHQuaXNJbml0aWFsaXplZCA9PT0gdHJ1ZSA/IHJlY29pbFZhbHVlc0ZvcktleXMkMihSZWNvaWxfY29uY2F0SXRlcmFibGVzKFtrbm93bkF0b21zLCBrbm93blNlbGVjdG9yc10pKSA6IFJlY29pbF9maWx0ZXJJdGVyYWJsZShyZWNvaWxWYWx1ZXMkMS52YWx1ZXMoKSwgKHtcbiAgICAgICAga2V5XG4gICAgICB9KSA9PiAha25vd25BdG9tcy5oYXMoa2V5KSAmJiAha25vd25TZWxlY3RvcnMuaGFzKGtleSkpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0SW5mb19VTlNUQUJMRVwiLCAoe1xuICAgICAga2V5XG4gICAgfSkgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgICByZXR1cm4gcGVla05vZGVJbmZvJDEodGhpcy5fc3RvcmUsIHRoaXMuX3N0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUsIGtleSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXBcIiwgbWFwcGVyID0+IHtcbiAgICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpO1xuICAgICAgY29uc3QgbXV0YWJsZVNuYXBzaG90ID0gbmV3IE11dGFibGVTbmFwc2hvdCh0aGlzLCBiYXRjaFVwZGF0ZXMkMSk7XG4gICAgICBtYXBwZXIobXV0YWJsZVNuYXBzaG90KTsgLy8gaWYgcmVtb3ZpbmcgYmF0Y2hVcGRhdGVzIGZyb20gYHNldGAgYWRkIGl0IGhlcmVcblxuICAgICAgcmV0dXJuIG11dGFibGVTbmFwc2hvdDtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFzeW5jTWFwXCIsIGFzeW5jIG1hcHBlciA9PiB7XG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcbiAgICAgIGNvbnN0IG11dGFibGVTbmFwc2hvdCA9IG5ldyBNdXRhYmxlU25hcHNob3QodGhpcywgYmF0Y2hVcGRhdGVzJDEpO1xuICAgICAgbXV0YWJsZVNuYXBzaG90LnJldGFpbigpOyAvLyBSZXRhaW4gbmV3IHNuYXBzaG90IGR1cmluZyBhc3luYyBtYXBwZXJcblxuICAgICAgYXdhaXQgbWFwcGVyKG11dGFibGVTbmFwc2hvdCk7IC8vIENvbnRpbnVlIHRvIHJldGFpbiB0aGUgbmV3IHNuYXBzaG90IGZvciB0aGUgdXNlciwgYnV0IGF1dG8tcmVsZWFzZSBpdFxuICAgICAgLy8gYWZ0ZXIgdGhlIG5leHQgdGljaywgdGhlIHNhbWUgYXMgYSBuZXcgc3luY2hyb25vdXMgc25hcHNob3QuXG5cbiAgICAgIG11dGFibGVTbmFwc2hvdC5hdXRvUmVsZWFzZV9JTlRFUk5BTCgpO1xuICAgICAgcmV0dXJuIG11dGFibGVTbmFwc2hvdDtcbiAgICB9KTtcblxuICAgIHRoaXMuX3N0b3JlID0ge1xuICAgICAgc3RvcmVJRDogZ2V0TmV4dFN0b3JlSUQkMSgpLFxuICAgICAgcGFyZW50U3RvcmVJRCxcbiAgICAgIGdldFN0YXRlOiAoKSA9PiBzdG9yZVN0YXRlLFxuICAgICAgcmVwbGFjZVN0YXRlOiByZXBsYWNlciA9PiB7XG4gICAgICAgIC8vIG5vIGJhdGNoaW5nLCBzbyBuZXh0VHJlZSBpcyBuZXZlciBhY3RpdmVcbiAgICAgICAgc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA9IHJlcGxhY2VyKHN0b3JlU3RhdGUuY3VycmVudFRyZWUpO1xuICAgICAgfSxcbiAgICAgIGdldEdyYXBoOiB2ZXJzaW9uID0+IHtcbiAgICAgICAgY29uc3QgZ3JhcGhzID0gc3RvcmVTdGF0ZS5ncmFwaHNCeVZlcnNpb247XG5cbiAgICAgICAgaWYgKGdyYXBocy5oYXModmVyc2lvbikpIHtcbiAgICAgICAgICByZXR1cm4gUmVjb2lsX251bGx0aHJvd3MoZ3JhcGhzLmdldCh2ZXJzaW9uKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXdHcmFwaCA9IGdyYXBoJDEoKTtcbiAgICAgICAgZ3JhcGhzLnNldCh2ZXJzaW9uLCBuZXdHcmFwaCk7XG4gICAgICAgIHJldHVybiBuZXdHcmFwaDtcbiAgICAgIH0sXG4gICAgICBzdWJzY3JpYmVUb1RyYW5zYWN0aW9uczogKCkgPT4gKHtcbiAgICAgICAgcmVsZWFzZTogKCkgPT4ge31cbiAgICAgIH0pLFxuICAgICAgYWRkVHJhbnNhY3Rpb25NZXRhZGF0YTogKCkgPT4ge1xuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdDYW5ub3Qgc3Vic2NyaWJlIHRvIFNuYXBzaG90cycpO1xuICAgICAgfVxuICAgIH07IC8vIEluaXRpYWxpemUgYW55IG5vZGVzIHRoYXQgYXJlIGxpdmUgaW4gdGhlIHBhcmVudCBzdG9yZSAocHJpbWFyaWx5IHNvIHRoYXRcbiAgICAvLyB0aGlzIHNuYXBzaG90IGdldHMgY291bnRlZCB0b3dhcmRzIHRoZSBub2RlJ3MgbGl2ZSBzdG9yZXMgY291bnQpLlxuICAgIC8vIFRPRE8gT3B0aW1pemUgdGhpcyB3aGVuIGNsb25pbmcgc25hcHNob3RzIGZvciBjYWxsYmFja3NcblxuICAgIGZvciAoY29uc3Qgbm9kZUtleSBvZiB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLmtub3duQXRvbXMpIHtcbiAgICAgIGluaXRpYWxpemVOb2RlJDEodGhpcy5fc3RvcmUsIG5vZGVLZXksICdnZXQnKTtcbiAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDEodGhpcy5fc3RvcmUsIG5vZGVLZXksIDEpO1xuICAgIH1cblxuICAgIHRoaXMuYXV0b1JlbGVhc2VfSU5URVJOQUwoKTtcbiAgfVxuXG4gIHJldGFpbigpIHtcbiAgICBpZiAodGhpcy5fcmVmQ291bnQgPD0gMCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdTbmFwc2hvdCBoYXMgYWxyZWFkeSBiZWVuIHJlbGVhc2VkLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdBdHRlbXB0IHRvIHJldGFpbigpIFNuYXBzaG90IHRoYXQgd2FzIGFscmVhZHkgcmVsZWFzZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fcmVmQ291bnQrKztcbiAgICBsZXQgcmVsZWFzZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFyZWxlYXNlZCkge1xuICAgICAgICByZWxlYXNlZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fcmVsZWFzZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlbGVhc2UgdGhlIHNuYXBzaG90IG9uIHRoZSBuZXh0IHRpY2suICBUaGlzIG1lYW5zIHRoZSBzbmFwc2hvdCBpcyByZXRhaW5lZFxuICAgKiBkdXJpbmcgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgY3VycmVudCBmdW5jdGlvbiB1c2luZyBpdC5cbiAgICovXG5cblxuICBhdXRvUmVsZWFzZV9JTlRFUk5BTCgpIHtcbiAgICBpZiAoIWlzU1NSJDEpIHtcbiAgICAgIC8vIFVzZSB0aW1lb3V0IG9mIDEwIHRvIHdvcmthcm91bmQgRmlyZWZveCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rZXhwZXJpbWVudGFsL1JlY29pbC9pc3N1ZXMvMTkzNlxuICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4gdGhpcy5fcmVsZWFzZSgpLCAxMCk7XG4gICAgfVxuICB9XG5cbiAgX3JlbGVhc2UoKSB7XG4gICAgdGhpcy5fcmVmQ291bnQtLTtcblxuICAgIGlmICh0aGlzLl9yZWZDb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5mb3JFYWNoKGNsZWFudXAgPT4gY2xlYW51cCgpKTtcblxuICAgICAgdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5jbGVhcigpO1xuXG4gICAgICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBUZW1wb3JhcmlseSBuZXJmaW5nIHRoaXMgdG8gYWxsb3cgdXMgdG8gZmluZCBicm9rZW4gY2FsbCBzaXRlcyB3aXRob3V0XG4gICAgICAvLyBhY3R1YWxseSBicmVha2luZyBhbnlib2R5IHlldC5cbiAgICAgIC8vIGZvciAoY29uc3QgayBvZiB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLmtub3duQXRvbXMpIHtcbiAgICAgIC8vICAgdXBkYXRlUmV0YWluQ291bnRUb1plcm8odGhpcy5fc3RvcmUsIGspO1xuICAgICAgLy8gfVxuXG4gICAgfSBlbHNlIGlmICh0aGlzLl9yZWZDb3VudCA8IDApIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdTbmFwc2hvdCByZWxlYXNlZCBhbiBleHRyYSB0aW1lLicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlzUmV0YWluZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZkNvdW50ID4gMDtcbiAgfVxuXG4gIGNoZWNrUmVmQ291bnRfSU5URVJOQUwoKSB7XG4gICAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykgJiYgdGhpcy5fcmVmQ291bnQgPD0gMCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24ocmV0YWluV2FybmluZyk7XG4gICAgICB9IC8vIFdoYXQgd2Ugd2lsbCBzaGlwIGxhdGVyOlxuICAgICAgLy8gdGhyb3cgZXJyKHJldGFpbldhcm5pbmcpO1xuXG4gICAgfVxuICB9XG5cbiAgZ2V0U3RvcmVfSU5URVJOQUwoKSB7XG4gICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlO1xuICB9XG5cbiAgZ2V0SUQoKSB7XG4gICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUuc3RhdGVJRDtcbiAgfVxuXG4gIGdldFN0b3JlSUQoKSB7XG4gICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlLnN0b3JlSUQ7XG4gIH0gLy8gV2Ugd2FudCB0byBhbGxvdyB0aGUgbWV0aG9kcyB0byBiZSBkZXN0cnVjdHVyZWQgYW5kIHVzZWQgYXMgYWNjZXNzb3JzXG5cbiAgLyogZXNsaW50LWRpc2FibGUgZmItd3d3L2V4dHJhLWFycm93LWluaXRpYWxpemVyICovXG5cbiAgLyogZXNsaW50LWVuYWJsZSBmYi13d3cvZXh0cmEtYXJyb3ctaW5pdGlhbGl6ZXIgKi9cblxuXG59XG5cbmZ1bmN0aW9uIGNsb25lU3RvcmVTdGF0ZShzdG9yZSwgdHJlZVN0YXRlLCBidW1wVmVyc2lvbiA9IGZhbHNlKSB7XG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBjb25zdCB2ZXJzaW9uID0gYnVtcFZlcnNpb24gPyBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQyKCkgOiB0cmVlU3RhdGUudmVyc2lvbjtcbiAgcmV0dXJuIHtcbiAgICAvLyBBbHdheXMgY2xvbmUgdGhlIFRyZWVTdGF0ZSB0byBpc29sYXRlIHN0b3JlcyBmcm9tIGFjY2lkZW50YWwgbXV0YXRpb25zLlxuICAgIC8vIEZvciBleGFtcGxlLCByZWFkaW5nIGEgc2VsZWN0b3IgZnJvbSBhIGNsb25lZCBzbmFwc2hvdCBzaG91bGRuJ3QgY2FjaGVcbiAgICAvLyBpbiB0aGUgb3JpZ2luYWwgdHJlZXN0YXRlIHdoaWNoIG1heSBjYXVzZSB0aGUgb3JpZ2luYWwgdG8gc2tpcFxuICAgIC8vIGluaXRpYWxpemF0aW9uIG9mIHVwc3RyZWFtIGF0b21zLlxuICAgIGN1cnJlbnRUcmVlOiB7XG4gICAgICAvLyBUT0RPIHNuYXBzaG90cyBzaG91bGRuJ3QgcmVhbGx5IGhhdmUgdmVyc2lvbnMgYmVjYXVzZSBhIG5ldyB2ZXJzaW9uIG51bWJlclxuICAgICAgLy8gaXMgYWx3YXlzIGFzc2lnbmVkIHdoZW4gdGhlIHNuYXBzaG90IGlzIGdvbmUgdG8uXG4gICAgICB2ZXJzaW9uOiBidW1wVmVyc2lvbiA/IHZlcnNpb24gOiB0cmVlU3RhdGUudmVyc2lvbixcbiAgICAgIHN0YXRlSUQ6IGJ1bXBWZXJzaW9uID8gdmVyc2lvbiA6IHRyZWVTdGF0ZS5zdGF0ZUlELFxuICAgICAgdHJhbnNhY3Rpb25NZXRhZGF0YTogeyAuLi50cmVlU3RhdGUudHJhbnNhY3Rpb25NZXRhZGF0YVxuICAgICAgfSxcbiAgICAgIGRpcnR5QXRvbXM6IG5ldyBTZXQodHJlZVN0YXRlLmRpcnR5QXRvbXMpLFxuICAgICAgYXRvbVZhbHVlczogdHJlZVN0YXRlLmF0b21WYWx1ZXMuY2xvbmUoKSxcbiAgICAgIG5vbnZhbGlkYXRlZEF0b21zOiB0cmVlU3RhdGUubm9udmFsaWRhdGVkQXRvbXMuY2xvbmUoKVxuICAgIH0sXG4gICAgY29tbWl0RGVwdGg6IDAsXG4gICAgbmV4dFRyZWU6IG51bGwsXG4gICAgcHJldmlvdXNUcmVlOiBudWxsLFxuICAgIGtub3duQXRvbXM6IG5ldyBTZXQoc3RvcmVTdGF0ZS5rbm93bkF0b21zKSxcbiAgICAvLyBGSVhNRSBoZXJlJ3MgYSBjb3B5XG4gICAga25vd25TZWxlY3RvcnM6IG5ldyBTZXQoc3RvcmVTdGF0ZS5rbm93blNlbGVjdG9ycyksXG4gICAgLy8gRklYTUUgaGVyZSdzIGEgY29weVxuICAgIHRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uczogbmV3IE1hcCgpLFxuICAgIG5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnM6IG5ldyBNYXAoKSxcbiAgICBub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zOiBuZXcgTWFwKCksXG4gICAgcXVldWVkQ29tcG9uZW50Q2FsbGJhY2tzX0RFUFJFQ0FURUQ6IFtdLFxuICAgIHN1c3BlbmRlZENvbXBvbmVudFJlc29sdmVyczogbmV3IFNldCgpLFxuICAgIGdyYXBoc0J5VmVyc2lvbjogbmV3IE1hcCgpLnNldCh2ZXJzaW9uLCBzdG9yZS5nZXRHcmFwaCh0cmVlU3RhdGUudmVyc2lvbikpLFxuICAgIHJldGVudGlvbjoge1xuICAgICAgcmVmZXJlbmNlQ291bnRzOiBuZXcgTWFwKCksXG4gICAgICBub2Rlc1JldGFpbmVkQnlab25lOiBuZXcgTWFwKCksXG4gICAgICByZXRhaW5hYmxlc1RvQ2hlY2tGb3JSZWxlYXNlOiBuZXcgU2V0KClcbiAgICB9LFxuICAgIC8vIEZJWE1FIGhlcmUncyBhIGNvcHlcbiAgICAvLyBDcmVhdGUgYmxhbmsgY2xlYW51cCBoYW5kbGVycyBmb3IgYXRvbXMgc28gc25hcHNob3RzIGRvbid0IHJlLXJ1blxuICAgIC8vIGF0b20gZWZmZWN0cy5cbiAgICBub2RlQ2xlYW51cEZ1bmN0aW9uczogbmV3IE1hcChSZWNvaWxfbWFwSXRlcmFibGUoc3RvcmVTdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5lbnRyaWVzKCksIChba2V5XSkgPT4gW2tleSwgKCkgPT4ge31dKSlcbiAgfTtcbn0gLy8gRmFjdG9yeSB0byBidWlsZCBhIGZyZXNoIHNuYXBzaG90XG5cblxuZnVuY3Rpb24gZnJlc2hTbmFwc2hvdChpbml0aWFsaXplU3RhdGUpIHtcbiAgY29uc3Qgc25hcHNob3QgPSBuZXcgU25hcHNob3QobWFrZUVtcHR5U3RvcmVTdGF0ZSQxKCkpO1xuICByZXR1cm4gaW5pdGlhbGl6ZVN0YXRlICE9IG51bGwgPyBzbmFwc2hvdC5tYXAoaW5pdGlhbGl6ZVN0YXRlKSA6IHNuYXBzaG90O1xufSAvLyBGYWN0b3J5IHRvIGNsb25lIGEgc25hcHNob3Qgc3RhdGVcblxuXG5jb25zdCBbbWVtb2l6ZWRDbG9uZVNuYXBzaG90LCBpbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQyXSA9IG1lbW9pemVPbmVXaXRoQXJnc0hhc2hBbmRJbnZhbGlkYXRpb24kMSggLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxuKHN0b3JlLCB2ZXJzaW9uKSA9PiB7XG4gIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZTtcblxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgY29uc3QgdHJlZVN0YXRlID0gdmVyc2lvbiA9PT0gJ2xhdGVzdCcgPyAoX3N0b3JlU3RhdGUkbmV4dFRyZWUgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmVTdGF0ZSRuZXh0VHJlZSAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbmV4dFRyZWUgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlIDogUmVjb2lsX251bGx0aHJvd3Moc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUpO1xuICByZXR1cm4gbmV3IFNuYXBzaG90KGNsb25lU3RvcmVTdGF0ZShzdG9yZSwgdHJlZVN0YXRlKSwgc3RvcmUuc3RvcmVJRCk7XG59LCAoc3RvcmUsIHZlcnNpb24pID0+IHtcbiAgdmFyIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCwgX3N0b3JlJGdldFN0YXRlJHByZXZpO1xuXG4gIHJldHVybiBTdHJpbmcodmVyc2lvbikgKyBTdHJpbmcoc3RvcmUuc3RvcmVJRCkgKyBTdHJpbmcoKF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCA9IHN0b3JlLmdldFN0YXRlKCkubmV4dFRyZWUpID09PSBudWxsIHx8IF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlJGdldFN0YXRlJG5leHRULnZlcnNpb24pICsgU3RyaW5nKHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUudmVyc2lvbikgKyBTdHJpbmcoKF9zdG9yZSRnZXRTdGF0ZSRwcmV2aSA9IHN0b3JlLmdldFN0YXRlKCkucHJldmlvdXNUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUkcHJldmkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZSRnZXRTdGF0ZSRwcmV2aS52ZXJzaW9uKTtcbn0pOyAvLyBBdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcblxuc2V0SW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMShpbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQyKTtcblxuZnVuY3Rpb24gY2xvbmVTbmFwc2hvdChzdG9yZSwgdmVyc2lvbiA9ICdsYXRlc3QnKSB7XG4gIGNvbnN0IHNuYXBzaG90ID0gbWVtb2l6ZWRDbG9uZVNuYXBzaG90KHN0b3JlLCB2ZXJzaW9uKTtcblxuICBpZiAoIXNuYXBzaG90LmlzUmV0YWluZWQoKSkge1xuICAgIGludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDIoKTtcbiAgICByZXR1cm4gbWVtb2l6ZWRDbG9uZVNuYXBzaG90KHN0b3JlLCB2ZXJzaW9uKTtcbiAgfVxuXG4gIHJldHVybiBzbmFwc2hvdDtcbn1cblxuY2xhc3MgTXV0YWJsZVNuYXBzaG90IGV4dGVuZHMgU25hcHNob3Qge1xuICBjb25zdHJ1Y3RvcihzbmFwc2hvdCwgYmF0Y2gpIHtcbiAgICBzdXBlcihjbG9uZVN0b3JlU3RhdGUoc25hcHNob3QuZ2V0U3RvcmVfSU5URVJOQUwoKSwgc25hcHNob3QuZ2V0U3RvcmVfSU5URVJOQUwoKS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlLCB0cnVlKSwgc25hcHNob3QuZ2V0U3RvcmVJRCgpKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9iYXRjaFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0XCIsIChyZWNvaWxTdGF0ZSwgbmV3VmFsdWVPclVwZGF0ZXIpID0+IHtcbiAgICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0aGlzLmdldFN0b3JlX0lOVEVSTkFMKCk7IC8vIFRoaXMgYmF0Y2hVcGRhdGVzIGVuc3VyZXMgdGhpcyBgc2V0YCBpcyBhcHBsaWVkIGltbWVkaWF0ZWx5IGFuZCB5b3UgY2FuXG4gICAgICAvLyByZWFkIHRoZSB3cml0dGVuIHZhbHVlIGFmdGVyIGNhbGxpbmcgYHNldGAuIEkgd291bGQgbGlrZSB0byByZW1vdmUgdGhpc1xuICAgICAgLy8gYmVoYXZpb3IgYW5kIG9ubHkgYmF0Y2ggaW4gYFNuYXBzaG90Lm1hcGAsIGJ1dCB0aGlzIHdvdWxkIGJlIGEgYnJlYWtpbmdcbiAgICAgIC8vIGNoYW5nZSBwb3RlbnRpYWxseS5cblxuICAgICAgdGhpcy5fYmF0Y2goKCkgPT4ge1xuICAgICAgICB1cGRhdGVSZXRhaW5Db3VudCQxKHN0b3JlLCByZWNvaWxTdGF0ZS5rZXksIDEpO1xuICAgICAgICBzZXRSZWNvaWxWYWx1ZSQxKHRoaXMuZ2V0U3RvcmVfSU5URVJOQUwoKSwgcmVjb2lsU3RhdGUsIG5ld1ZhbHVlT3JVcGRhdGVyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzZXRcIiwgcmVjb2lsU3RhdGUgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgICBjb25zdCBzdG9yZSA9IHRoaXMuZ2V0U3RvcmVfSU5URVJOQUwoKTsgLy8gU2VlIG5vdGUgYXQgYHNldGAgYWJvdXQgYmF0Y2hlZCB1cGRhdGVzLlxuXG4gICAgICB0aGlzLl9iYXRjaCgoKSA9PiB7XG4gICAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDEoc3RvcmUsIHJlY29pbFN0YXRlLmtleSwgMSk7XG4gICAgICAgIHNldFJlY29pbFZhbHVlJDEodGhpcy5nZXRTdG9yZV9JTlRFUk5BTCgpLCByZWNvaWxTdGF0ZSwgREVGQVVMVF9WQUxVRSQxKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzX0RFUFJFQ0FURURcIiwgdmFsdWVzID0+IHtcbiAgICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0aGlzLmdldFN0b3JlX0lOVEVSTkFMKCk7IC8vIFNlZSBub3RlIGF0IGBzZXRgIGFib3V0IGJhdGNoZWQgdXBkYXRlcy5cblxuICAgICAgYmF0Y2hVcGRhdGVzJDEoKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiB2YWx1ZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgdXBkYXRlUmV0YWluQ291bnQkMShzdG9yZSwgaywgMSk7XG4gICAgICAgICAgc2V0VW52YWxpZGF0ZWRSZWNvaWxWYWx1ZSQxKHN0b3JlLCBuZXcgQWJzdHJhY3RSZWNvaWxWYWx1ZSQyKGspLCB2KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9iYXRjaCA9IGJhdGNoO1xuICB9XG5cbn1cblxudmFyIFJlY29pbF9TbmFwc2hvdCA9IHtcbiAgU25hcHNob3QsXG4gIE11dGFibGVTbmFwc2hvdCxcbiAgZnJlc2hTbmFwc2hvdCxcbiAgY2xvbmVTbmFwc2hvdFxufTtcblxudmFyIFJlY29pbF9TbmFwc2hvdF8xID0gUmVjb2lsX1NuYXBzaG90LlNuYXBzaG90O1xudmFyIFJlY29pbF9TbmFwc2hvdF8yID0gUmVjb2lsX1NuYXBzaG90Lk11dGFibGVTbmFwc2hvdDtcbnZhciBSZWNvaWxfU25hcHNob3RfMyA9IFJlY29pbF9TbmFwc2hvdC5mcmVzaFNuYXBzaG90O1xudmFyIFJlY29pbF9TbmFwc2hvdF80ID0gUmVjb2lsX1NuYXBzaG90LmNsb25lU25hcHNob3Q7XG5cbnZhciBSZWNvaWxfU25hcHNob3QkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBTbmFwc2hvdDogUmVjb2lsX1NuYXBzaG90XzEsXG4gIE11dGFibGVTbmFwc2hvdDogUmVjb2lsX1NuYXBzaG90XzIsXG4gIGZyZXNoU25hcHNob3Q6IFJlY29pbF9TbmFwc2hvdF8zLFxuICBjbG9uZVNuYXBzaG90OiBSZWNvaWxfU25hcHNob3RfNFxufSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gdW5pb25TZXRzKC4uLnNldHMpIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xuXG4gIGZvciAoY29uc3Qgc2V0IG9mIHNldHMpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHNldCkge1xuICAgICAgcmVzdWx0LmFkZCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFJlY29pbF91bmlvblNldHMgPSB1bmlvblNldHM7XG5cbmNvbnN0IHtcbiAgdXNlUmVmXG59ID0gcmVhY3Q7XG4vKipcbiAqIFRoZSBzYW1lIGFzIGB1c2VSZWYoKWAgZXhjZXB0IHRoYXQgaWYgYSBmdW5jdGlvbiBpcyBzcGVjaWZpZWQgdGhlbiBpdCB3aWxsXG4gKiBjYWxsIHRoYXQgZnVuY3Rpb24gdG8gZ2V0IHRoZSB2YWx1ZSB0byBpbml0aWFsaXplIHRoZSByZWZlcmVuY2Ugd2l0aC5cbiAqIFRoaXMgaXMgc2ltaWxhciB0byBob3cgYHVzZVN0YXRlKClgIGJlaGF2ZXMgd2hlbiBnaXZlbiBhIGZ1bmN0aW9uLiAgSXQgYWxsb3dzXG4gKiB0aGUgdXNlciB0byBhdm9pZCBnZW5lcmF0aW5nIHRoZSBpbml0aWFsIHZhbHVlIGZvciBzdWJzZXF1ZW50IHJlbmRlcnMuXG4gKiBUaGUgdHJhZGVvZmYgaXMgdGhhdCB0byBzZXQgdGhlIHJlZmVyZW5jZSB0byBhIGZ1bmN0aW9uIGl0c2VsZiB5b3UgbmVlZCB0b1xuICogbmVzdCBpdDogdXNlUmVmSW5pdE9uY2UoKCkgPT4gKCkgPT4gey4uLn0pO1xuICovXG5cblxuZnVuY3Rpb24gdXNlUmVmSW5pdE9uY2UoaW5pdGlhbFZhbHVlKSB7XG4gIC8vICRGbG93RXhwZWN0ZWRFcnJvcltpbmNvbXBhdGlibGUtY2FsbF1cbiAgY29uc3QgcmVmID0gdXNlUmVmKGluaXRpYWxWYWx1ZSk7XG5cbiAgaWYgKHJlZi5jdXJyZW50ID09PSBpbml0aWFsVmFsdWUgJiYgdHlwZW9mIGluaXRpYWxWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vICRGbG93RXhwZWN0ZWRFcnJvcltpbmNvbXBhdGlibGUtdXNlXVxuICAgIHJlZi5jdXJyZW50ID0gaW5pdGlhbFZhbHVlKCk7XG4gIH1cblxuICByZXR1cm4gcmVmO1xufVxuXG52YXIgUmVjb2lsX3VzZVJlZkluaXRPbmNlID0gdXNlUmVmSW5pdE9uY2U7XG5cbi8vIEBmYi1vbmx5OiBjb25zdCBSZWNvaWx1c2FnZWxvZ0V2ZW50ID0gcmVxdWlyZSgnUmVjb2lsdXNhZ2Vsb2dFdmVudCcpO1xuLy8gQGZiLW9ubHk6IGNvbnN0IFJlY29pbFVzYWdlTG9nRmFsY29FdmVudCA9IHJlcXVpcmUoJ1JlY29pbFVzYWdlTG9nRmFsY29FdmVudCcpO1xuLy8gQGZiLW9ubHk6IGNvbnN0IFVSSSA9IHJlcXVpcmUoJ1VSSScpO1xuXG5cbmNvbnN0IHtcbiAgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb246IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDMsXG4gIG1ha2VFbXB0eVN0b3JlU3RhdGU6IG1ha2VFbXB0eVN0b3JlU3RhdGUkMlxufSA9IFJlY29pbF9TdGF0ZTtcblxuY29uc3Qge1xuICBjbGVhblVwTm9kZTogY2xlYW5VcE5vZGUkMixcbiAgZ2V0RG93bnN0cmVhbU5vZGVzOiBnZXREb3duc3RyZWFtTm9kZXMkMixcbiAgaW5pdGlhbGl6ZU5vZGU6IGluaXRpYWxpemVOb2RlJDIsXG4gIHNldE5vZGVWYWx1ZTogc2V0Tm9kZVZhbHVlJDIsXG4gIHNldFVudmFsaWRhdGVkQXRvbVZhbHVlX0RFUFJFQ0FURUQ6IHNldFVudmFsaWRhdGVkQXRvbVZhbHVlX0RFUFJFQ0FURUQkMVxufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcblxuY29uc3Qge1xuICBncmFwaDogZ3JhcGgkMlxufSA9IFJlY29pbF9HcmFwaDtcblxuY29uc3Qge1xuICBjbG9uZUdyYXBoOiBjbG9uZUdyYXBoJDFcbn0gPSBSZWNvaWxfR3JhcGg7XG5cbmNvbnN0IHtcbiAgZ2V0TmV4dFN0b3JlSUQ6IGdldE5leHRTdG9yZUlEJDJcbn0gPSBSZWNvaWxfS2V5cztcblxuY29uc3Qge1xuICBjcmVhdGVNdXRhYmxlU291cmNlOiBjcmVhdGVNdXRhYmxlU291cmNlJDEsXG4gIHJlYWN0TW9kZTogcmVhY3RNb2RlJDJcbn0gPSBSZWNvaWxfUmVhY3RNb2RlO1xuXG5jb25zdCB7XG4gIGFwcGx5QXRvbVZhbHVlV3JpdGVzOiBhcHBseUF0b21WYWx1ZVdyaXRlcyQxXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5jb25zdCB7XG4gIHJlbGVhc2VTY2hlZHVsZWRSZXRhaW5hYmxlc05vdzogcmVsZWFzZVNjaGVkdWxlZFJldGFpbmFibGVzTm93JDFcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xuXG5jb25zdCB7XG4gIGZyZXNoU25hcHNob3Q6IGZyZXNoU25hcHNob3QkMVxufSA9IFJlY29pbF9TbmFwc2hvdCQxO1xuXG5cblxuY29uc3Qge1xuICB1c2VDYWxsYmFjayxcbiAgdXNlQ29udGV4dCxcbiAgdXNlRWZmZWN0LFxuICB1c2VNZW1vLFxuICB1c2VSZWY6IHVzZVJlZiQxLFxuICB1c2VTdGF0ZVxufSA9IHJlYWN0O1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gbm90SW5BQ29udGV4dCgpIHtcbiAgdGhyb3cgUmVjb2lsX2VycignVGhpcyBjb21wb25lbnQgbXVzdCBiZSB1c2VkIGluc2lkZSBhIDxSZWNvaWxSb290PiBjb21wb25lbnQuJyk7XG59XG5cbmNvbnN0IGRlZmF1bHRTdG9yZSA9IE9iamVjdC5mcmVlemUoe1xuICBzdG9yZUlEOiBnZXROZXh0U3RvcmVJRCQyKCksXG4gIGdldFN0YXRlOiBub3RJbkFDb250ZXh0LFxuICByZXBsYWNlU3RhdGU6IG5vdEluQUNvbnRleHQsXG4gIGdldEdyYXBoOiBub3RJbkFDb250ZXh0LFxuICBzdWJzY3JpYmVUb1RyYW5zYWN0aW9uczogbm90SW5BQ29udGV4dCxcbiAgYWRkVHJhbnNhY3Rpb25NZXRhZGF0YTogbm90SW5BQ29udGV4dFxufSk7XG5sZXQgc3RhdGVSZXBsYWNlcklzQmVpbmdFeGVjdXRlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzdGFydE5leHRUcmVlSWZOZWVkZWQoc3RvcmUpIHtcbiAgaWYgKHN0YXRlUmVwbGFjZXJJc0JlaW5nRXhlY3V0ZWQpIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdBbiBhdG9tIHVwZGF0ZSB3YXMgdHJpZ2dlcmVkIHdpdGhpbiB0aGUgZXhlY3V0aW9uIG9mIGEgc3RhdGUgdXBkYXRlciBmdW5jdGlvbi4gU3RhdGUgdXBkYXRlciBmdW5jdGlvbnMgcHJvdmlkZWQgdG8gUmVjb2lsIG11c3QgYmUgcHVyZSBmdW5jdGlvbnMuJyk7XG4gIH1cblxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICBpZiAoc3RvcmVTdGF0ZS5uZXh0VHJlZSA9PT0gbnVsbCkge1xuICAgIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpICYmIFJlY29pbF9na3goJ3JlY29pbF9yZWxlYXNlX29uX2Nhc2NhZGluZ191cGRhdGVfa2lsbHN3aXRjaF8yMDIxJykpIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjYXNjYWRpbmcgdXBkYXRlICh0aGF0IGlzLCByZW5kZXJpbmcgZHVlIHRvIG9uZSBzdGF0ZSBjaGFuZ2VcbiAgICAgIC8vIGludm9rZXMgYSBzZWNvbmQgc3RhdGUgY2hhbmdlKSwgd2Ugd29uJ3QgaGF2ZSBjbGVhbmVkIHVwIHJldGFpbmFibGVzIHlldFxuICAgICAgLy8gYmVjYXVzZSB0aGlzIG5vcm1hbGx5IGhhcHBlbnMgYWZ0ZXIgbm90aWZ5aW5nIGNvbXBvbmVudHMuIERvIGl0IGJlZm9yZVxuICAgICAgLy8gcHJvY2VlZGluZyB3aXRoIHRoZSBjYXNjYWRpbmcgdXBkYXRlIHNvIHRoYXQgaXQgcmVtYWlucyBwcmVkaWN0YWJsZTpcbiAgICAgIGlmIChzdG9yZVN0YXRlLmNvbW1pdERlcHRoID4gMCkge1xuICAgICAgICByZWxlYXNlU2NoZWR1bGVkUmV0YWluYWJsZXNOb3ckMShzdG9yZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdmVyc2lvbiA9IHN0b3JlU3RhdGUuY3VycmVudFRyZWUudmVyc2lvbjtcbiAgICBjb25zdCBuZXh0VmVyc2lvbiA9IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDMoKTtcbiAgICBzdG9yZVN0YXRlLm5leHRUcmVlID0geyAuLi5zdG9yZVN0YXRlLmN1cnJlbnRUcmVlLFxuICAgICAgdmVyc2lvbjogbmV4dFZlcnNpb24sXG4gICAgICBzdGF0ZUlEOiBuZXh0VmVyc2lvbixcbiAgICAgIGRpcnR5QXRvbXM6IG5ldyBTZXQoKSxcbiAgICAgIHRyYW5zYWN0aW9uTWV0YWRhdGE6IHt9XG4gICAgfTtcbiAgICBzdG9yZVN0YXRlLmdyYXBoc0J5VmVyc2lvbi5zZXQobmV4dFZlcnNpb24sIGNsb25lR3JhcGgkMShSZWNvaWxfbnVsbHRocm93cyhzdG9yZVN0YXRlLmdyYXBoc0J5VmVyc2lvbi5nZXQodmVyc2lvbikpKSk7XG4gIH1cbn1cblxuY29uc3QgQXBwQ29udGV4dCA9IHJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBjdXJyZW50OiBkZWZhdWx0U3RvcmVcbn0pO1xuXG5jb25zdCB1c2VTdG9yZVJlZiA9ICgpID0+IHVzZUNvbnRleHQoQXBwQ29udGV4dCk7IC8vICRGbG93RXhwZWN0ZWRFcnJvcltpbmNvbXBhdGlibGUtY2FsbF1cblxuXG5jb25zdCBNdXRhYmxlU291cmNlQ29udGV4dCA9IHJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbmZ1bmN0aW9uIHVzZVJlY29pbE11dGFibGVTb3VyY2UoKSB7XG4gIGNvbnN0IG11dGFibGVTb3VyY2UgPSB1c2VDb250ZXh0KE11dGFibGVTb3VyY2VDb250ZXh0KTtcblxuICBpZiAobXV0YWJsZVNvdXJjZSA9PSBudWxsKSB7XG4gICAgUmVjb2lsX2V4cGVjdGF0aW9uVmlvbGF0aW9uKCdBdHRlbXB0ZWQgdG8gdXNlIGEgUmVjb2lsIGhvb2sgb3V0c2lkZSBvZiBhIDxSZWNvaWxSb290Pi4gJyArICc8UmVjb2lsUm9vdD4gbXVzdCBiZSBhbiBhbmNlc3RvciBvZiBhbnkgY29tcG9uZW50IHRoYXQgdXNlcyAnICsgJ1JlY29pbCBob29rcy4nKTtcbiAgfVxuXG4gIHJldHVybiBtdXRhYmxlU291cmNlO1xufVxuXG5mdW5jdGlvbiBub3RpZnlDb21wb25lbnRzKHN0b3JlLCBzdG9yZVN0YXRlLCB0cmVlU3RhdGUpIHtcbiAgY29uc3QgZGVwZW5kZW50Tm9kZXMgPSBnZXREb3duc3RyZWFtTm9kZXMkMihzdG9yZSwgdHJlZVN0YXRlLCB0cmVlU3RhdGUuZGlydHlBdG9tcyk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgZGVwZW5kZW50Tm9kZXMpIHtcbiAgICBjb25zdCBjb21wcyA9IHN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5nZXQoa2V5KTtcblxuICAgIGlmIChjb21wcykge1xuICAgICAgZm9yIChjb25zdCBbX3N1YklELCBbX2RlYnVnTmFtZSwgY2FsbGJhY2tdXSBvZiBjb21wcykge1xuICAgICAgICBjYWxsYmFjayh0cmVlU3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZW5kRW5kT2ZCYXRjaE5vdGlmaWNhdGlvbnMoc3RvcmUpIHtcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGNvbnN0IHRyZWVTdGF0ZSA9IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7IC8vIEluZm9ybSB0cmFuc2FjdGlvbiBzdWJzY3JpYmVycyBvZiB0aGUgdHJhbnNhY3Rpb246XG5cbiAgY29uc3QgZGlydHlBdG9tcyA9IHRyZWVTdGF0ZS5kaXJ0eUF0b21zO1xuXG4gIGlmIChkaXJ0eUF0b21zLnNpemUpIHtcbiAgICAvLyBFeGVjdXRlIE5vZGUtc3BlY2lmaWMgc3Vic2NyaWJlcnMgYmVmb3JlIGdsb2JhbCBzdWJzY3JpYmVyc1xuICAgIGZvciAoY29uc3QgW2tleSwgc3Vic2NyaXB0aW9uc10gb2Ygc3RvcmVTdGF0ZS5ub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zKSB7XG4gICAgICBpZiAoZGlydHlBdG9tcy5oYXMoa2V5KSkge1xuICAgICAgICBmb3IgKGNvbnN0IFtfLCBzdWJzY3JpcHRpb25dIG9mIHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb24oc3RvcmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBbXywgc3Vic2NyaXB0aW9uXSBvZiBzdG9yZVN0YXRlLnRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucykge1xuICAgICAgc3Vic2NyaXB0aW9uKHN0b3JlKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlYWN0TW9kZSQyKCkuZWFybHkgfHwgc3RvcmVTdGF0ZS5zdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnMuc2l6ZSA+IDApIHtcbiAgICAgIC8vIE5vdGlmeWluZyBjb21wb25lbnRzIGlzIG5lZWRlZCB0byB3YWtlIGZyb20gc3VzcGVuc2UsIGV2ZW4gd2hlbiB1c2luZ1xuICAgICAgLy8gZWFybHkgcmVuZGVyaW5nLlxuICAgICAgbm90aWZ5Q29tcG9uZW50cyhzdG9yZSwgc3RvcmVTdGF0ZSwgdHJlZVN0YXRlKTsgLy8gV2FrZSBhbGwgc3VzcGVuZGVkIGNvbXBvbmVudHMgc28gdGhlIHJpZ2h0IG9uZShzKSBjYW4gdHJ5IHRvIHJlLXJlbmRlci5cbiAgICAgIC8vIFdlIG5lZWQgdG8gd2FrZSB1cCBjb21wb25lbnRzIG5vdCBqdXN0IHdoZW4gc29tZSBhc3luY2hyb25vdXMgc2VsZWN0b3JcbiAgICAgIC8vIHJlc29sdmVkLCBidXQgYWxzbyB3aGVuIGNoYW5naW5nIHN5bmNocm9ub3VzIHZhbHVlcyBiZWNhdXNlIHRoaXMgbWF5IGNhdXNlXG4gICAgICAvLyBhIHNlbGVjdG9yIHRvIGNoYW5nZSBmcm9tIGFzeW5jaHJvbm91cyB0byBzeW5jaHJvbm91cywgaW4gd2hpY2ggY2FzZSB0aGVyZVxuICAgICAgLy8gd291bGQgYmUgbm8gZm9sbG93LXVwIGFzeW5jaHJvbm91cyByZXNvbHV0aW9uIHRvIHdha2UgdXMgdXAuXG4gICAgICAvLyBUT0RPIE9QVElNSVpBVElPTiBPbmx5IHdha2UgdXAgcmVsYXRlZCBkb3duc3RyZWFtIGNvbXBvbmVudHNcblxuICAgICAgc3RvcmVTdGF0ZS5zdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnMuZm9yRWFjaChjYiA9PiBjYigpKTtcbiAgICAgIHN0b3JlU3RhdGUuc3VzcGVuZGVkQ29tcG9uZW50UmVzb2x2ZXJzLmNsZWFyKCk7XG4gICAgfVxuICB9IC8vIFNwZWNpYWwgYmVoYXZpb3IgT05MWSBpbnZva2VkIGJ5IHVzZUludGVyZmFjZS5cbiAgLy8gRklYTUUgZGVsZXRlIHF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVEIHdoZW4gZGVsZXRpbmcgdXNlSW50ZXJmYWNlLlxuXG5cbiAgc3RvcmVTdGF0ZS5xdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRC5mb3JFYWNoKGNiID0+IGNiKHRyZWVTdGF0ZSkpO1xuICBzdG9yZVN0YXRlLnF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVELnNwbGljZSgwLCBzdG9yZVN0YXRlLnF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVELmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGVuZEJhdGNoKHN0b3JlKSB7XG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBzdG9yZVN0YXRlLmNvbW1pdERlcHRoKys7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7XG4gICAgICBuZXh0VHJlZVxuICAgIH0gPSBzdG9yZVN0YXRlOyAvLyBJZ25vcmUgY29tbWl0cyB0aGF0IGFyZSBub3QgYmVjYXVzZSBvZiBSZWNvaWwgdHJhbnNhY3Rpb25zIC0tIG5hbWVseSxcbiAgICAvLyBiZWNhdXNlIHNvbWV0aGluZyBhYm92ZSBSZWNvaWxSb290IHJlLXJlbmRlcmVkOlxuXG4gICAgaWYgKG5leHRUcmVlID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG5leHRUcmVlIGlzIG5vdyBjb21taXR0ZWQgLS0gbm90ZSB0aGF0IGNvcHlpbmcgYW5kIHJlc2V0IG9jY3VycyB3aGVuXG4gICAgLy8gYSB0cmFuc2FjdGlvbiBiZWdpbnMsIGluIHN0YXJ0TmV4dFRyZWVJZk5lZWRlZDpcblxuXG4gICAgc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUgPSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xuICAgIHN0b3JlU3RhdGUuY3VycmVudFRyZWUgPSBuZXh0VHJlZTtcbiAgICBzdG9yZVN0YXRlLm5leHRUcmVlID0gbnVsbDtcbiAgICBzZW5kRW5kT2ZCYXRjaE5vdGlmaWNhdGlvbnMoc3RvcmUpO1xuXG4gICAgaWYgKHN0b3JlU3RhdGUucHJldmlvdXNUcmVlICE9IG51bGwpIHtcbiAgICAgIHN0b3JlU3RhdGUuZ3JhcGhzQnlWZXJzaW9uLmRlbGV0ZShzdG9yZVN0YXRlLnByZXZpb3VzVHJlZS52ZXJzaW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdFbmRlZCBiYXRjaCB3aXRoIG5vIHByZXZpb3VzIHN0YXRlLCB3aGljaCBpcyB1bmV4cGVjdGVkJywgJ3JlY29pbCcpO1xuICAgIH1cblxuICAgIHN0b3JlU3RhdGUucHJldmlvdXNUcmVlID0gbnVsbDtcblxuICAgIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgICAvLyBPbmx5IHJlbGVhc2UgcmV0YWluYWJsZXMgaWYgdGhlcmUgd2VyZSBubyB3cml0ZXMgZHVyaW5nIHRoZSBlbmQgb2YgdGhlXG4gICAgICAvLyBiYXRjaC4gIFRoaXMgYXZvaWRzIHJlbGVhc2luZyBzb21ldGhpbmcgd2UgbWlnaHQgYmUgYWJvdXQgdG8gdXNlLlxuICAgICAgaWYgKG5leHRUcmVlID09IG51bGwpIHtcbiAgICAgICAgcmVsZWFzZVNjaGVkdWxlZFJldGFpbmFibGVzTm93JDEoc3RvcmUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBzdG9yZVN0YXRlLmNvbW1pdERlcHRoLS07XG4gIH1cbn1cbi8qXG4gKiBUaGUgcHVycG9zZSBvZiB0aGUgQmF0Y2hlciBpcyB0byBvYnNlcnZlIHdoZW4gUmVhY3QgYmF0Y2hlcyBlbmQgc28gdGhhdFxuICogUmVjb2lsIHN0YXRlIGNoYW5nZXMgY2FuIGJlIGJhdGNoZWQuIFdoZW5ldmVyIFJlY29pbCBzdGF0ZSBjaGFuZ2VzLCB3ZSBjYWxsXG4gKiBzZXRTdGF0ZSBvbiB0aGUgYmF0Y2hlci4gVGhlbiB3ZSB3YWl0IGZvciB0aGF0IGNoYW5nZSB0byBiZSBjb21taXR0ZWQsIHdoaWNoXG4gKiBzaWduaWZpZXMgdGhlIGVuZCBvZiB0aGUgYmF0Y2guIFRoYXQncyB3aGVuIHdlIHJlc3BvbmQgdG8gdGhlIFJlY29pbCBjaGFuZ2UuXG4gKi9cblxuXG5mdW5jdGlvbiBCYXRjaGVyKHtcbiAgc2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlXG59KSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYoKTtcbiAgY29uc3QgWywgc2V0U3RhdGVdID0gdXNlU3RhdGUoW10pOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXVxuXG4gIHNldE5vdGlmeUJhdGNoZXJPZkNoYW5nZSgoKSA9PiBzZXRTdGF0ZSh7fSkpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdXG4gICAgc2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlKCgpID0+IHNldFN0YXRlKHt9KSk7IC8vIElmIGFuIGFzeW5jaHJvbm91cyBzZWxlY3RvciByZXNvbHZlcyBhZnRlciB0aGUgQmF0Y2hlciBpcyB1bm1vdW50ZWQsXG4gICAgLy8gbm90aWZ5QmF0Y2hlck9mQ2hhbmdlIHdpbGwgc3RpbGwgYmUgY2FsbGVkLiBBbiBlcnJvciBnZXRzIHRocm93biB3aGVuZXZlclxuICAgIC8vIHNldFN0YXRlIGlzIGNhbGxlZCBhZnRlciBhIGNvbXBvbmVudCBpcyBhbHJlYWR5IHVubW91bnRlZCwgc28gdGhpcyBzZXRzXG4gICAgLy8gbm90aWZ5QmF0Y2hlck9mQ2hhbmdlIHRvIGJlIGEgbm8tb3AuXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlKCgpID0+IHt9KTtcbiAgICB9O1xuICB9LCBbc2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gZW5xdWV1ZUV4ZWN1dGlvbiBydW5zIHRoaXMgZnVuY3Rpb24gaW1tZWRpYXRlbHk7IGl0IGlzIG9ubHkgdXNlZCB0b1xuICAgIC8vIG1hbmlwdWxhdGUgdGhlIG9yZGVyIG9mIHVzZUVmZmVjdHMgZHVyaW5nIHRlc3RzLCBzaW5jZSBSZWFjdCBzZWVtcyB0b1xuICAgIC8vIGNhbGwgdXNlRWZmZWN0IGluIGFuIHVucHJlZGljdGFibGUgb3JkZXIgc29tZXRpbWVzLlxuICAgIFJlY29pbF9RdWV1ZS5lbnF1ZXVlRXhlY3V0aW9uKCdCYXRjaGVyJywgKCkgPT4ge1xuICAgICAgZW5kQmF0Y2goc3RvcmVSZWYuY3VycmVudCk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy4kcmVjb2lsRGVidWdTdGF0ZXMpIHtcbiAgICB3aW5kb3cuJHJlY29pbERlYnVnU3RhdGVzID0gW107XG4gIH1cbn0gLy8gV2hlbiByZW1vdmluZyB0aGlzIGRlcHJlY2F0ZWQgZnVuY3Rpb24sIHJlbW92ZSBzdGF0ZUJ5U2V0dGluZ1JlY29pbFZhbHVlXG4vLyB3aGljaCB3aWxsIG5vIGxvbmdlciBiZSBuZWVkZWQuXG5cblxuZnVuY3Rpb24gaW5pdGlhbFN0b3JlU3RhdGVfREVQUkVDQVRFRChzdG9yZSwgaW5pdGlhbGl6ZVN0YXRlKSB7XG4gIGNvbnN0IGluaXRpYWwgPSBtYWtlRW1wdHlTdG9yZVN0YXRlJDIoKTtcbiAgaW5pdGlhbGl6ZVN0YXRlKHtcbiAgICBzZXQ6IChhdG9tLCB2YWx1ZSkgPT4ge1xuICAgICAgY29uc3Qgc3RhdGUgPSBpbml0aWFsLmN1cnJlbnRUcmVlO1xuICAgICAgY29uc3Qgd3JpdGVzID0gc2V0Tm9kZVZhbHVlJDIoc3RvcmUsIHN0YXRlLCBhdG9tLmtleSwgdmFsdWUpO1xuICAgICAgY29uc3Qgd3JpdHRlbk5vZGVzID0gbmV3IFNldCh3cml0ZXMua2V5cygpKTtcbiAgICAgIGNvbnN0IG5vbnZhbGlkYXRlZEF0b21zID0gc3RhdGUubm9udmFsaWRhdGVkQXRvbXMuY2xvbmUoKTtcblxuICAgICAgZm9yIChjb25zdCBuIG9mIHdyaXR0ZW5Ob2Rlcykge1xuICAgICAgICBub252YWxpZGF0ZWRBdG9tcy5kZWxldGUobik7XG4gICAgICB9XG5cbiAgICAgIGluaXRpYWwuY3VycmVudFRyZWUgPSB7IC4uLnN0YXRlLFxuICAgICAgICBkaXJ0eUF0b21zOiBSZWNvaWxfdW5pb25TZXRzKHN0YXRlLmRpcnR5QXRvbXMsIHdyaXR0ZW5Ob2RlcyksXG4gICAgICAgIGF0b21WYWx1ZXM6IGFwcGx5QXRvbVZhbHVlV3JpdGVzJDEoc3RhdGUuYXRvbVZhbHVlcywgd3JpdGVzKSxcbiAgICAgICAgLy8gTkI6IFBMRUFTRSB1bi1leHBvcnQgYXBwbHlBdG9tVmFsdWVXcml0ZXMgd2hlbiBkZWxldGluZyB0aGlzIGNvZGVcbiAgICAgICAgbm9udmFsaWRhdGVkQXRvbXNcbiAgICAgIH07XG4gICAgfSxcbiAgICBzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXM6IGF0b21WYWx1ZXMgPT4ge1xuICAgICAgLy8gRklYTUUgcmVwbGFjZSB0aGlzIHdpdGggYSBtdXRhdGl2ZSBsb29wXG4gICAgICBhdG9tVmFsdWVzLmZvckVhY2goKHYsIGspID0+IHtcbiAgICAgICAgaW5pdGlhbC5jdXJyZW50VHJlZSA9IHNldFVudmFsaWRhdGVkQXRvbVZhbHVlX0RFUFJFQ0FURUQkMShpbml0aWFsLmN1cnJlbnRUcmVlLCBrLCB2KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpbml0aWFsO1xufSAvLyBJbml0aWFsaXplIHN0YXRlIHNuYXBzaG90IGZvciA8UmVjb2lsUm9vdD4gZm9yIHRoZSBpbml0aWFsaXplU3RhdGUgcHJvcC5cbi8vIEF0b20gZWZmZWN0IGluaXRpYWxpemF0aW9uIHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGlzIHByb3AuXG4vLyBBbnkgYXRvbSBlZmZlY3RzIHdpbGwgYmUgcnVuIGJlZm9yZSBpbml0aWFsaXphdGlvbiwgYnV0IHRoZW4gY2xlYW5lZCB1cCxcbi8vIHRoZXkgYXJlIHRoZW4gcmUtcnVuIHdoZW4gdXNlZCBhcyBwYXJ0IG9mIHJlbmRlcmluZy4gIFRoZXNlIHNlbWFudGljcyBhcmVcbi8vIGNvbXBhdGlibGUgd2l0aCBSZWFjdCBTdHJpY3RNb2RlIHdoZXJlIGVmZmVjdHMgbWF5IGJlIHJlLXJ1biBtdWx0aXBsZSB0aW1lc1xuLy8gYnV0IHN0YXRlIGluaXRpYWxpemF0aW9uIG9ubHkgaGFwcGVucyBvbmNlIHRoZSBmaXJzdCB0aW1lLlxuXG5cbmZ1bmN0aW9uIGluaXRpYWxTdG9yZVN0YXRlKGluaXRpYWxpemVTdGF0ZSkge1xuICAvLyBJbml0aWFsaXplIGEgc25hcHNob3QgYW5kIGdldCBpdHMgc3RvcmVcbiAgY29uc3Qgc25hcHNob3QgPSBmcmVzaFNuYXBzaG90JDEoaW5pdGlhbGl6ZVN0YXRlKTtcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHNuYXBzaG90LmdldFN0b3JlX0lOVEVSTkFMKCkuZ2V0U3RhdGUoKTsgLy8gQ291bnRlcmFjdCB0aGUgc25hcHNob3QgYXV0by1yZWxlYXNlXG5cbiAgc25hcHNob3QucmV0YWluKCk7IC8vIENsZWFudXAgYW55IGVmZmVjdHMgcnVuIGR1cmluZyBpbml0aWFsaXphdGlvbiBhbmQgY2xlYXIgdGhlIGhhbmRsZXJzIHNvXG4gIC8vIHRoZXkgd2lsbCByZS1pbml0aWFsaXplIGlmIHVzZWQgZHVyaW5nIHJlbmRlcmluZy4gIFRoaXMgYWxsb3dzIGF0b20gZWZmZWN0XG4gIC8vIGluaXRpYWxpemF0aW9uIHRvIHRha2UgcHJlY2VkZW5jZSBvdmVyIGluaXRpYWxpemVTdGF0ZSBhbmQgYmUgY29tcGF0aWJsZVxuICAvLyB3aXRoIFN0cmljdE1vZGUgc2VtYW50aWNzLlxuXG4gIHN0b3JlU3RhdGUubm9kZUNsZWFudXBGdW5jdGlvbnMuZm9yRWFjaChjbGVhbnVwID0+IGNsZWFudXAoKSk7XG4gIHN0b3JlU3RhdGUubm9kZUNsZWFudXBGdW5jdGlvbnMuY2xlYXIoKTtcbiAgcmV0dXJuIHN0b3JlU3RhdGU7XG59XG5cbmxldCBuZXh0SUQgPSAwO1xuXG5mdW5jdGlvbiBSZWNvaWxSb290X0lOVEVSTkFMKHtcbiAgaW5pdGlhbGl6ZVN0YXRlX0RFUFJFQ0FURUQsXG4gIGluaXRpYWxpemVTdGF0ZSxcbiAgc3RvcmVfSU5URVJOQUw6IHN0b3JlUHJvcCxcbiAgLy8gRm9yIHVzZSB3aXRoIFJlYWN0IFwiY29udGV4dCBicmlkZ2luZ1wiXG4gIGNoaWxkcmVuXG59KSB7XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICAvLyBAZmItb25seTogdXNlRWZmZWN0KCgpID0+IHtcbiAgLy8gQGZiLW9ubHk6IGlmIChna3goJ3JlY29pbF91c2FnZV9sb2dnaW5nJykpIHtcbiAgLy8gQGZiLW9ubHk6IHRyeSB7XG4gIC8vIEBmYi1vbmx5OiBSZWNvaWxVc2FnZUxvZ0ZhbGNvRXZlbnQubG9nKCgpID0+ICh7XG4gIC8vIEBmYi1vbmx5OiB0eXBlOiBSZWNvaWx1c2FnZWxvZ0V2ZW50LlJFQ09JTF9ST09UX01PVU5URUQsXG4gIC8vIEBmYi1vbmx5OiBwYXRoOiBVUkkuZ2V0UmVxdWVzdFVSSSgpLmdldFBhdGgoKSxcbiAgLy8gQGZiLW9ubHk6IH0pKTtcbiAgLy8gQGZiLW9ubHk6IH0gY2F0Y2gge1xuICAvLyBAZmItb25seTogcmVjb3ZlcmFibGVWaW9sYXRpb24oXG4gIC8vIEBmYi1vbmx5OiAnRXJyb3Igd2hlbiBsb2dnaW5nIFJlY29pbCBVc2FnZSBldmVudCcsXG4gIC8vIEBmYi1vbmx5OiAncmVjb2lsJyxcbiAgLy8gQGZiLW9ubHk6ICk7XG4gIC8vIEBmYi1vbmx5OiB9XG4gIC8vIEBmYi1vbmx5OiB9XG4gIC8vIEBmYi1vbmx5OiB9LCBbXSk7XG4gIGxldCBzdG9yZVN0YXRlUmVmOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1jb25zdFxuXG4gIGNvbnN0IGdldEdyYXBoID0gdmVyc2lvbiA9PiB7XG4gICAgY29uc3QgZ3JhcGhzID0gc3RvcmVTdGF0ZVJlZi5jdXJyZW50LmdyYXBoc0J5VmVyc2lvbjtcblxuICAgIGlmIChncmFwaHMuaGFzKHZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gUmVjb2lsX251bGx0aHJvd3MoZ3JhcGhzLmdldCh2ZXJzaW9uKSk7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3R3JhcGggPSBncmFwaCQyKCk7XG4gICAgZ3JhcGhzLnNldCh2ZXJzaW9uLCBuZXdHcmFwaCk7XG4gICAgcmV0dXJuIG5ld0dyYXBoO1xuICB9O1xuXG4gIGNvbnN0IHN1YnNjcmliZVRvVHJhbnNhY3Rpb25zID0gKGNhbGxiYWNrLCBrZXkpID0+IHtcbiAgICBpZiAoa2V5ID09IG51bGwpIHtcbiAgICAgIC8vIEdsb2JhbCB0cmFuc2FjdGlvbiBzdWJzY3JpcHRpb25zXG4gICAgICBjb25zdCB7XG4gICAgICAgIHRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uc1xuICAgICAgfSA9IHN0b3JlUmVmLmN1cnJlbnQuZ2V0U3RhdGUoKTtcbiAgICAgIGNvbnN0IGlkID0gbmV4dElEKys7XG4gICAgICB0cmFuc2FjdGlvblN1YnNjcmlwdGlvbnMuc2V0KGlkLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWxlYXNlOiAoKSA9PiB7XG4gICAgICAgICAgdHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zLmRlbGV0ZShpZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vZGUtc3BlY2lmaWMgdHJhbnNhY3Rpb24gc3Vic2NyaXB0aW9uczpcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uc1xuICAgICAgfSA9IHN0b3JlUmVmLmN1cnJlbnQuZ2V0U3RhdGUoKTtcblxuICAgICAgaWYgKCFub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zLmhhcyhrZXkpKSB7XG4gICAgICAgIG5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnMuc2V0KGtleSwgbmV3IE1hcCgpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaWQgPSBuZXh0SUQrKztcbiAgICAgIFJlY29pbF9udWxsdGhyb3dzKG5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnMuZ2V0KGtleSkpLnNldChpZCwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVsZWFzZTogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN1YnMgPSBub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zLmdldChrZXkpO1xuXG4gICAgICAgICAgaWYgKHN1YnMpIHtcbiAgICAgICAgICAgIHN1YnMuZGVsZXRlKGlkKTtcblxuICAgICAgICAgICAgaWYgKHN1YnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICBub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgYWRkVHJhbnNhY3Rpb25NZXRhZGF0YSA9IG1ldGFkYXRhID0+IHtcbiAgICBzdGFydE5leHRUcmVlSWZOZWVkZWQoc3RvcmVSZWYuY3VycmVudCk7XG5cbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMobWV0YWRhdGEpKSB7XG4gICAgICBSZWNvaWxfbnVsbHRocm93cyhzdG9yZVJlZi5jdXJyZW50LmdldFN0YXRlKCkubmV4dFRyZWUpLnRyYW5zYWN0aW9uTWV0YWRhdGFba10gPSBtZXRhZGF0YVtrXTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVwbGFjZVN0YXRlID0gcmVwbGFjZXIgPT4ge1xuICAgIHN0YXJ0TmV4dFRyZWVJZk5lZWRlZChzdG9yZVJlZi5jdXJyZW50KTsgLy8gVXNlIHJlcGxhY2VyIHRvIGdldCB0aGUgbmV4dCBzdGF0ZTpcblxuICAgIGNvbnN0IG5leHRUcmVlID0gUmVjb2lsX251bGx0aHJvd3Moc3RvcmVTdGF0ZVJlZi5jdXJyZW50Lm5leHRUcmVlKTtcbiAgICBsZXQgcmVwbGFjZWQ7XG5cbiAgICB0cnkge1xuICAgICAgc3RhdGVSZXBsYWNlcklzQmVpbmdFeGVjdXRlZCA9IHRydWU7XG4gICAgICByZXBsYWNlZCA9IHJlcGxhY2VyKG5leHRUcmVlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc3RhdGVSZXBsYWNlcklzQmVpbmdFeGVjdXRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChyZXBsYWNlZCA9PT0gbmV4dFRyZWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2luZG93LiRyZWNvaWxEZWJ1Z1N0YXRlcy5wdXNoKHJlcGxhY2VkKTsgLy8gVE9ETyB0aGlzIHNob3VsZG4ndCBoYXBwZW4gaGVyZSBiZWNhdXNlIGl0J3Mgbm90IGJhdGNoZWRcbiAgICAgIH1cbiAgICB9IC8vIFNhdmUgY2hhbmdlcyB0byBuZXh0VHJlZSBhbmQgc2NoZWR1bGUgYSBSZWFjdCB1cGRhdGU6XG5cblxuICAgIHN0b3JlU3RhdGVSZWYuY3VycmVudC5uZXh0VHJlZSA9IHJlcGxhY2VkO1xuXG4gICAgaWYgKHJlYWN0TW9kZSQyKCkuZWFybHkpIHtcbiAgICAgIG5vdGlmeUNvbXBvbmVudHMoc3RvcmVSZWYuY3VycmVudCwgc3RvcmVTdGF0ZVJlZi5jdXJyZW50LCByZXBsYWNlZCk7XG4gICAgfVxuXG4gICAgUmVjb2lsX251bGx0aHJvd3Mobm90aWZ5QmF0Y2hlck9mQ2hhbmdlLmN1cnJlbnQpKCk7XG4gIH07XG5cbiAgY29uc3Qgbm90aWZ5QmF0Y2hlck9mQ2hhbmdlID0gdXNlUmVmJDEobnVsbCk7XG4gIGNvbnN0IHNldE5vdGlmeUJhdGNoZXJPZkNoYW5nZSA9IHVzZUNhbGxiYWNrKHggPT4ge1xuICAgIG5vdGlmeUJhdGNoZXJPZkNoYW5nZS5jdXJyZW50ID0geDtcbiAgfSwgW25vdGlmeUJhdGNoZXJPZkNoYW5nZV0pO1xuICBjb25zdCBzdG9yZVJlZiA9IFJlY29pbF91c2VSZWZJbml0T25jZSgoKSA9PiBzdG9yZVByb3AgIT09IG51bGwgJiYgc3RvcmVQcm9wICE9PSB2b2lkIDAgPyBzdG9yZVByb3AgOiB7XG4gICAgc3RvcmVJRDogZ2V0TmV4dFN0b3JlSUQkMigpLFxuICAgIGdldFN0YXRlOiAoKSA9PiBzdG9yZVN0YXRlUmVmLmN1cnJlbnQsXG4gICAgcmVwbGFjZVN0YXRlLFxuICAgIGdldEdyYXBoLFxuICAgIHN1YnNjcmliZVRvVHJhbnNhY3Rpb25zLFxuICAgIGFkZFRyYW5zYWN0aW9uTWV0YWRhdGFcbiAgfSk7XG5cbiAgaWYgKHN0b3JlUHJvcCAhPSBudWxsKSB7XG4gICAgc3RvcmVSZWYuY3VycmVudCA9IHN0b3JlUHJvcDtcbiAgfVxuXG4gIHN0b3JlU3RhdGVSZWYgPSBSZWNvaWxfdXNlUmVmSW5pdE9uY2UoKCkgPT4gaW5pdGlhbGl6ZVN0YXRlX0RFUFJFQ0FURUQgIT0gbnVsbCA/IGluaXRpYWxTdG9yZVN0YXRlX0RFUFJFQ0FURUQoc3RvcmVSZWYuY3VycmVudCwgaW5pdGlhbGl6ZVN0YXRlX0RFUFJFQ0FURUQpIDogaW5pdGlhbGl6ZVN0YXRlICE9IG51bGwgPyBpbml0aWFsU3RvcmVTdGF0ZShpbml0aWFsaXplU3RhdGUpIDogbWFrZUVtcHR5U3RvcmVTdGF0ZSQyKCkpO1xuICBjb25zdCBtdXRhYmxlU291cmNlID0gdXNlTWVtbygoKSA9PiBjcmVhdGVNdXRhYmxlU291cmNlJDEgPT09IG51bGwgfHwgY3JlYXRlTXV0YWJsZVNvdXJjZSQxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjcmVhdGVNdXRhYmxlU291cmNlJDEoc3RvcmVTdGF0ZVJlZiwgKCkgPT4gc3RvcmVTdGF0ZVJlZi5jdXJyZW50LmN1cnJlbnRUcmVlLnZlcnNpb24pLCBbc3RvcmVTdGF0ZVJlZl0pOyAvLyBDbGVhbnVwIHdoZW4gdGhlIDxSZWNvaWxSb290PiBpcyB1bm1vdW50ZWRcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFJlYWN0IGlzIGZyZWUgdG8gY2FsbCBlZmZlY3QgY2xlYW51cCBoYW5kbGVycyBhbmQgZWZmZWN0cyBhdCB3aWxsLCB0aGVcbiAgICAvLyBkZXBzIGFycmF5IGlzIG9ubHkgYW4gb3B0aW1pemF0aW9uLiAgRm9yIGV4YW1wbGUsIFJlYWN0IHN0cmljdCBtb2RlXG4gICAgLy8gd2lsbCBleGVjdXRlIGVhY2ggZWZmZWN0IHR3aWNlIGZvciB0ZXN0aW5nLiAgVGhlcmVmb3JlLCB3ZSBuZWVkIHN5bW1ldHJ5XG4gICAgLy8gdG8gcmUtaW5pdGlhbGl6ZSBhbGwga25vd24gYXRvbXMgYWZ0ZXIgdGhleSB3ZXJlIGNsZWFuZWQgdXAuXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuXG4gICAgZm9yIChjb25zdCBhdG9tS2V5IG9mIG5ldyBTZXQoc3RvcmUuZ2V0U3RhdGUoKS5rbm93bkF0b21zKSkge1xuICAgICAgaW5pdGlhbGl6ZU5vZGUkMihzdG9yZSwgYXRvbUtleSwgJ2dldCcpO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGF0b21LZXkgb2Ygc3RvcmUuZ2V0U3RhdGUoKS5rbm93bkF0b21zKSB7XG4gICAgICAgIGNsZWFuVXBOb2RlJDIoc3RvcmUsIGF0b21LZXkpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtzdG9yZVJlZl0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL3JlYWN0LmNyZWF0ZUVsZW1lbnQoQXBwQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzdG9yZVJlZlxuICB9LCAvKiNfX1BVUkVfXyovcmVhY3QuY3JlYXRlRWxlbWVudChNdXRhYmxlU291cmNlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBtdXRhYmxlU291cmNlXG4gIH0sIC8qI19fUFVSRV9fKi9yZWFjdC5jcmVhdGVFbGVtZW50KEJhdGNoZXIsIHtcbiAgICBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2U6IHNldE5vdGlmeUJhdGNoZXJPZkNoYW5nZVxuICB9KSwgY2hpbGRyZW4pKTtcbn1cblxuZnVuY3Rpb24gUmVjb2lsUm9vdChwcm9wcykge1xuICBjb25zdCB7XG4gICAgb3ZlcnJpZGUsXG4gICAgLi4ucHJvcHNFeGNlcHRPdmVycmlkZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGFuY2VzdG9yU3RvcmVSZWYgPSB1c2VTdG9yZVJlZigpO1xuXG4gIGlmIChvdmVycmlkZSA9PT0gZmFsc2UgJiYgYW5jZXN0b3JTdG9yZVJlZi5jdXJyZW50ICE9PSBkZWZhdWx0U3RvcmUpIHtcbiAgICAvLyBJZiBhbmNlc3RvclN0b3JlUmVmLmN1cnJlbnQgIT09IGRlZmF1bHRTdG9yZSwgaXQgbWVhbnMgdGhhdCB0aGlzXG4gICAgLy8gUmVjb2lsUm9vdCBpcyBub3QgbmVzdGVkIHdpdGhpbiBhbm90aGVyLlxuICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovcmVhY3QuY3JlYXRlRWxlbWVudChSZWNvaWxSb290X0lOVEVSTkFMLCBwcm9wc0V4Y2VwdE92ZXJyaWRlKTtcbn1cblxuZnVuY3Rpb24gdXNlUmVjb2lsU3RvcmVJRCgpIHtcbiAgcmV0dXJuIHVzZVN0b3JlUmVmKCkuY3VycmVudC5zdG9yZUlEO1xufVxuXG52YXIgUmVjb2lsX1JlY29pbFJvb3QgPSB7XG4gIFJlY29pbFJvb3QsXG4gIHVzZVN0b3JlUmVmLFxuICB1c2VSZWNvaWxNdXRhYmxlU291cmNlLFxuICB1c2VSZWNvaWxTdG9yZUlELFxuICBub3RpZnlDb21wb25lbnRzX0ZPUl9URVNUSU5HOiBub3RpZnlDb21wb25lbnRzLFxuICBzZW5kRW5kT2ZCYXRjaE5vdGlmaWNhdGlvbnNfRk9SX1RFU1RJTkc6IHNlbmRFbmRPZkJhdGNoTm90aWZpY2F0aW9uc1xufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiBzaGFsbG93QXJyYXlFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBSZWNvaWxfc2hhbGxvd0FycmF5RXF1YWwgPSBzaGFsbG93QXJyYXlFcXVhbDtcblxuY29uc3Qge1xuICB1c2VFZmZlY3Q6IHVzZUVmZmVjdCQxLFxuICB1c2VSZWY6IHVzZVJlZiQyXG59ID0gcmVhY3Q7XG5cbmZ1bmN0aW9uIHVzZVByZXZpb3VzKHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZiQyKCk7XG4gIHVzZUVmZmVjdCQxKCgpID0+IHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXVxuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVmLmN1cnJlbnQ7XG59XG5cbnZhciBSZWNvaWxfdXNlUHJldmlvdXMgPSB1c2VQcmV2aW91cztcblxuY29uc3Qge1xuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkMVxufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5jb25zdCB7XG4gIFNVU1BFTlNFX1RJTUVPVVRfTVM6IFNVU1BFTlNFX1RJTUVPVVRfTVMkMVxufSA9IFJlY29pbF9SZXRlbnRpb247XG5cbmNvbnN0IHtcbiAgdXBkYXRlUmV0YWluQ291bnQ6IHVwZGF0ZVJldGFpbkNvdW50JDJcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xuXG5jb25zdCB7XG4gIFJldGVudGlvblpvbmU6IFJldGVudGlvblpvbmUkM1xufSA9IFJlY29pbF9SZXRlbnRpb25ab25lO1xuXG5jb25zdCB7XG4gIHVzZUVmZmVjdDogdXNlRWZmZWN0JDIsXG4gIHVzZVJlZjogdXNlUmVmJDNcbn0gPSByZWFjdDtcblxuY29uc3Qge1xuICBpc1NTUjogaXNTU1IkMlxufSA9IFJlY29pbF9FbnZpcm9ubWVudDtcblxuXG5cblxuXG4gLy8gSSBkb24ndCBzZWUgYSB3YXkgdG8gYXZvaWQgdGhlIGFueSB0eXBlIGhlcmUgYmVjYXVzZSB3ZSB3YW50IHRvIGFjY2VwdCByZWFkYWJsZVxuLy8gYW5kIHdyaXRhYmxlIHZhbHVlcyB3aXRoIGFueSB0eXBlIHBhcmFtZXRlciwgYnV0IG5vcm1hbGx5IHdpdGggd3JpdGFibGUgb25lc1xuLy8gUmVjb2lsU3RhdGU8U29tZVQ+IGlzIG5vdCBhIHN1YnR5cGUgb2YgUmVjb2lsU3RhdGU8bWl4ZWQ+LlxuXG5cbi8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuZnVuY3Rpb24gdXNlUmV0YWluKHRvUmV0YWluKSB7XG4gIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L3JlYWN0LWhvb2tzXG5cblxuICByZXR1cm4gdXNlUmV0YWluX0FDVFVBTCh0b1JldGFpbik7XG59XG5cbmZ1bmN0aW9uIHVzZVJldGFpbl9BQ1RVQUwodG9SZXRhaW4pIHtcbiAgY29uc3QgYXJyYXkgPSBBcnJheS5pc0FycmF5KHRvUmV0YWluKSA/IHRvUmV0YWluIDogW3RvUmV0YWluXTtcbiAgY29uc3QgcmV0YWluYWJsZXMgPSBhcnJheS5tYXAoYSA9PiBhIGluc3RhbmNlb2YgUmV0ZW50aW9uWm9uZSQzID8gYSA6IGEua2V5KTtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQxKCk7XG4gIHVzZUVmZmVjdCQyKCgpID0+IHtcbiAgICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAodGltZW91dElELmN1cnJlbnQgJiYgIWlzU1NSJDIpIHtcbiAgICAgIC8vIEFscmVhZHkgcGVyZm9ybWVkIGEgdGVtcG9yYXJ5IHJldGFpbiBvbiByZW5kZXIsIHNpbXBseSBjYW5jZWwgdGhlIHJlbGVhc2VcbiAgICAgIC8vIG9mIHRoYXQgdGVtcG9yYXJ5IHJldGFpbi5cbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElELmN1cnJlbnQpO1xuICAgICAgdGltZW91dElELmN1cnJlbnQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IHIgb2YgcmV0YWluYWJsZXMpIHtcbiAgICAgICAgdXBkYXRlUmV0YWluQ291bnQkMihzdG9yZSwgciwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgciBvZiByZXRhaW5hYmxlcykge1xuICAgICAgICB1cGRhdGVSZXRhaW5Db3VudCQyKHN0b3JlLCByLCAtMSk7XG4gICAgICB9XG4gICAgfTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9yZWFjdC1ob29rcy1kZXBzXG4gIH0sIFtzdG9yZVJlZiwgLi4ucmV0YWluYWJsZXNdKTsgLy8gV2Ugd2FudCB0byByZXRhaW4gaWYgdGhlIGNvbXBvbmVudCBzdXNwZW5kcy4gVGhpcyBpcyB0ZXJyaWJsZSBidXQgdGhlIFN1c3BlbnNlXG4gIC8vIEFQSSBhZmZvcmRzIHVzIG5vIGJldHRlciBvcHRpb24uIElmIHdlIHN1c3BlbmQgYW5kIG5ldmVyIGNvbW1pdCBhZnRlciBzb21lXG4gIC8vIHNlY29uZHMsIHRoZW4gcmVsZWFzZS4gVGhlICdhY3R1YWwnIHJldGFpbi9yZWxlYXNlIGluIHRoZSBlZmZlY3QgYWJvdmVcbiAgLy8gY2FuY2VscyB0aGlzLlxuXG4gIGNvbnN0IHRpbWVvdXRJRCA9IHVzZVJlZiQzKCk7XG4gIGNvbnN0IHByZXZpb3VzUmV0YWluYWJsZXMgPSBSZWNvaWxfdXNlUHJldmlvdXMocmV0YWluYWJsZXMpO1xuXG4gIGlmICghaXNTU1IkMiAmJiAocHJldmlvdXNSZXRhaW5hYmxlcyA9PT0gdW5kZWZpbmVkIHx8ICFSZWNvaWxfc2hhbGxvd0FycmF5RXF1YWwocHJldmlvdXNSZXRhaW5hYmxlcywgcmV0YWluYWJsZXMpKSkge1xuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcblxuICAgIGZvciAoY29uc3QgciBvZiByZXRhaW5hYmxlcykge1xuICAgICAgdXBkYXRlUmV0YWluQ291bnQkMihzdG9yZSwgciwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZpb3VzUmV0YWluYWJsZXMpIHtcbiAgICAgIGZvciAoY29uc3QgciBvZiBwcmV2aW91c1JldGFpbmFibGVzKSB7XG4gICAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDIoc3RvcmUsIHIsIC0xKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGltZW91dElELmN1cnJlbnQpIHtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElELmN1cnJlbnQpO1xuICAgIH1cblxuICAgIHRpbWVvdXRJRC5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGltZW91dElELmN1cnJlbnQgPSBudWxsO1xuXG4gICAgICBmb3IgKGNvbnN0IHIgb2YgcmV0YWluYWJsZXMpIHtcbiAgICAgICAgdXBkYXRlUmV0YWluQ291bnQkMihzdG9yZSwgciwgLTEpO1xuICAgICAgfVxuICAgIH0sIFNVU1BFTlNFX1RJTUVPVVRfTVMkMSk7XG4gIH1cbn1cblxudmFyIFJlY29pbF91c2VSZXRhaW4gPSB1c2VSZXRhaW47XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogVEhJUyBDT0RFIEhBUyBCRUVOIENPTU1FTlRFRCBPVVQgSU5URU5USU9OQUxMWVxuICpcbiAqIFRoaXMgdGVjaG5pcXVlIG9mIGdldHRpbmcgdGhlIGNvbXBvbmVudCBuYW1lIGlzIGltcGVyZmVjdCwgc2luY2UgaXQgYm90aCBvbmx5XG4gKiB3b3JrcyBpbiBhIG5vbi1taW5pZmllZCBjb2RlIGJhc2UsIGFuZCBtb3JlIGltcG9ydGFudGx5IGludHJvZHVjZXMgcGVyZm9ybWFuY2VcbiAqIHByb2JsZW1zIHNpbmNlIGl0IHJlbGllcyBpbiB0aHJvd2luZyBlcnJvcnMgd2hpY2ggaXMgYW4gZXhwZW5zaXZlIG9wZXJhdGlvbi5cbiAqXG4gKiBBdCBzb21lIHBvaW50IHdlIG1heSB3YW50IHRvIHJlZXZhbHVhdGUgdGhpcyB0ZWNobmlxdWUgaGVuY2Ugd2h5IHdlIGhhdmUgY29tbWVudGVkXG4gKiB0aGlzIGNvZGUgb3V0LCByYXRoZXIgdGhhbiBkZWxldGUgaXQgYWxsIHRvZ2V0aGVyLlxuICovXG4vLyBjb25zdCB7dXNlUmVmfSA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG4vLyBjb25zdCBna3ggPSByZXF1aXJlKCdyZWNvaWwtc2hhcmVkL3V0aWwvUmVjb2lsX2dreCcpO1xuLy8gY29uc3Qgc3RhY2tUcmFjZVBhcnNlciA9IHJlcXVpcmUoJ3JlY29pbC1zaGFyZWQvdXRpbC9SZWNvaWxfc3RhY2tUcmFjZVBhcnNlcicpO1xuXG5mdW5jdGlvbiB1c2VDb21wb25lbnROYW1lKCkge1xuICAvLyBjb25zdCBuYW1lUmVmID0gdXNlUmVmKCk7XG4gIC8vIGlmIChfX0RFVl9fKSB7XG4gIC8vICAgaWYgKGdreCgncmVjb2lsX2luZmVyX2NvbXBvbmVudF9uYW1lcycpKSB7XG4gIC8vICAgICBpZiAobmFtZVJlZi5jdXJyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgLy8gICAgICAgLy8gVGhlcmUgaXMgbm8gYmxlc3NlZCB3YXkgdG8gZGV0ZXJtaW5lIHRoZSBjYWxsaW5nIFJlYWN0IGNvbXBvbmVudCBmcm9tXG4gIC8vICAgICAgIC8vIHdpdGhpbiBhIGhvb2suIFRoaXMgaGFjayB1c2VzIHRoZSBmYWN0IHRoYXQgaG9va3MgbXVzdCBzdGFydCB3aXRoICd1c2UnXG4gIC8vICAgICAgIC8vIGFuZCB0aGF0IGhvb2tzIGFyZSBlaXRoZXIgY2FsbGVkIGJ5IFJlYWN0IENvbXBvbmVudHMgb3Igb3RoZXIgaG9va3MuIEl0XG4gIC8vICAgICAgIC8vIGZvbGxvd3MgdGhlcmVmb3JlLCB0aGF0IHRvIGZpbmQgdGhlIGNhbGxpbmcgY29tcG9uZW50LCB5b3Ugc2ltcGx5IG5lZWRcbiAgLy8gICAgICAgLy8gdG8gbG9vayBkb3duIHRoZSBzdGFjayBhbmQgZmluZCB0aGUgZmlyc3QgZnVuY3Rpb24gd2hpY2ggZG9lc24ndCBzdGFydFxuICAvLyAgICAgICAvLyB3aXRoICd1c2UnLiBXZSBhcmUgb25seSBlbmFibGluZyB0aGlzIGluIGRldiBmb3Igbm93LCBzaW5jZSBvbmNlIHRoZVxuICAvLyAgICAgICAvLyBjb2RlYmFzZSBpcyBtaW5pZmllZCwgdGhlIG5hbWluZyBhc3N1bXB0aW9ucyBubyBsb25nZXIgaG9sZCB0cnVlLlxuICAvLyAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L25vLW5ldy1lcnJvclxuICAvLyAgICAgICBjb25zdCBmcmFtZXMgPSBzdGFja1RyYWNlUGFyc2VyKG5ldyBFcnJvcigpLnN0YWNrKTtcbiAgLy8gICAgICAgZm9yIChjb25zdCB7bWV0aG9kTmFtZX0gb2YgZnJhbWVzKSB7XG4gIC8vICAgICAgICAgLy8gSSBvYnNlcnZlZCBjYXNlcyB3aGVyZSB0aGUgZnJhbWUgd2FzIG9mIHRoZSBmb3JtICdPYmplY3QudXNlWFhYJ1xuICAvLyAgICAgICAgIC8vIGhlbmNlIHdoeSBJJ20gc2VhcmNoaW5nIGZvciBob29rcyBmb2xsb3dpbmcgYSB3b3JkIGJvdW5kYXJ5XG4gIC8vICAgICAgICAgaWYgKCFtZXRob2ROYW1lLm1hdGNoKC9cXGJ1c2VbXlxcYl0rJC8pKSB7XG4gIC8vICAgICAgICAgICByZXR1cm4gKG5hbWVSZWYuY3VycmVudCA9IG1ldGhvZE5hbWUpO1xuICAvLyAgICAgICAgIH1cbiAgLy8gICAgICAgfVxuICAvLyAgICAgICBuYW1lUmVmLmN1cnJlbnQgPSBudWxsO1xuICAvLyAgICAgfVxuICAvLyAgICAgcmV0dXJuIG5hbWVSZWYuY3VycmVudCA/PyAnPHVuYWJsZSB0byBkZXRlcm1pbmUgY29tcG9uZW50IG5hbWU+JztcbiAgLy8gICB9XG4gIC8vIH1cbiAgLy8gQGZiLW9ubHk6IHJldHVybiBcIjxjb21wb25lbnQgbmFtZSBvbmx5IGF2YWlsYWJsZSB3aGVuIGJvdGggaW4gZGV2IG1vZGUgYW5kIHdoZW4gcGFzc2luZyBHSyAncmVjb2lsX2luZmVyX2NvbXBvbmVudF9uYW1lcyc+XCI7XG4gIHJldHVybiAnPGNvbXBvbmVudCBuYW1lIG5vdCBhdmFpbGFibGU+JzsgLy8gQG9zcy1vbmx5XG59XG5cbnZhciBSZWNvaWxfdXNlQ29tcG9uZW50TmFtZSA9IHVzZUNvbXBvbmVudE5hbWU7XG5cbmNvbnN0IHtcbiAgYmF0Y2hVcGRhdGVzOiBiYXRjaFVwZGF0ZXMkMlxufSA9IFJlY29pbF9CYXRjaGluZztcblxuY29uc3Qge1xuICBERUZBVUxUX1ZBTFVFOiBERUZBVUxUX1ZBTFVFJDJcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICBjdXJyZW50UmVuZGVyZXJTdXBwb3J0c1VzZVN5bmNFeHRlcm5hbFN0b3JlOiBjdXJyZW50UmVuZGVyZXJTdXBwb3J0c1VzZVN5bmNFeHRlcm5hbFN0b3JlJDEsXG4gIHJlYWN0TW9kZTogcmVhY3RNb2RlJDMsXG4gIHVzZU11dGFibGVTb3VyY2U6IHVzZU11dGFibGVTb3VyY2UkMSxcbiAgdXNlU3luY0V4dGVybmFsU3RvcmU6IHVzZVN5bmNFeHRlcm5hbFN0b3JlJDFcbn0gPSBSZWNvaWxfUmVhY3RNb2RlO1xuXG5jb25zdCB7XG4gIHVzZVJlY29pbE11dGFibGVTb3VyY2U6IHVzZVJlY29pbE11dGFibGVTb3VyY2UkMSxcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDJcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcblxuY29uc3Qge1xuICBpc1JlY29pbFZhbHVlOiBpc1JlY29pbFZhbHVlJDJcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWUkMTtcblxuY29uc3Qge1xuICBBYnN0cmFjdFJlY29pbFZhbHVlOiBBYnN0cmFjdFJlY29pbFZhbHVlJDMsXG4gIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZTogZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDIsXG4gIHNldFJlY29pbFZhbHVlOiBzZXRSZWNvaWxWYWx1ZSQyLFxuICBzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlOiBzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlJDIsXG4gIHN1YnNjcmliZVRvUmVjb2lsVmFsdWU6IHN1YnNjcmliZVRvUmVjb2lsVmFsdWUkMVxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcblxuXG5cbmNvbnN0IHtcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrJDEsXG4gIHVzZUVmZmVjdDogdXNlRWZmZWN0JDMsXG4gIHVzZU1lbW86IHVzZU1lbW8kMSxcbiAgdXNlUmVmOiB1c2VSZWYkNCxcbiAgdXNlU3RhdGU6IHVzZVN0YXRlJDFcbn0gPSByZWFjdDtcblxuY29uc3Qge1xuICBzZXRCeUFkZGluZ1RvU2V0OiBzZXRCeUFkZGluZ1RvU2V0JDJcbn0gPSBSZWNvaWxfQ29weU9uV3JpdGU7XG5cblxuXG5jb25zdCB7XG4gIGlzU1NSOiBpc1NTUiQzXG59ID0gUmVjb2lsX0Vudmlyb25tZW50O1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBoYW5kbGVMb2FkYWJsZShsb2FkYWJsZSwgcmVjb2lsVmFsdWUsIHN0b3JlUmVmKSB7XG4gIC8vIFdlIGNhbid0IGp1c3QgdGhyb3cgdGhlIHByb21pc2Ugd2UgYXJlIHdhaXRpbmcgb24gdG8gU3VzcGVuc2UuICBJZiB0aGVcbiAgLy8gdXBzdHJlYW0gZGVwZW5kZW5jaWVzIGNoYW5nZSBpdCBtYXkgcHJvZHVjZSBhIHN0YXRlIGluIHdoaWNoIHRoZSBjb21wb25lbnRcbiAgLy8gY2FuIHJlbmRlciwgYnV0IGl0IHdvdWxkIHN0aWxsIGJlIHN1c3BlbmRlZCBvbiBhIFByb21pc2UgdGhhdCBtYXkgbmV2ZXIgcmVzb2x2ZS5cbiAgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnKSB7XG4gICAgcmV0dXJuIGxvYWRhYmxlLmNvbnRlbnRzO1xuICB9IGVsc2UgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCBzdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnMgPSBzdG9yZVJlZi5jdXJyZW50LmdldFN0YXRlKCkuc3VzcGVuZGVkQ29tcG9uZW50UmVzb2x2ZXJzO1xuICAgICAgc3VzcGVuZGVkQ29tcG9uZW50UmVzb2x2ZXJzLmFkZChyZXNvbHZlKTsgLy8gU1NSIHNob3VsZCBjbGVhciBvdXQgdGhlIHdha2UtdXAgcmVzb2x2ZXIgaWYgdGhlIFByb21pc2UgaXMgcmVzb2x2ZWRcbiAgICAgIC8vIHRvIGF2b2lkIGluZmluaXRlIGxvb3BzLiAgKFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2tleHBlcmltZW50YWwvUmVjb2lsL3B1bGwvMjA3MylcblxuICAgICAgaWYgKGlzU1NSJDMgJiYgUmVjb2lsX2lzUHJvbWlzZShsb2FkYWJsZS5jb250ZW50cykpIHtcbiAgICAgICAgbG9hZGFibGUuY29udGVudHMuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgc3VzcGVuZGVkQ29tcG9uZW50UmVzb2x2ZXJzLmRlbGV0ZShyZXNvbHZlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7IC8vICRGbG93RXhwZWN0ZWRFcnJvciBGbG93KHByb3AtbWlzc2luZykgZm9yIGludGVncmF0aW5nIHdpdGggdG9vbHMgdGhhdCBpbnNwZWN0IHRocm93biBwcm9taXNlcyBAZmItb25seVxuICAgIC8vIEBmYi1vbmx5OiBwcm9taXNlLmRpc3BsYXlOYW1lID0gYFJlY29pbCBTdGF0ZTogJHtyZWNvaWxWYWx1ZS5rZXl9YDtcblxuICAgIHRocm93IHByb21pc2U7XG4gIH0gZWxzZSBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNFcnJvcicpIHtcbiAgICB0aHJvdyBsb2FkYWJsZS5jb250ZW50cztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKGBJbnZhbGlkIHZhbHVlIG9mIGxvYWRhYmxlIGF0b20gXCIke3JlY29pbFZhbHVlLmtleX1cImApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsIGhvb2tOYW1lIC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cbikge1xuICBpZiAoIWlzUmVjb2lsVmFsdWUkMihyZWNvaWxWYWx1ZSkpIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKGBJbnZhbGlkIGFyZ3VtZW50IHRvICR7aG9va05hbWV9OiBleHBlY3RlZCBhbiBhdG9tIG9yIHNlbGVjdG9yIGJ1dCBnb3QgJHtTdHJpbmcocmVjb2lsVmFsdWUpfWApO1xuICB9XG59XG5cbi8qKlxuICogVmFyaW91cyB0aGluZ3MgYXJlIGJyb2tlbiB3aXRoIHVzZVJlY29pbEludGVyZmFjZSwgcGFydGljdWxhcmx5IGNvbmN1cnJlbnRcbiAqIG1vZGUsIFJlYWN0IHN0cmljdCBtb2RlLCBhbmQgbWVtb3J5IG1hbmFnZW1lbnQuIFRoZXkgd2lsbCBub3QgYmUgZml4ZWQuXG4gKiAqL1xuZnVuY3Rpb24gdXNlUmVjb2lsSW50ZXJmYWNlX0RFUFJFQ0FURUQoKSB7XG4gIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBSZWNvaWxfdXNlQ29tcG9uZW50TmFtZSgpO1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9yZWFjdC1uby11bnVzZWQtc3RhdGUtaG9va1xuXG4gIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IHVzZVN0YXRlJDEoW10pO1xuICBjb25zdCByZWNvaWxWYWx1ZXNVc2VkID0gdXNlUmVmJDQobmV3IFNldCgpKTtcbiAgcmVjb2lsVmFsdWVzVXNlZC5jdXJyZW50ID0gbmV3IFNldCgpOyAvLyBUcmFjayB0aGUgUmVjb2lsVmFsdWVzIHVzZWQganVzdCBkdXJpbmcgdGhpcyByZW5kZXJcblxuICBjb25zdCBwcmV2aW91c1N1YnNjcmlwdGlvbnMgPSB1c2VSZWYkNChuZXcgU2V0KCkpO1xuICBjb25zdCBzdWJzY3JpcHRpb25zID0gdXNlUmVmJDQobmV3IE1hcCgpKTtcbiAgY29uc3QgdW5zdWJzY3JpYmVGcm9tID0gdXNlQ2FsbGJhY2skMShrZXkgPT4ge1xuICAgIGNvbnN0IHN1YiA9IHN1YnNjcmlwdGlvbnMuY3VycmVudC5nZXQoa2V5KTtcblxuICAgIGlmIChzdWIpIHtcbiAgICAgIHN1Yi5yZWxlYXNlKCk7XG4gICAgICBzdWJzY3JpcHRpb25zLmN1cnJlbnQuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9LCBbc3Vic2NyaXB0aW9uc10pO1xuICBjb25zdCB1cGRhdGVTdGF0ZSA9IHVzZUNhbGxiYWNrJDEoKF9zdGF0ZSwga2V5KSA9PiB7XG4gICAgaWYgKHN1YnNjcmlwdGlvbnMuY3VycmVudC5oYXMoa2V5KSkge1xuICAgICAgZm9yY2VVcGRhdGUoW10pO1xuICAgIH1cbiAgfSwgW10pOyAvLyBFZmZlY3QgdG8gYWRkL3JlbW92ZSBzdWJzY3JpcHRpb25zIGFzIG5vZGVzIGFyZSB1c2VkXG5cbiAgdXNlRWZmZWN0JDMoKCkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcbiAgICBSZWNvaWxfZGlmZmVyZW5jZVNldHMocmVjb2lsVmFsdWVzVXNlZC5jdXJyZW50LCBwcmV2aW91c1N1YnNjcmlwdGlvbnMuY3VycmVudCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKHN1YnNjcmlwdGlvbnMuY3VycmVudC5oYXMoa2V5KSkge1xuICAgICAgICBSZWNvaWxfZXhwZWN0YXRpb25WaW9sYXRpb24oYERvdWJsZSBzdWJzY3JpcHRpb24gdG8gUmVjb2lsVmFsdWUgXCIke2tleX1cImApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN1YiA9IHN1YnNjcmliZVRvUmVjb2lsVmFsdWUkMShzdG9yZSwgbmV3IEFic3RyYWN0UmVjb2lsVmFsdWUkMyhrZXkpLCBzdGF0ZSA9PiB1cGRhdGVTdGF0ZShzdGF0ZSwga2V5KSwgY29tcG9uZW50TmFtZSk7XG4gICAgICBzdWJzY3JpcHRpb25zLmN1cnJlbnQuc2V0KGtleSwgc3ViKTtcbiAgICAgIC8qKlxuICAgICAgICogU2luY2Ugd2UncmUgc3Vic2NyaWJpbmcgaW4gYW4gZWZmZWN0IHdlIG5lZWQgdG8gdXBkYXRlIHRvIHRoZSBsYXRlc3RcbiAgICAgICAqIHZhbHVlIG9mIHRoZSBhdG9tIHNpbmNlIGl0IG1heSBoYXZlIGNoYW5nZWQgc2luY2Ugd2UgcmVuZGVyZWQuIFdlIGNhblxuICAgICAgICogZ28gYWhlYWQgYW5kIGRvIHRoYXQgbm93LCB1bmxlc3Mgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIGJhdGNoIC0tXG4gICAgICAgKiBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBkbyBpdCBhdCB0aGUgZW5kIG9mIHRoZSBiYXRjaCwgZHVlIHRvIHRoZVxuICAgICAgICogZm9sbG93aW5nIGVkZ2UgY2FzZTogU3VwcG9zZSBhbiBhdG9tIGlzIHVwZGF0ZWQgaW4gYW5vdGhlciB1c2VFZmZlY3RcbiAgICAgICAqIG9mIHRoaXMgc2FtZSBjb21wb25lbnQuIFRoZW4gdGhlIGZvbGxvd2luZyBzZXF1ZW5jZSBvZiBldmVudHMgb2NjdXI6XG4gICAgICAgKiAxLiBBdG9tIGlzIHVwZGF0ZWQgYW5kIHN1YnMgZmlyZWQgKGJ1dCB3ZSBtYXkgbm90IGJlIHN1YnNjcmliZWRcbiAgICAgICAqICAgIHlldCBkZXBlbmRpbmcgb24gb3JkZXIgb2YgZWZmZWN0cywgc28gd2UgbWlzcyB0aGlzKSBVcGRhdGVkIHZhbHVlXG4gICAgICAgKiAgICBpcyBub3cgaW4gbmV4dFRyZWUsIGJ1dCBub3QgY3VycmVudFRyZWUuXG4gICAgICAgKiAyLiBUaGlzIGVmZmVjdCBoYXBwZW5zLiBXZSBzdWJzY3JpYmUgYW5kIHVwZGF0ZS5cbiAgICAgICAqIDMuIEZyb20gdGhlIHVwZGF0ZSB3ZSByZS1yZW5kZXIgYW5kIHJlYWQgY3VycmVudFRyZWUsIHdpdGggb2xkIHZhbHVlLlxuICAgICAgICogNC4gQmF0Y2hlcidzIGVmZmVjdCBzZXRzIGN1cnJlbnRUcmVlIHRvIG5leHRUcmVlLlxuICAgICAgICogSW4gdGhpcyBzZXF1ZW5jZSB3ZSBtaXNzIHRoZSB1cGRhdGUuIFRvIGF2b2lkIHRoYXQsIGFkZCB0aGUgdXBkYXRlXG4gICAgICAgKiB0byBxdWV1ZWRDb21wb25lbnRDYWxsYmFjayBpZiBhIGJhdGNoIGlzIGluIHByb2dyZXNzLlxuICAgICAgICovXG4gICAgICAvLyBGSVhNRSBkZWxldGUgcXVldWVkQ29tcG9uZW50Q2FsbGJhY2tzX0RFUFJFQ0FURUQgd2hlbiBkZWxldGluZyB1c2VJbnRlcmZhY2UuXG5cbiAgICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgaWYgKHN0YXRlLm5leHRUcmVlKSB7XG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkucXVldWVkQ29tcG9uZW50Q2FsbGJhY2tzX0RFUFJFQ0FURUQucHVzaCgoKSA9PiB7XG4gICAgICAgICAgdXBkYXRlU3RhdGUoc3RvcmUuZ2V0U3RhdGUoKSwga2V5KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVTdGF0ZShzdG9yZS5nZXRTdGF0ZSgpLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFJlY29pbF9kaWZmZXJlbmNlU2V0cyhwcmV2aW91c1N1YnNjcmlwdGlvbnMuY3VycmVudCwgcmVjb2lsVmFsdWVzVXNlZC5jdXJyZW50KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICB1bnN1YnNjcmliZUZyb20oa2V5KTtcbiAgICB9KTtcbiAgICBwcmV2aW91c1N1YnNjcmlwdGlvbnMuY3VycmVudCA9IHJlY29pbFZhbHVlc1VzZWQuY3VycmVudDtcbiAgfSk7IC8vIEVmZmVjdCB0byB1bnN1YnNjcmliZSBmcm9tIGFsbCB3aGVuIHVubW91bnRpbmdcblxuICB1c2VFZmZlY3QkMygoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudFN1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zLmN1cnJlbnQ7IC8vIFJlc3RvcmUgc3Vic2NyaXB0aW9ucyB0aGF0IHdlcmUgY2xlYXJlZCBkdWUgdG8gU3RyaWN0TW9kZSBydW5uaW5nIHRoaXMgZWZmZWN0IHR3aWNlXG5cbiAgICBSZWNvaWxfZGlmZmVyZW5jZVNldHMocmVjb2lsVmFsdWVzVXNlZC5jdXJyZW50LCBuZXcgU2V0KGN1cnJlbnRTdWJzY3JpcHRpb25zLmtleXMoKSkpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IHN1YiA9IHN1YnNjcmliZVRvUmVjb2lsVmFsdWUkMShzdG9yZVJlZi5jdXJyZW50LCBuZXcgQWJzdHJhY3RSZWNvaWxWYWx1ZSQzKGtleSksIHN0YXRlID0+IHVwZGF0ZVN0YXRlKHN0YXRlLCBrZXkpLCBjb21wb25lbnROYW1lKTtcbiAgICAgIGN1cnJlbnRTdWJzY3JpcHRpb25zLnNldChrZXksIHN1Yik7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IGN1cnJlbnRTdWJzY3JpcHRpb25zLmZvckVhY2goKF8sIGtleSkgPT4gdW5zdWJzY3JpYmVGcm9tKGtleSkpO1xuICB9LCBbY29tcG9uZW50TmFtZSwgc3RvcmVSZWYsIHVuc3Vic2NyaWJlRnJvbSwgdXBkYXRlU3RhdGVdKTtcbiAgcmV0dXJuIHVzZU1lbW8kMSgoKSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuICAgIGZ1bmN0aW9uIHVzZVNldFJlY29pbFN0YXRlKHJlY29pbFN0YXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VTZXRSZWNvaWxTdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3VmFsdWVPclVwZGF0ZXIgPT4ge1xuICAgICAgICBzZXRSZWNvaWxWYWx1ZSQyKHN0b3JlUmVmLmN1cnJlbnQsIHJlY29pbFN0YXRlLCBuZXdWYWx1ZU9yVXBkYXRlcik7XG4gICAgICB9O1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuXG5cbiAgICBmdW5jdGlvbiB1c2VSZXNldFJlY29pbFN0YXRlKHJlY29pbFN0YXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VSZXNldFJlY29pbFN0YXRlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoKSA9PiBzZXRSZWNvaWxWYWx1ZSQyKHN0b3JlUmVmLmN1cnJlbnQsIHJlY29pbFN0YXRlLCBERUZBVUxUX1ZBTFVFJDIpO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuXG5cbiAgICBmdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlKHJlY29pbFZhbHVlKSB7XG4gICAgICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWU7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSwgJ3VzZVJlY29pbFZhbHVlTG9hZGFibGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQuaGFzKHJlY29pbFZhbHVlLmtleSkpIHtcbiAgICAgICAgcmVjb2lsVmFsdWVzVXNlZC5jdXJyZW50ID0gc2V0QnlBZGRpbmdUb1NldCQyKHJlY29pbFZhbHVlc1VzZWQuY3VycmVudCwgcmVjb2lsVmFsdWUua2V5KTtcbiAgICAgIH0gLy8gVE9ETyBSZXN0b3JlIG9wdGltaXphdGlvbiB0byBtZW1vaXplIGxvb2t1cFxuXG5cbiAgICAgIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZVJlZi5jdXJyZW50LmdldFN0YXRlKCk7XG4gICAgICByZXR1cm4gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDIoc3RvcmVSZWYuY3VycmVudCwgcmVjb2lsVmFsdWUsIHJlYWN0TW9kZSQzKCkuZWFybHkgPyAoX3N0b3JlU3RhdGUkbmV4dFRyZWUgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmVTdGF0ZSRuZXh0VHJlZSAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbmV4dFRyZWUgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG5cblxuICAgIGZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlKHJlY29pbFZhbHVlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsICd1c2VSZWNvaWxWYWx1ZScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2FkYWJsZSA9IHVzZVJlY29pbFZhbHVlTG9hZGFibGUocmVjb2lsVmFsdWUpO1xuICAgICAgcmV0dXJuIGhhbmRsZUxvYWRhYmxlKGxvYWRhYmxlLCByZWNvaWxWYWx1ZSwgc3RvcmVSZWYpO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuXG5cbiAgICBmdW5jdGlvbiB1c2VSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlLCAndXNlUmVjb2lsU3RhdGUnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt1c2VSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSksIHVzZVNldFJlY29pbFN0YXRlKHJlY29pbFN0YXRlKV07XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG5cblxuICAgIGZ1bmN0aW9uIHVzZVJlY29pbFN0YXRlTG9hZGFibGUocmVjb2lsU3RhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlY29pbFN0YXRlTG9hZGFibGUnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlKHJlY29pbFN0YXRlKSwgdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0UmVjb2lsVmFsdWU6IHVzZVJlY29pbFZhbHVlLFxuICAgICAgZ2V0UmVjb2lsVmFsdWVMb2FkYWJsZTogdXNlUmVjb2lsVmFsdWVMb2FkYWJsZSxcbiAgICAgIGdldFJlY29pbFN0YXRlOiB1c2VSZWNvaWxTdGF0ZSxcbiAgICAgIGdldFJlY29pbFN0YXRlTG9hZGFibGU6IHVzZVJlY29pbFN0YXRlTG9hZGFibGUsXG4gICAgICBnZXRTZXRSZWNvaWxTdGF0ZTogdXNlU2V0UmVjb2lsU3RhdGUsXG4gICAgICBnZXRSZXNldFJlY29pbFN0YXRlOiB1c2VSZXNldFJlY29pbFN0YXRlXG4gICAgfTtcbiAgfSwgW3JlY29pbFZhbHVlc1VzZWQsIHN0b3JlUmVmXSk7XG59XG5cbmNvbnN0IHJlY29pbENvbXBvbmVudEdldFJlY29pbFZhbHVlQ291bnRfRk9SX1RFU1RJTkcgPSB7XG4gIGN1cnJlbnQ6IDBcbn07XG5cbmZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfU1lOQ19FWFRFUk5BTF9TVE9SRShyZWNvaWxWYWx1ZSkge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IFJlY29pbF91c2VDb21wb25lbnROYW1lKCk7XG4gIGNvbnN0IGdldFNuYXBzaG90ID0gdXNlQ2FsbGJhY2skMSgoKSA9PiB7XG4gICAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlMjtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHJlY29pbENvbXBvbmVudEdldFJlY29pbFZhbHVlQ291bnRfRk9SX1RFU1RJTkcuY3VycmVudCsrO1xuICAgIH1cblxuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcbiAgICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB0cmVlU3RhdGUgPSByZWFjdE1vZGUkMygpLmVhcmx5ID8gKF9zdG9yZVN0YXRlJG5leHRUcmVlMiA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlMiAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbmV4dFRyZWUyIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XG4gICAgY29uc3QgbG9hZGFibGUgPSBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMihzdG9yZSwgcmVjb2lsVmFsdWUsIHRyZWVTdGF0ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvYWRhYmxlLFxuICAgICAga2V5OiByZWNvaWxWYWx1ZS5rZXlcbiAgICB9O1xuICB9LCBbc3RvcmVSZWYsIHJlY29pbFZhbHVlXSk7IC8vIE1lbW9pemUgdGhlIHN0YXRlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHJlcmVuZGVyc1xuXG4gIGNvbnN0IG1lbW9pemVQcmV2aW91c1NuYXBzaG90ID0gdXNlQ2FsbGJhY2skMShnZXRTdGF0ZSA9PiB7XG4gICAgbGV0IHByZXZTdGF0ZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdmFyIF9wcmV2U3RhdGUsIF9wcmV2U3RhdGUyO1xuXG4gICAgICBjb25zdCBuZXh0U3RhdGUgPSBnZXRTdGF0ZSgpO1xuXG4gICAgICBpZiAoKF9wcmV2U3RhdGUgPSBwcmV2U3RhdGUpICE9PSBudWxsICYmIF9wcmV2U3RhdGUgIT09IHZvaWQgMCAmJiBfcHJldlN0YXRlLmxvYWRhYmxlLmlzKG5leHRTdGF0ZS5sb2FkYWJsZSkgJiYgKChfcHJldlN0YXRlMiA9IHByZXZTdGF0ZSkgPT09IG51bGwgfHwgX3ByZXZTdGF0ZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wcmV2U3RhdGUyLmtleSkgPT09IG5leHRTdGF0ZS5rZXkpIHtcbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZTtcbiAgICAgIH1cblxuICAgICAgcHJldlN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IGdldE1lbW9pemVkU25hcHNob3QgPSB1c2VNZW1vJDEoKCkgPT4gbWVtb2l6ZVByZXZpb3VzU25hcHNob3QoZ2V0U25hcHNob3QpLCBbZ2V0U25hcHNob3QsIG1lbW9pemVQcmV2aW91c1NuYXBzaG90XSk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHVzZUNhbGxiYWNrJDEobm90aWZ5ID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSQxKHN0b3JlLCByZWNvaWxWYWx1ZSwgbm90aWZ5LCBjb21wb25lbnROYW1lKTtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uLnJlbGVhc2U7XG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsVmFsdWUsIGNvbXBvbmVudE5hbWVdKTtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlJDEoc3Vic2NyaWJlLCBnZXRNZW1vaXplZFNuYXBzaG90LCAvLyBnZXRTbmFwc2hvdCgpXG4gIGdldE1lbW9pemVkU25hcHNob3QgLy8gZ2V0U2VydmVyU25hcHNob3QoKSBmb3IgU1NSIHN1cHBvcnRcbiAgKS5sb2FkYWJsZTtcbn1cblxuZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9NVVRBQkxFX1NPVVJDRShyZWNvaWxWYWx1ZSkge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcbiAgY29uc3QgZ2V0TG9hZGFibGUgPSB1c2VDYWxsYmFjayQxKCgpID0+IHtcbiAgICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWUzO1xuXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHRyZWVTdGF0ZSA9IHJlYWN0TW9kZSQzKCkuZWFybHkgPyAoX3N0b3JlU3RhdGUkbmV4dFRyZWUzID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkbmV4dFRyZWUzICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZTMgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZTtcbiAgICByZXR1cm4gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDIoc3RvcmUsIHJlY29pbFZhbHVlLCB0cmVlU3RhdGUpO1xuICB9LCBbc3RvcmVSZWYsIHJlY29pbFZhbHVlXSk7XG4gIGNvbnN0IGdldExvYWRhYmxlV2l0aFRlc3RpbmcgPSB1c2VDYWxsYmFjayQxKCgpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICByZWNvaWxDb21wb25lbnRHZXRSZWNvaWxWYWx1ZUNvdW50X0ZPUl9URVNUSU5HLmN1cnJlbnQrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0TG9hZGFibGUoKTtcbiAgfSwgW2dldExvYWRhYmxlXSk7XG4gIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBSZWNvaWxfdXNlQ29tcG9uZW50TmFtZSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSB1c2VDYWxsYmFjayQxKChfc3RvcmVTdGF0ZSwgbm90aWZ5KSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVjb2lsVmFsdWUkMShzdG9yZSwgcmVjb2lsVmFsdWUsICgpID0+IHtcbiAgICAgIGlmICghUmVjb2lsX2dreCgncmVjb2lsX3N1cHByZXNzX3JlcmVuZGVyX2luX2NhbGxiYWNrJykpIHtcbiAgICAgICAgcmV0dXJuIG5vdGlmeSgpO1xuICAgICAgfSAvLyBPbmx5IHJlLXJlbmRlciBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQuXG4gICAgICAvLyBUaGlzIHdpbGwgZXZhbHVhdGUgdGhlIGF0b20vc2VsZWN0b3Igbm93IGFzIHdlbGwgYXMgd2hlbiB0aGVcbiAgICAgIC8vIGNvbXBvbmVudCByZW5kZXJzLCBidXQgdGhhdCBtYXkgaGVscCB3aXRoIHByZWZldGNoaW5nLlxuXG5cbiAgICAgIGNvbnN0IG5ld0xvYWRhYmxlID0gZ2V0TG9hZGFibGUoKTtcblxuICAgICAgaWYgKCFwcmV2TG9hZGFibGVSZWYuY3VycmVudC5pcyhuZXdMb2FkYWJsZSkpIHtcbiAgICAgICAgbm90aWZ5KCk7XG4gICAgICB9IC8vIElmIHRoZSBjb21wb25lbnQgaXMgc3VzcGVuZGVkIHRoZW4gdGhlIGVmZmVjdCBzZXR0aW5nIHByZXZMb2FkYWJsZVJlZlxuICAgICAgLy8gd2lsbCBub3QgcnVuLiAgU28sIHNldCB0aGUgcHJldmlvdXMgdmFsdWUgaGVyZSB3aGVuIGl0cyBzdWJzY3JpcHRpb25cbiAgICAgIC8vIGlzIGZpcmVkIHRvIHdha2UgaXQgdXAuICBXZSBjYW4ndCBqdXN0IHJlbHkgb24gdGhpcywgdGhvdWdoLCBiZWNhdXNlXG4gICAgICAvLyB0aGlzIG9ubHkgZXhlY3V0ZXMgd2hlbiBhbiBhdG9tL3NlbGVjdG9yIGlzIGRpcnR5IGFuZCB0aGUgYXRvbS9zZWxlY3RvclxuICAgICAgLy8gcGFzc2VkIHRvIHRoZSBob29rIGNhbiBkeW5hbWljYWxseSBjaGFuZ2UuXG5cblxuICAgICAgcHJldkxvYWRhYmxlUmVmLmN1cnJlbnQgPSBuZXdMb2FkYWJsZTtcbiAgICB9LCBjb21wb25lbnROYW1lKTtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uLnJlbGVhc2U7XG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsVmFsdWUsIGNvbXBvbmVudE5hbWUsIGdldExvYWRhYmxlXSk7XG4gIGNvbnN0IHNvdXJjZSA9IHVzZVJlY29pbE11dGFibGVTb3VyY2UkMSgpO1xuXG4gIGlmIChzb3VyY2UgPT0gbnVsbCkge1xuICAgIHRocm93IFJlY29pbF9lcnIoJ1JlY29pbCBob29rcyBtdXN0IGJlIHVzZWQgaW4gY29tcG9uZW50cyBjb250YWluZWQgd2l0aGluIGEgPFJlY29pbFJvb3Q+IGNvbXBvbmVudC4nKTtcbiAgfVxuXG4gIGNvbnN0IGxvYWRhYmxlID0gdXNlTXV0YWJsZVNvdXJjZSQxKHNvdXJjZSwgZ2V0TG9hZGFibGVXaXRoVGVzdGluZywgc3Vic2NyaWJlKTtcbiAgY29uc3QgcHJldkxvYWRhYmxlUmVmID0gdXNlUmVmJDQobG9hZGFibGUpO1xuICB1c2VFZmZlY3QkMygoKSA9PiB7XG4gICAgcHJldkxvYWRhYmxlUmVmLmN1cnJlbnQgPSBsb2FkYWJsZTtcbiAgfSk7XG4gIHJldHVybiBsb2FkYWJsZTtcbn1cblxuZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlQocmVjb2lsVmFsdWUpIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XG4gIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBSZWNvaWxfdXNlQ29tcG9uZW50TmFtZSgpOyAvLyBBY2Nlc3NvcnMgdG8gZ2V0IHRoZSBjdXJyZW50IHN0YXRlXG5cbiAgY29uc3QgZ2V0TG9hZGFibGUgPSB1c2VDYWxsYmFjayQxKCgpID0+IHtcbiAgICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWU0O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmVjb2lsQ29tcG9uZW50R2V0UmVjb2lsVmFsdWVDb3VudF9GT1JfVEVTVElORy5jdXJyZW50Kys7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHRyZWVTdGF0ZSA9IHJlYWN0TW9kZSQzKCkuZWFybHkgPyAoX3N0b3JlU3RhdGUkbmV4dFRyZWU0ID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkbmV4dFRyZWU0ICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZTQgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZTtcbiAgICByZXR1cm4gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDIoc3RvcmUsIHJlY29pbFZhbHVlLCB0cmVlU3RhdGUpO1xuICB9LCBbc3RvcmVSZWYsIHJlY29pbFZhbHVlXSk7XG4gIGNvbnN0IGdldFN0YXRlID0gdXNlQ2FsbGJhY2skMSgoKSA9PiAoe1xuICAgIGxvYWRhYmxlOiBnZXRMb2FkYWJsZSgpLFxuICAgIGtleTogcmVjb2lsVmFsdWUua2V5XG4gIH0pLCBbZ2V0TG9hZGFibGUsIHJlY29pbFZhbHVlLmtleV0pOyAvLyBNZW1vaXplIHN0YXRlIHNuYXBzaG90c1xuXG4gIGNvbnN0IHVwZGF0ZVN0YXRlID0gdXNlQ2FsbGJhY2skMShwcmV2U3RhdGUgPT4ge1xuICAgIGNvbnN0IG5leHRTdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgcmV0dXJuIHByZXZTdGF0ZS5sb2FkYWJsZS5pcyhuZXh0U3RhdGUubG9hZGFibGUpICYmIHByZXZTdGF0ZS5rZXkgPT09IG5leHRTdGF0ZS5rZXkgPyBwcmV2U3RhdGUgOiBuZXh0U3RhdGU7XG4gIH0sIFtnZXRTdGF0ZV0pOyAvLyBTdWJzY3JpYmUgdG8gUmVjb2lsIHN0YXRlIGNoYW5nZXNcblxuICB1c2VFZmZlY3QkMygoKSA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSQxKHN0b3JlUmVmLmN1cnJlbnQsIHJlY29pbFZhbHVlLCBfc3RhdGUgPT4ge1xuICAgICAgc2V0U3RhdGUodXBkYXRlU3RhdGUpO1xuICAgIH0sIGNvbXBvbmVudE5hbWUpOyAvLyBVcGRhdGUgc3RhdGUgaW4gY2FzZSB3ZSBhcmUgdXNpbmcgYSBkaWZmZXJlbnQga2V5XG5cbiAgICBzZXRTdGF0ZSh1cGRhdGVTdGF0ZSk7XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbi5yZWxlYXNlO1xuICB9LCBbY29tcG9uZW50TmFtZSwgcmVjb2lsVmFsdWUsIHN0b3JlUmVmLCB1cGRhdGVTdGF0ZV0pOyAvLyBHZXQgdGhlIGN1cnJlbnQgc3RhdGVcblxuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlJDEoZ2V0U3RhdGUpOyAvLyBJZiB3ZSBjaGFuZ2VkIGtleXMsIHRoZW4gcmV0dXJuIHRoZSBzdGF0ZSBmb3IgdGhlIG5ldyBrZXkuXG4gIC8vIFRoaXMgaXMgaW1wb3J0YW50IGluIGNhc2UgdGhlIG9sZCBrZXkgd291bGQgY2F1c2UgdGhlIGNvbXBvbmVudCB0byBzdXNwZW5kLlxuICAvLyBXZSBkb24ndCBoYXZlIHRvIHNldCB0aGUgbmV3IHN0YXRlIGhlcmUgc2luY2UgdGhlIHN1YnNjcmliaW5nIGVmZmVjdCBhYm92ZVxuICAvLyB3aWxsIGRvIHRoYXQuXG5cbiAgcmV0dXJuIHN0YXRlLmtleSAhPT0gcmVjb2lsVmFsdWUua2V5ID8gZ2V0U3RhdGUoKS5sb2FkYWJsZSA6IHN0YXRlLmxvYWRhYmxlO1xufVxuXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX0xFR0FDWShyZWNvaWxWYWx1ZSkge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9yZWFjdC1uby11bnVzZWQtc3RhdGUtaG9va1xuXG4gIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IHVzZVN0YXRlJDEoW10pO1xuICBjb25zdCBjb21wb25lbnROYW1lID0gUmVjb2lsX3VzZUNvbXBvbmVudE5hbWUoKTtcbiAgY29uc3QgZ2V0TG9hZGFibGUgPSB1c2VDYWxsYmFjayQxKCgpID0+IHtcbiAgICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWU1O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmVjb2lsQ29tcG9uZW50R2V0UmVjb2lsVmFsdWVDb3VudF9GT1JfVEVTVElORy5jdXJyZW50Kys7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHRyZWVTdGF0ZSA9IHJlYWN0TW9kZSQzKCkuZWFybHkgPyAoX3N0b3JlU3RhdGUkbmV4dFRyZWU1ID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkbmV4dFRyZWU1ICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZTUgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZTtcbiAgICByZXR1cm4gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDIoc3RvcmUsIHJlY29pbFZhbHVlLCB0cmVlU3RhdGUpO1xuICB9LCBbc3RvcmVSZWYsIHJlY29pbFZhbHVlXSk7XG4gIGNvbnN0IGxvYWRhYmxlID0gZ2V0TG9hZGFibGUoKTtcbiAgY29uc3QgcHJldkxvYWRhYmxlUmVmID0gdXNlUmVmJDQobG9hZGFibGUpO1xuICB1c2VFZmZlY3QkMygoKSA9PiB7XG4gICAgcHJldkxvYWRhYmxlUmVmLmN1cnJlbnQgPSBsb2FkYWJsZTtcbiAgfSk7XG4gIHVzZUVmZmVjdCQzKCgpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSQxKHN0b3JlLCByZWNvaWxWYWx1ZSwgX3N0YXRlID0+IHtcbiAgICAgIHZhciBfcHJldkxvYWRhYmxlUmVmJGN1cnI7XG5cbiAgICAgIGlmICghUmVjb2lsX2dreCgncmVjb2lsX3N1cHByZXNzX3JlcmVuZGVyX2luX2NhbGxiYWNrJykpIHtcbiAgICAgICAgcmV0dXJuIGZvcmNlVXBkYXRlKFtdKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3TG9hZGFibGUgPSBnZXRMb2FkYWJsZSgpO1xuXG4gICAgICBpZiAoISgoX3ByZXZMb2FkYWJsZVJlZiRjdXJyID0gcHJldkxvYWRhYmxlUmVmLmN1cnJlbnQpICE9PSBudWxsICYmIF9wcmV2TG9hZGFibGVSZWYkY3VyciAhPT0gdm9pZCAwICYmIF9wcmV2TG9hZGFibGVSZWYkY3Vyci5pcyhuZXdMb2FkYWJsZSkpKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdXG4gICAgICAgIGZvcmNlVXBkYXRlKG5ld0xvYWRhYmxlKTtcbiAgICAgIH1cblxuICAgICAgcHJldkxvYWRhYmxlUmVmLmN1cnJlbnQgPSBuZXdMb2FkYWJsZTtcbiAgICB9LCBjb21wb25lbnROYW1lKTtcbiAgICAvKipcbiAgICAgKiBTaW5jZSB3ZSdyZSBzdWJzY3JpYmluZyBpbiBhbiBlZmZlY3Qgd2UgbmVlZCB0byB1cGRhdGUgdG8gdGhlIGxhdGVzdFxuICAgICAqIHZhbHVlIG9mIHRoZSBhdG9tIHNpbmNlIGl0IG1heSBoYXZlIGNoYW5nZWQgc2luY2Ugd2UgcmVuZGVyZWQuIFdlIGNhblxuICAgICAqIGdvIGFoZWFkIGFuZCBkbyB0aGF0IG5vdywgdW5sZXNzIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSBiYXRjaCAtLVxuICAgICAqIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkIGRvIGl0IGF0IHRoZSBlbmQgb2YgdGhlIGJhdGNoLCBkdWUgdG8gdGhlXG4gICAgICogZm9sbG93aW5nIGVkZ2UgY2FzZTogU3VwcG9zZSBhbiBhdG9tIGlzIHVwZGF0ZWQgaW4gYW5vdGhlciB1c2VFZmZlY3RcbiAgICAgKiBvZiB0aGlzIHNhbWUgY29tcG9uZW50LiBUaGVuIHRoZSBmb2xsb3dpbmcgc2VxdWVuY2Ugb2YgZXZlbnRzIG9jY3VyOlxuICAgICAqIDEuIEF0b20gaXMgdXBkYXRlZCBhbmQgc3VicyBmaXJlZCAoYnV0IHdlIG1heSBub3QgYmUgc3Vic2NyaWJlZFxuICAgICAqICAgIHlldCBkZXBlbmRpbmcgb24gb3JkZXIgb2YgZWZmZWN0cywgc28gd2UgbWlzcyB0aGlzKSBVcGRhdGVkIHZhbHVlXG4gICAgICogICAgaXMgbm93IGluIG5leHRUcmVlLCBidXQgbm90IGN1cnJlbnRUcmVlLlxuICAgICAqIDIuIFRoaXMgZWZmZWN0IGhhcHBlbnMuIFdlIHN1YnNjcmliZSBhbmQgdXBkYXRlLlxuICAgICAqIDMuIEZyb20gdGhlIHVwZGF0ZSB3ZSByZS1yZW5kZXIgYW5kIHJlYWQgY3VycmVudFRyZWUsIHdpdGggb2xkIHZhbHVlLlxuICAgICAqIDQuIEJhdGNoZXIncyBlZmZlY3Qgc2V0cyBjdXJyZW50VHJlZSB0byBuZXh0VHJlZS5cbiAgICAgKiBJbiB0aGlzIHNlcXVlbmNlIHdlIG1pc3MgdGhlIHVwZGF0ZS4gVG8gYXZvaWQgdGhhdCwgYWRkIHRoZSB1cGRhdGVcbiAgICAgKiB0byBxdWV1ZWRDb21wb25lbnRDYWxsYmFjayBpZiBhIGJhdGNoIGlzIGluIHByb2dyZXNzLlxuICAgICAqL1xuXG4gICAgaWYgKHN0b3JlU3RhdGUubmV4dFRyZWUpIHtcbiAgICAgIHN0b3JlLmdldFN0YXRlKCkucXVldWVkQ29tcG9uZW50Q2FsbGJhY2tzX0RFUFJFQ0FURUQucHVzaCgoKSA9PiB7XG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdXG4gICAgICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgZm9yY2VVcGRhdGUoW10pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfcHJldkxvYWRhYmxlUmVmJGN1cnIyO1xuXG4gICAgICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9zdXBwcmVzc19yZXJlbmRlcl9pbl9jYWxsYmFjaycpKSB7XG4gICAgICAgIHJldHVybiBmb3JjZVVwZGF0ZShbXSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld0xvYWRhYmxlID0gZ2V0TG9hZGFibGUoKTtcblxuICAgICAgaWYgKCEoKF9wcmV2TG9hZGFibGVSZWYkY3VycjIgPSBwcmV2TG9hZGFibGVSZWYuY3VycmVudCkgIT09IG51bGwgJiYgX3ByZXZMb2FkYWJsZVJlZiRjdXJyMiAhPT0gdm9pZCAwICYmIF9wcmV2TG9hZGFibGVSZWYkY3VycjIuaXMobmV3TG9hZGFibGUpKSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXVxuICAgICAgICBmb3JjZVVwZGF0ZShuZXdMb2FkYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbmV3TG9hZGFibGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbi5yZWxlYXNlO1xuICB9LCBbY29tcG9uZW50TmFtZSwgZ2V0TG9hZGFibGUsIHJlY29pbFZhbHVlLCBzdG9yZVJlZl0pO1xuICByZXR1cm4gbG9hZGFibGU7XG59XG4vKipcbiAgTGlrZSB1c2VSZWNvaWxWYWx1ZSgpLCBidXQgZWl0aGVyIHJldHVybnMgdGhlIHZhbHVlIGlmIGF2YWlsYWJsZSBvclxuICBqdXN0IHVuZGVmaW5lZCBpZiBub3QgYXZhaWxhYmxlIGZvciBhbnkgcmVhc29uLCBzdWNoIGFzIHBlbmRpbmcgb3IgZXJyb3IuXG4qL1xuXG5cbmZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlTG9hZGFibGUocmVjb2lsVmFsdWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsICd1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlJyk7XG4gIH1cblxuICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvcmVhY3QtaG9va3NcbiAgICBSZWNvaWxfdXNlUmV0YWluKHJlY29pbFZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgVFJBTlNJVElPTl9TVVBQT1JUOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVCxcbiAgICAvLyBSZWNvaWwgd2lsbCBhdHRlbXAgdG8gZGV0ZWN0IGlmIGB1c2VTeW5jRXh0ZXJuYWxTdG9yZSgpYCBpcyBzdXBwb3J0ZWQgd2l0aFxuICAgIC8vIGByZWFjdE1vZGUoKWAgYmVmb3JlIGNhbGxpbmcgaXQuICBIb3dldmVyLCBzb21ldGltZXMgdGhlIGhvc3QgUmVhY3RcbiAgICAvLyBlbnZpcm9ubWVudCBzdXBwb3J0cyBpdCBidXQgdXNlcyBhZGRpdGlvbmFsIFJlYWN0IHJlbmRlcmVycyAoc3VjaCBhcyB3aXRoXG4gICAgLy8gYHJlYWN0LXRocmVlLWZpYmVyYCkgd2hpY2ggZG8gbm90LiAgV2hpbGUgdGhpcyBpcyB0ZWNobmljYWxseSBhIHVzZXIgaXNzdWVcbiAgICAvLyBieSB1c2luZyBhIHJlbmRlcmVyIHdpdGggUmVhY3QgMTgrIHRoYXQgZG9lc24ndCBmdWxseSBzdXBwb3J0IFJlYWN0IDE4IHdlXG4gICAgLy8gZG9uJ3Qgd2FudCB0byBicmVhayB1c2VycyBpZiBpdCBjYW4gYmUgYXZvaWRlZC4gQXMgdGhlIGN1cnJlbnQgcmVuZGVyZXIgY2FuXG4gICAgLy8gY2hhbmdlIGF0IHJ1bnRpbWUsIHdlIG5lZWQgdG8gZHluYW1pY2FsbHkgY2hlY2sgYW5kIGZhbGxiYWNrIGlmIG5lY2Vzc2FyeS5cbiAgICBTWU5DX0VYVEVSTkFMX1NUT1JFOiBjdXJyZW50UmVuZGVyZXJTdXBwb3J0c1VzZVN5bmNFeHRlcm5hbFN0b3JlJDEoKSA/IHVzZVJlY29pbFZhbHVlTG9hZGFibGVfU1lOQ19FWFRFUk5BTF9TVE9SRSA6IHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JULFxuICAgIE1VVEFCTEVfU09VUkNFOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX01VVEFCTEVfU09VUkNFLFxuICAgIExFR0FDWTogdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9MRUdBQ1lcbiAgfVtyZWFjdE1vZGUkMygpLm1vZGVdKHJlY29pbFZhbHVlKTtcbn1cbi8qKlxuICBSZXR1cm5zIHRoZSB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgUmVjb2lsVmFsdWUuXG4gIElmIHRoZSB2YWx1ZSBpcyBwZW5kaW5nLCBpdCB3aWxsIHRocm93IGEgUHJvbWlzZSB0byBzdXNwZW5kIHRoZSBjb21wb25lbnQsXG4gIGlmIHRoZSB2YWx1ZSBpcyBhbiBlcnJvciBpdCB3aWxsIHRocm93IGl0IGZvciB0aGUgbmVhcmVzdCBSZWFjdCBlcnJvciBib3VuZGFyeS5cbiAgVGhpcyB3aWxsIGFsc28gc3Vic2NyaWJlIHRoZSBjb21wb25lbnQgZm9yIGFueSB1cGRhdGVzIGluIHRoZSB2YWx1ZS5cbiAgKi9cblxuXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSwgJ3VzZVJlY29pbFZhbHVlJyk7XG4gIH1cblxuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcbiAgY29uc3QgbG9hZGFibGUgPSB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlKHJlY29pbFZhbHVlKTtcbiAgcmV0dXJuIGhhbmRsZUxvYWRhYmxlKGxvYWRhYmxlLCByZWNvaWxWYWx1ZSwgc3RvcmVSZWYpO1xufVxuLyoqXG4gIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFsbG93cyB0aGUgdmFsdWUgb2YgYSBSZWNvaWxTdGF0ZSB0byBiZSB1cGRhdGVkLCBidXQgZG9lc1xuICBub3Qgc3Vic2NyaWJlIHRoZSBjb21wb25lbnQgdG8gY2hhbmdlcyB0byB0aGF0IFJlY29pbFN0YXRlLlxuKi9cblxuXG5mdW5jdGlvbiB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVNldFJlY29pbFN0YXRlJyk7XG4gIH1cblxuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrJDEobmV3VmFsdWVPclVwZGF0ZXIgPT4ge1xuICAgIHNldFJlY29pbFZhbHVlJDIoc3RvcmVSZWYuY3VycmVudCwgcmVjb2lsU3RhdGUsIG5ld1ZhbHVlT3JVcGRhdGVyKTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxTdGF0ZV0pO1xufVxuLyoqXG4gIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVzZXQgdGhlIHZhbHVlIG9mIGEgUmVjb2lsU3RhdGUgdG8gaXRzIGRlZmF1bHRcbiovXG5cblxuZnVuY3Rpb24gdXNlUmVzZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlc2V0UmVjb2lsU3RhdGUnKTtcbiAgfVxuXG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2skMSgoKSA9PiB7XG4gICAgc2V0UmVjb2lsVmFsdWUkMihzdG9yZVJlZi5jdXJyZW50LCByZWNvaWxTdGF0ZSwgREVGQVVMVF9WQUxVRSQyKTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxTdGF0ZV0pO1xufVxuLyoqXG4gIEVxdWl2YWxlbnQgdG8gdXNlU3RhdGUoKS4gQWxsb3dzIHRoZSB2YWx1ZSBvZiB0aGUgUmVjb2lsU3RhdGUgdG8gYmUgcmVhZCBhbmQgd3JpdHRlbi5cbiAgU3Vic2VxdWVudCB1cGRhdGVzIHRvIHRoZSBSZWNvaWxTdGF0ZSB3aWxsIGNhdXNlIHRoZSBjb21wb25lbnQgdG8gcmUtcmVuZGVyLiBJZiB0aGVcbiAgUmVjb2lsU3RhdGUgaXMgcGVuZGluZywgdGhpcyB3aWxsIHN1c3BlbmQgdGhlIGNvbXBvbmVudCBhbmQgaW5pdGlhdGUgdGhlXG4gIHJldHJpZXZhbCBvZiB0aGUgdmFsdWUuIElmIGV2YWx1YXRpbmcgdGhlIFJlY29pbFN0YXRlIHJlc3VsdGVkIGluIGFuIGVycm9yLCB0aGlzIHdpbGxcbiAgdGhyb3cgdGhlIGVycm9yIHNvIHRoYXQgdGhlIG5lYXJlc3QgUmVhY3QgZXJyb3IgYm91bmRhcnkgY2FuIGNhdGNoIGl0LlxuKi9cblxuXG5mdW5jdGlvbiB1c2VSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlY29pbFN0YXRlJyk7XG4gIH1cblxuICByZXR1cm4gW3VzZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlKSwgdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpXTtcbn1cbi8qKlxuICBMaWtlIHVzZVJlY29pbFN0YXRlKCksIGJ1dCBkb2VzIG5vdCBjYXVzZSBTdXNwZW5zZSBvciBSZWFjdCBlcnJvciBoYW5kbGluZy4gUmV0dXJuc1xuICBhbiBvYmplY3QgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgUmVjb2lsU3RhdGUgaXMgYXZhaWxhYmxlLCBwZW5kaW5nLCBvclxuICB1bmF2YWlsYWJsZSBkdWUgdG8gYW4gZXJyb3IuXG4qL1xuXG5cbmZ1bmN0aW9uIHVzZVJlY29pbFN0YXRlTG9hZGFibGUocmVjb2lsU3RhdGUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlJyk7XG4gIH1cblxuICByZXR1cm4gW3VzZVJlY29pbFZhbHVlTG9hZGFibGUocmVjb2lsU3RhdGUpLCB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSldO1xufVxuXG5mdW5jdGlvbiB1c2VTZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXMoKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xuICByZXR1cm4gKHZhbHVlcywgdHJhbnNhY3Rpb25NZXRhZGF0YSA9IHt9KSA9PiB7XG4gICAgYmF0Y2hVcGRhdGVzJDIoKCkgPT4ge1xuICAgICAgc3RvcmVSZWYuY3VycmVudC5hZGRUcmFuc2FjdGlvbk1ldGFkYXRhKHRyYW5zYWN0aW9uTWV0YWRhdGEpO1xuICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUkMihzdG9yZVJlZi5jdXJyZW50LCBuZXcgQWJzdHJhY3RSZWNvaWxWYWx1ZSQzKGtleSksIHZhbHVlKSk7XG4gICAgfSk7XG4gIH07XG59XG4vKipcbiAqIEV4cGVyaW1lbnRhbCB2YXJpYW50cyBvZiBob29rcyB3aXRoIHN1cHBvcnQgZm9yIHVzZVRyYW5zaXRpb24oKVxuICovXG5cblxuZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUocmVjb2lsVmFsdWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsICd1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRScpO1xuXG4gICAgaWYgKCFyZWFjdE1vZGUkMygpLmVhcmx5KSB7XG4gICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ0F0dGVwbXQgdG8gdXNlIGEgaG9vayB3aXRoIFVOU1RBQkxFX1RSQU5TSVRJT05fU1VQUE9SVCBpbiBhIHJlbmRlcmluZyBtb2RlIGluY29tcGF0aWJsZSB3aXRoIGNvbmN1cnJlbnQgcmVuZGVyaW5nLiAgVHJ5IGVuYWJsaW5nIHRoZSByZWNvaWxfc3luY19leHRlcm5hbF9zdG9yZSBvciByZWNvaWxfdHJhbnNpdGlvbl9zdXBwb3J0IEdLcy4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvcmVhY3QtaG9va3NcbiAgICBSZWNvaWxfdXNlUmV0YWluKHJlY29pbFZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVChyZWNvaWxWYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRShyZWNvaWxWYWx1ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSwgJ3VzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRScpO1xuICB9XG5cbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XG4gIGNvbnN0IGxvYWRhYmxlID0gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUocmVjb2lsVmFsdWUpO1xuICByZXR1cm4gaGFuZGxlTG9hZGFibGUobG9hZGFibGUsIHJlY29pbFZhbHVlLCBzdG9yZVJlZik7XG59XG5cbmZ1bmN0aW9uIHVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRShyZWNvaWxTdGF0ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRScpO1xuICB9XG5cbiAgcmV0dXJuIFt1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUocmVjb2lsU3RhdGUpLCB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSldO1xufVxuXG52YXIgUmVjb2lsX0hvb2tzID0ge1xuICByZWNvaWxDb21wb25lbnRHZXRSZWNvaWxWYWx1ZUNvdW50X0ZPUl9URVNUSU5HLFxuICB1c2VSZWNvaWxJbnRlcmZhY2U6IHVzZVJlY29pbEludGVyZmFjZV9ERVBSRUNBVEVELFxuICB1c2VSZWNvaWxTdGF0ZSxcbiAgdXNlUmVjb2lsU3RhdGVMb2FkYWJsZSxcbiAgdXNlUmVjb2lsVmFsdWUsXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGUsXG4gIHVzZVJlc2V0UmVjb2lsU3RhdGUsXG4gIHVzZVNldFJlY29pbFN0YXRlLFxuICB1c2VTZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXMsXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFLFxuICB1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUsXG4gIHVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRVxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGEgbWFwIGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBrZXlzICsgdmFsdWVzIGZyb20gdGhlIG9yaWdpbmFsIG1hcCB3aGVyZVxuICogdGhlIGdpdmVuIGNhbGxiYWNrIHJldHVybmVkIHRydWUuXG4gKi9cblxuZnVuY3Rpb24gZmlsdGVyTWFwKG1hcCwgY2FsbGJhY2spIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcCkge1xuICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5KSkge1xuICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVjb2lsX2ZpbHRlck1hcCA9IGZpbHRlck1hcDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGEgc2V0IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSB2YWx1ZXMgZnJvbSB0aGUgb3JpZ2luYWwgc2V0IHdoZXJlXG4gKiB0aGUgZ2l2ZW4gY2FsbGJhY2sgcmV0dXJuZWQgdHJ1ZS5cbiAqL1xuXG5mdW5jdGlvbiBmaWx0ZXJTZXQoc2V0LCBjYWxsYmFjaykge1xuICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG5cbiAgZm9yIChjb25zdCB2YWx1ZSBvZiBzZXQpIHtcbiAgICBpZiAoY2FsbGJhY2sodmFsdWUpKSB7XG4gICAgICByZXN1bHQuYWRkKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVjb2lsX2ZpbHRlclNldCA9IGZpbHRlclNldDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiBtZXJnZU1hcHMoLi4ubWFwcykge1xuICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBtYXBzW2ldLmtleXMoKTtcbiAgICBsZXQgbmV4dEtleTtcblxuICAgIHdoaWxlICghKG5leHRLZXkgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgIC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLWNhbGxdIC0gbWFwL2l0ZXJhdG9yIGtub3dzIG5vdGhpbmcgYWJvdXQgZmxvdyB0eXBlc1xuICAgICAgcmVzdWx0LnNldChuZXh0S2V5LnZhbHVlLCBtYXBzW2ldLmdldChuZXh0S2V5LnZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFJlY29pbF9tZXJnZU1hcHMgPSBtZXJnZU1hcHM7XG5cbmNvbnN0IHtcbiAgYmF0Y2hVcGRhdGVzOiBiYXRjaFVwZGF0ZXMkM1xufSA9IFJlY29pbF9CYXRjaGluZztcblxuY29uc3Qge1xuICBERUZBVUxUX1ZBTFVFOiBERUZBVUxUX1ZBTFVFJDMsXG4gIGdldE5vZGU6IGdldE5vZGUkNCxcbiAgbm9kZXM6IG5vZGVzJDFcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkM1xufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5jb25zdCB7XG4gIEFic3RyYWN0UmVjb2lsVmFsdWU6IEFic3RyYWN0UmVjb2lsVmFsdWUkNCxcbiAgc2V0UmVjb2lsVmFsdWVMb2FkYWJsZTogc2V0UmVjb2lsVmFsdWVMb2FkYWJsZSQxXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5jb25zdCB7XG4gIFNVU1BFTlNFX1RJTUVPVVRfTVM6IFNVU1BFTlNFX1RJTUVPVVRfTVMkMlxufSA9IFJlY29pbF9SZXRlbnRpb247XG5cbmNvbnN0IHtcbiAgY2xvbmVTbmFwc2hvdDogY2xvbmVTbmFwc2hvdCQxXG59ID0gUmVjb2lsX1NuYXBzaG90JDE7XG5cbmNvbnN0IHtcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrJDIsXG4gIHVzZUVmZmVjdDogdXNlRWZmZWN0JDQsXG4gIHVzZVJlZjogdXNlUmVmJDUsXG4gIHVzZVN0YXRlOiB1c2VTdGF0ZSQyXG59ID0gcmVhY3Q7XG5cbmNvbnN0IHtcbiAgaXNTU1I6IGlzU1NSJDRcbn0gPSBSZWNvaWxfRW52aXJvbm1lbnQ7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiB1c2VUcmFuc2FjdGlvblN1YnNjcmlwdGlvbihjYWxsYmFjaykge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDMoKTtcbiAgdXNlRWZmZWN0JDQoKCkgPT4ge1xuICAgIGNvbnN0IHN1YiA9IHN0b3JlUmVmLmN1cnJlbnQuc3Vic2NyaWJlVG9UcmFuc2FjdGlvbnMoY2FsbGJhY2spO1xuICAgIHJldHVybiBzdWIucmVsZWFzZTtcbiAgfSwgW2NhbGxiYWNrLCBzdG9yZVJlZl0pO1xufVxuXG5mdW5jdGlvbiBleHRlcm5hbGx5VmlzaWJsZUF0b21WYWx1ZXNJblN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IGF0b21WYWx1ZXMgPSBzdGF0ZS5hdG9tVmFsdWVzLnRvTWFwKCk7XG4gIGNvbnN0IHBlcnNpc3RlZEF0b21Db250ZW50c1ZhbHVlcyA9IFJlY29pbF9tYXBNYXAoUmVjb2lsX2ZpbHRlck1hcChhdG9tVmFsdWVzLCAodiwgaykgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSBnZXROb2RlJDQoayk7XG4gICAgY29uc3QgcGVyc2lzdGVuY2UgPSBub2RlLnBlcnNpc3RlbmNlX1VOU1RBQkxFO1xuICAgIHJldHVybiBwZXJzaXN0ZW5jZSAhPSBudWxsICYmIHBlcnNpc3RlbmNlLnR5cGUgIT09ICdub25lJyAmJiB2LnN0YXRlID09PSAnaGFzVmFsdWUnO1xuICB9KSwgdiA9PiB2LmNvbnRlbnRzKTsgLy8gTWVyZ2UgaW4gbm9udmFsaWRhdGVkIGF0b21zOyB3ZSBtYXkgbm90IGhhdmUgZGVmcyBmb3IgdGhlbSBidXQgdGhleSB3aWxsXG4gIC8vIGFsbCBoYXZlIHBlcnNpc3RlbmNlIG9uIG9yIHRoZXkgd291bGRuJ3QgYmUgdGhlcmUgaW4gdGhlIGZpcnN0IHBsYWNlLlxuXG4gIHJldHVybiBSZWNvaWxfbWVyZ2VNYXBzKHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLnRvTWFwKCksIHBlcnNpc3RlZEF0b21Db250ZW50c1ZhbHVlcyk7XG59XG5cbi8qKlxuICBDYWxscyB0aGUgZ2l2ZW4gY2FsbGJhY2sgYWZ0ZXIgYW55IGF0b21zIGhhdmUgYmVlbiBtb2RpZmllZCBhbmQgdGhlIGNvbnNlcXVlbnRcbiAgY29tcG9uZW50IHJlLXJlbmRlcnMgaGF2ZSBiZWVuIGNvbW1pdHRlZC4gVGhpcyBpcyBpbnRlbmRlZCBmb3IgcGVyc2lzdGluZ1xuICB0aGUgdmFsdWVzIG9mIHRoZSBhdG9tcyB0byBzdG9yYWdlLiBUaGUgc3RvcmVkIHZhbHVlcyBjYW4gdGhlbiBiZSByZXN0b3JlZFxuICB1c2luZyB0aGUgdXNlU2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzIGhvb2suXG5cbiAgVGhlIGNhbGxiYWNrIHJlY2VpdmVzIHRoZSBmb2xsb3dpbmcgaW5mbzpcblxuICBhdG9tVmFsdWVzOiBUaGUgY3VycmVudCB2YWx1ZSBvZiBldmVyeSBhdG9tIHRoYXQgaXMgYm90aCBwZXJzaXN0YWJsZSAocGVyc2lzdGVuY2VcbiAgICAgICAgICAgICAgdHlwZSBub3Qgc2V0IHRvICdub25lJykgYW5kIHdob3NlIHZhbHVlIGlzIGF2YWlsYWJsZSAobm90IGluIGFuXG4gICAgICAgICAgICAgIGVycm9yIG9yIGxvYWRpbmcgc3RhdGUpLlxuXG4gIHByZXZpb3VzQXRvbVZhbHVlczogVGhlIHZhbHVlIG9mIGV2ZXJ5IHBlcnNpc3RhYmxlIGFuZCBhdmFpbGFibGUgYXRvbSBiZWZvcmVcbiAgICAgICAgICAgICAgIHRoZSB0cmFuc2FjdGlvbiBiZWdhbi5cblxuICBhdG9tSW5mbzogQSBtYXAgY29udGFpbmluZyB0aGUgcGVyc2lzdGVuY2Ugc2V0dGluZ3MgZm9yIGVhY2ggYXRvbS4gRXZlcnkga2V5XG4gICAgICAgICAgICB0aGF0IGV4aXN0cyBpbiBhdG9tVmFsdWVzIHdpbGwgYWxzbyBleGlzdCBpbiBhdG9tSW5mby5cblxuICBtb2RpZmllZEF0b21zOiBUaGUgc2V0IG9mIGF0b21zIHRoYXQgd2VyZSB3cml0dGVuIHRvIGR1cmluZyB0aGUgdHJhbnNhY3Rpb24uXG5cbiAgdHJhbnNhY3Rpb25NZXRhZGF0YTogQXJiaXRyYXJ5IGluZm9ybWF0aW9uIHRoYXQgd2FzIGFkZGVkIHZpYSB0aGVcbiAgICAgICAgICB1c2VTZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXMgaG9vay4gVXNlZnVsIGZvciBpZ25vcmluZyB0aGUgdXNlU2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzXG4gICAgICAgICAgdHJhbnNhY3Rpb24sIHRvIGF2b2lkIGxvb3BzLlxuKi9cbmZ1bmN0aW9uIHVzZVRyYW5zYWN0aW9uT2JzZXJ2YXRpb25fREVQUkVDQVRFRChjYWxsYmFjaykge1xuICB1c2VUcmFuc2FjdGlvblN1YnNjcmlwdGlvbih1c2VDYWxsYmFjayQyKHN0b3JlID0+IHtcbiAgICBsZXQgcHJldmlvdXNUcmVlID0gc3RvcmUuZ2V0U3RhdGUoKS5wcmV2aW91c1RyZWU7XG4gICAgY29uc3QgY3VycmVudFRyZWUgPSBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlO1xuXG4gICAgaWYgKCFwcmV2aW91c1RyZWUpIHtcbiAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignVHJhbnNhY3Rpb24gc3Vic2NyaWJlcnMgbm90aWZpZWQgd2l0aG91dCBhIHByZXZpb3VzIHRyZWUgYmVpbmcgcHJlc2VudCAtLSB0aGlzIGlzIGEgYnVnIGluIFJlY29pbCcpO1xuICAgICAgcHJldmlvdXNUcmVlID0gc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZTsgLy8gYXR0ZW1wdCB0byB0cnVuZGxlIG9uXG4gICAgfVxuXG4gICAgY29uc3QgYXRvbVZhbHVlcyA9IGV4dGVybmFsbHlWaXNpYmxlQXRvbVZhbHVlc0luU3RhdGUoY3VycmVudFRyZWUpO1xuICAgIGNvbnN0IHByZXZpb3VzQXRvbVZhbHVlcyA9IGV4dGVybmFsbHlWaXNpYmxlQXRvbVZhbHVlc0luU3RhdGUocHJldmlvdXNUcmVlKTtcbiAgICBjb25zdCBhdG9tSW5mbyA9IFJlY29pbF9tYXBNYXAobm9kZXMkMSwgbm9kZSA9PiB7XG4gICAgICB2YXIgX25vZGUkcGVyc2lzdGVuY2VfVU5TLCBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMyLCBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMzLCBfbm9kZSRwZXJzaXN0ZW5jZV9VTlM0O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwZXJzaXN0ZW5jZV9VTlNUQUJMRToge1xuICAgICAgICAgIHR5cGU6IChfbm9kZSRwZXJzaXN0ZW5jZV9VTlMgPSAoX25vZGUkcGVyc2lzdGVuY2VfVU5TMiA9IG5vZGUucGVyc2lzdGVuY2VfVU5TVEFCTEUpID09PSBudWxsIHx8IF9ub2RlJHBlcnNpc3RlbmNlX1VOUzIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJHBlcnNpc3RlbmNlX1VOUzIudHlwZSkgIT09IG51bGwgJiYgX25vZGUkcGVyc2lzdGVuY2VfVU5TICE9PSB2b2lkIDAgPyBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMgOiAnbm9uZScsXG4gICAgICAgICAgYmFja0J1dHRvbjogKF9ub2RlJHBlcnNpc3RlbmNlX1VOUzMgPSAoX25vZGUkcGVyc2lzdGVuY2VfVU5TNCA9IG5vZGUucGVyc2lzdGVuY2VfVU5TVEFCTEUpID09PSBudWxsIHx8IF9ub2RlJHBlcnNpc3RlbmNlX1VOUzQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJHBlcnNpc3RlbmNlX1VOUzQuYmFja0J1dHRvbikgIT09IG51bGwgJiYgX25vZGUkcGVyc2lzdGVuY2VfVU5TMyAhPT0gdm9pZCAwID8gX25vZGUkcGVyc2lzdGVuY2VfVU5TMyA6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7IC8vIEZpbHRlciBvbiBleGlzdGFuY2UgaW4gYXRvbVZhbHVlcyBzbyB0aGF0IGV4dGVybmFsbHktdmlzaWJsZSBydWxlc1xuICAgIC8vIGFyZSBhbHNvIGFwcGxpZWQgdG8gbW9kaWZpZWQgYXRvbXMgKHNwZWNpZmljYWxseSBleGNsdWRlIHNlbGVjdG9ycyk6XG5cbiAgICBjb25zdCBtb2RpZmllZEF0b21zID0gUmVjb2lsX2ZpbHRlclNldChjdXJyZW50VHJlZS5kaXJ0eUF0b21zLCBrID0+IGF0b21WYWx1ZXMuaGFzKGspIHx8IHByZXZpb3VzQXRvbVZhbHVlcy5oYXMoaykpO1xuICAgIGNhbGxiYWNrKHtcbiAgICAgIGF0b21WYWx1ZXMsXG4gICAgICBwcmV2aW91c0F0b21WYWx1ZXMsXG4gICAgICBhdG9tSW5mbyxcbiAgICAgIG1vZGlmaWVkQXRvbXMsXG4gICAgICB0cmFuc2FjdGlvbk1ldGFkYXRhOiB7IC4uLmN1cnJlbnRUcmVlLnRyYW5zYWN0aW9uTWV0YWRhdGFcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW2NhbGxiYWNrXSkpO1xufVxuXG5mdW5jdGlvbiB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyKGNhbGxiYWNrKSB7XG4gIHVzZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uKHVzZUNhbGxiYWNrJDIoc3RvcmUgPT4ge1xuICAgIGNvbnN0IHNuYXBzaG90ID0gY2xvbmVTbmFwc2hvdCQxKHN0b3JlLCAnbGF0ZXN0Jyk7XG4gICAgY29uc3QgcHJldmlvdXNTbmFwc2hvdCA9IGNsb25lU25hcHNob3QkMShzdG9yZSwgJ3ByZXZpb3VzJyk7XG4gICAgY2FsbGJhY2soe1xuICAgICAgc25hcHNob3QsXG4gICAgICBwcmV2aW91c1NuYXBzaG90XG4gICAgfSk7XG4gIH0sIFtjYWxsYmFja10pKTtcbn0gLy8gUmV0dXJuIGEgc25hcHNob3Qgb2YgdGhlIGN1cnJlbnQgc3RhdGUgYW5kIHN1YnNjcmliZSB0byBhbGwgc3RhdGUgY2hhbmdlc1xuXG5cbmZ1bmN0aW9uIHVzZVJlY29pbFNuYXBzaG90KCkge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDMoKTtcbiAgY29uc3QgW3NuYXBzaG90LCBzZXRTbmFwc2hvdF0gPSB1c2VTdGF0ZSQyKCgpID0+IGNsb25lU25hcHNob3QkMShzdG9yZVJlZi5jdXJyZW50KSk7XG4gIGNvbnN0IHByZXZpb3VzU25hcHNob3QgPSBSZWNvaWxfdXNlUHJldmlvdXMoc25hcHNob3QpO1xuICBjb25zdCB0aW1lb3V0SUQgPSB1c2VSZWYkNSgpO1xuICBjb25zdCByZWxlYXNlUmVmID0gdXNlUmVmJDUoKTtcbiAgdXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb24odXNlQ2FsbGJhY2skMihzdG9yZSA9PiBzZXRTbmFwc2hvdChjbG9uZVNuYXBzaG90JDEoc3RvcmUpKSwgW10pKTsgLy8gUmV0YWluIHNuYXBzaG90IGZvciBkdXJhdGlvbiBjb21wb25lbnQgaXMgbW91bnRlZFxuXG4gIHVzZUVmZmVjdCQ0KCgpID0+IHtcbiAgICBjb25zdCByZWxlYXNlID0gc25hcHNob3QucmV0YWluKCk7IC8vIFJlbGVhc2UgdGhlIHJldGFpbiBmcm9tIHRoZSByZW5kZXJpbmcgY2FsbFxuXG4gICAgaWYgKHRpbWVvdXRJRC5jdXJyZW50ICYmICFpc1NTUiQ0KSB7XG4gICAgICB2YXIgX3JlbGVhc2VSZWYkY3VycmVudDtcblxuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0SUQuY3VycmVudCk7XG4gICAgICB0aW1lb3V0SUQuY3VycmVudCA9IG51bGw7XG4gICAgICAoX3JlbGVhc2VSZWYkY3VycmVudCA9IHJlbGVhc2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX3JlbGVhc2VSZWYkY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlbGVhc2VSZWYkY3VycmVudC5jYWxsKHJlbGVhc2VSZWYpO1xuICAgICAgcmVsZWFzZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gRGVmZXIgdGhlIHJlbGVhc2UuICBJZiBcIkZhc3QgUmVmcmVzaFwiXCIgaXMgdXNlZCB0aGVuIHRoZSBjb21wb25lbnQgbWF5XG4gICAgICAvLyByZS1yZW5kZXIgd2l0aCB0aGUgc2FtZSBzdGF0ZS4gIFRoZSBwcmV2aW91cyBjbGVhbnVwIHdpbGwgdGhlbiBydW4gYW5kXG4gICAgICAvLyB0aGVuIHRoZSBuZXcgZWZmZWN0IHdpbGwgcnVuLiBXZSBkb24ndCB3YW50IHRoZSBzbmFwc2hvdCB0byBiZSByZWxlYXNlZFxuICAgICAgLy8gYnkgdGhhdCBjbGVhbnVwIGJlZm9yZSB0aGUgbmV3IGVmZmVjdCBoYXMgYSBjaGFuY2UgdG8gcmV0YWluIGl0IGFnYWluLlxuICAgICAgLy8gVXNlIHRpbWVvdXQgb2YgMTAgdG8gd29ya2Fyb3VuZCBGaXJlZm94IGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2tleHBlcmltZW50YWwvUmVjb2lsL2lzc3Vlcy8xOTM2XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChyZWxlYXNlLCAxMCk7XG4gICAgfTtcbiAgfSwgW3NuYXBzaG90XSk7IC8vIFJldGFpbiBzbmFwc2hvdCB1bnRpbCBhYm92ZSBlZmZlY3QgaXMgcnVuLlxuICAvLyBSZWxlYXNlIGFmdGVyIGEgdGhyZXNob2xkIGluIGNhc2UgY29tcG9uZW50IGlzIHN1c3BlbmRlZC5cblxuICBpZiAocHJldmlvdXNTbmFwc2hvdCAhPT0gc25hcHNob3QgJiYgIWlzU1NSJDQpIHtcbiAgICAvLyBSZWxlYXNlIHRoZSBwcmV2aW91cyBzbmFwc2hvdFxuICAgIGlmICh0aW1lb3V0SUQuY3VycmVudCkge1xuICAgICAgdmFyIF9yZWxlYXNlUmVmJGN1cnJlbnQyO1xuXG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJRC5jdXJyZW50KTtcbiAgICAgIHRpbWVvdXRJRC5jdXJyZW50ID0gbnVsbDtcbiAgICAgIChfcmVsZWFzZVJlZiRjdXJyZW50MiA9IHJlbGVhc2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX3JlbGVhc2VSZWYkY3VycmVudDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZWxlYXNlUmVmJGN1cnJlbnQyLmNhbGwocmVsZWFzZVJlZik7XG4gICAgICByZWxlYXNlUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cblxuICAgIHJlbGVhc2VSZWYuY3VycmVudCA9IHNuYXBzaG90LnJldGFpbigpO1xuICAgIHRpbWVvdXRJRC5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdmFyIF9yZWxlYXNlUmVmJGN1cnJlbnQzO1xuXG4gICAgICB0aW1lb3V0SUQuY3VycmVudCA9IG51bGw7XG4gICAgICAoX3JlbGVhc2VSZWYkY3VycmVudDMgPSByZWxlYXNlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9yZWxlYXNlUmVmJGN1cnJlbnQzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVsZWFzZVJlZiRjdXJyZW50My5jYWxsKHJlbGVhc2VSZWYpO1xuICAgICAgcmVsZWFzZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9LCBTVVNQRU5TRV9USU1FT1VUX01TJDIpO1xuICB9XG5cbiAgcmV0dXJuIHNuYXBzaG90O1xufVxuXG5mdW5jdGlvbiBnb3RvU25hcHNob3Qoc3RvcmUsIHNuYXBzaG90KSB7XG4gIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZTtcblxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgY29uc3QgcHJldiA9IChfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XG4gIGNvbnN0IG5leHQgPSBzbmFwc2hvdC5nZXRTdG9yZV9JTlRFUk5BTCgpLmdldFN0YXRlKCkuY3VycmVudFRyZWU7XG4gIGJhdGNoVXBkYXRlcyQzKCgpID0+IHtcbiAgICBjb25zdCBrZXlzVG9VcGRhdGUgPSBuZXcgU2V0KCk7XG5cbiAgICBmb3IgKGNvbnN0IGtleXMgb2YgW3ByZXYuYXRvbVZhbHVlcy5rZXlzKCksIG5leHQuYXRvbVZhbHVlcy5rZXlzKCldKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIHZhciBfcHJldiRhdG9tVmFsdWVzJGdldCwgX25leHQkYXRvbVZhbHVlcyRnZXQ7XG5cbiAgICAgICAgaWYgKCgoX3ByZXYkYXRvbVZhbHVlcyRnZXQgPSBwcmV2LmF0b21WYWx1ZXMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9wcmV2JGF0b21WYWx1ZXMkZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcHJldiRhdG9tVmFsdWVzJGdldC5jb250ZW50cykgIT09ICgoX25leHQkYXRvbVZhbHVlcyRnZXQgPSBuZXh0LmF0b21WYWx1ZXMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9uZXh0JGF0b21WYWx1ZXMkZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbmV4dCRhdG9tVmFsdWVzJGdldC5jb250ZW50cykgJiYgZ2V0Tm9kZSQ0KGtleSkuc2hvdWxkUmVzdG9yZUZyb21TbmFwc2hvdHMpIHtcbiAgICAgICAgICBrZXlzVG9VcGRhdGUuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBrZXlzVG9VcGRhdGUuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgc2V0UmVjb2lsVmFsdWVMb2FkYWJsZSQxKHN0b3JlLCBuZXcgQWJzdHJhY3RSZWNvaWxWYWx1ZSQ0KGtleSksIG5leHQuYXRvbVZhbHVlcy5oYXMoa2V5KSA/IFJlY29pbF9udWxsdGhyb3dzKG5leHQuYXRvbVZhbHVlcy5nZXQoa2V5KSkgOiBERUZBVUxUX1ZBTFVFJDMpO1xuICAgIH0pO1xuICAgIHN0b3JlLnJlcGxhY2VTdGF0ZShzdGF0ZSA9PiAoeyAuLi5zdGF0ZSxcbiAgICAgIHN0YXRlSUQ6IHNuYXBzaG90LmdldElEKClcbiAgICB9KSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VHb3RvUmVjb2lsU25hcHNob3QoKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMygpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2skMihzbmFwc2hvdCA9PiBnb3RvU25hcHNob3Qoc3RvcmVSZWYuY3VycmVudCwgc25hcHNob3QpLCBbc3RvcmVSZWZdKTtcbn1cblxudmFyIFJlY29pbF9TbmFwc2hvdEhvb2tzID0ge1xuICB1c2VSZWNvaWxTbmFwc2hvdCxcbiAgZ290b1NuYXBzaG90LFxuICB1c2VHb3RvUmVjb2lsU25hcHNob3QsXG4gIHVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXIsXG4gIHVzZVRyYW5zYWN0aW9uT2JzZXJ2YXRpb25fREVQUkVDQVRFRCxcbiAgdXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25fREVQUkVDQVRFRDogdXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25cbn07XG5cbmNvbnN0IHtcbiAgcGVla05vZGVJbmZvOiBwZWVrTm9kZUluZm8kMlxufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcblxuY29uc3Qge1xuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkNFxufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5mdW5jdGlvbiB1c2VHZXRSZWNvaWxWYWx1ZUluZm8oKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkNCgpOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgcmV0dXJuICh7XG4gICAga2V5XG4gIH0pID0+IHBlZWtOb2RlSW5mbyQyKHN0b3JlUmVmLmN1cnJlbnQsIHN0b3JlUmVmLmN1cnJlbnQuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZSwga2V5KTtcbn1cblxudmFyIFJlY29pbF91c2VHZXRSZWNvaWxWYWx1ZUluZm8gPSB1c2VHZXRSZWNvaWxWYWx1ZUluZm87XG5cbmNvbnN0IHtcbiAgcmVhY3RNb2RlOiByZWFjdE1vZGUkNFxufSA9IFJlY29pbF9SZWFjdE1vZGU7XG5cbmNvbnN0IHtcbiAgUmVjb2lsUm9vdDogUmVjb2lsUm9vdCQxLFxuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkNVxufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5cblxuY29uc3Qge1xuICB1c2VNZW1vOiB1c2VNZW1vJDJcbn0gPSByZWFjdDtcblxuZnVuY3Rpb24gdXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290cygpIHtcbiAgLy8gVGhlIHRlc3QgZmFpbHMgd2hlbiB1c2luZyB1c2VNdXRhYmxlU291cmNlKCksIGJ1dCBvbmx5IGlmIGFjdCgpIGlzIHVzZWRcbiAgLy8gZm9yIHRoZSBuZXN0ZWQgcm9vdC4gIFNvLCB0aGlzIG1heSBvbmx5IGJlIGEgdGVzdGluZyBlbnZpcm9ubWVudCBpc3N1ZS5cbiAgaWYgKHJlYWN0TW9kZSQ0KCkubW9kZSA9PT0gJ01VVEFCTEVfU09VUkNFJykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybignV2FybmluZzogVGhlcmUgYXJlIGtub3duIGlzc3VlcyB1c2luZyB1c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzKCkgaW4gcmVjb2lsX211dGFibGVfc291cmNlIHJlbmRlcmluZyBtb2RlLiAgUGxlYXNlIGNvbnNpZGVyIHVwZ3JhZGluZyB0byByZWNvaWxfc3luY19leHRlcm5hbF9zdG9yZSBtb2RlLicpO1xuICB9XG5cbiAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZVJlZiQ1KCkuY3VycmVudDtcbiAgcmV0dXJuIHVzZU1lbW8kMigoKSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuICAgIGZ1bmN0aW9uIFJlY29pbEJyaWRnZSh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovcmVhY3QuY3JlYXRlRWxlbWVudChSZWNvaWxSb290JDEsIHtcbiAgICAgICAgc3RvcmVfSU5URVJOQUw6IHN0b3JlXG4gICAgICB9LCBjaGlsZHJlbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlY29pbEJyaWRnZTtcbiAgfSwgW3N0b3JlXSk7XG59XG5cbnZhciBSZWNvaWxfdXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290cyA9IHVzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHM7XG5cbmNvbnN0IHtcbiAgbG9hZGFibGVXaXRoVmFsdWU6IGxvYWRhYmxlV2l0aFZhbHVlJDFcbn0gPSBSZWNvaWxfTG9hZGFibGUkMTtcblxuY29uc3Qge1xuICBpbml0aWFsaXplTm9kZTogaW5pdGlhbGl6ZU5vZGUkM1xufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcblxuY29uc3Qge1xuICBERUZBVUxUX1ZBTFVFOiBERUZBVUxUX1ZBTFVFJDQsXG4gIGdldE5vZGU6IGdldE5vZGUkNVxufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIGNvcHlUcmVlU3RhdGU6IGNvcHlUcmVlU3RhdGUkMSxcbiAgZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlOiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMyxcbiAgaW52YWxpZGF0ZURvd25zdHJlYW1zOiBpbnZhbGlkYXRlRG93bnN0cmVhbXMkMSxcbiAgd3JpdGVMb2FkYWJsZVRvVHJlZVN0YXRlOiB3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUkMVxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcblxuXG5cbmZ1bmN0aW9uIGlzQXRvbShyZWNvaWxWYWx1ZSkge1xuICByZXR1cm4gZ2V0Tm9kZSQ1KHJlY29pbFZhbHVlLmtleSkubm9kZVR5cGUgPT09ICdhdG9tJztcbn1cblxuY2xhc3MgVHJhbnNhY3Rpb25JbnRlcmZhY2VJbXBsIHtcbiAgY29uc3RydWN0b3Ioc3RvcmUsIHRyZWVTdGF0ZSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdG9yZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RyZWVTdGF0ZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NoYW5nZXNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFwiLCByZWNvaWxWYWx1ZSA9PiB7XG4gICAgICBpZiAodGhpcy5fY2hhbmdlcy5oYXMocmVjb2lsVmFsdWUua2V5KSkge1xuICAgICAgICAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VzLmdldChyZWNvaWxWYWx1ZS5rZXkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzQXRvbShyZWNvaWxWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgUmVjb2lsX2VycignUmVhZGluZyBzZWxlY3RvcnMgd2l0aGluIGF0b21pY1VwZGF0ZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvYWRhYmxlID0gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDModGhpcy5fc3RvcmUsIHJlY29pbFZhbHVlLCB0aGlzLl90cmVlU3RhdGUpO1xuXG4gICAgICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScpIHtcbiAgICAgICAgcmV0dXJuIGxvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgfSBlbHNlIGlmIChsb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc0Vycm9yJykge1xuICAgICAgICB0aHJvdyBsb2FkYWJsZS5jb250ZW50cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IFJlY29pbF9lcnIoYEV4cGVjdGVkIFJlY29pbCBhdG9tICR7cmVjb2lsVmFsdWUua2V5fSB0byBoYXZlIGEgdmFsdWUsIGJ1dCBpdCBpcyBpbiBhIGxvYWRpbmcgc3RhdGUuYCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRcIiwgKHJlY29pbFN0YXRlLCB2YWx1ZU9yVXBkYXRlcikgPT4ge1xuICAgICAgaWYgKCFpc0F0b20ocmVjb2lsU3RhdGUpKSB7XG4gICAgICAgIHRocm93IFJlY29pbF9lcnIoJ1NldHRpbmcgc2VsZWN0b3JzIHdpdGhpbiBhdG9taWNVcGRhdGUgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlT3JVcGRhdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmdldChyZWNvaWxTdGF0ZSk7XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlcy5zZXQocmVjb2lsU3RhdGUua2V5LCB2YWx1ZU9yVXBkYXRlcihjdXJyZW50KSk7IC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbml0aWFsaXplIGF0b20gYW5kIHJ1biBlZmZlY3RzIGlmIG5vdCBpbml0aWFsaXplZCB5ZXRcbiAgICAgICAgaW5pdGlhbGl6ZU5vZGUkMyh0aGlzLl9zdG9yZSwgcmVjb2lsU3RhdGUua2V5LCAnc2V0Jyk7XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlcy5zZXQocmVjb2lsU3RhdGUua2V5LCB2YWx1ZU9yVXBkYXRlcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXNldFwiLCByZWNvaWxTdGF0ZSA9PiB7XG4gICAgICB0aGlzLnNldChyZWNvaWxTdGF0ZSwgREVGQVVMVF9WQUxVRSQ0KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3N0b3JlID0gc3RvcmU7XG4gICAgdGhpcy5fdHJlZVN0YXRlID0gdHJlZVN0YXRlO1xuICAgIHRoaXMuX2NoYW5nZXMgPSBuZXcgTWFwKCk7XG4gIH0gLy8gQWxsb3cgZGVzdHJ1Y3RpbmdcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9leHRyYS1hcnJvdy1pbml0aWFsaXplclxuXG5cbiAgbmV3VHJlZVN0YXRlX0lOVEVSTkFMKCkge1xuICAgIGlmICh0aGlzLl9jaGFuZ2VzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmVlU3RhdGU7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3U3RhdGUgPSBjb3B5VHJlZVN0YXRlJDEodGhpcy5fdHJlZVN0YXRlKTtcblxuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHRoaXMuX2NoYW5nZXMpIHtcbiAgICAgIHdyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZSQxKG5ld1N0YXRlLCBrLCBsb2FkYWJsZVdpdGhWYWx1ZSQxKHYpKTtcbiAgICB9XG5cbiAgICBpbnZhbGlkYXRlRG93bnN0cmVhbXMkMSh0aGlzLl9zdG9yZSwgbmV3U3RhdGUpO1xuICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGF0b21pY1VwZGF0ZXIoc3RvcmUpIHtcbiAgcmV0dXJuIGZuID0+IHtcbiAgICBzdG9yZS5yZXBsYWNlU3RhdGUodHJlZVN0YXRlID0+IHtcbiAgICAgIGNvbnN0IGNoYW5nZXNldCA9IG5ldyBUcmFuc2FjdGlvbkludGVyZmFjZUltcGwoc3RvcmUsIHRyZWVTdGF0ZSk7XG4gICAgICBmbihjaGFuZ2VzZXQpO1xuICAgICAgcmV0dXJuIGNoYW5nZXNldC5uZXdUcmVlU3RhdGVfSU5URVJOQUwoKTtcbiAgICB9KTtcbiAgfTtcbn1cblxudmFyIFJlY29pbF9BdG9taWNVcGRhdGVzID0ge1xuICBhdG9taWNVcGRhdGVyXG59O1xuXG52YXIgUmVjb2lsX0F0b21pY1VwZGF0ZXNfMSA9IFJlY29pbF9BdG9taWNVcGRhdGVzLmF0b21pY1VwZGF0ZXI7XG5cbnZhciBSZWNvaWxfQXRvbWljVXBkYXRlcyQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGF0b21pY1VwZGF0ZXI6IFJlY29pbF9BdG9taWNVcGRhdGVzXzFcbn0pO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cblxudmFyIGludmFyaWFudF8xID0gaW52YXJpYW50O1xuXG4vLyBAb3NzLW9ubHlcblxuXG52YXIgUmVjb2lsX2ludmFyaWFudCA9IGludmFyaWFudF8xO1xuXG5jb25zdCB7XG4gIGF0b21pY1VwZGF0ZXI6IGF0b21pY1VwZGF0ZXIkMVxufSA9IFJlY29pbF9BdG9taWNVcGRhdGVzJDE7XG5cbmNvbnN0IHtcbiAgYmF0Y2hVcGRhdGVzOiBiYXRjaFVwZGF0ZXMkNFxufSA9IFJlY29pbF9CYXRjaGluZztcblxuY29uc3Qge1xuICBERUZBVUxUX1ZBTFVFOiBERUZBVUxUX1ZBTFVFJDVcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkNlxufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5jb25zdCB7XG4gIHJlZnJlc2hSZWNvaWxWYWx1ZTogcmVmcmVzaFJlY29pbFZhbHVlJDEsXG4gIHNldFJlY29pbFZhbHVlOiBzZXRSZWNvaWxWYWx1ZSQzXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5jb25zdCB7XG4gIGNsb25lU25hcHNob3Q6IGNsb25lU25hcHNob3QkMlxufSA9IFJlY29pbF9TbmFwc2hvdCQxO1xuXG5jb25zdCB7XG4gIGdvdG9TbmFwc2hvdDogZ290b1NuYXBzaG90JDFcbn0gPSBSZWNvaWxfU25hcHNob3RIb29rcztcblxuY29uc3Qge1xuICB1c2VDYWxsYmFjazogdXNlQ2FsbGJhY2skM1xufSA9IHJlYWN0O1xuXG5cblxuXG5cblxuXG5cblxuY2xhc3MgU2VudGluZWwge31cblxuY29uc3QgU0VOVElORUwgPSBuZXcgU2VudGluZWwoKTtcblxuZnVuY3Rpb24gcmVjb2lsQ2FsbGJhY2soc3RvcmUsIGZuLCBhcmdzLCBleHRyYUludGVyZmFjZSkge1xuICBsZXQgcmV0ID0gU0VOVElORUw7XG4gIGxldCByZWxlYXNlU25hcHNob3Q7XG4gIGJhdGNoVXBkYXRlcyQ0KCgpID0+IHtcbiAgICBjb25zdCBlcnJNc2cgPSAndXNlUmVjb2lsQ2FsbGJhY2soKSBleHBlY3RzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb246ICcgKyAnaXQgYWNjZXB0cyBhIGZ1bmN0aW9uIG9mIHRoZSB0eXBlIChSZWNvaWxJbnRlcmZhY2UpID0+IChBcmdzKSA9PiBSZXR1cm5UeXBlICcgKyAnYW5kIHJldHVybnMgYSBjYWxsYmFjayBmdW5jdGlvbiAoQXJncykgPT4gUmV0dXJuVHlwZSwgd2hlcmUgUmVjb2lsSW50ZXJmYWNlIGlzICcgKyAnYW4gb2JqZWN0IHtzbmFwc2hvdCwgc2V0LCAuLi59IGFuZCBBcmdzIGFuZCBSZXR1cm5UeXBlIGFyZSB0aGUgYXJndW1lbnQgYW5kIHJldHVybiAnICsgJ3R5cGVzIG9mIHRoZSBjYWxsYmFjayB5b3Ugd2FudCB0byBjcmVhdGUuICBQbGVhc2Ugc2VlIHRoZSBkb2NzICcgKyAnYXQgcmVjb2lsanMub3JnIGZvciBkZXRhaWxzLic7XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKGVyck1zZyk7XG4gICAgfSAvLyBDbG9uZSB0aGUgc25hcHNob3QgbGF6aWx5IHRvIGF2b2lkIG92ZXJoZWFkIGlmIHRoZSBjYWxsYmFjayBkb2VzIG5vdCB1c2UgaXQuXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgbWVhbnMgdGhlIHNuYXBzaG90IG1heSByZXByZXNlbnQgbGF0ZXIgc3RhdGUgZnJvbSB3aGVuXG4gICAgLy8gdGhlIGNhbGxiYWNrIHdhcyBjYWxsZWQgaWYgaXQgZmlyc3QgYWNjZXNzZXMgdGhlIHNuYXBzaG90IGFzeW5jaHJvbm91c2x5LlxuXG5cbiAgICBjb25zdCBjYWxsYmFja0ludGVyZmFjZSA9IFJlY29pbF9sYXp5UHJveHkoeyAuLi4oZXh0cmFJbnRlcmZhY2UgIT09IG51bGwgJiYgZXh0cmFJbnRlcmZhY2UgIT09IHZvaWQgMCA/IGV4dHJhSW50ZXJmYWNlIDoge30pLFxuICAgICAgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4gICAgICAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG4gICAgICBzZXQ6IChub2RlLCBuZXdWYWx1ZSkgPT4gc2V0UmVjb2lsVmFsdWUkMyhzdG9yZSwgbm9kZSwgbmV3VmFsdWUpLFxuICAgICAgLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxuICAgICAgcmVzZXQ6IG5vZGUgPT4gc2V0UmVjb2lsVmFsdWUkMyhzdG9yZSwgbm9kZSwgREVGQVVMVF9WQUxVRSQ1KSxcbiAgICAgIC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cbiAgICAgIHJlZnJlc2g6IG5vZGUgPT4gcmVmcmVzaFJlY29pbFZhbHVlJDEoc3RvcmUsIG5vZGUpLFxuICAgICAgZ290b1NuYXBzaG90OiBzbmFwc2hvdCA9PiBnb3RvU25hcHNob3QkMShzdG9yZSwgc25hcHNob3QpLFxuICAgICAgdHJhbnNhY3RfVU5TVEFCTEU6IHRyYW5zYWN0aW9uID0+IGF0b21pY1VwZGF0ZXIkMShzdG9yZSkodHJhbnNhY3Rpb24pXG4gICAgfSwge1xuICAgICAgc25hcHNob3Q6ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc25hcHNob3QgPSBjbG9uZVNuYXBzaG90JDIoc3RvcmUpO1xuICAgICAgICByZWxlYXNlU25hcHNob3QgPSBzbmFwc2hvdC5yZXRhaW4oKTtcbiAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gZm4oY2FsbGJhY2tJbnRlcmZhY2UpO1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgUmVjb2lsX2VycihlcnJNc2cpO1xuICAgIH1cblxuICAgIHJldCA9IGNhbGxiYWNrKC4uLmFyZ3MpO1xuICB9KTtcbiAgISEocmV0IGluc3RhbmNlb2YgU2VudGluZWwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUmVjb2lsX2ludmFyaWFudChmYWxzZSwgJ2JhdGNoVXBkYXRlcyBzaG91bGQgcmV0dXJuIGltbWVkaWF0ZWx5JykgOiBSZWNvaWxfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICBpZiAoUmVjb2lsX2lzUHJvbWlzZShyZXQpKSB7XG4gICAgcmV0ID0gcmV0LmZpbmFsbHkoKCkgPT4ge1xuICAgICAgdmFyIF9yZWxlYXNlU25hcHNob3Q7XG5cbiAgICAgIChfcmVsZWFzZVNuYXBzaG90ID0gcmVsZWFzZVNuYXBzaG90KSA9PT0gbnVsbCB8fCBfcmVsZWFzZVNuYXBzaG90ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVsZWFzZVNuYXBzaG90KCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9yZWxlYXNlU25hcHNob3QyO1xuXG4gICAgKF9yZWxlYXNlU25hcHNob3QyID0gcmVsZWFzZVNuYXBzaG90KSA9PT0gbnVsbCB8fCBfcmVsZWFzZVNuYXBzaG90MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlbGVhc2VTbmFwc2hvdDIoKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHVzZVJlY29pbENhbGxiYWNrKGZuLCBkZXBzKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkNigpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2skMyggLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtY2FsbF1cbiAgKC4uLmFyZ3MpID0+IHtcbiAgICByZXR1cm4gcmVjb2lsQ2FsbGJhY2soc3RvcmVSZWYuY3VycmVudCwgZm4sIGFyZ3MpO1xuICB9LCBkZXBzICE9IG51bGwgPyBbLi4uZGVwcywgc3RvcmVSZWZdIDogdW5kZWZpbmVkIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZmItd3d3L3JlYWN0LWhvb2tzLWRlcHNcbiAgKTtcbn1cblxudmFyIFJlY29pbF91c2VSZWNvaWxDYWxsYmFjayA9IHtcbiAgcmVjb2lsQ2FsbGJhY2ssXG4gIHVzZVJlY29pbENhbGxiYWNrXG59O1xuXG5jb25zdCB7XG4gIHVzZVN0b3JlUmVmOiB1c2VTdG9yZVJlZiQ3XG59ID0gUmVjb2lsX1JlY29pbFJvb3Q7XG5cbmNvbnN0IHtcbiAgcmVmcmVzaFJlY29pbFZhbHVlOiByZWZyZXNoUmVjb2lsVmFsdWUkMlxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcblxuY29uc3Qge1xuICB1c2VDYWxsYmFjazogdXNlQ2FsbGJhY2skNFxufSA9IHJlYWN0O1xuXG5mdW5jdGlvbiB1c2VSZWNvaWxSZWZyZXNoZXIocmVjb2lsVmFsdWUpIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQ3KCk7XG4gIHJldHVybiB1c2VDYWxsYmFjayQ0KCgpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG4gICAgcmVmcmVzaFJlY29pbFZhbHVlJDIoc3RvcmUsIHJlY29pbFZhbHVlKTtcbiAgfSwgW3JlY29pbFZhbHVlLCBzdG9yZVJlZl0pO1xufVxuXG52YXIgUmVjb2lsX3VzZVJlY29pbFJlZnJlc2hlciA9IHVzZVJlY29pbFJlZnJlc2hlcjtcblxuY29uc3Qge1xuICBhdG9taWNVcGRhdGVyOiBhdG9taWNVcGRhdGVyJDJcbn0gPSBSZWNvaWxfQXRvbWljVXBkYXRlcyQxO1xuXG5jb25zdCB7XG4gIHVzZVN0b3JlUmVmOiB1c2VTdG9yZVJlZiQ4XG59ID0gUmVjb2lsX1JlY29pbFJvb3Q7XG5cbmNvbnN0IHtcbiAgdXNlTWVtbzogdXNlTWVtbyQzXG59ID0gcmVhY3Q7XG5cbmZ1bmN0aW9uIHVzZVJlY29pbFRyYW5zYWN0aW9uKGZuLCBkZXBzKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkOCgpO1xuICByZXR1cm4gdXNlTWVtbyQzKCgpID0+ICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgYXRvbWljVXBkYXRlID0gYXRvbWljVXBkYXRlciQyKHN0b3JlUmVmLmN1cnJlbnQpO1xuICAgIGF0b21pY1VwZGF0ZSh0cmFuc2FjdGlvbkludGVyZmFjZSA9PiB7XG4gICAgICBmbih0cmFuc2FjdGlvbkludGVyZmFjZSkoLi4uYXJncyk7XG4gICAgfSk7XG4gIH0sIGRlcHMgIT0gbnVsbCA/IFsuLi5kZXBzLCBzdG9yZVJlZl0gOiB1bmRlZmluZWQgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmYi13d3cvcmVhY3QtaG9va3MtZGVwc1xuICApO1xufVxuXG52YXIgUmVjb2lsX3VzZVJlY29pbFRyYW5zYWN0aW9uID0gdXNlUmVjb2lsVHJhbnNhY3Rpb247XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuY2xhc3MgV3JhcHBlZFZhbHVlIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbn1cblxudmFyIFJlY29pbF9XcmFwcGVyID0ge1xuICBXcmFwcGVkVmFsdWVcbn07XG5cbnZhciBSZWNvaWxfV3JhcHBlcl8xID0gUmVjb2lsX1dyYXBwZXIuV3JhcHBlZFZhbHVlO1xuXG52YXIgUmVjb2lsX1dyYXBwZXIkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBXcmFwcGVkVmFsdWU6IFJlY29pbF9XcmFwcGVyXzFcbn0pO1xuXG5jb25zdCB7XG4gIGlzRmFzdFJlZnJlc2hFbmFibGVkOiBpc0Zhc3RSZWZyZXNoRW5hYmxlZCQyXG59ID0gUmVjb2lsX1JlYWN0TW9kZTtcblxuXG5cbmNsYXNzIENoYW5nZWRQYXRoRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG5jbGFzcyBUcmVlQ2FjaGUge1xuICAvLyAkRmxvd0lzc3VlW3VuY2xlYXItdHlwZV1cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfb3B0aW9ucyRvbkhpdCwgX29wdGlvbnMkb25TZXQsIF9vcHRpb25zJG1hcE5vZGVWYWx1ZTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9uYW1lXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbnVtTGVhZnNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9yb290XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfb25IaXRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9vblNldFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX21hcE5vZGVWYWx1ZVwiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5fbmFtZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5uYW1lO1xuICAgIHRoaXMuX251bUxlYWZzID0gMDtcbiAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICB0aGlzLl9vbkhpdCA9IChfb3B0aW9ucyRvbkhpdCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vbkhpdCkgIT09IG51bGwgJiYgX29wdGlvbnMkb25IaXQgIT09IHZvaWQgMCA/IF9vcHRpb25zJG9uSGl0IDogKCkgPT4ge307XG4gICAgdGhpcy5fb25TZXQgPSAoX29wdGlvbnMkb25TZXQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25TZXQpICE9PSBudWxsICYmIF9vcHRpb25zJG9uU2V0ICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRvblNldCA6ICgpID0+IHt9O1xuICAgIHRoaXMuX21hcE5vZGVWYWx1ZSA9IChfb3B0aW9ucyRtYXBOb2RlVmFsdWUgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWFwTm9kZVZhbHVlKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRtYXBOb2RlVmFsdWUgIT09IHZvaWQgMCA/IF9vcHRpb25zJG1hcE5vZGVWYWx1ZSA6IHZhbCA9PiB2YWw7XG4gIH1cblxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9udW1MZWFmcztcbiAgfSAvLyAkRmxvd0lzc3VlW3VuY2xlYXItdHlwZV1cblxuXG4gIHJvb3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG4gIH1cblxuICBnZXQoZ2V0Tm9kZVZhbHVlLCBoYW5kbGVycykge1xuICAgIHZhciBfdGhpcyRnZXRMZWFmTm9kZTtcblxuICAgIHJldHVybiAoX3RoaXMkZ2V0TGVhZk5vZGUgPSB0aGlzLmdldExlYWZOb2RlKGdldE5vZGVWYWx1ZSwgaGFuZGxlcnMpKSA9PT0gbnVsbCB8fCBfdGhpcyRnZXRMZWFmTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZ2V0TGVhZk5vZGUudmFsdWU7XG4gIH1cblxuICBnZXRMZWFmTm9kZShnZXROb2RlVmFsdWUsIGhhbmRsZXJzKSB7XG4gICAgaWYgKHRoaXMuX3Jvb3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IC8vIEl0ZXJhdGUgZG93biB0aGUgdHJlZSBiYXNlZCBvbiB0aGUgY3VycmVudCBub2RlIHZhbHVlcyB1bnRpbCB3ZSBoaXQgYSBsZWFmXG4gICAgLy8gJEZsb3dJc3N1ZVt1bmNsZWFyLXR5cGVdXG5cblxuICAgIGxldCBub2RlID0gdGhpcy5fcm9vdDtcblxuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBoYW5kbGVycyA9PT0gbnVsbCB8fCBoYW5kbGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaGFuZGxlcnMub25Ob2RlVmlzaXQobm9kZSk7XG5cbiAgICAgIGlmIChub2RlLnR5cGUgPT09ICdsZWFmJykge1xuICAgICAgICB0aGlzLl9vbkhpdChub2RlKTtcblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZVZhbHVlID0gdGhpcy5fbWFwTm9kZVZhbHVlKGdldE5vZGVWYWx1ZShub2RlLm5vZGVLZXkpKTtcblxuICAgICAgbm9kZSA9IG5vZGUuYnJhbmNoZXMuZ2V0KG5vZGVWYWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHNldChyb3V0ZSwgdmFsdWUsIGhhbmRsZXJzKSB7XG4gICAgY29uc3QgYWRkTGVhZiA9ICgpID0+IHtcbiAgICAgIHZhciBfbm9kZTIsIF9ub2RlMywgX3RoaXMkX3Jvb3QyLCBfaGFuZGxlcnMkb25Ob2RlVmlzaXQyO1xuXG4gICAgICAvLyBGaXJzdCwgc2V0dXAgdGhlIGJyYW5jaCBub2RlcyBmb3IgdGhlIHJvdXRlOlxuICAgICAgLy8gSXRlcmF0ZSBkb3duIHRoZSB0cmVlIHRvIGZpbmQgb3IgYWRkIGJyYW5jaCBub2RlcyBmb2xsb3dpbmcgdGhlIHJvdXRlXG4gICAgICBsZXQgbm9kZTtcbiAgICAgIGxldCBicmFuY2hLZXk7XG5cbiAgICAgIGZvciAoY29uc3QgW25vZGVLZXksIG5vZGVWYWx1ZV0gb2Ygcm91dGUpIHtcbiAgICAgICAgdmFyIF9ub2RlLCBfaGFuZGxlcnMkb25Ob2RlVmlzaXQsIF90aGlzJF9yb290O1xuXG4gICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyByb290IHdhcyBhIGxlYWYsIHdoaWxlIHdlIG5vdCBoYXZlIGEgZ2V0KCksIGl0IG1lYW5zXG4gICAgICAgIC8vIHRoZSBzZWxlY3RvciBoYXMgaW5jb25zaXN0ZW50IHZhbHVlcyBvciBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkLlxuICAgICAgICBjb25zdCByb290ID0gdGhpcy5fcm9vdDtcblxuICAgICAgICBpZiAoKHJvb3QgPT09IG51bGwgfHwgcm9vdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcm9vdC50eXBlKSA9PT0gJ2xlYWYnKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5pbnZhbGlkQ2FjaGVFcnJvcigpO1xuICAgICAgICB9IC8vIG5vZGUgbm93IHJlZmVycyB0byB0aGUgbmV4dCBub2RlIGRvd24gaW4gdGhlIHRyZWVcblxuXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGU7IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXVxuXG4gICAgICAgIG5vZGUgPSBwYXJlbnQgPyBwYXJlbnQuYnJhbmNoZXMuZ2V0KGJyYW5jaEtleSkgOiByb290OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV1cblxuICAgICAgICBub2RlID0gKF9ub2RlID0gbm9kZSkgIT09IG51bGwgJiYgX25vZGUgIT09IHZvaWQgMCA/IF9ub2RlIDoge1xuICAgICAgICAgIHR5cGU6ICdicmFuY2gnLFxuICAgICAgICAgIG5vZGVLZXksXG4gICAgICAgICAgcGFyZW50LFxuICAgICAgICAgIGJyYW5jaGVzOiBuZXcgTWFwKCksXG4gICAgICAgICAgYnJhbmNoS2V5XG4gICAgICAgIH07IC8vIElmIHdlIGZvdW5kIGFuIGV4aXN0aW5nIG5vZGUsIGNvbmZpcm0gaXQgaGFzIGEgY29uc2lzdGVudCB2YWx1ZVxuXG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09ICdicmFuY2gnIHx8IG5vZGUubm9kZUtleSAhPT0gbm9kZUtleSkge1xuICAgICAgICAgIHRocm93IHRoaXMuaW52YWxpZENhY2hlRXJyb3IoKTtcbiAgICAgICAgfSAvLyBBZGQgdGhlIGJyYW5jaCBub2RlIHRvIHRoZSB0cmVlXG5cblxuICAgICAgICBwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuYnJhbmNoZXMuc2V0KGJyYW5jaEtleSwgbm9kZSk7XG4gICAgICAgIGhhbmRsZXJzID09PSBudWxsIHx8IGhhbmRsZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2hhbmRsZXJzJG9uTm9kZVZpc2l0ID0gaGFuZGxlcnMub25Ob2RlVmlzaXQpID09PSBudWxsIHx8IF9oYW5kbGVycyRvbk5vZGVWaXNpdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2hhbmRsZXJzJG9uTm9kZVZpc2l0LmNhbGwoaGFuZGxlcnMsIG5vZGUpOyAvLyBQcmVwYXJlIGZvciBuZXh0IGl0ZXJhdGlvbiBhbmQgaW5zdGFsbCByb290IGlmIGl0IGlzIG5ldy5cblxuICAgICAgICBicmFuY2hLZXkgPSB0aGlzLl9tYXBOb2RlVmFsdWUobm9kZVZhbHVlKTtcbiAgICAgICAgdGhpcy5fcm9vdCA9IChfdGhpcyRfcm9vdCA9IHRoaXMuX3Jvb3QpICE9PSBudWxsICYmIF90aGlzJF9yb290ICE9PSB2b2lkIDAgPyBfdGhpcyRfcm9vdCA6IG5vZGU7XG4gICAgICB9IC8vIFNlY29uZCwgc2V0dXAgdGhlIGxlYWYgbm9kZTpcbiAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIGxlYWYgZm9yIHRoaXMgcm91dGUgY29uZmlybSBpdCBpcyBjb25zaXN0ZW50XG5cblxuICAgICAgY29uc3Qgb2xkTGVhZiA9IG5vZGUgPyAoX25vZGUyID0gbm9kZSkgPT09IG51bGwgfHwgX25vZGUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZTIuYnJhbmNoZXMuZ2V0KGJyYW5jaEtleSkgOiB0aGlzLl9yb290O1xuXG4gICAgICBpZiAob2xkTGVhZiAhPSBudWxsICYmIChvbGRMZWFmLnR5cGUgIT09ICdsZWFmJyB8fCBvbGRMZWFmLmJyYW5jaEtleSAhPT0gYnJhbmNoS2V5KSkge1xuICAgICAgICB0aHJvdyB0aGlzLmludmFsaWRDYWNoZUVycm9yKCk7XG4gICAgICB9IC8vIENyZWF0ZSBhIG5ldyBvciByZXBsYWNlbWVudCBsZWFmLlxuXG5cbiAgICAgIGNvbnN0IGxlYWZOb2RlID0ge1xuICAgICAgICB0eXBlOiAnbGVhZicsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBwYXJlbnQ6IG5vZGUsXG4gICAgICAgIGJyYW5jaEtleVxuICAgICAgfTsgLy8gSW5zdGFsbCB0aGUgbGVhZiBhbmQgY2FsbCBoYW5kbGVyc1xuXG4gICAgICAoX25vZGUzID0gbm9kZSkgPT09IG51bGwgfHwgX25vZGUzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZTMuYnJhbmNoZXMuc2V0KGJyYW5jaEtleSwgbGVhZk5vZGUpO1xuICAgICAgdGhpcy5fcm9vdCA9IChfdGhpcyRfcm9vdDIgPSB0aGlzLl9yb290KSAhPT0gbnVsbCAmJiBfdGhpcyRfcm9vdDIgIT09IHZvaWQgMCA/IF90aGlzJF9yb290MiA6IGxlYWZOb2RlO1xuICAgICAgdGhpcy5fbnVtTGVhZnMrKztcblxuICAgICAgdGhpcy5fb25TZXQobGVhZk5vZGUpO1xuXG4gICAgICBoYW5kbGVycyA9PT0gbnVsbCB8fCBoYW5kbGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9oYW5kbGVycyRvbk5vZGVWaXNpdDIgPSBoYW5kbGVycy5vbk5vZGVWaXNpdCkgPT09IG51bGwgfHwgX2hhbmRsZXJzJG9uTm9kZVZpc2l0MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2hhbmRsZXJzJG9uTm9kZVZpc2l0Mi5jYWxsKGhhbmRsZXJzLCBsZWFmTm9kZSk7XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICBhZGRMZWFmKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElmIHRoZSBjYWNoZSB3YXMgc3RhbGUgb3Igb2JzZXJ2ZWQgaW5jb25zaXN0ZW50IHZhbHVlcywgc3VjaCBhcyB3aXRoXG4gICAgICAvLyBGYXN0IFJlZnJlc2gsIHRoZW4gY2xlYXIgaXQgYW5kIHJlYnVpbGQgd2l0aCB0aGUgbmV3IHZhbHVlcy5cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENoYW5nZWRQYXRoRXJyb3IpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICBhZGRMZWFmKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUmV0dXJucyB0cnVlIGlmIGxlYWYgd2FzIGFjdHVhbGx5IGRlbGV0ZWQgZnJvbSB0aGUgdHJlZVxuXG5cbiAgZGVsZXRlKGxlYWYpIHtcbiAgICBjb25zdCByb290ID0gdGhpcy5yb290KCk7XG5cbiAgICBpZiAoIXJvb3QpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobGVhZiA9PT0gcm9vdCkge1xuICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgICB0aGlzLl9udW1MZWFmcyA9IDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIEl0ZXJhdGUgdXAgZnJvbSB0aGUgbGVhZiBkZWxldGVpbmcgaXQgZnJvbSBpdCdzIHBhcmVudCdzIGJyYW5jaGVzLlxuXG5cbiAgICBsZXQgbm9kZSA9IGxlYWYucGFyZW50O1xuICAgIGxldCBicmFuY2hLZXkgPSBsZWFmLmJyYW5jaEtleTtcblxuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICB2YXIgX25vZGU0O1xuXG4gICAgICBub2RlLmJyYW5jaGVzLmRlbGV0ZShicmFuY2hLZXkpOyAvLyBTdG9wIGl0ZXJhdGluZyBpZiB3ZSBoaXQgdGhlIHJvb3QuXG5cbiAgICAgIGlmIChub2RlID09PSByb290KSB7XG4gICAgICAgIGlmIChub2RlLmJyYW5jaGVzLnNpemUgPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9udW1MZWFmcyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fbnVtTGVhZnMtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBTdG9wIGl0ZXJhdGluZyBpZiB0aGVyZSBhcmUgb3RoZXIgYnJhbmNoZXMgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgLy8gcmVtb3ZlIGFueSBtb3JlIG5vZGVzLlxuXG5cbiAgICAgIGlmIChub2RlLmJyYW5jaGVzLnNpemUgPiAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBJdGVyYXRlIHVwIHRvIG91ciBwYXJlbnRcblxuXG4gICAgICBicmFuY2hLZXkgPSAoX25vZGU0ID0gbm9kZSkgPT09IG51bGwgfHwgX25vZGU0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZTQuYnJhbmNoS2V5O1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIH0gLy8gQ29uZmlybSB0aGF0IHRoZSBsZWFmIHdlIGFyZSBkZWxldGluZyBpcyBhY3R1YWxseSBhdHRhY2hlZCB0byBvdXIgdHJlZVxuXG5cbiAgICBmb3IgKDsgbm9kZSAhPT0gcm9vdDsgbm9kZSA9IG5vZGUucGFyZW50KSB7XG4gICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9udW1MZWFmcy0tO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fbnVtTGVhZnMgPSAwO1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICB9XG5cbiAgaW52YWxpZENhY2hlRXJyb3IoKSB7XG4gICAgY29uc3QgQ0hBTkdFRF9QQVRIX0VSUk9SX01FU1NBR0UgPSBpc0Zhc3RSZWZyZXNoRW5hYmxlZCQyKCkgPyAnUG9zc2libGUgRmFzdCBSZWZyZXNoIG1vZHVsZSByZWxvYWQgZGV0ZWN0ZWQuICAnICsgJ1RoaXMgbWF5IGFsc28gYmUgY2F1c2VkIGJ5IGFuIHNlbGVjdG9yIHJldHVybmluZyBpbmNvbnNpc3RlbnQgdmFsdWVzLiAnICsgJ1Jlc2V0dGluZyBjYWNoZS4nIDogJ0ludmFsaWQgY2FjaGUgdmFsdWVzLiAgVGhpcyBoYXBwZW5zIHdoZW4gc2VsZWN0b3JzIGRvIG5vdCByZXR1cm4gJyArICdjb25zaXN0ZW50IHZhbHVlcyBmb3IgdGhlIHNhbWUgaW5wdXQgZGVwZW5kZW5jeSB2YWx1ZXMuICBUaGF0IG1heSBhbHNvICcgKyAnYmUgY2F1c2VkIHdoZW4gdXNpbmcgRmFzdCBSZWZyZXNoIHRvIGNoYW5nZSBhIHNlbGVjdG9yIGltcGxlbWVudGF0aW9uLiAgJyArICdSZXNldHRpbmcgY2FjaGUuJztcbiAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oQ0hBTkdFRF9QQVRIX0VSUk9SX01FU1NBR0UgKyAodGhpcy5fbmFtZSAhPSBudWxsID8gYCAtICR7dGhpcy5fbmFtZX1gIDogJycpKTtcbiAgICB0aHJvdyBuZXcgQ2hhbmdlZFBhdGhFcnJvcigpO1xuICB9XG5cbn1cblxudmFyIFJlY29pbF9UcmVlQ2FjaGUgPSB7XG4gIFRyZWVDYWNoZVxufTtcblxudmFyIFJlY29pbF9UcmVlQ2FjaGVfMSA9IFJlY29pbF9UcmVlQ2FjaGUuVHJlZUNhY2hlO1xuXG52YXIgUmVjb2lsX1RyZWVDYWNoZSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIFRyZWVDYWNoZTogUmVjb2lsX1RyZWVDYWNoZV8xXG59KTtcblxuY2xhc3MgTFJVQ2FjaGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9vcHRpb25zJG1hcEtleTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9tYXhTaXplXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc2l6ZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2hlYWRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90YWlsXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWFwXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfa2V5TWFwcGVyXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLl9tYXhTaXplID0gb3B0aW9ucy5tYXhTaXplO1xuICAgIHRoaXMuX3NpemUgPSAwO1xuICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgIHRoaXMuX3RhaWwgPSBudWxsO1xuICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9rZXlNYXBwZXIgPSAoX29wdGlvbnMkbWFwS2V5ID0gb3B0aW9ucy5tYXBLZXkpICE9PSBudWxsICYmIF9vcHRpb25zJG1hcEtleSAhPT0gdm9pZCAwID8gX29wdGlvbnMkbWFwS2V5IDogdiA9PiB2O1xuICB9XG5cbiAgaGVhZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZDtcbiAgfVxuXG4gIHRhaWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhaWw7XG4gIH1cblxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9zaXplO1xuICB9XG5cbiAgbWF4U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4U2l6ZTtcbiAgfVxuXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyh0aGlzLl9rZXlNYXBwZXIoa2V5KSk7XG4gIH1cblxuICBnZXQoa2V5KSB7XG4gICAgY29uc3QgbWFwcGVkS2V5ID0gdGhpcy5fa2V5TWFwcGVyKGtleSk7XG5cbiAgICBjb25zdCBub2RlID0gdGhpcy5fbWFwLmdldChtYXBwZWRLZXkpO1xuXG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRoaXMuc2V0KGtleSwgbm9kZS52YWx1ZSk7XG4gICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gIH1cblxuICBzZXQoa2V5LCB2YWwpIHtcbiAgICBjb25zdCBtYXBwZWRLZXkgPSB0aGlzLl9rZXlNYXBwZXIoa2V5KTtcblxuICAgIGNvbnN0IGV4aXN0aW5nTm9kZSA9IHRoaXMuX21hcC5nZXQobWFwcGVkS2V5KTtcblxuICAgIGlmIChleGlzdGluZ05vZGUpIHtcbiAgICAgIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgfVxuXG4gICAgY29uc3QgaGVhZCA9IHRoaXMuaGVhZCgpO1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICBrZXksXG4gICAgICByaWdodDogaGVhZCxcbiAgICAgIGxlZnQ6IG51bGwsXG4gICAgICB2YWx1ZTogdmFsXG4gICAgfTtcblxuICAgIGlmIChoZWFkKSB7XG4gICAgICBoZWFkLmxlZnQgPSBub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90YWlsID0gbm9kZTtcbiAgICB9XG5cbiAgICB0aGlzLl9tYXAuc2V0KG1hcHBlZEtleSwgbm9kZSk7XG5cbiAgICB0aGlzLl9oZWFkID0gbm9kZTtcbiAgICB0aGlzLl9zaXplKys7XG5cbiAgICB0aGlzLl9tYXliZURlbGV0ZUxSVSgpO1xuICB9XG5cbiAgX21heWJlRGVsZXRlTFJVKCkge1xuICAgIGlmICh0aGlzLnNpemUoKSA+IHRoaXMubWF4U2l6ZSgpKSB7XG4gICAgICB0aGlzLmRlbGV0ZUxydSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlbGV0ZUxydSgpIHtcbiAgICBjb25zdCB0YWlsID0gdGhpcy50YWlsKCk7XG5cbiAgICBpZiAodGFpbCkge1xuICAgICAgdGhpcy5kZWxldGUodGFpbC5rZXkpO1xuICAgIH1cbiAgfVxuXG4gIGRlbGV0ZShrZXkpIHtcbiAgICBjb25zdCBtYXBwZWRLZXkgPSB0aGlzLl9rZXlNYXBwZXIoa2V5KTtcblxuICAgIGlmICghdGhpcy5fc2l6ZSB8fCAhdGhpcy5fbWFwLmhhcyhtYXBwZWRLZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZSA9IFJlY29pbF9udWxsdGhyb3dzKHRoaXMuX21hcC5nZXQobWFwcGVkS2V5KSk7XG4gICAgY29uc3QgcmlnaHQgPSBub2RlLnJpZ2h0O1xuICAgIGNvbnN0IGxlZnQgPSBub2RlLmxlZnQ7XG5cbiAgICBpZiAocmlnaHQpIHtcbiAgICAgIHJpZ2h0LmxlZnQgPSBub2RlLmxlZnQ7XG4gICAgfVxuXG4gICAgaWYgKGxlZnQpIHtcbiAgICAgIGxlZnQucmlnaHQgPSBub2RlLnJpZ2h0O1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSB0aGlzLmhlYWQoKSkge1xuICAgICAgdGhpcy5faGVhZCA9IHJpZ2h0O1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSB0aGlzLnRhaWwoKSkge1xuICAgICAgdGhpcy5fdGFpbCA9IGxlZnQ7XG4gICAgfVxuXG4gICAgdGhpcy5fbWFwLmRlbGV0ZShtYXBwZWRLZXkpO1xuXG4gICAgdGhpcy5fc2l6ZS0tO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgdGhpcy5faGVhZCA9IG51bGw7XG4gICAgdGhpcy5fdGFpbCA9IG51bGw7XG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICB9XG5cbn1cblxudmFyIFJlY29pbF9MUlVDYWNoZSA9IHtcbiAgTFJVQ2FjaGVcbn07XG5cbnZhciBSZWNvaWxfTFJVQ2FjaGVfMSA9IFJlY29pbF9MUlVDYWNoZS5MUlVDYWNoZTtcblxudmFyIFJlY29pbF9MUlVDYWNoZSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIExSVUNhY2hlOiBSZWNvaWxfTFJVQ2FjaGVfMVxufSk7XG5cbmNvbnN0IHtcbiAgTFJVQ2FjaGU6IExSVUNhY2hlJDFcbn0gPSBSZWNvaWxfTFJVQ2FjaGUkMTtcblxuY29uc3Qge1xuICBUcmVlQ2FjaGU6IFRyZWVDYWNoZSQxXG59ID0gUmVjb2lsX1RyZWVDYWNoZSQxO1xuXG5mdW5jdGlvbiB0cmVlQ2FjaGVMUlUoe1xuICBuYW1lLFxuICBtYXhTaXplLFxuICBtYXBOb2RlVmFsdWUgPSB2ID0+IHZcbn0pIHtcbiAgY29uc3QgbHJ1Q2FjaGUgPSBuZXcgTFJVQ2FjaGUkMSh7XG4gICAgbWF4U2l6ZVxuICB9KTtcbiAgY29uc3QgY2FjaGUgPSBuZXcgVHJlZUNhY2hlJDEoe1xuICAgIG5hbWUsXG4gICAgbWFwTm9kZVZhbHVlLFxuICAgIG9uSGl0OiBub2RlID0+IHtcbiAgICAgIGxydUNhY2hlLnNldChub2RlLCB0cnVlKTtcbiAgICB9LFxuICAgIG9uU2V0OiBub2RlID0+IHtcbiAgICAgIGNvbnN0IGxydU5vZGUgPSBscnVDYWNoZS50YWlsKCk7XG4gICAgICBscnVDYWNoZS5zZXQobm9kZSwgdHJ1ZSk7XG5cbiAgICAgIGlmIChscnVOb2RlICYmIGNhY2hlLnNpemUoKSA+IG1heFNpemUpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF1cbiAgICAgICAgY2FjaGUuZGVsZXRlKGxydU5vZGUua2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2FjaGU7XG59XG5cbnZhciBSZWNvaWxfdHJlZUNhY2hlTFJVID0gdHJlZUNhY2hlTFJVO1xuXG5jb25zdCBUSU1FX1dBUk5JTkdfVEhSRVNIT0xEX01TID0gMTU7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeSh4LCBvcHQsIGtleSkge1xuICAvLyBBIG9wdGltaXphdGlvbiB0byBhdm9pZCB0aGUgbW9yZSBleHBlbnNpdmUgSlNPTi5zdHJpbmdpZnkoKSBmb3Igc2ltcGxlIHN0cmluZ3NcbiAgLy8gVGhpcyBtYXkgbG9zZSBwcm90ZWN0aW9uIGZvciB1MjAyOCBhbmQgdTIwMjksIHRob3VnaC5cbiAgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJyAmJiAheC5pbmNsdWRlcygnXCInKSAmJiAheC5pbmNsdWRlcygnXFxcXCcpKSB7XG4gICAgcmV0dXJuIGBcIiR7eH1cImA7XG4gIH0gLy8gSGFuZGxlIHByaW1pdGl2ZSB0eXBlc1xuXG5cbiAgc3dpdGNoICh0eXBlb2YgeCkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gJyc7XG4gICAgLy8gSlNPTi5zdHJpbmdpZnkodW5kZWZpbmVkKSByZXR1cm5zIHVuZGVmaW5lZCwgYnV0IHdlIGFsd2F5cyB3YW50IHRvIHJldHVybiBhIHN0cmluZ1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4geCA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAvLyBjYXNlICdiaWdpbnQnOiAvLyBCaWdJbnQgaXMgbm90IHN1cHBvcnRlZCBpbiB3d3dcbiAgICAgIHJldHVybiBTdHJpbmcoeCk7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgLy8gQWRkIHN1cnJvdW5kaW5nIHF1b3RlcyBhbmQgZXNjYXBlIGludGVybmFsIHF1b3Rlc1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHgpO1xuXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgaWYgKChvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQuYWxsb3dGdW5jdGlvbnMpICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IFJlY29pbF9lcnIoJ0F0dGVtcHQgdG8gc2VyaWFsaXplIGZ1bmN0aW9uIGluIGEgUmVjb2lsIGNhY2hlIGtleScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYF9fRlVOQ1RJT04oJHt4Lm5hbWV9KV9fYDtcbiAgfVxuXG4gIGlmICh4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfSAvLyBGYWxsYmFjayBjYXNlIGZvciB1bmtub3duIHR5cGVzXG5cblxuICBpZiAodHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgdmFyIF9KU09OJHN0cmluZ2lmeTtcblxuICAgIHJldHVybiAoX0pTT04kc3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnkoeCkpICE9PSBudWxsICYmIF9KU09OJHN0cmluZ2lmeSAhPT0gdm9pZCAwID8gX0pTT04kc3RyaW5naWZ5IDogJyc7XG4gIH0gLy8gRGVhbCB3aXRoIGFsbCBwcm9taXNlcyBhcyBlcXVpdmFsZW50IGZvciBub3cuXG5cblxuICBpZiAoUmVjb2lsX2lzUHJvbWlzZSh4KSkge1xuICAgIHJldHVybiAnX19QUk9NSVNFX18nO1xuICB9IC8vIEFycmF5cyBoYW5kbGUgcmVjdXJzaXZlIHN0cmluZ2lmaWNhdGlvblxuXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG4gICAgcmV0dXJuIGBbJHt4Lm1hcCgodiwgaSkgPT4gc3RyaW5naWZ5KHYsIG9wdCwgaS50b1N0cmluZygpKSl9XWA7XG4gIH0gLy8gSWYgYW4gb2JqZWN0IGRlZmluZXMgYSB0b0pTT04oKSBtZXRob2QsIHRoZW4gdXNlIHRoYXQgdG8gb3ZlcnJpZGUgdGhlXG4gIC8vIHNlcmlhbGl6YXRpb24uICBUaGlzIG1hdGNoZXMgdGhlIGJlaGF2aW9yIG9mIEpTT04uc3RyaW5naWZ5KCkuXG4gIC8vIFBhc3MgdGhlIGtleSBmb3IgY29tcGF0aWJpbGl0eS5cbiAgLy8gSW1tdXRhYmxlLmpzIGNvbGxlY3Rpb25zIGRlZmluZSB0aGlzIG1ldGhvZCB0byBhbGxvdyB1cyB0byBzZXJpYWxpemUgdGhlbS5cblxuXG4gIGlmICh0eXBlb2YgeC50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOiBvZmZcbiAgICByZXR1cm4gc3RyaW5naWZ5KHgudG9KU09OKGtleSksIG9wdCwga2V5KTtcbiAgfSAvLyBGb3IgYnVpbHQtaW4gTWFwcywgc29ydCB0aGUga2V5cyBpbiBhIHN0YWJsZSBvcmRlciBpbnN0ZWFkIG9mIHRoZVxuICAvLyBkZWZhdWx0IGluc2VydGlvbiBvcmRlci4gIFN1cHBvcnQgbm9uLXN0cmluZyBrZXlzLlxuXG5cbiAgaWYgKHggaW5zdGFuY2VvZiBNYXApIHtcbiAgICBjb25zdCBvYmogPSB7fTtcblxuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHgpIHtcbiAgICAgIC8vIFN0cmluZ2lmeSB3aWxsIGVzY2FwZSBhbnkgbmVzdGVkIHF1b3Rlc1xuICAgICAgb2JqW3R5cGVvZiBrID09PSAnc3RyaW5nJyA/IGsgOiBzdHJpbmdpZnkoaywgb3B0KV0gPSB2O1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdpZnkob2JqLCBvcHQsIGtleSk7XG4gIH0gLy8gRm9yIGJ1aWx0LWluIFNldHMsIHNvcnQgdGhlIGtleXMgaW4gYSBzdGFibGUgb3JkZXIgaW5zdGVhZCBvZiB0aGVcbiAgLy8gZGVmYXVsdCBpbnNlcnRpb24gb3JkZXIuXG5cblxuICBpZiAoeCBpbnN0YW5jZW9mIFNldCkge1xuICAgIHJldHVybiBzdHJpbmdpZnkoIC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cbiAgICBBcnJheS5mcm9tKHgpLnNvcnQoKGEsIGIpID0+IHN0cmluZ2lmeShhLCBvcHQpLmxvY2FsZUNvbXBhcmUoc3RyaW5naWZ5KGIsIG9wdCkpKSwgb3B0LCBrZXkpO1xuICB9IC8vIEFueXRoaW5nIGVsc2UgdGhhdCBpcyBpdGVyYWJsZSBzZXJpYWxpemUgYXMgYW4gQXJyYXkuXG5cblxuICBpZiAoU3ltYm9sICE9PSB1bmRlZmluZWQgJiYgeFtTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgJiYgdHlwZW9mIHhbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6IG9mZlxuICAgIHJldHVybiBzdHJpbmdpZnkoQXJyYXkuZnJvbSh4KSwgb3B0LCBrZXkpO1xuICB9IC8vIEZvciBhbGwgb3RoZXIgT2JqZWN0cywgc29ydCB0aGUga2V5cyBpbiBhIHN0YWJsZSBvcmRlci5cblxuXG4gIHJldHVybiBgeyR7T2JqZWN0LmtleXMoeCkuZmlsdGVyKGsgPT4geFtrXSAhPT0gdW5kZWZpbmVkKS5zb3J0KCkgLy8gc3RyaW5naWZ5IHRoZSBrZXkgdG8gYWRkIHF1b3RlcyBhbmQgZXNjYXBlIGFueSBuZXN0ZWQgc2xhc2hlcyBvciBxdW90ZXMuXG4gIC5tYXAoayA9PiBgJHtzdHJpbmdpZnkoaywgb3B0KX06JHtzdHJpbmdpZnkoeFtrXSwgb3B0LCBrKX1gKS5qb2luKCcsJyl9fWA7XG59IC8vIFV0aWxpdHkgc2ltaWxhciB0byBKU09OLnN0cmluZ2lmeSgpIGV4Y2VwdDpcbi8vICogU2VyaWFsaXplIGJ1aWx0LWluIFNldHMgYXMgYW4gQXJyYXlcbi8vICogU2VyaWFsaXplIGJ1aWx0LWluIE1hcHMgYXMgYW4gT2JqZWN0LiAgU3VwcG9ydHMgbm9uLXN0cmluZyBrZXlzLlxuLy8gKiBTZXJpYWxpemUgb3RoZXIgaXRlcmFibGVzIGFzIGFycmF5c1xuLy8gKiBTb3J0IHRoZSBrZXlzIG9mIE9iamVjdHMgYW5kIE1hcHMgdG8gaGF2ZSBhIHN0YWJsZSBvcmRlciBiYXNlZCBvbiBzdHJpbmcgY29udmVyc2lvbi5cbi8vICAgIFRoaXMgb3ZlcnJpZGVzIHRoZWlyIGRlZmF1bHQgaW5zZXJ0aW9uIG9yZGVyLlxuLy8gKiBTdGlsbCB1c2VzIHRvSlNPTigpIG9mIGFueSBvYmplY3QgdG8gb3ZlcnJpZGUgc2VyaWFsaXphdGlvblxuLy8gKiBTdXBwb3J0IFN5bWJvbHMgKHRob3VnaCBkb24ndCBndWFyYW50ZWUgdW5pcXVlbmVzcylcbi8vICogV2UgY291bGQgc3VwcG9ydCBCaWdJbnQsIGJ1dCBGbG93IGRvZXNuJ3Qgc2VlbSB0byBsaWtlIGl0LlxuLy8gU2VlIFJlY29pbF9zdGFibGVTdHJpbmdpZnktdGVzdC5qcyBmb3IgZXhhbXBsZXNcblxuXG5mdW5jdGlvbiBzdGFibGVTdHJpbmdpZnkoeCwgb3B0ID0ge1xuICBhbGxvd0Z1bmN0aW9uczogZmFsc2Vcbn0pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlID8gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIDogMDtcbiAgICAgIGNvbnN0IHN0ciA9IHN0cmluZ2lmeSh4LCBvcHQpO1xuICAgICAgY29uc3QgZW5kVGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZSA/IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSA6IDA7XG5cbiAgICAgIGlmIChlbmRUaW1lIC0gc3RhcnRUaW1lID4gVElNRV9XQVJOSU5HX1RIUkVTSE9MRF9NUykge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBmYi13d3cvbm8tY29uc29sZSAqL1xuICAgICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKGBSZWNvaWw6IFNwZW50ICR7ZW5kVGltZSAtIHN0YXJ0VGltZX1tcyBjb21wdXRpbmcgYSBjYWNoZSBrZXlgKTtcbiAgICAgICAgY29uc29sZS53YXJuKHgsIHN0cik7XG4gICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBmYi13d3cvbm8tY29uc29sZSAqL1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHJpbmdpZnkoeCwgb3B0KTtcbn1cblxudmFyIFJlY29pbF9zdGFibGVTdHJpbmdpZnkgPSBzdGFibGVTdHJpbmdpZnk7XG5cbmNvbnN0IHtcbiAgVHJlZUNhY2hlOiBUcmVlQ2FjaGUkMlxufSA9IFJlY29pbF9UcmVlQ2FjaGUkMTtcblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IGRlZmF1bHRQb2xpY3kgPSB7XG4gIGVxdWFsaXR5OiAncmVmZXJlbmNlJyxcbiAgZXZpY3Rpb246ICdrZWVwLWFsbCcsXG4gIG1heFNpemU6IEluZmluaXR5XG59O1xuXG5mdW5jdGlvbiB0cmVlQ2FjaGVGcm9tUG9saWN5KHtcbiAgZXF1YWxpdHkgPSBkZWZhdWx0UG9saWN5LmVxdWFsaXR5LFxuICBldmljdGlvbiA9IGRlZmF1bHRQb2xpY3kuZXZpY3Rpb24sXG4gIG1heFNpemUgPSBkZWZhdWx0UG9saWN5Lm1heFNpemVcbn0gPSBkZWZhdWx0UG9saWN5LCBuYW1lKSB7XG4gIGNvbnN0IHZhbHVlTWFwcGVyID0gZ2V0VmFsdWVNYXBwZXIoZXF1YWxpdHkpO1xuICByZXR1cm4gZ2V0VHJlZUNhY2hlKGV2aWN0aW9uLCBtYXhTaXplLCB2YWx1ZU1hcHBlciwgbmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlTWFwcGVyKGVxdWFsaXR5KSB7XG4gIHN3aXRjaCAoZXF1YWxpdHkpIHtcbiAgICBjYXNlICdyZWZlcmVuY2UnOlxuICAgICAgcmV0dXJuIHZhbCA9PiB2YWw7XG5cbiAgICBjYXNlICd2YWx1ZSc6XG4gICAgICByZXR1cm4gdmFsID0+IFJlY29pbF9zdGFibGVTdHJpbmdpZnkodmFsKTtcbiAgfVxuXG4gIHRocm93IFJlY29pbF9lcnIoYFVucmVjb2duaXplZCBlcXVhbGl0eSBwb2xpY3kgJHtlcXVhbGl0eX1gKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJlZUNhY2hlKGV2aWN0aW9uLCBtYXhTaXplLCBtYXBOb2RlVmFsdWUsIG5hbWUpIHtcbiAgc3dpdGNoIChldmljdGlvbikge1xuICAgIGNhc2UgJ2tlZXAtYWxsJzpcbiAgICAgIHJldHVybiBuZXcgVHJlZUNhY2hlJDIoe1xuICAgICAgICBuYW1lLFxuICAgICAgICBtYXBOb2RlVmFsdWVcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnbHJ1JzpcbiAgICAgIHJldHVybiBSZWNvaWxfdHJlZUNhY2hlTFJVKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgbWF4U2l6ZTogUmVjb2lsX251bGx0aHJvd3MobWF4U2l6ZSksXG4gICAgICAgIG1hcE5vZGVWYWx1ZVxuICAgICAgfSk7XG5cbiAgICBjYXNlICdtb3N0LXJlY2VudCc6XG4gICAgICByZXR1cm4gUmVjb2lsX3RyZWVDYWNoZUxSVSh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIG1heFNpemU6IDEsXG4gICAgICAgIG1hcE5vZGVWYWx1ZVxuICAgICAgfSk7XG4gIH1cblxuICB0aHJvdyBSZWNvaWxfZXJyKGBVbnJlY29nbml6ZWQgZXZpY3Rpb24gcG9saWN5ICR7ZXZpY3Rpb259YCk7XG59XG5cbnZhciBSZWNvaWxfdHJlZUNhY2hlRnJvbVBvbGljeSA9IHRyZWVDYWNoZUZyb21Qb2xpY3k7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xuICB2YXIgX293bmVyRG9jdW1lbnQsIF9kb2MkZGVmYXVsdFZpZXc7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgZG9jID0gb2JqZWN0ICE9IG51bGwgPyAoX293bmVyRG9jdW1lbnQgPSBvYmplY3Qub3duZXJEb2N1bWVudCkgIT09IG51bGwgJiYgX293bmVyRG9jdW1lbnQgIT09IHZvaWQgMCA/IF9vd25lckRvY3VtZW50IDogb2JqZWN0IDogZG9jdW1lbnQ7XG4gIGNvbnN0IGRlZmF1bHRWaWV3ID0gKF9kb2MkZGVmYXVsdFZpZXcgPSBkb2MuZGVmYXVsdFZpZXcpICE9PSBudWxsICYmIF9kb2MkZGVmYXVsdFZpZXcgIT09IHZvaWQgMCA/IF9kb2MkZGVmYXVsdFZpZXcgOiB3aW5kb3c7XG4gIHJldHVybiAhIShvYmplY3QgIT0gbnVsbCAmJiAodHlwZW9mIGRlZmF1bHRWaWV3Lk5vZGUgPT09ICdmdW5jdGlvbicgPyBvYmplY3QgaW5zdGFuY2VvZiBkZWZhdWx0Vmlldy5Ob2RlIDogdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZycpKTtcbn1cblxudmFyIFJlY29pbF9pc05vZGUgPSBpc05vZGU7XG5cbmNvbnN0IHtcbiAgaXNSZWFjdE5hdGl2ZTogaXNSZWFjdE5hdGl2ZSQxLFxuICBpc1dpbmRvdzogaXNXaW5kb3ckMVxufSA9IFJlY29pbF9FbnZpcm9ubWVudDtcblxuXG5cblxuXG5mdW5jdGlvbiBzaG91bGROb3RCZUZyb3plbih2YWx1ZSkge1xuICAvLyBQcmltaXRpdmVzIGFuZCBmdW5jdGlvbnM6XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gUmVhY3QgZWxlbWVudHM6XG5cblxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZS4kJHR5cGVvZikge1xuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJbW11dGFibGUgc3RydWN0dXJlczpcblxuXG4gIGlmICh2YWx1ZVsnQEBfX0lNTVVUQUJMRV9JVEVSQUJMRV9fQEAnXSAhPSBudWxsIHx8IHZhbHVlWydAQF9fSU1NVVRBQkxFX0tFWUVEX19AQCddICE9IG51bGwgfHwgdmFsdWVbJ0BAX19JTU1VVEFCTEVfSU5ERVhFRF9fQEAnXSAhPSBudWxsIHx8IHZhbHVlWydAQF9fSU1NVVRBQkxFX09SREVSRURfX0BAJ10gIT0gbnVsbCB8fCB2YWx1ZVsnQEBfX0lNTVVUQUJMRV9SRUNPUkRfX0BAJ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIERPTSBub2RlczpcblxuXG4gIGlmIChSZWNvaWxfaXNOb2RlKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKFJlY29pbF9pc1Byb21pc2UodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBTb21lIGVudmlyb25tZW50cywganVzdCBhcyBKZXN0LCBkb24ndCB3b3JrIHdpdGggdGhlIGluc3RhbmNlb2YgY2hlY2tcblxuXG4gIGlmICghaXNSZWFjdE5hdGl2ZSQxICYmIGlzV2luZG93JDEodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IC8vIFJlY3Vyc2l2ZWx5IGZyZWV6ZSBhIHZhbHVlIHRvIGVuZm9yY2UgaXQgaXMgcmVhZC1vbmx5LlxuLy8gVGhpcyBtYXkgYWxzbyBoYXZlIG1pbmltYWwgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRzIGZvciBlbnVtZXJhdGluZ1xuLy8gb2JqZWN0cyAoYmFzZWQgb24gYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMsIG9mIGNvdXJzZSlcblxuXG5mdW5jdGlvbiBkZWVwRnJlZXplVmFsdWUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgc2hvdWxkTm90QmVGcm96ZW4odmFsdWUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgT2JqZWN0LmZyZWV6ZSh2YWx1ZSk7IC8vIE1ha2UgYWxsIHByb3BlcnRpZXMgcmVhZC1vbmx5XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAvLyAkRmxvd0lzc3VlW21ldGhvZC11bmJpbmRpbmddIGFkZGVkIHdoZW4gaW1wcm92aW5nIHR5cGluZyBmb3IgdGhpcyBwYXJhbWV0ZXJzXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgY29uc3QgcHJvcCA9IHZhbHVlW2tleV07IC8vIFByZXZlbnQgaW5maW5pdGUgcmVjdXJzc2lvbiBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcy5cblxuICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnb2JqZWN0JyAmJiBwcm9wICE9IG51bGwgJiYgIU9iamVjdC5pc0Zyb3plbihwcm9wKSkge1xuICAgICAgICBkZWVwRnJlZXplVmFsdWUocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LnNlYWwodmFsdWUpOyAvLyBUaGlzIGFsc28gbWFrZXMgZXhpc3RpbmcgcHJvcGVydGllcyBub24tY29uZmlndXJhYmxlLlxufVxuXG52YXIgUmVjb2lsX2RlZXBGcmVlemVWYWx1ZSA9IGRlZXBGcmVlemVWYWx1ZTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFRoaXMgaXMgYSBzdHViIGZvciBzb21lIGludGVncmF0aW9uIGludG8gRkIgaW50ZXJuYWwgc3R1ZmZcbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0UGVyZkJsb2NrKF9pZCkge1xuICByZXR1cm4gKCkgPT4gbnVsbDtcbn1cblxudmFyIFJlY29pbF9QZXJmb3JtYW5jZVRpbWluZ3MgPSB7XG4gIHN0YXJ0UGVyZkJsb2NrXG59O1xuXG5jb25zdCB7XG4gIGlzTG9hZGFibGU6IGlzTG9hZGFibGUkMSxcbiAgbG9hZGFibGVXaXRoRXJyb3I6IGxvYWRhYmxlV2l0aEVycm9yJDEsXG4gIGxvYWRhYmxlV2l0aFByb21pc2U6IGxvYWRhYmxlV2l0aFByb21pc2UkMSxcbiAgbG9hZGFibGVXaXRoVmFsdWU6IGxvYWRhYmxlV2l0aFZhbHVlJDJcbn0gPSBSZWNvaWxfTG9hZGFibGUkMTtcblxuY29uc3Qge1xuICBXcmFwcGVkVmFsdWU6IFdyYXBwZWRWYWx1ZSQxXG59ID0gUmVjb2lsX1dyYXBwZXIkMTtcblxuXG5cbmNvbnN0IHtcbiAgZ2V0Tm9kZUxvYWRhYmxlOiBnZXROb2RlTG9hZGFibGUkMixcbiAgcGVla05vZGVMb2FkYWJsZTogcGVla05vZGVMb2FkYWJsZSQxLFxuICBzZXROb2RlVmFsdWU6IHNldE5vZGVWYWx1ZSQzXG59ID0gUmVjb2lsX0Z1bmN0aW9uYWxDb3JlO1xuXG5jb25zdCB7XG4gIHNhdmVEZXBzVG9TdG9yZTogc2F2ZURlcHNUb1N0b3JlJDFcbn0gPSBSZWNvaWxfR3JhcGg7XG5cbmNvbnN0IHtcbiAgREVGQVVMVF9WQUxVRTogREVGQVVMVF9WQUxVRSQ2LFxuICBnZXRDb25maWdEZWxldGlvbkhhbmRsZXI6IGdldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQxLFxuICBnZXROb2RlOiBnZXROb2RlJDYsXG4gIHJlZ2lzdGVyTm9kZTogcmVnaXN0ZXJOb2RlJDFcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICBpc1JlY29pbFZhbHVlOiBpc1JlY29pbFZhbHVlJDNcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWUkMTtcblxuY29uc3Qge1xuICBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZDogbWFya1JlY29pbFZhbHVlTW9kaWZpZWQkMVxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcblxuY29uc3Qge1xuICByZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHQ6IHJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdCQxXG59ID0gUmVjb2lsX1JldGVudGlvbjtcblxuY29uc3Qge1xuICByZWNvaWxDYWxsYmFjazogcmVjb2lsQ2FsbGJhY2skMVxufSA9IFJlY29pbF91c2VSZWNvaWxDYWxsYmFjaztcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3Qge1xuICBzdGFydFBlcmZCbG9jazogc3RhcnRQZXJmQmxvY2skMVxufSA9IFJlY29pbF9QZXJmb3JtYW5jZVRpbWluZ3M7XG5cblxuXG5jbGFzcyBDYW5jZWxlZCB7fVxuXG5jb25zdCBDQU5DRUxFRCA9IG5ldyBDYW5jZWxlZCgpO1xuLyoqXG4gKiBBbiBFeGVjdXRpb25JRCBpcyBhbiBhcmJpdHJhcnkgSUQgdGhhdCBsZXRzIHVzIGRpc3Rpbmd1aXNoIGV4ZWN1dGlvbnMgZnJvbVxuICogZWFjaCBvdGhlci4gVGhpcyBpcyBuZWNlc3NhcnkgYXMgd2UgbmVlZCBhIHdheSBvZiBzb2x2aW5nIHRoaXMgcHJvYmxlbTpcbiAqIFwiZ2l2ZW4gMyBhc3luYyBleGVjdXRpb25zLCBvbmx5IHVwZGF0ZSBzdGF0ZSBmb3IgdGhlICdsYXRlc3QnIGV4ZWN1dGlvbiB3aGVuXG4gKiBpdCBmaW5pc2hlcyBydW5uaW5nIHJlZ2FyZGxlc3Mgb2Ygd2hlbiB0aGUgb3RoZXIgMiBmaW5pc2hcIi4gRXhlY3V0aW9uSURzXG4gKiBwcm92aWRlIGEgY29udmVuaWVudCB3YXkgb2YgaWRlbnRpZnlpbmcgZXhlY3V0aW9ucyBzbyB0aGF0IHdlIGNhbiB0cmFjayBhbmRcbiAqIG1hbmFnZSB0aGVtIG92ZXIgdGltZS5cbiAqL1xuXG5jb25zdCBkZXBlbmRlbmN5U3RhY2sgPSBbXTsgLy8gZm9yIGRldGVjdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG5cbmNvbnN0IHdhaXRpbmdTdG9yZXMgPSBuZXcgTWFwKCk7XG5cbmNvbnN0IGdldE5ld0V4ZWN1dGlvbklEID0gKCgpID0+IHtcbiAgbGV0IGV4ZWN1dGlvbklEID0gMDtcbiAgcmV0dXJuICgpID0+IGV4ZWN1dGlvbklEKys7XG59KSgpO1xuLyogZXNsaW50LWRpc2FibGUgbm8tcmVkZWNsYXJlICovXG5cblxuZnVuY3Rpb24gc2VsZWN0b3Iob3B0aW9ucykge1xuICBsZXQgcmVjb2lsVmFsdWUgPSBudWxsO1xuICBjb25zdCB7XG4gICAga2V5LFxuICAgIGdldCxcbiAgICBjYWNoZVBvbGljeV9VTlNUQUJMRTogY2FjaGVQb2xpY3lcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHNldCA9IG9wdGlvbnMuc2V0ICE9IG51bGwgPyBvcHRpb25zLnNldCA6IHVuZGVmaW5lZDsgLy8gZmxvd1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IFJlY29pbF9lcnIoJ0Ega2V5IG9wdGlvbiB3aXRoIGEgdW5pcXVlIHN0cmluZyB2YWx1ZSBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gY3JlYXRpbmcgYSBzZWxlY3Rvci4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGdldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgUmVjb2lsX2VycignU2VsZWN0b3JzIG11c3Qgc3BlY2lmeSBhIGdldCBjYWxsYmFjayBvcHRpb24gdG8gZ2V0IHRoZSBzZWxlY3RvciB2YWx1ZS4nKTtcbiAgICB9XG4gIH0gLy8gVGhpcyBpcyBldmVyeSBkaXNjb3ZlcmVkIGRlcGVuZGVuY3kgYWNyb3NzIGFsbCBleGVjdXRpb25zXG5cblxuICBjb25zdCBkaXNjb3ZlcmVkRGVwZW5kZW5jeU5vZGVLZXlzID0gbmV3IFNldCgpO1xuICBjb25zdCBjYWNoZSA9IFJlY29pbF90cmVlQ2FjaGVGcm9tUG9saWN5KGNhY2hlUG9saWN5ICE9PSBudWxsICYmIGNhY2hlUG9saWN5ICE9PSB2b2lkIDAgPyBjYWNoZVBvbGljeSA6IHtcbiAgICBlcXVhbGl0eTogJ3JlZmVyZW5jZScsXG4gICAgZXZpY3Rpb246ICdrZWVwLWFsbCdcbiAgfSwga2V5KTtcbiAgY29uc3QgcmV0YWluZWRCeSA9IHJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdCQxKG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRSk7XG4gIGNvbnN0IGV4ZWN1dGlvbkluZm9NYXAgPSBuZXcgTWFwKCk7XG4gIGxldCBsaXZlU3RvcmVzQ291bnQgPSAwO1xuXG4gIGZ1bmN0aW9uIHNlbGVjdG9ySXNMaXZlKCkge1xuICAgIHJldHVybiAhUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSB8fCBsaXZlU3RvcmVzQ291bnQgPiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0b3JJbml0KHN0b3JlKSB7XG4gICAgc3RvcmUuZ2V0U3RhdGUoKS5rbm93blNlbGVjdG9ycy5hZGQoa2V5KTtcbiAgICBsaXZlU3RvcmVzQ291bnQrKztcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGl2ZVN0b3Jlc0NvdW50LS07XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdG9yU2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlKCkge1xuICAgIHJldHVybiBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMShrZXkpICE9PSB1bmRlZmluZWQgJiYgIXNlbGVjdG9ySXNMaXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlQXN5bmMoc3RvcmUsIHN0YXRlLCBleGVjdXRpb25JRCwgbG9hZGFibGUsIGRlcFZhbHVlcykge1xuICAgIHNldENhY2hlKHN0YXRlLCBsb2FkYWJsZSwgZGVwVmFsdWVzKTtcbiAgICBub3RpZnlTdG9yZXNPZlJlc29sdmVkQXN5bmMoc3RvcmUsIGV4ZWN1dGlvbklEKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeVN0b3Jlc09mUmVzb2x2ZWRBc3luYyhzdG9yZSwgZXhlY3V0aW9uSUQpIHtcbiAgICBpZiAoaXNMYXRlc3RFeGVjdXRpb24oc3RvcmUsIGV4ZWN1dGlvbklEKSkge1xuICAgICAgY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKTtcbiAgICB9XG5cbiAgICBub3RpZnlXYWl0aW5nU3RvcmVzKGV4ZWN1dGlvbklELCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogTm90aWZ5IHN0b3JlcyB0byBwdWxsIHRoZSBzZWxlY3RvciBhZ2FpbiBpZiBhIG5ldyBhc3luYyBkZXAgd2FzIGRpc2NvdmVyZWQuXG4gICAqIDEpIEFzeW5jIHNlbGVjdG9yIGFkZHMgYSBuZXcgZGVwIGJ1dCBkb2Vzbid0IHJlc29sdmUgeWV0LlxuICAgKiAgICBOb3RlIHRoYXQgZGVwcyBmb3IgYW4gYXN5bmMgc2VsZWN0b3IgYXJlIGJhc2VkIG9uIHRoZSBzdGF0ZSB3aGVuIHRoZVxuICAgKiAgICBldmFsdWF0aW9uIHN0YXJ0ZWQsIGluIG9yZGVyIHRvIHByb3ZpZGUgYSBjb25zaXN0ZW50IHBpY3R1cmUgb2Ygc3RhdGUuXG4gICAqIDIpIEJ1dCwgbmV3IHZhbHVlIG9mIGRlcCBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZSBtaWdodCBjYXVzZSB0aGUgc2VsZWN0b3JcbiAgICogICAgdG8gcmVzb2x2ZSBvciByZXNvbHZlIGRpZmZlcmVudGx5LlxuICAgKiAzKSBUaGVyZWZvcmUsIHRoaXMgbm90aWZpY2F0aW9uIHdpbGwgcHVsbCB0aGUgc2VsZWN0b3IgYmFzZWQgb24gdGhlIGN1cnJlbnRcbiAgICogICAgc3RhdGUgZm9yIHRoZSBjb21wb25lbnRzXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbm90aWZ5U3RvcmVzT2ZOZXdBc3luY0RlcChzdG9yZSwgZXhlY3V0aW9uSUQpIHtcbiAgICBpZiAoaXNMYXRlc3RFeGVjdXRpb24oc3RvcmUsIGV4ZWN1dGlvbklEKSkge1xuICAgICAgY29uc3QgZXhlY3V0aW9uSW5mbyA9IFJlY29pbF9udWxsdGhyb3dzKGdldEV4ZWN1dGlvbkluZm8oc3RvcmUpKTtcbiAgICAgIGV4ZWN1dGlvbkluZm8uc3RhdGVWZXJzaW9ucy5jbGVhcigpO1xuICAgICAgbm90aWZ5V2FpdGluZ1N0b3JlcyhleGVjdXRpb25JRCwgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeVdhaXRpbmdTdG9yZXMoZXhlY3V0aW9uSUQsIGNsZWFyV2FpdGxpc3QpIHtcbiAgICBjb25zdCBzdG9yZXMgPSB3YWl0aW5nU3RvcmVzLmdldChleGVjdXRpb25JRCk7XG5cbiAgICBpZiAoc3RvcmVzICE9IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3Qgd2FpdGluZ1N0b3JlIG9mIHN0b3Jlcykge1xuICAgICAgICBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCQxKHdhaXRpbmdTdG9yZSwgUmVjb2lsX251bGx0aHJvd3MocmVjb2lsVmFsdWUpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsZWFyV2FpdGxpc3QpIHtcbiAgICAgICAgd2FpdGluZ1N0b3Jlcy5kZWxldGUoZXhlY3V0aW9uSUQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtTdG9yZVdhaXRpbmdGb3JSZXNvbHZlZEFzeW5jKHN0b3JlLCBleGVjdXRpb25JRCkge1xuICAgIGxldCBzdG9yZXMgPSB3YWl0aW5nU3RvcmVzLmdldChleGVjdXRpb25JRCk7XG5cbiAgICBpZiAoc3RvcmVzID09IG51bGwpIHtcbiAgICAgIHdhaXRpbmdTdG9yZXMuc2V0KGV4ZWN1dGlvbklELCBzdG9yZXMgPSBuZXcgU2V0KCkpO1xuICAgIH1cblxuICAgIHN0b3Jlcy5hZGQoc3RvcmUpO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGF0dGFjaGVzIGEgdGhlbigpIGFuZCBhIGNhdGNoKCkgdG8gYSBwcm9taXNlIHRoYXQgd2FzXG4gICAqIHJldHVybmVkIGZyb20gYSBzZWxlY3RvcidzIGdldCgpIChlaXRoZXIgZXhwbGljaXRseSBvciBpbXBsaWNpdGx5IGJ5XG4gICAqIHJ1bm5pbmcgYSBmdW5jdGlvbiB0aGF0IHVzZXMgdGhlIFwiYXN5bmNcIiBrZXl3b3JkKS4gSWYgYSBzZWxlY3RvcidzIGdldCgpXG4gICAqIHJldHVybnMgYSBwcm9taXNlLCB3ZSBoYXZlIHR3byBwb3NzaWJpbGl0aWVzOlxuICAgKlxuICAgKiAxLiBUaGUgcHJvbWlzZSB3aWxsIHJlc29sdmUsIGluIHdoaWNoIGNhc2UgaXQgd2lsbCBoYXZlIGNvbXBsZXRlbHkgZmluaXNoZWRcbiAgICogICAgZXhlY3V0aW5nIHdpdGhvdXQgYW55IHJlbWFpbmluZyBwZW5kaW5nIGRlcGVuZGVuY2llcy4gTm8gbW9yZSByZXRyaWVzXG4gICAqICAgIGFyZSBuZWVkZWQgYW5kIHdlIGNhbiBwcm9jZWVkIHdpdGggdXBkYXRpbmcgdGhlIGNhY2hlIGFuZCBub3RpZnlpbmdcbiAgICogICAgc3Vic2NyaWJlcnMgKGlmIGl0IGlzIHRoZSBsYXRlc3QgZXhlY3V0aW9uLCBvdGhlcndpc2Ugb25seSB0aGUgY2FjaGVcbiAgICogICAgd2lsbCBiZSB1cGRhdGVkIGFuZCBzdWJzY3JpcHRpb25zIHdpbGwgbm90IGJlIGZpcmVkKS4gVGhpcyBpcyB0aGUgY2FzZVxuICAgKiAgICBoYW5kbGVkIGJ5IHRoZSBhdHRhY2hlZCB0aGVuKCkgaGFuZGxlci5cbiAgICpcbiAgICogMi4gVGhlIHByb21pc2Ugd2lsbCB0aHJvdyBiZWNhdXNlIGl0IGVpdGhlciBoYXMgYW4gZXJyb3Igb3IgaXQgY2FtZSBhY3Jvc3NcbiAgICogICAgYW4gYXN5bmMgZGVwZW5kZW5jeSB0aGF0IGhhcyBub3QgeWV0IHJlc29sdmVkLCBpbiB3aGljaCBjYXNlIHdlIHdpbGxcbiAgICogICAgY2FsbCB3cmFwRGVwZGVuY3lQcm9taXNlKCksIHdob3NlIHJlc3BvbnNpYmlsaXR5IGlzIHRvIGhhbmRsZSBkZXBlbmRlbmN5XG4gICAqICAgIHByb21pc2VzLiBUaGlzIGNhc2UgaXMgaGFuZGxlZCBieSB0aGUgYXR0YWNoZWQgY2F0Y2goKSBoYW5kbGVyLlxuICAgKlxuICAgKiBCb3RoIGJyYW5jaGVzIHdpbGwgZXZlbnR1YWxseSByZXNvbHZlIHRvIHRoZSBmaW5hbCByZXN1bHQgb2YgdGhlIHNlbGVjdG9yXG4gICAqIChvciBhbiBlcnJvciBpZiBhIHJlYWwgZXJyb3Igb2NjdXJyZWQpLlxuICAgKlxuICAgKiBUaGUgZXhlY3V0aW9uIHdpbGwgcnVuIHRvIGNvbXBsZXRpb24gZXZlbiBpZiBpdCBpcyBzdGFsZSwgYW5kIGl0cyB2YWx1ZVxuICAgKiB3aWxsIGJlIGNhY2hlZC4gQnV0IHN0YWxlIGV4ZWN1dGlvbnMgd2lsbCBub3QgdXBkYXRlIGdsb2JhbCBzdGF0ZSBvciB1cGRhdGVcbiAgICogZXhlY3V0aW9uSW5mbyBhcyB0aGF0IGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgJ2xhdGVzdCcgZXhlY3V0aW9uLlxuICAgKlxuICAgKiBOb3RlIHRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSBwYXNzZWQgYSBwcm9taXNlIHRoYXQgd2FzIHRocm93bi0tQUtBIGFcbiAgICogZGVwZW5kZW5jeSBwcm9taXNlLiBEZXBlbmRlbmN5IHByb21pc2VzIHNob3VsZCBiZSBwYXNzZWQgdG9cbiAgICogd3JhcFBlbmRpbmdEZXBlbmRlbmN5UHJvbWlzZSgpKS5cbiAgICovXG5cblxuICBmdW5jdGlvbiB3cmFwUmVzdWx0UHJvbWlzZShzdG9yZSwgcHJvbWlzZSwgc3RhdGUsIGRlcFZhbHVlcywgZXhlY3V0aW9uSUQsIGxvYWRpbmdEZXBzU3RhdGUpIHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKHZhbHVlID0+IHtcbiAgICAgIGlmICghc2VsZWN0b3JJc0xpdmUoKSkge1xuICAgICAgICAvLyBUaGUgc2VsZWN0b3Igd2FzIHJlbGVhc2VkIHNpbmNlIHRoZSByZXF1ZXN0IGJlZ2FuOyBpZ25vcmUgdGhlIHJlc3BvbnNlLlxuICAgICAgICBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpO1xuICAgICAgICB0aHJvdyBDQU5DRUxFRDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9hZGFibGUgPSBsb2FkYWJsZVdpdGhWYWx1ZSQyKHZhbHVlKTtcbiAgICAgIHJlc29sdmVBc3luYyhzdG9yZSwgc3RhdGUsIGV4ZWN1dGlvbklELCBsb2FkYWJsZSwgZGVwVmFsdWVzKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KS5jYXRjaChlcnJvck9yUHJvbWlzZSA9PiB7XG4gICAgICBpZiAoIXNlbGVjdG9ySXNMaXZlKCkpIHtcbiAgICAgICAgLy8gVGhlIHNlbGVjdG9yIHdhcyByZWxlYXNlZCBzaW5jZSB0aGUgcmVxdWVzdCBiZWdhbjsgaWdub3JlIHRoZSByZXNwb25zZS5cbiAgICAgICAgY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKTtcbiAgICAgICAgdGhyb3cgQ0FOQ0VMRUQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKGVycm9yT3JQcm9taXNlKSkge1xuICAgICAgICByZXR1cm4gd3JhcFBlbmRpbmdEZXBlbmRlbmN5UHJvbWlzZShzdG9yZSwgZXJyb3JPclByb21pc2UsIHN0YXRlLCBkZXBWYWx1ZXMsIGV4ZWN1dGlvbklELCBsb2FkaW5nRGVwc1N0YXRlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9hZGFibGUgPSBsb2FkYWJsZVdpdGhFcnJvciQxKGVycm9yT3JQcm9taXNlKTtcbiAgICAgIHJlc29sdmVBc3luYyhzdG9yZSwgc3RhdGUsIGV4ZWN1dGlvbklELCBsb2FkYWJsZSwgZGVwVmFsdWVzKTtcbiAgICAgIHRocm93IGVycm9yT3JQcm9taXNlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGF0dGFjaGVzIGEgdGhlbigpIGFuZCBhIGNhdGNoKCkgdG8gYSBwcm9taXNlIHRoYXQgd2FzXG4gICAqIHRocm93biBmcm9tIGEgc2VsZWN0b3IncyBnZXQoKS4gSWYgYSBzZWxlY3RvcidzIGdldCgpIHRocm93cyBhIHByb21pc2UsXG4gICAqIHdlIGhhdmUgdHdvIHBvc3NpYmlsaXRpZXM6XG4gICAqXG4gICAqIDEuIFRoZSBwcm9taXNlIHdpbGwgcmVzb2x2ZSwgbWVhbmluZyBvbmUgb2Ygb3VyIHNlbGVjdG9yJ3MgZGVwZW5kZW5jaWVzIGlzXG4gICAqICAgIG5vdyBhdmFpbGFibGUgYW5kIHdlIHNob3VsZCBcInJldHJ5XCIgb3VyIGdldCgpIGJ5IHJ1bm5pbmcgaXQgYWdhaW4uIFRoaXNcbiAgICogICAgaXMgdGhlIGNhc2UgaGFuZGxlZCBieSB0aGUgYXR0YWNoZWQgdGhlbigpIGhhbmRsZXIuXG4gICAqXG4gICAqIDIuIFRoZSBwcm9taXNlIHdpbGwgdGhyb3cgYmVjYXVzZSBzb21ldGhpbmcgd2VudCB3cm9uZyB3aXRoIHRoZSBkZXBlbmRlbmN5XG4gICAqICAgIHByb21pc2UgKGluIG90aGVyIHdvcmRzIGEgcmVhbCBlcnJvciBvY2N1cnJlZCkuIFRoaXMgY2FzZSBpcyBoYW5kbGVkIGJ5XG4gICAqICAgIHRoZSBhdHRhY2hlZCBjYXRjaCgpIGhhbmRsZXIuIElmIHRoZSBkZXBlbmRlbmN5IHByb21pc2UgdGhyb3dzLCBpdCBpc1xuICAgKiAgICBfYWx3YXlzXyBhIHJlYWwgZXJyb3IgYW5kIG5vdCBhbm90aGVyIGRlcGVuZGVuY3kgcHJvbWlzZSAoYW55IGRlcGVuZGVuY3lcbiAgICogICAgcHJvbWlzZXMgd291bGQgaGF2ZSBiZWVuIGhhbmRsZWQgdXBzdHJlYW0pLlxuICAgKlxuICAgKiBUaGUgdGhlbigpIGJyYW5jaCB3aWxsIGV2ZW50dWFsbHkgcmVzb2x2ZSB0byB0aGUgZmluYWwgcmVzdWx0IG9mIHRoZVxuICAgKiBzZWxlY3RvciAob3IgYW4gZXJyb3IgaWYgYSByZWFsIGVycm9yIG9jY3VycyksIGFuZCB0aGUgY2F0Y2goKSB3aWxsIGFsd2F5c1xuICAgKiByZXNvbHZlIHRvIGFuIGVycm9yIGJlY2F1c2UgdGhlIGRlcGVuZGVuY3kgcHJvbWlzZSBpcyBhIHByb21pc2UgdGhhdCB3YXNcbiAgICogd3JhcHBlZCB1cHN0cmVhbSwgbWVhbmluZyBpdCB3aWxsIG9ubHkgcmVzb2x2ZSB0byBpdHMgcmVhbCB2YWx1ZSBvciB0byBhXG4gICAqIHJlYWwgZXJyb3IuXG4gICAqXG4gICAqIFRoZSBleGVjdXRpb24gd2lsbCBydW4gdG8gY29tcGxldGlvbiBldmVuIGlmIGl0IGlzIHN0YWxlLCBhbmQgaXRzIHZhbHVlXG4gICAqIHdpbGwgYmUgY2FjaGVkLiBCdXQgc3RhbGUgZXhlY3V0aW9ucyB3aWxsIG5vdCB1cGRhdGUgZ2xvYmFsIHN0YXRlIG9yIHVwZGF0ZVxuICAgKiBleGVjdXRpb25JbmZvIGFzIHRoYXQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSAnbGF0ZXN0JyBleGVjdXRpb24uXG4gICAqXG4gICAqIE5vdGUgdGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlIHBhc3NlZCBhIHByb21pc2UgdGhhdCB3YXMgcmV0dXJuZWQgZnJvbVxuICAgKiBnZXQoKS4gVGhlIGludGVudGlvbiBpcyB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgb25seSBwYXNzZWQgcHJvbWlzZXMgdGhhdFxuICAgKiB3ZXJlIHRocm93biBkdWUgdG8gYSBwZW5kaW5nIGRlcGVuZGVuY3kuIFByb21pc2VzIHJldHVybmVkIGJ5IGdldCgpIHNob3VsZFxuICAgKiBiZSBwYXNzZWQgdG8gd3JhcFJlc3VsdFByb21pc2UoKSBpbnN0ZWFkLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHdyYXBQZW5kaW5nRGVwZW5kZW5jeVByb21pc2Uoc3RvcmUsIHByb21pc2UsIHN0YXRlLCBleGlzdGluZ0RlcHMsIGV4ZWN1dGlvbklELCBsb2FkaW5nRGVwc1N0YXRlKSB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbihyZXNvbHZlZERlcCA9PiB7XG4gICAgICBpZiAoIXNlbGVjdG9ySXNMaXZlKCkpIHtcbiAgICAgICAgLy8gVGhlIHNlbGVjdG9yIHdhcyByZWxlYXNlZCBzaW5jZSB0aGUgcmVxdWVzdCBiZWdhbjsgaWdub3JlIHRoZSByZXNwb25zZS5cbiAgICAgICAgY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKTtcbiAgICAgICAgdGhyb3cgQ0FOQ0VMRUQ7XG4gICAgICB9IC8vIENoZWNrIGlmIHdlIGFyZSBoYW5kbGluZyBhIHBlbmRpbmcgUmVjb2lsIGRlcGVuZGVuY3kgb3IgaWYgdGhlIHVzZXJcbiAgICAgIC8vIHRocmV3IHRoZWlyIG93biBQcm9taXNlIHRvIFwic3VzcGVuZFwiIGEgc2VsZWN0b3IgZXZhbHVhdGlvbi4gIFdlIG5lZWRcbiAgICAgIC8vIHRvIGNoZWNrIHRoYXQgdGhlIGxvYWRpbmdEZXBQcm9taXNlIGFjdHVhbGx5IG1hdGNoZXMgdGhlIHByb21pc2UgdGhhdFxuICAgICAgLy8gd2UgY2F1Z2h0IGluIGNhc2UgdGhlIHNlbGVjdG9yIGhhcHBlbmVkIHRvIGNhdGNoIHRoZSBwcm9taXNlIHdlIHRocmV3XG4gICAgICAvLyBmb3IgYSBwZW5kaW5nIFJlY29pbCBkZXBlbmRlbmN5IGZyb20gYGdldFJlY29pbFZhbHVlKClgIGFuZCB0aHJld1xuICAgICAgLy8gdGhlaXIgb3duIHByb21pc2UgaW5zdGVhZC5cblxuXG4gICAgICBpZiAobG9hZGluZ0RlcHNTdGF0ZS5sb2FkaW5nRGVwS2V5ICE9IG51bGwgJiYgbG9hZGluZ0RlcHNTdGF0ZS5sb2FkaW5nRGVwUHJvbWlzZSA9PT0gcHJvbWlzZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogTm90ZSBmb3IgYXN5bmMgYXRvbXMsIHRoaXMgbWVhbnMgd2UgYXJlIGNoYW5naW5nIHRoZSBhdG9tJ3MgdmFsdWVcbiAgICAgICAgICogaW4gdGhlIHN0b3JlIGZvciB0aGUgZ2l2ZW4gdmVyc2lvbi4gVGhpcyBzaG91bGQgYmUgYWxyaWdodCBiZWNhdXNlXG4gICAgICAgICAqIHRoZSB2ZXJzaW9uIG9mIHN0YXRlIGlzIG5vdyBzdGFsZSBhbmQgYSBuZXcgdmVyc2lvbiB3aWxsIGhhdmVcbiAgICAgICAgICogYWxyZWFkeSBiZWVuIHRyaWdnZXJlZCBieSB0aGUgYXRvbSBiZWluZyByZXNvbHZlZCAoc2VlIHRoaXMgbG9naWNcbiAgICAgICAgICogaW4gUmVjb2lsX2F0b20uanMpXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0ZS5hdG9tVmFsdWVzLnNldChsb2FkaW5nRGVwc1N0YXRlLmxvYWRpbmdEZXBLZXksIGxvYWRhYmxlV2l0aFZhbHVlJDIocmVzb2x2ZWREZXApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiByZXNvbHZlZERlcEtleSBpcyBub3QgZGVmaW5lZCwgdGhlIHByb21pc2Ugd2FzIGEgdXNlci10aHJvd25cbiAgICAgICAgICogcHJvbWlzZS4gVXNlci10aHJvd24gcHJvbWlzZXMgYXJlIGFuIGFkdmFuY2VkIGZlYXR1cmUgYW5kIHRoZXlcbiAgICAgICAgICogc2hvdWxkIGJlIGF2b2lkZWQgaW4gYWxtb3N0IGFsbCBjYXNlcy4gVXNpbmcgYGxvYWRhYmxlLm1hcCgpYCBpbnNpZGVcbiAgICAgICAgICogb2Ygc2VsZWN0b3JzIGZvciBsb2FkaW5nIGxvYWRhYmxlcyBhbmQgdGhlbiB0aHJvd2luZyB0aGF0IG1hcHBlZFxuICAgICAgICAgKiBsb2FkYWJsZSdzIHByb21pc2UgaXMgYW4gZXhhbXBsZSBvZiBhIHVzZXItdGhyb3duIHByb21pc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gd2UgaGl0IGEgdXNlci10aHJvd24gcHJvbWlzZSwgd2UgaGF2ZSB0byBiYWlsIG91dCBvZiBhbiBvcHRpbWl6YXRpb25cbiAgICAgICAgICogd2hlcmUgd2UgYnlwYXNzIGNhbGN1bGF0aW5nIHNlbGVjdG9yIGNhY2hlIGtleXMgZm9yIHNlbGVjdG9ycyB0aGF0XG4gICAgICAgICAqIGhhdmUgYmVlbiBwcmV2aW91c2x5IHNlZW4gZm9yIGEgZ2l2ZW4gc3RhdGUgKHRoZXNlIHNlbGVjdG9ycyBhcmUgc2F2ZWQgaW5cbiAgICAgICAgICogc3RhdGUuYXRvbVZhbHVlcykgdG8gYXZvaWQgc3RhbGUgc3RhdGUgYXMgd2UgaGF2ZSBubyB3YXkgb2Yga25vd2luZ1xuICAgICAgICAgKiB3aGF0IHN0YXRlIGNoYW5nZXMgaGFwcGVuZWQgKGlmIGFueSkgaW4gcmVzdWx0IHRvIHRoZSBwcm9taXNlIHJlc29sdmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWRlYWxseSB3ZSB3b3VsZCBvbmx5IGJhaWwgb3V0IHNlbGVjdG9ycyB0aGF0IGFyZSBpbiB0aGUgY2hhaW4gb2ZcbiAgICAgICAgICogZGVwZW5kZW5jaWVzIGZvciB0aGlzIHNlbGVjdG9yLCBidXQgdGhlcmUncyBjdXJyZW50bHkgbm8gd2F5IHRvIGdldFxuICAgICAgICAgKiBhIGZ1bGwgbGlzdCBvZiBhIHNlbGVjdG9yJ3MgZG93bnN0cmVhbSBub2RlcyBiZWNhdXNlIHRoZSBzdGF0ZSB0aGF0XG4gICAgICAgICAqIGlzIGV4ZWN1dGluZyBtYXkgYmUgYSBkaXNjYXJkZWQgdHJlZSAoc28gc3RvcmUuZ2V0R3JhcGgoc3RhdGUudmVyc2lvbilcbiAgICAgICAgICogd2lsbCBiZSBlbXB0eSksIGFuZCB0aGUgZnVsbCBkZXAgdHJlZSBtYXkgbm90IGJlIGluIHRoZSBzZWxlY3RvclxuICAgICAgICAgKiBjYWNoZXMgaW4gdGhlIGNhc2Ugd2hlcmUgdGhlIHNlbGVjdG9yJ3MgY2FjaGUgd2FzIGNsZWFyZWQuIFRvIHNvbHZlXG4gICAgICAgICAqIGZvciB0aGlzIHdlIHdvdWxkIGhhdmUgdG8ga2VlcCB0cmFjayBvZiBhbGwgcnVubmluZyBzZWxlY3RvclxuICAgICAgICAgKiBleGVjdXRpb25zIGFuZCB0aGVpciBkb3duc3RyZWFtIGRlcHMuIEJlY2F1c2UgdGhpcyBvbmx5IGNvdmVycyBlZGdlXG4gICAgICAgICAqIGNhc2VzLCB0aGF0IGNvbXBsZXhpdHkgbWlnaHQgbm90IGJlIGp1c3RpZnlhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5rbm93blNlbGVjdG9ycy5mb3JFYWNoKG5vZGVLZXkgPT4ge1xuICAgICAgICAgIHN0YXRlLmF0b21WYWx1ZXMuZGVsZXRlKG5vZGVLZXkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogT3B0aW1pemF0aW9uOiBOb3cgdGhhdCB0aGUgZGVwZW5kZW5jeSBoYXMgcmVzb2x2ZWQsIGxldCdzIHRyeSBoaXR0aW5nXG4gICAgICAgKiB0aGUgY2FjaGUgaW4gY2FzZSB0aGUgZGVwIHJlc29sdmVkIHRvIGEgdmFsdWUgd2UgaGF2ZSBwcmV2aW91c2x5IHNlZW4uXG4gICAgICAgKlxuICAgICAgICogVE9ETzpcbiAgICAgICAqIE5vdGUgdGhpcyBvcHRpbWl6YXRpb24gaXMgbm90IHBlcmZlY3QgYmVjYXVzZSBpdCBvbmx5IHByZXZlbnRzIHJlLWV4ZWN1dGlvbnNcbiAgICAgICAqIF9hZnRlcl8gdGhlIHBvaW50IHdoZXJlIGFuIGFzeW5jIGRlcGVuZGVuY3kgaXMgZm91bmQuIEFueSBjb2RlIGxlYWRpbmdcbiAgICAgICAqIHVwIHRvIHRoZSBhc3luYyBkZXBlbmRlbmN5IG1heSBoYXZlIHJ1biB1bm5lY2Vzc2FyaWx5LiBUaGUgaWRlYWwgY2FzZVxuICAgICAgICogd291bGQgYmUgdG8gd2FpdCBmb3IgdGhlIGFzeW5jIGRlcGVuZGVuY3kgdG8gcmVzb2x2ZSBmaXJzdCwgY2hlY2sgdGhlXG4gICAgICAgKiBjYWNoZSwgYW5kIHByZXZlbnQgX2FueV8gZXhlY3V0aW9uIG9mIHRoZSBzZWxlY3RvciBpZiB0aGUgcmVzdWx0aW5nXG4gICAgICAgKiB2YWx1ZSBvZiB0aGUgZGVwZW5kZW5jeSBsZWFkcyB0byBhIHBhdGggdGhhdCBpcyBmb3VuZCBpbiB0aGUgY2FjaGUuXG4gICAgICAgKiBUaGUgaWRlYWwgY2FzZSBpcyBtb3JlIGRpZmZpY3VsdCB0byBpbXBsZW1lbnQgYXMgaXQgd291bGQgcmVxdWlyZSB0aGF0XG4gICAgICAgKiB3ZSBjYXB0dXJlIGFuZCB3YWl0IGZvciB0aGUgdGhlIGFzeW5jIGRlcGVuZGVuY3kgcmlnaHQgYWZ0ZXIgY2hlY2tpbmdcbiAgICAgICAqIHRoZSBjYWNoZS4gVGhlIGN1cnJlbnQgYXBwcm9hY2ggdGFrZXMgYWR2YW50YWdlIG9mIHRoZSBmYWN0IHRoYXQgcnVubmluZ1xuICAgICAgICogdGhlIHNlbGVjdG9yIGFscmVhZHkgaGFzIGEgY29kZSBwYXRoIHRoYXQgbGV0cyB1cyBleGl0IGVhcmx5IHdoZW5cbiAgICAgICAqIGFuIGFzeW5jIGRlcCByZXNvbHZlcy5cbiAgICAgICAqL1xuXG5cbiAgICAgIGNvbnN0IGNhY2hlZExvYWRhYmxlID0gZ2V0TG9hZGFibGVGcm9tQ2FjaGVBbmRVcGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSk7XG5cbiAgICAgIGlmIChjYWNoZWRMb2FkYWJsZSAmJiBjYWNoZWRMb2FkYWJsZS5zdGF0ZSAhPT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGhhcyB0byBub3RpZnkgc3RvcmVzIG9mIGEgcmVzb2x2ZWQgYXN5bmMsIGV2ZW4gaWYgdGhlcmUgaXMgbm9cbiAgICAgICAgICogY3VycmVudCBwZW5kaW5nIGV4ZWN1dGlvbiBmb3IgdGhlIGZvbGxvd2luZyBjYXNlOlxuICAgICAgICAgKiAxKSBBIGNvbXBvbmVudCByZW5kZXJzIHdpdGggdGhpcyBwZW5kaW5nIGxvYWRhYmxlLlxuICAgICAgICAgKiAyKSBUaGUgdXBzdHJlYW0gZGVwZW5kZW5jeSByZXNvbHZlcy5cbiAgICAgICAgICogMykgV2hpbGUgcHJvY2Vzc2luZyBzb21lIG90aGVyIHNlbGVjdG9yIGl0IHJlYWRzIHRoaXMgb25lLCBzdWNoIGFzXG4gICAgICAgICAqICAgIHdoaWxlIHRyYXZlcnNpbmcgaXRzIGRlcGVuZGVuY2llcy4gIEF0IHRoaXMgcG9pbnQgaXQgZ2V0cyB0aGVcbiAgICAgICAgICogICAgbmV3IHJlc29sdmVkIHZhbHVlIHN5bmNocm9ub3VzbHkgYW5kIGNsZWFycyB0aGUgY3VycmVudFxuICAgICAgICAgKiAgICBleGVjdXRpb24gSUQuICBUaGUgY29tcG9uZW50IHdhc24ndCBnZXR0aW5nIHRoZSB2YWx1ZSBpdHNlbGYsXG4gICAgICAgICAqICAgIHRob3VnaCwgc28gaXQgc3RpbGwgaGFzIHRoZSBwZW5kaW5nIGxvYWRhYmxlLlxuICAgICAgICAgKiA0KSBXaGVuIHRoaXMgY29kZSBleGVjdXRlcyB0aGUgY3VycmVudCBleGVjdXRpb24gaWQgd2FzIGNsZWFyZWRcbiAgICAgICAgICogICAgYW5kIGl0IHdvdWxkbid0IG5vdGlmeSB0aGUgY29tcG9uZW50IG9mIHRoZSBuZXcgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEkgdGhpbmsgdGhpcyBpcyBvbmx5IGFuIGlzc3VlIHdpdGggXCJlYXJseVwiIHJlbmRlcmluZyBzaW5jZSB0aGVcbiAgICAgICAgICogY29tcG9uZW50cyBnb3QgdGhlaXIgdmFsdWUgdXNpbmcgdGhlIGluLXByb2dyZXNzIGV4ZWN1dGlvbi5cbiAgICAgICAgICogV2UgZG9uJ3QgaGF2ZSBhIHVuaXQgdGVzdCBmb3IgdGhpcyBjYXNlIHlldC4gIEknbSBub3Qgc3VyZSBpdCBpc1xuICAgICAgICAgKiBuZWNlc3Nhcnkgd2l0aCByZWNvaWxfdHJhbnNpdGlvbl9zdXBwb3J0IG1vZGUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNMYXRlc3RFeGVjdXRpb24oc3RvcmUsIGV4ZWN1dGlvbklEKSB8fCBnZXRFeGVjdXRpb25JbmZvKHN0b3JlKSA9PSBudWxsKSB7XG4gICAgICAgICAgbm90aWZ5U3RvcmVzT2ZSZXNvbHZlZEFzeW5jKHN0b3JlLCBleGVjdXRpb25JRCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2FjaGVkTG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGVkTG9hZGFibGUuY29udGVudHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgY2FjaGVkTG9hZGFibGUuY29udGVudHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogSWYgdGhpcyBleGVjdXRpb24gaXMgc3RhbGUsIGxldCdzIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBzb21lIGluXG4gICAgICAgKiBwcm9ncmVzcyBleGVjdXRpb24gd2l0aCBhIG1hdGNoaW5nIHN0YXRlLiBJZiB3ZSBmaW5kIGEgbWF0Y2gsIHRoZW5cbiAgICAgICAqIHdlIGNhbiB0YWtlIHRoZSB2YWx1ZSBmcm9tIHRoYXQgaW4tcHJvZ3Jlc3MgZXhlY3V0aW9uLiBOb3RlIHRoaXMgbWF5XG4gICAgICAgKiBzb3VuZCBsaWtlIGFuIGVkZ2UgY2FzZSwgYnV0IG1heSBiZSB2ZXJ5IGNvbW1vbiBpbiBjYXNlcyB3aGVyZSBhXG4gICAgICAgKiBsb2FkaW5nIGRlcGVuZGVuY3kgcmVzb2x2ZXMgZnJvbSBsb2FkaW5nIHRvIGhhdmluZyBhIHZhbHVlICh0aHVzXG4gICAgICAgKiBwb3NzaWJseSB0cmlnZ2VyaW5nIGEgcmUtcmVuZGVyKSwgYW5kIFJlYWN0IHJlLXJlbmRlcnMgYmVmb3JlIHRoZVxuICAgICAgICogY2hhaW5lZCAudGhlbigpIGZ1bmN0aW9ucyBydW4sIHRodXMgc3RhcnRpbmcgYSBuZXcgZXhlY3V0aW9uIGFzIHRoZVxuICAgICAgICogZGVwIGhhcyBjaGFuZ2VkIHZhbHVlLiBXaXRob3V0IHRoaXMgY2hlY2sgd2Ugd2lsbCBydW4gdGhlIHNlbGVjdG9yXG4gICAgICAgKiB0d2ljZSAob25jZSBpbiB0aGUgbmV3IGV4ZWN1dGlvbiBhbmQgb25jZSBhZ2FpbiBpbiB0aGlzIC50aGVuKCksIHNvXG4gICAgICAgKiB0aGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBrZWVwIHVubmVjZXNzYXJ5IHJlLWV4ZWN1dGlvbnMgdG8gYVxuICAgICAgICogbWluaW11bSkuXG4gICAgICAgKlxuICAgICAgICogQWxzbyBub3RlIHRoaXMgY29kZSBkb2VzIG5vdCBjaGVjayBhY3Jvc3MgYWxsIGV4ZWN1dGlvbnMgdGhhdCBtYXkgYmVcbiAgICAgICAqIHJ1bm5pbmcuIEl0IG9ubHkgb3B0aW1pemVzIGZvciB0aGUgX2xhdGVzdF8gZXhlY3V0aW9uIHBlciBzdG9yZSBhc1xuICAgICAgICogd2UgY3VycmVudGx5IGRvIG5vdCBtYWludGFpbiBhIGxpc3Qgb2YgYWxsIGN1cnJlbnRseSBydW5uaW5nIGV4ZWN1dGlvbnMuXG4gICAgICAgKiBUaGlzIG1lYW5zIGluIHNvbWUgY2FzZXMgd2UgbWF5IHJ1biBzZWxlY3RvcnMgbW9yZSB0aGFuIHN0cmljdGx5XG4gICAgICAgKiBuZWNlc3Nhcnkgd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgZXhlY3V0aW9ucyBydW5uaW5nIGZvciB0aGUgc2FtZVxuICAgICAgICogc2VsZWN0b3IuIFRoaXMgbWF5IGJlIGEgdmFsaWQgdHJhZGVvZmYgYXMgY2hlY2tpbmcgZm9yIGRlcCBjaGFuZ2VzXG4gICAgICAgKiBhY3Jvc3MgYWxsIGluLXByb2dyZXNzIGV4ZWN1dGlvbnMgbWF5IHRha2UgbG9uZ2VyIHRoYW4ganVzdFxuICAgICAgICogcmUtcnVubmluZyB0aGUgc2VsZWN0b3IuIFRoaXMgd2lsbCBiZSBhcHAtZGVwZW5kZW50LCBhbmQgbWF5YmUgaW4gdGhlXG4gICAgICAgKiBmdXR1cmUgd2UgY2FuIG1ha2UgdGhlIGJlaGF2aW9yIGNvbmZpZ3VyYWJsZS4gQW4gaWRlYWwgZml4IG1heSBiZVxuICAgICAgICogdG8gZXh0ZW5kIHRoZSB0cmVlIGNhY2hlIHRvIHN1cHBvcnQgY2FjaGluZyBsb2FkaW5nIHN0YXRlcy5cbiAgICAgICAqL1xuXG5cbiAgICAgIGlmICghaXNMYXRlc3RFeGVjdXRpb24oc3RvcmUsIGV4ZWN1dGlvbklEKSkge1xuICAgICAgICBjb25zdCBleGVjdXRpb25JbmZvID0gZ2V0SW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8oc3RvcmUsIHN0YXRlKTtcblxuICAgICAgICBpZiAoZXhlY3V0aW9uSW5mbyAhPSBudWxsKSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogUmV0dXJuaW5nIHByb21pc2UgaGVyZSB3aXRob3V0IHdyYXBwaW5nIGFzIHRoZSB3cmFwcGVyIGxvZ2ljIHdhc1xuICAgICAgICAgICAqIGFscmVhZHkgZG9uZSB1cHN0cmVhbSB3aGVuIHRoaXMgcHJvbWlzZSB3YXMgZ2VuZXJhdGVkLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHJldHVybiBleGVjdXRpb25JbmZvLmxvYWRpbmdMb2FkYWJsZS5jb250ZW50cztcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZXRyeSB0aGUgc2VsZWN0b3IgZXZhbHVhdGlvbiBub3cgdGhhdCB0aGUgZGVwZW5kZW5jeSBoYXMgcmVzb2x2ZWRcblxuXG4gICAgICBjb25zdCBbbG9hZGFibGUsIGRlcFZhbHVlc10gPSBldmFsdWF0ZVNlbGVjdG9yR2V0dGVyKHN0b3JlLCBzdGF0ZSwgZXhlY3V0aW9uSUQpO1xuXG4gICAgICBpZiAobG9hZGFibGUuc3RhdGUgIT09ICdsb2FkaW5nJykge1xuICAgICAgICByZXNvbHZlQXN5bmMoc3RvcmUsIHN0YXRlLCBleGVjdXRpb25JRCwgbG9hZGFibGUsIGRlcFZhbHVlcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc0Vycm9yJykge1xuICAgICAgICB0aHJvdyBsb2FkYWJsZS5jb250ZW50cztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxvYWRhYmxlLmNvbnRlbnRzO1xuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIC8vIFRoZSBzZWxlY3RvciB3YXMgcmVsZWFzZWQgc2luY2UgdGhlIHJlcXVlc3QgYmVnYW47IGlnbm9yZSB0aGUgcmVzcG9uc2UuXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDYW5jZWxlZCkge1xuICAgICAgICB0aHJvdyBDQU5DRUxFRDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZWxlY3RvcklzTGl2ZSgpKSB7XG4gICAgICAgIGNsZWFyRXhlY3V0aW9uSW5mbyhzdG9yZSk7XG4gICAgICAgIHRocm93IENBTkNFTEVEO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2FkYWJsZSA9IGxvYWRhYmxlV2l0aEVycm9yJDEoZXJyb3IpO1xuICAgICAgcmVzb2x2ZUFzeW5jKHN0b3JlLCBzdGF0ZSwgZXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBleGlzdGluZ0RlcHMpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSwgZGVwcywgZXhlY3V0aW9uSUQpIHtcbiAgICB2YXIgX3N0b3JlJGdldFN0YXRlLCBfc3RvcmUkZ2V0U3RhdGUkY3VycmUsIF9zdG9yZSRnZXRTdGF0ZTIsIF9zdG9yZSRnZXRTdGF0ZTIkbmV4dDtcblxuICAgIGlmIChpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpIHx8IHN0YXRlLnZlcnNpb24gPT09ICgoX3N0b3JlJGdldFN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3N0b3JlJGdldFN0YXRlJGN1cnJlID0gX3N0b3JlJGdldFN0YXRlLmN1cnJlbnRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUkY3VycmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZSRnZXRTdGF0ZSRjdXJyZS52ZXJzaW9uKSB8fCBzdGF0ZS52ZXJzaW9uID09PSAoKF9zdG9yZSRnZXRTdGF0ZTIgPSBzdG9yZS5nZXRTdGF0ZSgpKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3N0b3JlJGdldFN0YXRlMiRuZXh0ID0gX3N0b3JlJGdldFN0YXRlMi5uZXh0VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlMiRuZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmUkZ2V0U3RhdGUyJG5leHQudmVyc2lvbikpIHtcbiAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQsIF9zdG9yZSRnZXRTdGF0ZTMsIF9zdG9yZSRnZXRTdGF0ZTMkbmV4dDtcblxuICAgICAgc2F2ZURlcHNUb1N0b3JlJDEoa2V5LCBkZXBzLCBzdG9yZSwgKF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCA9IChfc3RvcmUkZ2V0U3RhdGUzID0gc3RvcmUuZ2V0U3RhdGUoKSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zdG9yZSRnZXRTdGF0ZTMkbmV4dCA9IF9zdG9yZSRnZXRTdGF0ZTMubmV4dFRyZWUpID09PSBudWxsIHx8IF9zdG9yZSRnZXRTdGF0ZTMkbmV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlJGdldFN0YXRlMyRuZXh0LnZlcnNpb24pICE9PSBudWxsICYmIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCAhPT0gdm9pZCAwID8gX3N0b3JlJGdldFN0YXRlJG5leHRUIDogc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZS52ZXJzaW9uKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IG5vZGVLZXkgb2YgZGVwcykge1xuICAgICAgZGlzY292ZXJlZERlcGVuZGVuY3lOb2RlS2V5cy5hZGQobm9kZUtleSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZXZhbHVhdGVTZWxlY3RvckdldHRlcihzdG9yZSwgc3RhdGUsIGV4ZWN1dGlvbklEKSB7XG4gICAgY29uc3QgZW5kUGVyZkJsb2NrID0gc3RhcnRQZXJmQmxvY2skMShrZXkpOyAvLyBUT0RPIFQ2Mzk2NTg2NjogdXNlIGV4ZWN1dGlvbiBJRCBoZXJlXG5cbiAgICBsZXQgZHVyaW5nU3luY2hyb25vdXNFeGVjdXRpb24gPSB0cnVlO1xuICAgIGxldCBkdXJpbmdBc3luY2hyb25vdXNFeGVjdXRpb24gPSB0cnVlO1xuXG4gICAgY29uc3QgZmluaXNoRXZhbHVhdGlvbiA9ICgpID0+IHtcbiAgICAgIGVuZFBlcmZCbG9jaygpO1xuICAgICAgZHVyaW5nQXN5bmNocm9ub3VzRXhlY3V0aW9uID0gZmFsc2U7XG4gICAgfTtcblxuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IHJlc3VsdElzRXJyb3IgPSBmYWxzZTtcbiAgICBsZXQgbG9hZGFibGU7XG4gICAgY29uc3QgbG9hZGluZ0RlcHNTdGF0ZSA9IHtcbiAgICAgIGxvYWRpbmdEZXBLZXk6IG51bGwsXG4gICAgICBsb2FkaW5nRGVwUHJvbWlzZTogbnVsbFxuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhcnRpbmcgYSBmcmVzaCBzZXQgb2YgZGVwcyB0aGF0IHdlJ2xsIGJlIHVzaW5nIHRvIHVwZGF0ZSBzdGF0ZS4gV2UncmVcbiAgICAgKiBzdGFydGluZyBhIG5ldyBzZXQgdmVyc3VzIGFkZGluZyBpdCBpbiBleGlzdGluZyBzdGF0ZSBkZXBzIGJlY2F1c2VcbiAgICAgKiB0aGUgdmVyc2lvbiBvZiBzdGF0ZSB0aGF0IHdlIHVwZGF0ZSBkZXBzIGZvciBtYXkgYmUgYSBtb3JlIHJlY2VudCB2ZXJzaW9uXG4gICAgICogdGhhbiB0aGUgdmVyc2lvbiB0aGUgc2VsZWN0b3Igd2FzIGNhbGxlZCB3aXRoLiBUaGlzIGlzIGJlY2F1c2UgdGhlIGxhdGVzdFxuICAgICAqIGV4ZWN1dGlvbiB3aWxsIHVwZGF0ZSB0aGUgZGVwcyBvZiB0aGUgY3VycmVudC9sYXRlc3QgdmVyc2lvbiBvZiBzdGF0ZVxuICAgICAqIChUaGlzIGlzIHNhZmUgdG8gZG8gYmVjYXVzZSB0aGUgZmFjdCB0aGF0IHRoZSBzZWxlY3RvciBpcyB0aGUgbGF0ZXN0XG4gICAgICogZXhlY3V0aW9uIG1lYW5zIHRoZSBkZXBzIHdlIGRpc2NvdmVyIGJlbG93IGFyZSBvdXIgYmVzdCBndWVzcyBhdCB0aGVcbiAgICAgKiBkZXBzIGZvciB0aGUgY3VycmVudC9sYXRlc3Qgc3RhdGUgaW4gdGhlIHN0b3JlKVxuICAgICAqL1xuXG4gICAgY29uc3QgZGVwVmFsdWVzID0gbmV3IE1hcCgpO1xuXG4gICAgZnVuY3Rpb24gZ2V0UmVjb2lsVmFsdWUoe1xuICAgICAga2V5OiBkZXBLZXlcbiAgICB9KSB7XG4gICAgICBjb25zdCBkZXBMb2FkYWJsZSA9IGdldE5vZGVMb2FkYWJsZSQyKHN0b3JlLCBzdGF0ZSwgZGVwS2V5KTtcbiAgICAgIGRlcFZhbHVlcy5zZXQoZGVwS2V5LCBkZXBMb2FkYWJsZSk7IC8vIFdlIG5lZWQgdG8gdXBkYXRlIGFzeW5jaHJvbm91cyBkZXBlbmRlbmNpZXMgYXMgd2UgZ28gc28gdGhlIHNlbGVjdG9yXG4gICAgICAvLyBrbm93cyBpZiBpdCBoYXMgdG8gcmVzdGFydCBldmFsdWF0aW9uIGlmIG9uZSBvZiB0aGVtIGlzIHVwZGF0ZWQgYmVmb3JlXG4gICAgICAvLyB0aGUgYXN5bmNocm9ub3VzIHNlbGVjdG9yIGNvbXBsZXRlbHkgcmVzb2x2ZXMuXG5cbiAgICAgIGlmICghZHVyaW5nU3luY2hyb25vdXNFeGVjdXRpb24pIHtcbiAgICAgICAgdXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUsIG5ldyBTZXQoZGVwVmFsdWVzLmtleXMoKSksIGV4ZWN1dGlvbklEKTtcbiAgICAgICAgbm90aWZ5U3RvcmVzT2ZOZXdBc3luY0RlcChzdG9yZSwgZXhlY3V0aW9uSUQpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGRlcExvYWRhYmxlLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgJ2hhc1ZhbHVlJzpcbiAgICAgICAgICByZXR1cm4gZGVwTG9hZGFibGUuY29udGVudHM7XG5cbiAgICAgICAgY2FzZSAnaGFzRXJyb3InOlxuICAgICAgICAgIHRocm93IGRlcExvYWRhYmxlLmNvbnRlbnRzO1xuXG4gICAgICAgIGNhc2UgJ2xvYWRpbmcnOlxuICAgICAgICAgIGxvYWRpbmdEZXBzU3RhdGUubG9hZGluZ0RlcEtleSA9IGRlcEtleTtcbiAgICAgICAgICBsb2FkaW5nRGVwc1N0YXRlLmxvYWRpbmdEZXBQcm9taXNlID0gZGVwTG9hZGFibGUuY29udGVudHM7XG4gICAgICAgICAgdGhyb3cgZGVwTG9hZGFibGUuY29udGVudHM7XG4gICAgICB9XG5cbiAgICAgIHRocm93IFJlY29pbF9lcnIoJ0ludmFsaWQgTG9hZGFibGUgc3RhdGUnKTtcbiAgICB9XG5cbiAgICBjb25zdCBnZXRDYWxsYmFjayA9IGZuID0+IHtcbiAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoZHVyaW5nQXN5bmNocm9ub3VzRXhlY3V0aW9uKSB7XG4gICAgICAgICAgdGhyb3cgUmVjb2lsX2VycignQ2FsbGJhY2tzIGZyb20gZ2V0Q2FsbGJhY2soKSBzaG91bGQgb25seSBiZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkgYWZ0ZXIgdGhlIHNlbGVjdG9yIGlzIGV2YWx1dGF0ZWQuICBJdCBjYW4gYmUgdXNlZCBmb3Igc2VsZWN0b3JzIHRvIHJldHVybiBvYmplY3RzIHdpdGggY2FsbGJhY2tzIHRoYXQgY2FuIHdvcmsgd2l0aCBSZWNvaWwgc3RhdGUgd2l0aG91dCBhIHN1YnNjcmlwdGlvbi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgICEocmVjb2lsVmFsdWUgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBSZWNvaWxfaW52YXJpYW50KGZhbHNlLCAnUmVjb2lsIFZhbHVlIGNhbiBuZXZlciBiZSBudWxsJykgOiBSZWNvaWxfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHJlY29pbENhbGxiYWNrJDEoc3RvcmUsIGZuLCBhcmdzLCB7XG4gICAgICAgICAgbm9kZTogcmVjb2lsVmFsdWVcbiAgICAgICAgfSAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBnZXQoe1xuICAgICAgICBnZXQ6IGdldFJlY29pbFZhbHVlLFxuICAgICAgICBnZXRDYWxsYmFja1xuICAgICAgfSk7XG4gICAgICByZXN1bHQgPSBpc1JlY29pbFZhbHVlJDMocmVzdWx0KSA/IGdldFJlY29pbFZhbHVlKHJlc3VsdCkgOiByZXN1bHQ7XG5cbiAgICAgIGlmIChpc0xvYWRhYmxlJDEocmVzdWx0KSkge1xuICAgICAgICBpZiAocmVzdWx0LnN0YXRlID09PSAnaGFzRXJyb3InKSB7XG4gICAgICAgICAgcmVzdWx0SXNFcnJvciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSByZXN1bHQuY29udGVudHM7XG4gICAgICB9XG5cbiAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gd3JhcFJlc3VsdFByb21pc2Uoc3RvcmUsIHJlc3VsdCwgc3RhdGUsIGRlcFZhbHVlcywgZXhlY3V0aW9uSUQsIGxvYWRpbmdEZXBzU3RhdGUpLmZpbmFsbHkoZmluaXNoRXZhbHVhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5pc2hFdmFsdWF0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IHJlc3VsdCBpbnN0YW5jZW9mIFdyYXBwZWRWYWx1ZSQxID8gcmVzdWx0LnZhbHVlIDogcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yT3JEZXBQcm9taXNlKSB7XG4gICAgICByZXN1bHQgPSBlcnJvck9yRGVwUHJvbWlzZTtcblxuICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UocmVzdWx0KSkge1xuICAgICAgICByZXN1bHQgPSB3cmFwUGVuZGluZ0RlcGVuZGVuY3lQcm9taXNlKHN0b3JlLCByZXN1bHQsIHN0YXRlLCBkZXBWYWx1ZXMsIGV4ZWN1dGlvbklELCBsb2FkaW5nRGVwc1N0YXRlKS5maW5hbGx5KGZpbmlzaEV2YWx1YXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0SXNFcnJvciA9IHRydWU7XG4gICAgICAgIGZpbmlzaEV2YWx1YXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzdWx0SXNFcnJvcikge1xuICAgICAgbG9hZGFibGUgPSBsb2FkYWJsZVdpdGhFcnJvciQxKHJlc3VsdCk7XG4gICAgfSBlbHNlIGlmIChSZWNvaWxfaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgIGxvYWRhYmxlID0gbG9hZGFibGVXaXRoUHJvbWlzZSQxKHJlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRhYmxlID0gbG9hZGFibGVXaXRoVmFsdWUkMihyZXN1bHQpO1xuICAgIH1cblxuICAgIGR1cmluZ1N5bmNocm9ub3VzRXhlY3V0aW9uID0gZmFsc2U7XG4gICAgdXBkYXRlRXhlY3V0aW9uSW5mb0RlcFZhbHVlcyhzdG9yZSwgZXhlY3V0aW9uSUQsIGRlcFZhbHVlcyk7XG4gICAgdXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUsIG5ldyBTZXQoZGVwVmFsdWVzLmtleXMoKSksIGV4ZWN1dGlvbklEKTtcbiAgICByZXR1cm4gW2xvYWRhYmxlLCBkZXBWYWx1ZXNdO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TG9hZGFibGVGcm9tQ2FjaGVBbmRVcGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSkge1xuICAgIC8vIEZpcnN0LCBsb29rIHVwIGluIHRoZSBzdGF0ZSBjYWNoZVxuICAgIC8vIElmIGl0J3MgaGVyZSwgdGhlbiB0aGUgZGVwcyBpbiB0aGUgc3RvcmUgc2hvdWxkIGFscmVhZHkgYmUgdmFsaWQuXG4gICAgbGV0IGNhY2hlZExvYWRhYmxlID0gc3RhdGUuYXRvbVZhbHVlcy5nZXQoa2V5KTtcblxuICAgIGlmIChjYWNoZWRMb2FkYWJsZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkTG9hZGFibGU7XG4gICAgfSAvLyBTZWNvbmQsIGxvb2sgdXAgaW4gdGhlIHNlbGVjdG9yIGNhY2hlIGFuZCB1cGRhdGUgdGhlIGRlcHMgaW4gdGhlIHN0b3JlXG5cblxuICAgIGNvbnN0IGRlcHNBZnRlckNhY2hlTG9va3VwID0gbmV3IFNldCgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNhY2hlZExvYWRhYmxlID0gY2FjaGUuZ2V0KG5vZGVLZXkgPT4ge1xuICAgICAgICAhKHR5cGVvZiBub2RlS2V5ID09PSAnc3RyaW5nJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBSZWNvaWxfaW52YXJpYW50KGZhbHNlLCAnQ2FjaGUgbm9kZUtleSBpcyB0eXBlIHN0cmluZycpIDogUmVjb2lsX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICAgIHJldHVybiBnZXROb2RlTG9hZGFibGUkMihzdG9yZSwgc3RhdGUsIG5vZGVLZXkpLmNvbnRlbnRzO1xuICAgICAgfSwge1xuICAgICAgICBvbk5vZGVWaXNpdDogbm9kZSA9PiB7XG4gICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2JyYW5jaCcgJiYgbm9kZS5ub2RlS2V5ICE9PSBrZXkpIHtcbiAgICAgICAgICAgIGRlcHNBZnRlckNhY2hlTG9va3VwLmFkZChub2RlLm5vZGVLZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IFJlY29pbF9lcnIoYFByb2JsZW0gd2l0aCBjYWNoZSBsb29rdXAgZm9yIHNlbGVjdG9yIFwiJHtrZXl9XCI6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICBpZiAoY2FjaGVkTG9hZGFibGUpIHtcbiAgICAgIHZhciBfZ2V0RXhlY3V0aW9uSW5mbztcblxuICAgICAgLy8gQ2FjaGUgdGhlIHJlc3VsdHMgaW4gdGhlIHN0YXRlIHRvIGFsbG93IGZvciBjaGVhcGVyIGxvb2t1cCB0aGFuXG4gICAgICAvLyBpdGVyYXRpbmcgdGhlIHRyZWUgY2FjaGUgb2YgZGVwZW5kZW5jaWVzLlxuICAgICAgc3RhdGUuYXRvbVZhbHVlcy5zZXQoa2V5LCBjYWNoZWRMb2FkYWJsZSk7XG4gICAgICAvKipcbiAgICAgICAqIEVuc3VyZSBzdG9yZSBjb250YWlucyBjb3JyZWN0IGRlcGVuZGVuY2llcyBpZiB3ZSBoaXQgdGhlIGNhY2hlIHNvIHRoYXRcbiAgICAgICAqIHRoZSBzdG9yZSBkZXBzIGFuZCBjYWNoZSBhcmUgaW4gc3luYyBmb3IgYSBnaXZlbiBzdGF0ZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgICAgICAqIGJlY2F1c2Ugc3RvcmUgZGVwcyBhcmUgbm9ybWFsbHkgdXBkYXRlZCB3aGVuIG5ldyBleGVjdXRpb25zIGFyZSBjcmVhdGVkLFxuICAgICAgICogYnV0IGNhY2hlIGhpdHMgZG9uJ3QgdHJpZ2dlciBuZXcgZXhlY3V0aW9ucyBidXQgdGhleSBzdGlsbCBfbWF5XyBzaWduaWZ5XG4gICAgICAgKiBhIGNoYW5nZSBpbiBkZXBzIGluIHRoZSBzdG9yZSBpZiB0aGUgc3RvcmUgZGVwcyBmb3IgdGhpcyBzdGF0ZSBhcmUgZW1wdHlcbiAgICAgICAqIG9yIHN0YWxlLlxuICAgICAgICovXG5cbiAgICAgIHVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlLCBkZXBzQWZ0ZXJDYWNoZUxvb2t1cCwgKF9nZXRFeGVjdXRpb25JbmZvID0gZ2V0RXhlY3V0aW9uSW5mbyhzdG9yZSkpID09PSBudWxsIHx8IF9nZXRFeGVjdXRpb25JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0RXhlY3V0aW9uSW5mby5leGVjdXRpb25JRCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlZExvYWRhYmxlO1xuICB9XG4gIC8qKlxuICAgKiBHaXZlbiBhIHRyZWUgc3RhdGUsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIExvYWRhYmxlIG9mIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgKlxuICAgKiBUaGUgc2VsZWN0b3IncyBnZXQoKSBmdW5jdGlvbiB3aWxsIG9ubHkgYmUgcmUtZXZhbHVhdGVkIGlmIF9ib3RoXyBvZiB0aGVcbiAgICogZm9sbG93aW5nIHN0YXRlbWVudHMgYXJlIHRydWU6XG4gICAqXG4gICAqIDEuIFRoZSBjdXJyZW50IGRlcCB2YWx1ZXMgZnJvbSB0aGUgZ2l2ZW4gc3RhdGUgcHJvZHVjZWQgYSBjYWNoZSBrZXkgdGhhdFxuICAgKiAgICB3YXMgbm90IGZvdW5kIGluIHRoZSBjYWNoZS5cbiAgICogMi4gVGhlcmUgaXMgbm8gY3VycmVudGx5IHJ1bm5pbmcgYXN5bmMgZXhlY3V0aW9uIE9SIHRoZXJlIGlzIGFuXG4gICAqICAgIGFzeW5jIGV4ZWN1dGlvbiB0aGF0IGlzIHJ1bm5pbmcsIGJ1dCBhZnRlciBjb21wYXJpbmcgdGhlIGRlcCB2YWx1ZXMgaW5cbiAgICogICAgdGhlIGdpdmVuIHN0YXRlIHdpdGggdGhlIGRlcCB2YWx1ZXMgdGhhdCB0aGUgZXhlY3V0aW9uIGhhcyBkaXNjb3ZlcmVkIHNvXG4gICAqICAgIGZhciB3ZSBmaW5kIHRoYXQgYXQgbGVhc3Qgb25lIGRlcCB2YWx1ZSBoYXMgY2hhbmdlZCwgaW4gd2hpY2ggY2FzZSB3ZVxuICAgKiAgICBzdGFydCBhIG5ldyBleGVjdXRpb24gKHRoZSBwcmV2aW91c2x5IHJ1bm5pbmcgZXhlY3V0aW9uIHdpbGwgY29udGludWUgdG9cbiAgICogICAgcnVuIHRvIGNvbXBsZXRpb24sIGJ1dCBvbmx5IHRoZSBuZXcgZXhlY3V0aW9uIHdpbGwgYmUgZGVlbWVkIHRoZVxuICAgKiAgICAnbGF0ZXN0JyBleGVjdXRpb24sIG1lYW5pbmcgaXQgd2lsbCBiZSB0aGUgb25seSBleGVjdXRpb24gdGhhdCB3aWxsXG4gICAqICAgIHVwZGF0ZSBnbG9iYWwgc3RhdGUgd2hlbiBpdCBpcyBmaW5pc2hlZC4gQW55IG5vbi1sYXRlc3QgZXhlY3V0aW9ucyB3aWxsXG4gICAqICAgIHJ1biB0byBjb21wbGV0aW9uIGFuZCB1cGRhdGUgdGhlIHNlbGVjdG9yIGNhY2hlIGJ1dCBub3QgZ2xvYmFsIHN0YXRlKS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRTZWxlY3RvckxvYWRhYmxlQW5kVXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUpIHtcbiAgICAvLyBGaXJzdCwgc2VlIGlmIG91ciBjdXJyZW50IHN0YXRlIGlzIGNhY2hlZFxuICAgIGNvbnN0IGNhY2hlZFZhbCA9IGdldExvYWRhYmxlRnJvbUNhY2hlQW5kVXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUpO1xuXG4gICAgaWYgKGNhY2hlZFZhbCAhPSBudWxsKSB7XG4gICAgICBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpO1xuICAgICAgcmV0dXJuIGNhY2hlZFZhbDtcbiAgICB9IC8vIFNlY29uZCwgY2hlY2sgaWYgdGhlcmUgaXMgYWxyZWFkeSBhbiBvbmdvaW5nIGV4ZWN1dGlvbiBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZVxuXG5cbiAgICBjb25zdCBpblByb2dyZXNzRXhlY3V0aW9uSW5mbyA9IGdldEluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvKHN0b3JlLCBzdGF0ZSk7XG5cbiAgICBpZiAoaW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8gIT0gbnVsbCkge1xuICAgICAgdmFyIF9pblByb2dyZXNzRXhlY3V0aW9uSTtcblxuICAgICAgaWYgKCgoX2luUHJvZ3Jlc3NFeGVjdXRpb25JID0gaW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8ubG9hZGluZ0xvYWRhYmxlKSA9PT0gbnVsbCB8fCBfaW5Qcm9ncmVzc0V4ZWN1dGlvbkkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9pblByb2dyZXNzRXhlY3V0aW9uSS5zdGF0ZSkgPT09ICdsb2FkaW5nJykge1xuICAgICAgICBtYXJrU3RvcmVXYWl0aW5nRm9yUmVzb2x2ZWRBc3luYyhzdG9yZSwgaW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8uZXhlY3V0aW9uSUQpO1xuICAgICAgfSAvLyBGSVhNRTogY2hlY2sgYWZ0ZXIgdGhlIGZhY3QgdG8gc2VlIGlmIHdlIG1hZGUgdGhlIHJpZ2h0IGNob2ljZSBieSB3YWl0aW5nXG5cblxuICAgICAgcmV0dXJuIGluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvLmxvYWRpbmdMb2FkYWJsZTtcbiAgICB9IC8vIFRoaXJkLCBzdGFydCBhIG5ldyBldmFsdWF0aW9uIG9mIHRoZSBzZWxlY3RvclxuXG5cbiAgICBjb25zdCBuZXdFeGVjdXRpb25JRCA9IGdldE5ld0V4ZWN1dGlvbklEKCk7XG4gICAgY29uc3QgW2xvYWRhYmxlLCBuZXdEZXBWYWx1ZXNdID0gZXZhbHVhdGVTZWxlY3RvckdldHRlcihzdG9yZSwgc3RhdGUsIG5ld0V4ZWN1dGlvbklEKTtcbiAgICAvKipcbiAgICAgKiBDb25kaXRpb25hbGx5IHVwZGF0ZXMgdGhlIGNhY2hlIHdpdGggYSBnaXZlbiBsb2FkYWJsZS5cbiAgICAgKlxuICAgICAqIFdlIG9ubHkgY2FjaGUgbG9hZGFibGVzIHRoYXQgYXJlIG5vdCBsb2FkaW5nIGJlY2F1c2Ugb3VyIGNhY2hlIGtleXMgYXJlXG4gICAgICogYmFzZWQgb24gZGVwIHZhbHVlcywgd2hpY2ggYXJlIGluIGFuIHVuZmluaXNoZWQgc3RhdGUgZm9yIGxvYWRhYmxlcyB0aGF0XG4gICAgICogaGF2ZSBhICdsb2FkaW5nJyBzdGF0ZSAobmV3IGRlcHMgbWF5IGJlIGRpc2NvdmVyZWQgd2hpbGUgdGhlIHNlbGVjdG9yXG4gICAgICogcnVucyBpdHMgYXN5bmMgY29kZSkuIFdlIG5ldmVyIHdhbnQgdG8gY2FjaGUgcGFydGlhbCBkZXBlbmRlbmNpZXMgYi9jIGl0XG4gICAgICogY291bGQgbGVhZCB0byBlcnJvcnMsIHN1Y2ggYXMgcHJlbWF0dXJlbHkgcmV0dXJuaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gYVxuICAgICAqIHBhcnRpYWwgbGlzdCBvZiBkZXBzLS0gd2UgbmVlZCB0aGUgZnVsbCBsaXN0IG9mIGRlcHMgdG8gZW5zdXJlIHRoYXQgd2VcbiAgICAgKiBhcmUgcmV0dXJuaW5nIHRoZSBjb3JyZWN0IHJlc3VsdCBmcm9tIGNhY2hlLlxuICAgICAqL1xuXG4gICAgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgIHNldEV4ZWN1dGlvbkluZm8oc3RvcmUsIG5ld0V4ZWN1dGlvbklELCBsb2FkYWJsZSwgbmV3RGVwVmFsdWVzLCBzdGF0ZSk7XG4gICAgICBtYXJrU3RvcmVXYWl0aW5nRm9yUmVzb2x2ZWRBc3luYyhzdG9yZSwgbmV3RXhlY3V0aW9uSUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpO1xuICAgICAgc2V0Q2FjaGUoc3RhdGUsIGxvYWRhYmxlLCBuZXdEZXBWYWx1ZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBsb2FkYWJsZTtcbiAgfVxuICAvKipcbiAgICogU2VhcmNoZXMgZXhlY3V0aW9uIGluZm8gYWNyb3NzIGFsbCBzdG9yZXMgdG8gc2VlIGlmIHRoZXJlIGlzIGFuIGluLXByb2dyZXNzXG4gICAqIGV4ZWN1dGlvbiB3aG9zZSBkZXBlbmRlbmN5IHZhbHVlcyBtYXRjaCB0aGUgdmFsdWVzIG9mIHRoZSByZXF1ZXN0aW5nIHN0b3JlLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldEluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvKHN0b3JlLCBzdGF0ZSkge1xuICAgIC8vIFNvcnQgdGhlIHBlbmRpbmcgZXhlY3V0aW9ucyBzbyB0aGF0IG91ciBjdXJyZW50IHN0b3JlIGlzIGNoZWNrZWQgZmlyc3QuXG4gICAgY29uc3QgcGVuZGluZ0V4ZWN1dGlvbnMgPSBSZWNvaWxfY29uY2F0SXRlcmFibGVzKFtleGVjdXRpb25JbmZvTWFwLmhhcyhzdG9yZSkgPyBbUmVjb2lsX251bGx0aHJvd3MoZXhlY3V0aW9uSW5mb01hcC5nZXQoc3RvcmUpKV0gOiBbXSwgUmVjb2lsX21hcEl0ZXJhYmxlKFJlY29pbF9maWx0ZXJJdGVyYWJsZShleGVjdXRpb25JbmZvTWFwLCAoW3NdKSA9PiBzICE9PSBzdG9yZSksIChbLCBleGVjSW5mb10pID0+IGV4ZWNJbmZvKV0pO1xuXG4gICAgZnVuY3Rpb24gYW55RGVwQ2hhbmdlZChleGVjRGVwVmFsdWVzKSB7XG4gICAgICBmb3IgKGNvbnN0IFtkZXBLZXksIGV4ZWNMb2FkYWJsZV0gb2YgZXhlY0RlcFZhbHVlcykge1xuICAgICAgICBpZiAoIWdldE5vZGVMb2FkYWJsZSQyKHN0b3JlLCBzdGF0ZSwgZGVwS2V5KS5pcyhleGVjTG9hZGFibGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgZXhlY0luZm8gb2YgcGVuZGluZ0V4ZWN1dGlvbnMpIHtcbiAgICAgIGlmICggLy8gSWYgdGhpcyBleGVjdXRpb24gd2FzIGFscmVhZHkgY2hlY2tlZCB0byBiZSB2YWxpZCB3aXRoIHRoaXMgdmVyc2lvblxuICAgICAgLy8gb2Ygc3RhdGUsIHRoZW4gbGV0J3MgdXNlIGl0IVxuICAgICAgZXhlY0luZm8uc3RhdGVWZXJzaW9ucy5nZXQoc3RhdGUudmVyc2lvbikgfHwgLy8gSWYgdGhlIGRlcHMgZm9yIHRoZSBleGVjdXRpb24gbWF0Y2ggb3VyIGN1cnJlbnQgc3RhdGUsIHRoZW4gaXQncyB2YWxpZFxuICAgICAgIWFueURlcENoYW5nZWQoZXhlY0luZm8uZGVwVmFsdWVzRGlzY292ZXJlZFNvRmFyRHVyaW5nQXN5bmNXb3JrKSkge1xuICAgICAgICBleGVjSW5mby5zdGF0ZVZlcnNpb25zLnNldChzdGF0ZS52ZXJzaW9uLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGV4ZWNJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhlY0luZm8uc3RhdGVWZXJzaW9ucy5zZXQoc3RhdGUudmVyc2lvbiwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFeGVjdXRpb25JbmZvKHN0b3JlKSB7XG4gICAgcmV0dXJuIGV4ZWN1dGlvbkluZm9NYXAuZ2V0KHN0b3JlKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHVwZGF0ZSB0aGUgc2VsZWN0b3IncyBleGVjdXRpb24gaW5mbyB3aGVuIHRoZSBzZWxlY3RvclxuICAgKiBoYXMgZWl0aGVyIGZpbmlzaGVkIHJ1bm5pbmcgYW4gZXhlY3V0aW9uIG9yIGhhcyBzdGFydGVkIGEgbmV3IGV4ZWN1dGlvbi4gSWZcbiAgICogdGhlIGdpdmVuIGxvYWRhYmxlIGlzIGluIGEgJ2xvYWRpbmcnIHN0YXRlLCB0aGUgaW50ZW50aW9uIGlzIHRoYXQgYSBuZXdcbiAgICogZXhlY3V0aW9uIGhhcyBzdGFydGVkLiBPdGhlcndpc2UsIHRoZSBpbnRlbnRpb24gaXMgdGhhdCBhbiBleGVjdXRpb24gaGFzXG4gICAqIGp1c3QgZmluaXNoZWQuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc2V0RXhlY3V0aW9uSW5mbyhzdG9yZSwgbmV3RXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBkZXBWYWx1ZXMsIHN0YXRlKSB7XG4gICAgZXhlY3V0aW9uSW5mb01hcC5zZXQoc3RvcmUsIHtcbiAgICAgIGRlcFZhbHVlc0Rpc2NvdmVyZWRTb0ZhckR1cmluZ0FzeW5jV29yazogZGVwVmFsdWVzLFxuICAgICAgZXhlY3V0aW9uSUQ6IG5ld0V4ZWN1dGlvbklELFxuICAgICAgbG9hZGluZ0xvYWRhYmxlOiBsb2FkYWJsZSxcbiAgICAgIHN0YXRlVmVyc2lvbnM6IG5ldyBNYXAoW1tzdGF0ZS52ZXJzaW9uLCB0cnVlXV0pXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVFeGVjdXRpb25JbmZvRGVwVmFsdWVzKHN0b3JlLCBleGVjdXRpb25JRCwgZGVwVmFsdWVzKSB7XG4gICAgLy8gV2Ugb25seSBuZWVkIHRvIGJvdGhlciB1cGRhdGluZyB0aGUgZGVwcyBmb3IgdGhlIGxhdGVzdCBleGVjdXRpb24gYmVjYXVzZVxuICAgIC8vIHRoYXQncyBhbGwgZ2V0SW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8oKSB3aWxsIGJlIGxvb2tpbmcgZm9yLlxuICAgIGlmIChpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpKSB7XG4gICAgICBjb25zdCBleGVjdXRpb25JbmZvID0gZ2V0RXhlY3V0aW9uSW5mbyhzdG9yZSk7XG5cbiAgICAgIGlmIChleGVjdXRpb25JbmZvICE9IG51bGwpIHtcbiAgICAgICAgZXhlY3V0aW9uSW5mby5kZXBWYWx1ZXNEaXNjb3ZlcmVkU29GYXJEdXJpbmdBc3luY1dvcmsgPSBkZXBWYWx1ZXM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKSB7XG4gICAgZXhlY3V0aW9uSW5mb01hcC5kZWxldGUoc3RvcmUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNMYXRlc3RFeGVjdXRpb24oc3RvcmUsIGV4ZWN1dGlvbklEKSB7XG4gICAgdmFyIF9nZXRFeGVjdXRpb25JbmZvMjtcblxuICAgIHJldHVybiBleGVjdXRpb25JRCA9PT0gKChfZ2V0RXhlY3V0aW9uSW5mbzIgPSBnZXRFeGVjdXRpb25JbmZvKHN0b3JlKSkgPT09IG51bGwgfHwgX2dldEV4ZWN1dGlvbkluZm8yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0RXhlY3V0aW9uSW5mbzIuZXhlY3V0aW9uSUQpO1xuICB9XG4gIC8qKlxuICAgKiBGSVhNRTogZGVwIGtleXMgc2hvdWxkIHRha2UgaW50byBhY2NvdW50IHRoZSBzdGF0ZSBvZiB0aGUgbG9hZGFibGUgdG9cbiAgICogcHJldmVudCB0aGUgZWRnZSBjYXNlIHdoZXJlIGEgbG9hZGFibGUgd2l0aCBhbiBlcnJvciBhbmQgYSBsb2FkYWJsZSB3aXRoXG4gICAqIGFuIGVycm9yIGFzIGEgdmFsdWUgYXJlIHRyZWF0ZWQgYXMgdGhlIHNhbWUgdGhpbmcgaW5jb3JyZWN0bHkuIEZvciBleGFtcGxlXG4gICAqIHRoZXNlIHR3byBzaG91bGQgYmUgdHJlYXRlZCBkaWZmZXJlbnRseTpcbiAgICpcbiAgICogc2VsZWN0b3Ioe2tleTogJycsIGdldDogKCkgPT4gbmV3IEVycm9yKCdoaScpfSk7XG4gICAqIHNlbGVjdG9yKHtrZXk6ICcnLCBnZXQgKCkgPT4ge3Rocm93IG5ldyBFcnJvcignaGknKX19KTtcbiAgICpcbiAgICogV2l0aCBjdXJyZW50IGltcGxlbWVudGF0aW9uIHRoZXkgYXJlIHRyZWF0ZWQgdGhlIHNhbWVcbiAgICovXG5cblxuICBmdW5jdGlvbiBkZXBWYWx1ZXNUb0RlcFJvdXRlKGRlcFZhbHVlcykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGRlcFZhbHVlcy5lbnRyaWVzKCkpLm1hcCgoW2RlcEtleSwgdmFsTG9hZGFibGVdKSA9PiBbZGVwS2V5LCB2YWxMb2FkYWJsZS5jb250ZW50c10pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q2FjaGUoc3RhdGUsIGxvYWRhYmxlLCBkZXBWYWx1ZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAobG9hZGFibGUuc3RhdGUgIT09ICdsb2FkaW5nJyAmJiBCb29sZWFuKG9wdGlvbnMuZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHkpID09PSBmYWxzZSkge1xuICAgICAgICBSZWNvaWxfZGVlcEZyZWV6ZVZhbHVlKGxvYWRhYmxlLmNvbnRlbnRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5hdG9tVmFsdWVzLnNldChrZXksIGxvYWRhYmxlKTtcblxuICAgIHRyeSB7XG4gICAgICBjYWNoZS5zZXQoZGVwVmFsdWVzVG9EZXBSb3V0ZShkZXBWYWx1ZXMpLCBsb2FkYWJsZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IFJlY29pbF9lcnIoYFByb2JsZW0gd2l0aCBzZXR0aW5nIGNhY2hlIGZvciBzZWxlY3RvciBcIiR7a2V5fVwiOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0ZWN0Q2lyY3VsYXJEZXBlbmRlbmNpZXMoZm4pIHtcbiAgICBpZiAoZGVwZW5kZW5jeVN0YWNrLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgUmVjb2lsIHNlbGVjdG9yIGhhcyBjaXJjdWxhciBkZXBlbmRlbmNpZXM6ICR7ZGVwZW5kZW5jeVN0YWNrLnNsaWNlKGRlcGVuZGVuY3lTdGFjay5pbmRleE9mKGtleSkpLmpvaW4oJyBcXHUyMTkyICcpfWA7XG4gICAgICByZXR1cm4gbG9hZGFibGVXaXRoRXJyb3IkMShSZWNvaWxfZXJyKG1lc3NhZ2UpKTtcbiAgICB9XG5cbiAgICBkZXBlbmRlbmN5U3RhY2sucHVzaChrZXkpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBkZXBlbmRlbmN5U3RhY2sucG9wKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0b3JQZWVrKHN0b3JlLCBzdGF0ZSkge1xuICAgIGNvbnN0IGNhY2hlZExvYWRhYmxlID0gc3RhdGUuYXRvbVZhbHVlcy5nZXQoa2V5KTtcblxuICAgIGlmIChjYWNoZWRMb2FkYWJsZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkTG9hZGFibGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlLmdldChub2RlS2V5ID0+IHtcbiAgICAgIHZhciBfcGVla05vZGVMb2FkYWJsZTtcblxuICAgICAgISh0eXBlb2Ygbm9kZUtleSA9PT0gJ3N0cmluZycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUmVjb2lsX2ludmFyaWFudChmYWxzZSwgJ0NhY2hlIG5vZGVLZXkgaXMgdHlwZSBzdHJpbmcnKSA6IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIChfcGVla05vZGVMb2FkYWJsZSA9IHBlZWtOb2RlTG9hZGFibGUkMShzdG9yZSwgc3RhdGUsIG5vZGVLZXkpKSA9PT0gbnVsbCB8fCBfcGVla05vZGVMb2FkYWJsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3BlZWtOb2RlTG9hZGFibGUuY29udGVudHM7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3RvckdldChzdG9yZSwgc3RhdGUpIHtcbiAgICByZXR1cm4gZGV0ZWN0Q2lyY3VsYXJEZXBlbmRlbmNpZXMoKCkgPT4gZ2V0U2VsZWN0b3JMb2FkYWJsZUFuZFVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZhbGlkYXRlU2VsZWN0b3Ioc3RhdGUpIHtcbiAgICBzdGF0ZS5hdG9tVmFsdWVzLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJTZWxlY3RvckNhY2hlKHN0b3JlLCB0cmVlU3RhdGUpIHtcbiAgICAhKHJlY29pbFZhbHVlICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUmVjb2lsX2ludmFyaWFudChmYWxzZSwgJ1JlY29pbCBWYWx1ZSBjYW4gbmV2ZXIgYmUgbnVsbCcpIDogUmVjb2lsX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICBmb3IgKGNvbnN0IG5vZGVLZXkgb2YgZGlzY292ZXJlZERlcGVuZGVuY3lOb2RlS2V5cykge1xuICAgICAgdmFyIF9ub2RlJGNsZWFyQ2FjaGU7XG5cbiAgICAgIGNvbnN0IG5vZGUgPSBnZXROb2RlJDYobm9kZUtleSk7XG4gICAgICAoX25vZGUkY2xlYXJDYWNoZSA9IG5vZGUuY2xlYXJDYWNoZSkgPT09IG51bGwgfHwgX25vZGUkY2xlYXJDYWNoZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkY2xlYXJDYWNoZS5jYWxsKG5vZGUsIHN0b3JlLCB0cmVlU3RhdGUpO1xuICAgIH1cblxuICAgIGRpc2NvdmVyZWREZXBlbmRlbmN5Tm9kZUtleXMuY2xlYXIoKTtcbiAgICBpbnZhbGlkYXRlU2VsZWN0b3IodHJlZVN0YXRlKTtcbiAgICBjYWNoZS5jbGVhcigpO1xuICAgIG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkJDEoc3RvcmUsIHJlY29pbFZhbHVlKTtcbiAgfVxuXG4gIGlmIChzZXQgIT0gbnVsbCkge1xuICAgIC8qKlxuICAgICAqIEVTNSBzdHJpY3QgbW9kZSBwcm9oaWJpdHMgZGVmaW5pbmcgbm9uLXRvcC1sZXZlbCBmdW5jdGlvbiBkZWNsYXJhdGlvbnMsXG4gICAgICogc28gZG9uJ3QgdXNlIGZ1bmN0aW9uIGRlY2xhcmF0aW9uIHN5bnRheCBoZXJlXG4gICAgICovXG4gICAgY29uc3Qgc2VsZWN0b3JTZXQgPSAoc3RvcmUsIHN0YXRlLCBuZXdWYWx1ZSkgPT4ge1xuICAgICAgbGV0IHN5bmNTZWxlY3RvclNldEZpbmlzaGVkID0gZmFsc2U7XG4gICAgICBjb25zdCB3cml0ZXMgPSBuZXcgTWFwKCk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldFJlY29pbFZhbHVlKHtcbiAgICAgICAga2V5OiBkZXBLZXlcbiAgICAgIH0pIHtcbiAgICAgICAgaWYgKHN5bmNTZWxlY3RvclNldEZpbmlzaGVkKSB7XG4gICAgICAgICAgdGhyb3cgUmVjb2lsX2VycignUmVjb2lsOiBBc3luYyBzZWxlY3RvciBzZXRzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvYWRhYmxlID0gZ2V0Tm9kZUxvYWRhYmxlJDIoc3RvcmUsIHN0YXRlLCBkZXBLZXkpO1xuXG4gICAgICAgIGlmIChsb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJykge1xuICAgICAgICAgIHJldHVybiBsb2FkYWJsZS5jb250ZW50cztcbiAgICAgICAgfSBlbHNlIGlmIChsb2FkYWJsZS5zdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gYEdldHRpbmcgdmFsdWUgb2YgYXN5bmNocm9ub3VzIGF0b20gb3Igc2VsZWN0b3IgXCIke2RlcEtleX1cIiBpbiBhIHBlbmRpbmcgc3RhdGUgd2hpbGUgc2V0dGluZyBzZWxlY3RvciBcIiR7a2V5fVwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLmA7XG4gICAgICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKG1zZyk7XG4gICAgICAgICAgdGhyb3cgUmVjb2lsX2Vycihtc2cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGxvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldFJlY29pbFN0YXRlKHJlY29pbFN0YXRlLCB2YWx1ZU9yVXBkYXRlciAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG4gICAgICApIHtcbiAgICAgICAgaWYgKHN5bmNTZWxlY3RvclNldEZpbmlzaGVkKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gJ1JlY29pbDogQXN5bmMgc2VsZWN0b3Igc2V0cyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuJztcbiAgICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24obXNnKTtcbiAgICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKG1zZyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZXRWYWx1ZSA9IHR5cGVvZiB2YWx1ZU9yVXBkYXRlciA9PT0gJ2Z1bmN0aW9uJyA/IC8vIGNhc3QgdG8gYW55IGJlY2F1c2Ugd2UgY2FuJ3QgcmVzdHJpY3QgdHlwZSBTIGZyb20gYmVpbmcgYSBmdW5jdGlvbiBpdHNlbGYgd2l0aG91dCBsb3Npbmcgc3VwcG9ydCBmb3Igb3BhcXVlIHR5cGVzXG4gICAgICAgIC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4gICAgICAgIHZhbHVlT3JVcGRhdGVyKGdldFJlY29pbFZhbHVlKHJlY29pbFN0YXRlKSkgOiB2YWx1ZU9yVXBkYXRlcjtcbiAgICAgICAgY29uc3QgdXBzdHJlYW1Xcml0ZXMgPSBzZXROb2RlVmFsdWUkMyhzdG9yZSwgc3RhdGUsIHJlY29pbFN0YXRlLmtleSwgc2V0VmFsdWUpO1xuICAgICAgICB1cHN0cmVhbVdyaXRlcy5mb3JFYWNoKCh2LCBrKSA9PiB3cml0ZXMuc2V0KGssIHYpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVzZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xuICAgICAgICBzZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSwgREVGQVVMVF9WQUxVRSQ2KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmV0ID0gc2V0KHtcbiAgICAgICAgc2V0OiBzZXRSZWNvaWxTdGF0ZSxcbiAgICAgICAgZ2V0OiBnZXRSZWNvaWxWYWx1ZSxcbiAgICAgICAgcmVzZXQ6IHJlc2V0UmVjb2lsU3RhdGVcbiAgICAgIH0sIG5ld1ZhbHVlKTsgLy8gc2V0IHNob3VsZCBiZSBhIHZvaWQgbWV0aG9kLCBidXQgaWYgdGhlIHVzZXIgbWFrZXMgaXQgYGFzeW5jYCwgdGhlbiBpdFxuICAgICAgLy8gd2lsbCByZXR1cm4gYSBQcm9taXNlLCB3aGljaCB3ZSBkb24ndCBjdXJyZW50bHkgc3VwcG9ydC5cblxuICAgICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IFJlY29pbF9pc1Byb21pc2UocmV0KSA/IFJlY29pbF9lcnIoJ1JlY29pbDogQXN5bmMgc2VsZWN0b3Igc2V0cyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuJykgOiBSZWNvaWxfZXJyKCdSZWNvaWw6IHNlbGVjdG9yIHNldCBzaG91bGQgYmUgYSB2b2lkIGZ1bmN0aW9uLicpO1xuICAgICAgfVxuXG4gICAgICBzeW5jU2VsZWN0b3JTZXRGaW5pc2hlZCA9IHRydWU7XG4gICAgICByZXR1cm4gd3JpdGVzO1xuICAgIH07XG5cbiAgICByZXR1cm4gcmVjb2lsVmFsdWUgPSByZWdpc3Rlck5vZGUkMSh7XG4gICAgICBrZXksXG4gICAgICBub2RlVHlwZTogJ3NlbGVjdG9yJyxcbiAgICAgIHBlZWs6IHNlbGVjdG9yUGVlayxcbiAgICAgIGdldDogc2VsZWN0b3JHZXQsXG4gICAgICBzZXQ6IHNlbGVjdG9yU2V0LFxuICAgICAgaW5pdDogc2VsZWN0b3JJbml0LFxuICAgICAgaW52YWxpZGF0ZTogaW52YWxpZGF0ZVNlbGVjdG9yLFxuICAgICAgY2xlYXJDYWNoZTogY2xlYXJTZWxlY3RvckNhY2hlLFxuICAgICAgc2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlOiBzZWxlY3RvclNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZSxcbiAgICAgIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiBvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5LFxuICAgICAgc2hvdWxkUmVzdG9yZUZyb21TbmFwc2hvdHM6IGZhbHNlLFxuICAgICAgcmV0YWluZWRCeVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZWNvaWxWYWx1ZSA9IHJlZ2lzdGVyTm9kZSQxKHtcbiAgICAgIGtleSxcbiAgICAgIG5vZGVUeXBlOiAnc2VsZWN0b3InLFxuICAgICAgcGVlazogc2VsZWN0b3JQZWVrLFxuICAgICAgZ2V0OiBzZWxlY3RvckdldCxcbiAgICAgIGluaXQ6IHNlbGVjdG9ySW5pdCxcbiAgICAgIGludmFsaWRhdGU6IGludmFsaWRhdGVTZWxlY3RvcixcbiAgICAgIGNsZWFyQ2FjaGU6IGNsZWFyU2VsZWN0b3JDYWNoZSxcbiAgICAgIHNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZTogc2VsZWN0b3JTaG91bGREZWxldGVDb25maWdPblJlbGVhc2UsXG4gICAgICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSxcbiAgICAgIHNob3VsZFJlc3RvcmVGcm9tU25hcHNob3RzOiBmYWxzZSxcbiAgICAgIHJldGFpbmVkQnlcbiAgICB9KTtcbiAgfVxufVxuLyogZXNsaW50LWVuYWJsZSBuby1yZWRlY2xhcmUgKi9cbi8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLXVzZV1cbi8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cblxuXG5zZWxlY3Rvci52YWx1ZSA9IHZhbHVlID0+IG5ldyBXcmFwcGVkVmFsdWUkMSh2YWx1ZSk7XG5cbnZhciBSZWNvaWxfc2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuLy8gQGZiLW9ubHk6IGltcG9ydCB0eXBlIHtTY29wZVJ1bGVzfSBmcm9tICdSZWNvaWxfU2NvcGVkQXRvbSc7XG4vLyBAZmItb25seTogY29uc3Qge3Njb3BlZEF0b219ID0gcmVxdWlyZSgnUmVjb2lsX1Njb3BlZEF0b20nKTtcbmNvbnN0IHtcbiAgaXNMb2FkYWJsZTogaXNMb2FkYWJsZSQyLFxuICBsb2FkYWJsZVdpdGhFcnJvcjogbG9hZGFibGVXaXRoRXJyb3IkMixcbiAgbG9hZGFibGVXaXRoUHJvbWlzZTogbG9hZGFibGVXaXRoUHJvbWlzZSQyLFxuICBsb2FkYWJsZVdpdGhWYWx1ZTogbG9hZGFibGVXaXRoVmFsdWUkM1xufSA9IFJlY29pbF9Mb2FkYWJsZSQxO1xuXG5jb25zdCB7XG4gIFdyYXBwZWRWYWx1ZTogV3JhcHBlZFZhbHVlJDJcbn0gPSBSZWNvaWxfV3JhcHBlciQxO1xuXG5jb25zdCB7XG4gIHBlZWtOb2RlSW5mbzogcGVla05vZGVJbmZvJDNcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XG5cbmNvbnN0IHtcbiAgREVGQVVMVF9WQUxVRTogREVGQVVMVF9WQUxVRSQ3LFxuICBEZWZhdWx0VmFsdWU6IERlZmF1bHRWYWx1ZSQyLFxuICBnZXRDb25maWdEZWxldGlvbkhhbmRsZXI6IGdldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQyLFxuICByZWdpc3Rlck5vZGU6IHJlZ2lzdGVyTm9kZSQyLFxuICBzZXRDb25maWdEZWxldGlvbkhhbmRsZXI6IHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQxXG59ID0gUmVjb2lsX05vZGU7XG5cbmNvbnN0IHtcbiAgaXNSZWNvaWxWYWx1ZTogaXNSZWNvaWxWYWx1ZSQ0XG59ID0gUmVjb2lsX1JlY29pbFZhbHVlJDE7XG5cbmNvbnN0IHtcbiAgZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlOiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkNCxcbiAgbWFya1JlY29pbFZhbHVlTW9kaWZpZWQ6IG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkJDIsXG4gIHNldFJlY29pbFZhbHVlOiBzZXRSZWNvaWxWYWx1ZSQ0LFxuICBzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlOiBzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlJDJcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XG5cbmNvbnN0IHtcbiAgcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0OiByZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHQkMlxufSA9IFJlY29pbF9SZXRlbnRpb247XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jb25zdCB1bndyYXAgPSB4ID0+IHggaW5zdGFuY2VvZiBXcmFwcGVkVmFsdWUkMiA/IHgudmFsdWUgOiB4O1xuXG5mdW5jdGlvbiBiYXNlQXRvbShvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBrZXksXG4gICAgcGVyc2lzdGVuY2VfVU5TVEFCTEU6IHBlcnNpc3RlbmNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCByZXRhaW5lZEJ5ID0gcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0JDIob3B0aW9ucy5yZXRhaW5lZEJ5X1VOU1RBQkxFKTtcbiAgbGV0IGxpdmVTdG9yZXNDb3VudCA9IDA7XG5cbiAgZnVuY3Rpb24gdW53cmFwUHJvbWlzZShwcm9taXNlKSB7XG4gICAgcmV0dXJuIGxvYWRhYmxlV2l0aFByb21pc2UkMihwcm9taXNlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgZGVmYXVsdExvYWRhYmxlID0gbG9hZGFibGVXaXRoVmFsdWUkMyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgZGVmYXVsdExvYWRhYmxlID0gbG9hZGFibGVXaXRoRXJyb3IkMihlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KSk7XG4gIH1cblxuICBsZXQgZGVmYXVsdExvYWRhYmxlID0gUmVjb2lsX2lzUHJvbWlzZShvcHRpb25zLmRlZmF1bHQpID8gdW53cmFwUHJvbWlzZShvcHRpb25zLmRlZmF1bHQpIDogaXNMb2FkYWJsZSQyKG9wdGlvbnMuZGVmYXVsdCkgPyBvcHRpb25zLmRlZmF1bHQuc3RhdGUgPT09ICdsb2FkaW5nJyA/IHVud3JhcFByb21pc2Uob3B0aW9ucy5kZWZhdWx0LmNvbnRlbnRzKSA6IG9wdGlvbnMuZGVmYXVsdCA6IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdXG4gIGxvYWRhYmxlV2l0aFZhbHVlJDModW53cmFwKG9wdGlvbnMuZGVmYXVsdCkpO1xuICBtYXliZUZyZWV6ZVZhbHVlT3JQcm9taXNlKGRlZmF1bHRMb2FkYWJsZS5jb250ZW50cyk7XG4gIGxldCBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlID0gdW5kZWZpbmVkOyAvLyBDbGVhbnVwIGhhbmRsZXJzIGZvciB0aGlzIGF0b21cbiAgLy8gUmVseSBvbiBzdGFibGUgcmVmZXJlbmNlIGVxdWFsaXR5IG9mIHRoZSBzdG9yZSB0byB1c2UgaXQgYXMgYSBrZXkgcGVyIDxSZWNvaWxSb290PlxuXG4gIGNvbnN0IGNsZWFudXBFZmZlY3RzQnlTdG9yZSA9IG5ldyBNYXAoKTtcblxuICBmdW5jdGlvbiBtYXliZUZyZWV6ZVZhbHVlT3JQcm9taXNlKHZhbHVlT3JQcm9taXNlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKG9wdGlvbnMuZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHkgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UodmFsdWVPclByb21pc2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlT3JQcm9taXNlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgUmVjb2lsX2RlZXBGcmVlemVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUmVjb2lsX2RlZXBGcmVlemVWYWx1ZSh2YWx1ZU9yUHJvbWlzZSk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlT3JQcm9taXNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlT3JQcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcFBlbmRpbmdQcm9taXNlKHN0b3JlLCBwcm9taXNlKSB7XG4gICAgY29uc3Qgd3JhcHBlZFByb21pc2UgPSBwcm9taXNlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCwgX3N0YXRlJGF0b21WYWx1ZXMkZ2V0O1xuXG4gICAgICBjb25zdCBzdGF0ZSA9IChfc3RvcmUkZ2V0U3RhdGUkbmV4dFQgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQgIT09IHZvaWQgMCA/IF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCA6IHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWU7XG5cbiAgICAgIGlmICgoKF9zdGF0ZSRhdG9tVmFsdWVzJGdldCA9IHN0YXRlLmF0b21WYWx1ZXMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9zdGF0ZSRhdG9tVmFsdWVzJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlJGF0b21WYWx1ZXMkZ2V0LmNvbnRlbnRzKSA9PT0gd3JhcHBlZFByb21pc2UpIHtcbiAgICAgICAgc2V0UmVjb2lsVmFsdWUkNChzdG9yZSwgbm9kZSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDIsIF9zdGF0ZSRhdG9tVmFsdWVzJGdldDI7XG5cbiAgICAgIGNvbnN0IHN0YXRlID0gKF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDIgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQyICE9PSB2b2lkIDAgPyBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQyIDogc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZTtcblxuICAgICAgaWYgKCgoX3N0YXRlJGF0b21WYWx1ZXMkZ2V0MiA9IHN0YXRlLmF0b21WYWx1ZXMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9zdGF0ZSRhdG9tVmFsdWVzJGdldDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZSRhdG9tVmFsdWVzJGdldDIuY29udGVudHMpID09PSB3cmFwcGVkUHJvbWlzZSkge1xuICAgICAgICBzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlJDIoc3RvcmUsIG5vZGUsIGxvYWRhYmxlV2l0aEVycm9yJDIoZXJyb3IpKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gICAgcmV0dXJuIHdyYXBwZWRQcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdEF0b20oc3RvcmUsIGluaXRTdGF0ZSwgdHJpZ2dlcikge1xuICAgIHZhciBfb3B0aW9ucyRlZmZlY3RzO1xuXG4gICAgbGl2ZVN0b3Jlc0NvdW50Kys7XG5cbiAgICBjb25zdCBjbGVhbnVwQXRvbSA9ICgpID0+IHtcbiAgICAgIHZhciBfY2xlYW51cEVmZmVjdHNCeVN0b3I7XG5cbiAgICAgIGxpdmVTdG9yZXNDb3VudC0tO1xuICAgICAgKF9jbGVhbnVwRWZmZWN0c0J5U3RvciA9IGNsZWFudXBFZmZlY3RzQnlTdG9yZS5nZXQoc3RvcmUpKSA9PT0gbnVsbCB8fCBfY2xlYW51cEVmZmVjdHNCeVN0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jbGVhbnVwRWZmZWN0c0J5U3Rvci5mb3JFYWNoKGNsZWFudXAgPT4gY2xlYW51cCgpKTtcbiAgICAgIGNsZWFudXBFZmZlY3RzQnlTdG9yZS5kZWxldGUoc3RvcmUpO1xuICAgIH07XG5cbiAgICBzdG9yZS5nZXRTdGF0ZSgpLmtub3duQXRvbXMuYWRkKGtleSk7IC8vIFNldHVwIGFzeW5jIGRlZmF1bHRzIHRvIG5vdGlmeSBzdWJzY3JpYmVycyB3aGVuIHRoZXkgcmVzb2x2ZVxuXG4gICAgaWYgKGRlZmF1bHRMb2FkYWJsZS5zdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICBjb25zdCBub3RpZnlEZWZhdWx0U3Vic2NyaWJlcnMgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQzO1xuXG4gICAgICAgIGNvbnN0IHN0YXRlID0gKF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDMgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQzICE9PSB2b2lkIDAgPyBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQzIDogc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZTtcblxuICAgICAgICBpZiAoIXN0YXRlLmF0b21WYWx1ZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCQyKHN0b3JlLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZGVmYXVsdExvYWRhYmxlLmNvbnRlbnRzLmZpbmFsbHkobm90aWZ5RGVmYXVsdFN1YnNjcmliZXJzKTtcbiAgICB9IC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBSdW4gQXRvbSBFZmZlY3RzXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbiAgICBjb25zdCBlZmZlY3RzID0gKF9vcHRpb25zJGVmZmVjdHMgPSBvcHRpb25zLmVmZmVjdHMpICE9PSBudWxsICYmIF9vcHRpb25zJGVmZmVjdHMgIT09IHZvaWQgMCA/IF9vcHRpb25zJGVmZmVjdHMgOiBvcHRpb25zLmVmZmVjdHNfVU5TVEFCTEU7XG5cbiAgICBpZiAoZWZmZWN0cyAhPSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHN0YXRlIGlzIHNjb3BlZCBieSBTdG9yZSwgc2luY2UgdGhpcyBpcyBpbiB0aGUgaW5pdEF0b20oKSBjbG9zdXJlXG4gICAgICBsZXQgaW5pdFZhbHVlID0gREVGQVVMVF9WQUxVRSQ3O1xuICAgICAgbGV0IGlzRHVyaW5nSW5pdCA9IHRydWU7XG4gICAgICBsZXQgaXNJbml0RXJyb3IgPSBmYWxzZTtcbiAgICAgIGxldCBwZW5kaW5nU2V0U2VsZiA9IG51bGw7XG5cbiAgICAgIGZ1bmN0aW9uIGdldExvYWRhYmxlKHJlY29pbFZhbHVlKSB7XG4gICAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBqdXN0IGdldCB0aGUgY3VycmVudCB2YWx1ZSBvZiBhbm90aGVyIGF0b20uXG4gICAgICAgIC8vIEJ1dCBmb3Igb3VyIG93biB2YWx1ZSB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIGEgcGVuZGluZ1xuICAgICAgICAvLyBpbml0aWFsaXplZCB2YWx1ZSBvciBnZXQgdGhlIGZhbGxiYWNrIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgIGlmIChpc0R1cmluZ0luaXQgJiYgcmVjb2lsVmFsdWUua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAvLyBDYXN0IFQgdG8gU1xuICAgICAgICAgIGNvbnN0IHJldFZhbHVlID0gaW5pdFZhbHVlOyAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcblxuICAgICAgICAgIHJldHVybiByZXRWYWx1ZSBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQyID8gcGVla0F0b20oc3RvcmUsIGluaXRTdGF0ZSkgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4gICAgICAgICAgOiBSZWNvaWxfaXNQcm9taXNlKHJldFZhbHVlKSA/IGxvYWRhYmxlV2l0aFByb21pc2UkMihyZXRWYWx1ZS50aGVuKHYgPT4gdiBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQyID8gLy8gQ2FzdCBUIHRvIFNcbiAgICAgICAgICBkZWZhdWx0TG9hZGFibGUudG9Qcm9taXNlKCkgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4gICAgICAgICAgOiB2KSkgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXVxuICAgICAgICAgIGxvYWRhYmxlV2l0aFZhbHVlJDMocmV0VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQ0KHN0b3JlLCByZWNvaWxWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFByb21pc2UocmVjb2lsVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGdldExvYWRhYmxlKHJlY29pbFZhbHVlKS50b1Byb21pc2UoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0SW5mb19VTlNUQUJMRShyZWNvaWxWYWx1ZSkge1xuICAgICAgICB2YXIgX3N0b3JlJGdldFN0YXRlJG5leHRUNDtcblxuICAgICAgICBjb25zdCBpbmZvID0gcGVla05vZGVJbmZvJDMoc3RvcmUsIChfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ0ID0gc3RvcmUuZ2V0U3RhdGUoKS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlJGdldFN0YXRlJG5leHRUNCAhPT0gdm9pZCAwID8gX3N0b3JlJGdldFN0YXRlJG5leHRUNCA6IHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUsIHJlY29pbFZhbHVlLmtleSk7XG4gICAgICAgIHJldHVybiBpc0R1cmluZ0luaXQgJiYgcmVjb2lsVmFsdWUua2V5ID09PSBrZXkgJiYgIShpbml0VmFsdWUgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMikgPyB7IC4uLmluZm8sXG4gICAgICAgICAgaXNTZXQ6IHRydWUsXG4gICAgICAgICAgbG9hZGFibGU6IGdldExvYWRhYmxlKHJlY29pbFZhbHVlKVxuICAgICAgICB9IDogaW5mbztcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2V0U2VsZiA9IGVmZmVjdCA9PiB2YWx1ZU9yVXBkYXRlciA9PiB7XG4gICAgICAgIGlmIChpc0R1cmluZ0luaXQpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50TG9hZGFibGUgPSBnZXRMb2FkYWJsZShub2RlKTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBjdXJyZW50TG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScgPyBjdXJyZW50TG9hZGFibGUuY29udGVudHMgOiBERUZBVUxUX1ZBTFVFJDc7XG4gICAgICAgICAgaW5pdFZhbHVlID0gdHlwZW9mIHZhbHVlT3JVcGRhdGVyID09PSAnZnVuY3Rpb24nID8gLy8gY2FzdCB0byBhbnkgYmVjYXVzZSB3ZSBjYW4ndCByZXN0cmljdCBUIGZyb20gYmVpbmcgYSBmdW5jdGlvbiB3aXRob3V0IGxvc2luZyBzdXBwb3J0IGZvciBvcGFxdWUgdHlwZXNcbiAgICAgICAgICB2YWx1ZU9yVXBkYXRlcihjdXJyZW50VmFsdWUpIC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuICAgICAgICAgIDogdmFsdWVPclVwZGF0ZXI7XG5cbiAgICAgICAgICBpZiAoUmVjb2lsX2lzUHJvbWlzZShpbml0VmFsdWUpKSB7XG4gICAgICAgICAgICBpbml0VmFsdWUgPSBpbml0VmFsdWUudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgIC8vIEF2b2lkIGNhbGxpbmcgb25TZXQoKSB3aGVuIHNldFNlbGYoKSBpbml0aWFsaXplcyB3aXRoIGEgUHJvbWlzZVxuICAgICAgICAgICAgICBwZW5kaW5nU2V0U2VsZiA9IHtcbiAgICAgICAgICAgICAgICBlZmZlY3QsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKHZhbHVlT3JVcGRhdGVyKSkge1xuICAgICAgICAgICAgdGhyb3cgUmVjb2lsX2VycignU2V0dGluZyBhdG9tcyB0byBhc3luYyB2YWx1ZXMgaXMgbm90IGltcGxlbWVudGVkLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVPclVwZGF0ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHBlbmRpbmdTZXRTZWxmID0ge1xuICAgICAgICAgICAgICBlZmZlY3QsXG4gICAgICAgICAgICAgIHZhbHVlOiB1bndyYXAodmFsdWVPclVwZGF0ZXIpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldFJlY29pbFZhbHVlJDQoc3RvcmUsIG5vZGUsIHR5cGVvZiB2YWx1ZU9yVXBkYXRlciA9PT0gJ2Z1bmN0aW9uJyA/IGN1cnJlbnRWYWx1ZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHVud3JhcCggLy8gY2FzdCB0byBhbnkgYmVjYXVzZSB3ZSBjYW4ndCByZXN0cmljdCBUIGZyb20gYmVpbmcgYSBmdW5jdGlvbiB3aXRob3V0IGxvc2luZyBzdXBwb3J0IGZvciBvcGFxdWUgdHlwZXNcbiAgICAgICAgICAgIHZhbHVlT3JVcGRhdGVyKGN1cnJlbnRWYWx1ZSkgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4gICAgICAgICAgICApOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXVxuXG4gICAgICAgICAgICBwZW5kaW5nU2V0U2VsZiA9IHtcbiAgICAgICAgICAgICAgZWZmZWN0LFxuICAgICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgICAgICAgfSA6IHVud3JhcCh2YWx1ZU9yVXBkYXRlcikpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXNldFNlbGYgPSBlZmZlY3QgPT4gKCkgPT4gc2V0U2VsZihlZmZlY3QpKERFRkFVTFRfVkFMVUUkNyk7XG5cbiAgICAgIGNvbnN0IG9uU2V0ID0gZWZmZWN0ID0+IGhhbmRsZXIgPT4ge1xuICAgICAgICB2YXIgX2NsZWFudXBFZmZlY3RzQnlTdG9yMjtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmVsZWFzZVxuICAgICAgICB9ID0gc3RvcmUuc3Vic2NyaWJlVG9UcmFuc2FjdGlvbnMoY3VycmVudFN0b3JlID0+IHtcbiAgICAgICAgICB2YXIgX2N1cnJlbnRUcmVlJGF0b21WYWx1O1xuXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBjdXJyZW50VHJlZSxcbiAgICAgICAgICAgIHByZXZpb3VzVHJlZVxuICAgICAgICAgIH0gPSBjdXJyZW50U3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgICAgIGlmICghcHJldmlvdXNUcmVlKSB7XG4gICAgICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ1RyYW5zYWN0aW9uIHN1YnNjcmliZXJzIG5vdGlmaWVkIHdpdGhvdXQgYSBuZXh0IHRyZWUgYmVpbmcgcHJlc2VudCAtLSB0aGlzIGlzIGEgYnVnIGluIFJlY29pbCcpO1xuICAgICAgICAgICAgcHJldmlvdXNUcmVlID0gY3VycmVudFRyZWU7IC8vIGF0dGVtcHQgdG8gdHJ1bmRsZSBvblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG5ld0xvYWRhYmxlID0gKF9jdXJyZW50VHJlZSRhdG9tVmFsdSA9IGN1cnJlbnRUcmVlLmF0b21WYWx1ZXMuZ2V0KGtleSkpICE9PSBudWxsICYmIF9jdXJyZW50VHJlZSRhdG9tVmFsdSAhPT0gdm9pZCAwID8gX2N1cnJlbnRUcmVlJGF0b21WYWx1IDogZGVmYXVsdExvYWRhYmxlO1xuXG4gICAgICAgICAgaWYgKG5ld0xvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnKSB7XG4gICAgICAgICAgICB2YXIgX3ByZXZpb3VzVHJlZSRhdG9tVmFsLCBfcGVuZGluZ1NldFNlbGYsIF9wZW5kaW5nU2V0U2VsZjIsIF9wZW5kaW5nU2V0U2VsZjM7XG5cbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gbmV3TG9hZGFibGUuY29udGVudHM7XG4gICAgICAgICAgICBjb25zdCBvbGRMb2FkYWJsZSA9IChfcHJldmlvdXNUcmVlJGF0b21WYWwgPSBwcmV2aW91c1RyZWUuYXRvbVZhbHVlcy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX3ByZXZpb3VzVHJlZSRhdG9tVmFsICE9PSB2b2lkIDAgPyBfcHJldmlvdXNUcmVlJGF0b21WYWwgOiBkZWZhdWx0TG9hZGFibGU7XG4gICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IG9sZExvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnID8gb2xkTG9hZGFibGUuY29udGVudHMgOiBERUZBVUxUX1ZBTFVFJDc7IC8vIFRPRE8gVGhpcyBpc24ndCBhY3R1YWxseSB2YWxpZCwgdXNlIGFzIGEgcGxhY2Vob2xkZXIgZm9yIG5vdy5cbiAgICAgICAgICAgIC8vIElnbm9yZSBhdG9tIHZhbHVlIGNoYW5nZXMgdGhhdCB3ZXJlIHNldCB2aWEgc2V0U2VsZigpIGluIHRoZSBzYW1lIGVmZmVjdC5cbiAgICAgICAgICAgIC8vIFdlIHdpbGwgc3RpbGwgcHJvcGVybHkgY2FsbCB0aGUgaGFuZGxlciBpZiB0aGVyZSB3YXMgYSBzdWJzZXF1ZW50XG4gICAgICAgICAgICAvLyBzZXQgZnJvbSBzb21ldGhpbmcgb3RoZXIgdGhhbiBhbiBhdG9tIGVmZmVjdCB3aGljaCB3YXMgYmF0Y2hlZFxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgYHNldFNlbGYoKWAgY2FsbC4gIEhvd2V2ZXIsIHdlIG1heSBpbmNvcnJlY3RseSBpZ25vcmVcbiAgICAgICAgICAgIC8vIHRoZSBoYW5kbGVyIGlmIHRoZSBzdWJzZXF1ZW50IGJhdGNoZWQgY2FsbCBoYXBwZW5zIHRvIHNldCB0aGVcbiAgICAgICAgICAgIC8vIGF0b20gdG8gdGhlIGV4YWN0IHNhbWUgdmFsdWUgYXMgdGhlIGBzZXRTZWxmKClgLiAgIEJ1dCwgaW4gdGhhdFxuICAgICAgICAgICAgLy8gY2FzZSwgaXQgd2FzIGtpbmQgb2YgYSBub29wLCBzbyB0aGUgc2VtYW50aWNzIGFyZSBkZWJhdGFibGUuLlxuXG4gICAgICAgICAgICBpZiAoKChfcGVuZGluZ1NldFNlbGYgPSBwZW5kaW5nU2V0U2VsZikgPT09IG51bGwgfHwgX3BlbmRpbmdTZXRTZWxmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGVuZGluZ1NldFNlbGYuZWZmZWN0KSAhPT0gZWZmZWN0IHx8ICgoX3BlbmRpbmdTZXRTZWxmMiA9IHBlbmRpbmdTZXRTZWxmKSA9PT0gbnVsbCB8fCBfcGVuZGluZ1NldFNlbGYyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGVuZGluZ1NldFNlbGYyLnZhbHVlKSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgaGFuZGxlcihuZXdWYWx1ZSwgb2xkVmFsdWUsICFjdXJyZW50VHJlZS5hdG9tVmFsdWVzLmhhcyhrZXkpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKChfcGVuZGluZ1NldFNlbGYzID0gcGVuZGluZ1NldFNlbGYpID09PSBudWxsIHx8IF9wZW5kaW5nU2V0U2VsZjMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wZW5kaW5nU2V0U2VsZjMuZWZmZWN0KSA9PT0gZWZmZWN0KSB7XG4gICAgICAgICAgICAgIHBlbmRpbmdTZXRTZWxmID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIGtleSk7XG4gICAgICAgIGNsZWFudXBFZmZlY3RzQnlTdG9yZS5zZXQoc3RvcmUsIFsuLi4oKF9jbGVhbnVwRWZmZWN0c0J5U3RvcjIgPSBjbGVhbnVwRWZmZWN0c0J5U3RvcmUuZ2V0KHN0b3JlKSkgIT09IG51bGwgJiYgX2NsZWFudXBFZmZlY3RzQnlTdG9yMiAhPT0gdm9pZCAwID8gX2NsZWFudXBFZmZlY3RzQnlTdG9yMiA6IFtdKSwgcmVsZWFzZV0pO1xuICAgICAgfTtcblxuICAgICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSBlZmZlY3Qoe1xuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHN0b3JlSUQ6IHN0b3JlLnN0b3JlSUQsXG4gICAgICAgICAgICBwYXJlbnRTdG9yZUlEX1VOU1RBQkxFOiBzdG9yZS5wYXJlbnRTdG9yZUlELFxuICAgICAgICAgICAgdHJpZ2dlcixcbiAgICAgICAgICAgIHNldFNlbGY6IHNldFNlbGYoZWZmZWN0KSxcbiAgICAgICAgICAgIHJlc2V0U2VsZjogcmVzZXRTZWxmKGVmZmVjdCksXG4gICAgICAgICAgICBvblNldDogb25TZXQoZWZmZWN0KSxcbiAgICAgICAgICAgIGdldFByb21pc2UsXG4gICAgICAgICAgICBnZXRMb2FkYWJsZSxcbiAgICAgICAgICAgIGdldEluZm9fVU5TVEFCTEVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChjbGVhbnVwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfY2xlYW51cEVmZmVjdHNCeVN0b3IzO1xuXG4gICAgICAgICAgICBjbGVhbnVwRWZmZWN0c0J5U3RvcmUuc2V0KHN0b3JlLCBbLi4uKChfY2xlYW51cEVmZmVjdHNCeVN0b3IzID0gY2xlYW51cEVmZmVjdHNCeVN0b3JlLmdldChzdG9yZSkpICE9PSBudWxsICYmIF9jbGVhbnVwRWZmZWN0c0J5U3RvcjMgIT09IHZvaWQgMCA/IF9jbGVhbnVwRWZmZWN0c0J5U3RvcjMgOiBbXSksIGNsZWFudXBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaW5pdFZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgaXNJbml0RXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlzRHVyaW5nSW5pdCA9IGZhbHNlOyAvLyBNdXRhdGUgaW5pdGlhbCBzdGF0ZSBpbiBwbGFjZSBzaW5jZSB3ZSBrbm93IHRoZXJlIGFyZSBubyBvdGhlciBzdWJzY3JpYmVyc1xuICAgICAgLy8gc2luY2Ugd2UgYXJlIHRoZSBvbmVzIGluaXRpYWxpemluZyBvbiBmaXJzdCB1c2UuXG5cbiAgICAgIGlmICghKGluaXRWYWx1ZSBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQyKSkge1xuICAgICAgICB2YXIgX3N0b3JlJGdldFN0YXRlJG5leHRUNTtcblxuICAgICAgICBjb25zdCBpbml0TG9hZGFibGUgPSBpc0luaXRFcnJvciA/IGxvYWRhYmxlV2l0aEVycm9yJDIoaW5pdFZhbHVlKSA6IFJlY29pbF9pc1Byb21pc2UoaW5pdFZhbHVlKSA/IGxvYWRhYmxlV2l0aFByb21pc2UkMih3cmFwUGVuZGluZ1Byb21pc2Uoc3RvcmUsIGluaXRWYWx1ZSkpIDogbG9hZGFibGVXaXRoVmFsdWUkMyh1bndyYXAoaW5pdFZhbHVlKSk7XG4gICAgICAgIG1heWJlRnJlZXplVmFsdWVPclByb21pc2UoaW5pdExvYWRhYmxlLmNvbnRlbnRzKTtcbiAgICAgICAgaW5pdFN0YXRlLmF0b21WYWx1ZXMuc2V0KGtleSwgaW5pdExvYWRhYmxlKTsgLy8gSWYgdGhlcmUgaXMgYSBwZW5kaW5nIHRyYW5zYWN0aW9uLCB0aGVuIGFsc28gbXV0YXRlIHRoZSBuZXh0IHN0YXRlIHRyZWUuXG4gICAgICAgIC8vIFRoaXMgY291bGQgaGFwcGVuIGlmIHRoZSBhdG9tIHdhcyBmaXJzdCBpbml0aWFsaXplZCBpbiBhbiBhY3Rpb24gdGhhdFxuICAgICAgICAvLyBhbHNvIHVwZGF0ZWQgc29tZSBvdGhlciBhdG9tJ3Mgc3RhdGUuXG5cbiAgICAgICAgKF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDUgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ1LmF0b21WYWx1ZXMuc2V0KGtleSwgaW5pdExvYWRhYmxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xlYW51cEF0b207XG4gIH1cblxuICBmdW5jdGlvbiBwZWVrQXRvbShfc3RvcmUsIHN0YXRlKSB7XG4gICAgdmFyIF9yZWYsIF9zdGF0ZSRhdG9tVmFsdWVzJGdldDM7XG5cbiAgICByZXR1cm4gKF9yZWYgPSAoX3N0YXRlJGF0b21WYWx1ZXMkZ2V0MyA9IHN0YXRlLmF0b21WYWx1ZXMuZ2V0KGtleSkpICE9PSBudWxsICYmIF9zdGF0ZSRhdG9tVmFsdWVzJGdldDMgIT09IHZvaWQgMCA/IF9zdGF0ZSRhdG9tVmFsdWVzJGdldDMgOiBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlKSAhPT0gbnVsbCAmJiBfcmVmICE9PSB2b2lkIDAgPyBfcmVmIDogZGVmYXVsdExvYWRhYmxlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QXRvbShfc3RvcmUsIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmF0b21WYWx1ZXMuaGFzKGtleSkpIHtcbiAgICAgIC8vIEF0b20gdmFsdWUgaXMgc3RvcmVkIGluIHN0YXRlOlxuICAgICAgcmV0dXJuIFJlY29pbF9udWxsdGhyb3dzKHN0YXRlLmF0b21WYWx1ZXMuZ2V0KGtleSkpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubm9udmFsaWRhdGVkQXRvbXMuaGFzKGtleSkpIHtcbiAgICAgIC8vIEF0b20gdmFsdWUgaXMgc3RvcmVkIGJ1dCBuZWVkcyB2YWxpZGF0aW9uIGJlZm9yZSB1c2UuXG4gICAgICAvLyBXZSBtaWdodCBoYXZlIGFscmVhZHkgdmFsaWRhdGVkIGl0IGFuZCBoYXZlIGEgY2FjaGVkIHZhbGlkYXRlZCB2YWx1ZTpcbiAgICAgIGlmIChjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwZXJzaXN0ZW5jZSA9PSBudWxsKSB7XG4gICAgICAgIFJlY29pbF9leHBlY3RhdGlvblZpb2xhdGlvbihgVHJpZWQgdG8gcmVzdG9yZSBhIHBlcnNpc3RlZCB2YWx1ZSBmb3IgYXRvbSAke2tleX0gYnV0IGl0IGhhcyBubyBwZXJzaXN0ZW5jZSBzZXR0aW5ncy5gKTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2FkYWJsZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9udmFsaWRhdGVkVmFsdWUgPSBzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5nZXQoa2V5KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRvclJlc3VsdCA9IHBlcnNpc3RlbmNlLnZhbGlkYXRvcihub252YWxpZGF0ZWRWYWx1ZSwgREVGQVVMVF9WQUxVRSQ3KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFZhbHVlTG9hZGFibGUgPSB2YWxpZGF0b3JSZXN1bHQgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMiA/IGRlZmF1bHRMb2FkYWJsZSA6IGxvYWRhYmxlV2l0aFZhbHVlJDModmFsaWRhdG9yUmVzdWx0KTtcbiAgICAgIGNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWUgPSB2YWxpZGF0ZWRWYWx1ZUxvYWRhYmxlO1xuICAgICAgcmV0dXJuIGNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkZWZhdWx0TG9hZGFibGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52YWxpZGF0ZUF0b20oKSB7XG4gICAgY2FjaGVkQW5zd2VyRm9yVW52YWxpZGF0ZWRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEF0b20oX3N0b3JlLCBzdGF0ZSwgbmV3VmFsdWUpIHtcbiAgICAvLyBCYWlsIG91dCBpZiB3ZSdyZSBiZWluZyBzZXQgdG8gdGhlIGV4aXN0aW5nIHZhbHVlLCBvciBpZiB3ZSdyZSBiZWluZ1xuICAgIC8vIHJlc2V0IGJ1dCBoYXZlIG5vIHN0b3JlZCB2YWx1ZSAodmFsaWRhdGVkIG9yIHVudmFsaWRhdGVkKSB0byByZXNldCBmcm9tOlxuICAgIGlmIChzdGF0ZS5hdG9tVmFsdWVzLmhhcyhrZXkpKSB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IFJlY29pbF9udWxsdGhyb3dzKHN0YXRlLmF0b21WYWx1ZXMuZ2V0KGtleSkpO1xuXG4gICAgICBpZiAoZXhpc3Rpbmcuc3RhdGUgPT09ICdoYXNWYWx1ZScgJiYgbmV3VmFsdWUgPT09IGV4aXN0aW5nLmNvbnRlbnRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghc3RhdGUubm9udmFsaWRhdGVkQXRvbXMuaGFzKGtleSkgJiYgbmV3VmFsdWUgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMikge1xuICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICBtYXliZUZyZWV6ZVZhbHVlT3JQcm9taXNlKG5ld1ZhbHVlKTtcbiAgICBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlID0gdW5kZWZpbmVkOyAvLyBjYW4gYmUgcmVsZWFzZWQgbm93IGlmIGl0IHdhcyBwcmV2aW91c2x5IGluIHVzZVxuXG4gICAgcmV0dXJuIG5ldyBNYXAoKS5zZXQoa2V5LCBsb2FkYWJsZVdpdGhWYWx1ZSQzKG5ld1ZhbHVlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGREZWxldGVDb25maWdPblJlbGVhc2VBdG9tKCkge1xuICAgIHJldHVybiBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMihrZXkpICE9PSB1bmRlZmluZWQgJiYgbGl2ZVN0b3Jlc0NvdW50IDw9IDA7XG4gIH1cblxuICBjb25zdCBub2RlID0gcmVnaXN0ZXJOb2RlJDIoe1xuICAgIGtleSxcbiAgICBub2RlVHlwZTogJ2F0b20nLFxuICAgIHBlZWs6IHBlZWtBdG9tLFxuICAgIGdldDogZ2V0QXRvbSxcbiAgICBzZXQ6IHNldEF0b20sXG4gICAgaW5pdDogaW5pdEF0b20sXG4gICAgaW52YWxpZGF0ZTogaW52YWxpZGF0ZUF0b20sXG4gICAgc2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlOiBzaG91bGREZWxldGVDb25maWdPblJlbGVhc2VBdG9tLFxuICAgIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiBvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5LFxuICAgIHBlcnNpc3RlbmNlX1VOU1RBQkxFOiBvcHRpb25zLnBlcnNpc3RlbmNlX1VOU1RBQkxFID8ge1xuICAgICAgdHlwZTogb3B0aW9ucy5wZXJzaXN0ZW5jZV9VTlNUQUJMRS50eXBlLFxuICAgICAgYmFja0J1dHRvbjogb3B0aW9ucy5wZXJzaXN0ZW5jZV9VTlNUQUJMRS5iYWNrQnV0dG9uXG4gICAgfSA6IHVuZGVmaW5lZCxcbiAgICBzaG91bGRSZXN0b3JlRnJvbVNuYXBzaG90czogdHJ1ZSxcbiAgICByZXRhaW5lZEJ5XG4gIH0pO1xuICByZXR1cm4gbm9kZTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxuZnVuY3Rpb24gYXRvbShvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMua2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgUmVjb2lsX2VycignQSBrZXkgb3B0aW9uIHdpdGggYSB1bmlxdWUgc3RyaW5nIHZhbHVlIG11c3QgYmUgcHJvdmlkZWQgd2hlbiBjcmVhdGluZyBhbiBhdG9tLicpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHsgLy8gQGZiLW9ubHk6IHNjb3BlUnVsZXNfQVBQRU5EX09OTFlfUkVBRF9USEVfRE9DUyxcbiAgICAuLi5yZXN0T3B0aW9uc1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgb3B0aW9uc0RlZmF1bHQgPSAnZGVmYXVsdCcgaW4gb3B0aW9ucyA/IC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLXR5cGVdIE5vIHdheSB0byByZWZpbmUgaW4gRmxvdyB0aGF0IHByb3BlcnR5IGlzIG5vdCBkZWZpbmVkXG4gIG9wdGlvbnMuZGVmYXVsdCA6IG5ldyBQcm9taXNlKCgpID0+IHt9KTtcblxuICBpZiAoaXNSZWNvaWxWYWx1ZSQ0KG9wdGlvbnNEZWZhdWx0KSAvLyBDb250aW51ZSB0byB1c2UgYXRvbVdpdGhGYWxsYmFjayBmb3IgcHJvbWlzZSBkZWZhdWx0cyBmb3Igc2NvcGVkIGF0b21zXG4gIC8vIGZvciBub3csIHNpbmNlIHNjb3BlZCBhdG9tcyBkb24ndCBzdXBwb3J0IGFzeW5jIGRlZmF1bHRzXG4gIC8vIEBmYi1vbmx5OiB8fCAoaXNQcm9taXNlKG9wdGlvbnNEZWZhdWx0KSAmJiBzY29wZVJ1bGVzX0FQUEVORF9PTkxZX1JFQURfVEhFX0RPQ1MpXG4gIC8vIEBmYi1vbmx5OiB8fCAoaXNMb2FkYWJsZShvcHRpb25zRGVmYXVsdCkgJiYgc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTKVxuICApIHtcbiAgICByZXR1cm4gYXRvbVdpdGhGYWxsYmFjayh7IC4uLnJlc3RPcHRpb25zLFxuICAgICAgZGVmYXVsdDogb3B0aW9uc0RlZmF1bHQgLy8gQGZiLW9ubHk6IHNjb3BlUnVsZXNfQVBQRU5EX09OTFlfUkVBRF9USEVfRE9DUyxcblxuICAgIH0pOyAvLyBAZmItb25seTogfSBlbHNlIGlmIChzY29wZVJ1bGVzX0FQUEVORF9PTkxZX1JFQURfVEhFX0RPQ1NcbiAgICAvLyBAZmItb25seTogJiYgIWlzUHJvbWlzZShvcHRpb25zRGVmYXVsdClcbiAgICAvLyBAZmItb25seTogJiYgIWlzTG9hZGFibGUob3B0aW9uc0RlZmF1bHQpXG4gICAgLy8gQGZiLW9ubHk6ICkge1xuICAgIC8vIEBmYi1vbmx5OiByZXR1cm4gc2NvcGVkQXRvbTxUPih7XG4gICAgLy8gQGZiLW9ubHk6IC4uLnJlc3RPcHRpb25zLFxuICAgIC8vIEBmYi1vbmx5OiBkZWZhdWx0OiB1bndyYXA8VD4ob3B0aW9uc0RlZmF1bHQpLFxuICAgIC8vIEBmYi1vbmx5OiBzY29wZVJ1bGVzX0FQUEVORF9PTkxZX1JFQURfVEhFX0RPQ1MsXG4gICAgLy8gQGZiLW9ubHk6IH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlQXRvbSh7IC4uLnJlc3RPcHRpb25zLFxuICAgICAgZGVmYXVsdDogb3B0aW9uc0RlZmF1bHRcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdG9tV2l0aEZhbGxiYWNrKG9wdGlvbnMpIHtcbiAgY29uc3QgYmFzZSA9IGF0b20oeyAuLi5vcHRpb25zLFxuICAgIGRlZmF1bHQ6IERFRkFVTFRfVkFMVUUkNyxcbiAgICBwZXJzaXN0ZW5jZV9VTlNUQUJMRTogb3B0aW9ucy5wZXJzaXN0ZW5jZV9VTlNUQUJMRSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogeyAuLi5vcHRpb25zLnBlcnNpc3RlbmNlX1VOU1RBQkxFLFxuICAgICAgdmFsaWRhdG9yOiBzdG9yZWRWYWx1ZSA9PiBzdG9yZWRWYWx1ZSBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQyID8gc3RvcmVkVmFsdWUgOiBSZWNvaWxfbnVsbHRocm93cyhvcHRpb25zLnBlcnNpc3RlbmNlX1VOU1RBQkxFKS52YWxpZGF0b3Ioc3RvcmVkVmFsdWUsIERFRkFVTFRfVkFMVUUkNylcbiAgICB9LFxuICAgIC8vIFRPRE8gSGFjayBmb3Igbm93LlxuICAgIGVmZmVjdHM6IG9wdGlvbnMuZWZmZWN0cyxcbiAgICAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTogb2ZmXG4gICAgZWZmZWN0c19VTlNUQUJMRTogb3B0aW9ucy5lZmZlY3RzX1VOU1RBQkxFIC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOiBvZmZcblxuICB9KTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF1cblxuICBjb25zdCBzZWwgPSBSZWNvaWxfc2VsZWN0b3Ioe1xuICAgIGtleTogYCR7b3B0aW9ucy5rZXl9X193aXRoRmFsbGJhY2tgLFxuICAgIGdldDogKHtcbiAgICAgIGdldFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGdldChiYXNlKTtcbiAgICAgIHJldHVybiBiYXNlVmFsdWUgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMiA/IG9wdGlvbnMuZGVmYXVsdCA6IGJhc2VWYWx1ZTtcbiAgICB9LFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdXG4gICAgc2V0OiAoe1xuICAgICAgc2V0XG4gICAgfSwgbmV3VmFsdWUpID0+IHNldChiYXNlLCBuZXdWYWx1ZSksXG4gICAgLy8gVGhpcyBzZWxlY3RvciBkb2VzIG5vdCBuZWVkIHRvIGNhY2hlIGFzIGl0IGlzIGEgd3JhcHBlciBzZWxlY3RvclxuICAgIC8vIGFuZCB0aGUgc2VsZWN0b3Igd2l0aGluIHRoZSB3cmFwcGVyIHNlbGVjdG9yIHdpbGwgaGF2ZSBhIGNhY2hlXG4gICAgLy8gb3B0aW9uIGJ5IGRlZmF1bHRcbiAgICBjYWNoZVBvbGljeV9VTlNUQUJMRToge1xuICAgICAgZXZpY3Rpb246ICdtb3N0LXJlY2VudCdcbiAgICB9LFxuICAgIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiBvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5XG4gIH0pO1xuICBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMShzZWwua2V5LCBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMihvcHRpb25zLmtleSkpO1xuICByZXR1cm4gc2VsO1xufSAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG5cblxuYXRvbS52YWx1ZSA9IHZhbHVlID0+IG5ldyBXcmFwcGVkVmFsdWUkMih2YWx1ZSk7XG5cbnZhciBSZWNvaWxfYXRvbSA9IGF0b207XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuY2xhc3MgTWFwQ2FjaGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9vcHRpb25zJG1hcEtleTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9tYXBcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9rZXlNYXBwZXJcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9rZXlNYXBwZXIgPSAoX29wdGlvbnMkbWFwS2V5ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1hcEtleSkgIT09IG51bGwgJiYgX29wdGlvbnMkbWFwS2V5ICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRtYXBLZXkgOiB2ID0+IHY7XG4gIH1cblxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuc2l6ZTtcbiAgfVxuXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyh0aGlzLl9rZXlNYXBwZXIoa2V5KSk7XG4gIH1cblxuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5nZXQodGhpcy5fa2V5TWFwcGVyKGtleSkpO1xuICB9XG5cbiAgc2V0KGtleSwgdmFsKSB7XG4gICAgdGhpcy5fbWFwLnNldCh0aGlzLl9rZXlNYXBwZXIoa2V5KSwgdmFsKTtcbiAgfVxuXG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLl9tYXAuZGVsZXRlKHRoaXMuX2tleU1hcHBlcihrZXkpKTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX21hcC5jbGVhcigpO1xuICB9XG5cbn1cblxudmFyIFJlY29pbF9NYXBDYWNoZSA9IHtcbiAgTWFwQ2FjaGVcbn07XG5cbnZhciBSZWNvaWxfTWFwQ2FjaGVfMSA9IFJlY29pbF9NYXBDYWNoZS5NYXBDYWNoZTtcblxudmFyIFJlY29pbF9NYXBDYWNoZSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIE1hcENhY2hlOiBSZWNvaWxfTWFwQ2FjaGVfMVxufSk7XG5cbmNvbnN0IHtcbiAgTFJVQ2FjaGU6IExSVUNhY2hlJDJcbn0gPSBSZWNvaWxfTFJVQ2FjaGUkMTtcblxuY29uc3Qge1xuICBNYXBDYWNoZTogTWFwQ2FjaGUkMVxufSA9IFJlY29pbF9NYXBDYWNoZSQxO1xuXG5cblxuXG5cblxuXG5jb25zdCBkZWZhdWx0UG9saWN5JDEgPSB7XG4gIGVxdWFsaXR5OiAncmVmZXJlbmNlJyxcbiAgZXZpY3Rpb246ICdub25lJyxcbiAgbWF4U2l6ZTogSW5maW5pdHlcbn07XG5cbmZ1bmN0aW9uIGNhY2hlRnJvbVBvbGljeSh7XG4gIGVxdWFsaXR5ID0gZGVmYXVsdFBvbGljeSQxLmVxdWFsaXR5LFxuICBldmljdGlvbiA9IGRlZmF1bHRQb2xpY3kkMS5ldmljdGlvbixcbiAgbWF4U2l6ZSA9IGRlZmF1bHRQb2xpY3kkMS5tYXhTaXplXG59ID0gZGVmYXVsdFBvbGljeSQxKSB7XG4gIGNvbnN0IHZhbHVlTWFwcGVyID0gZ2V0VmFsdWVNYXBwZXIkMShlcXVhbGl0eSk7XG4gIGNvbnN0IGNhY2hlID0gZ2V0Q2FjaGUoZXZpY3Rpb24sIG1heFNpemUsIHZhbHVlTWFwcGVyKTtcbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZU1hcHBlciQxKGVxdWFsaXR5KSB7XG4gIHN3aXRjaCAoZXF1YWxpdHkpIHtcbiAgICBjYXNlICdyZWZlcmVuY2UnOlxuICAgICAgcmV0dXJuIHZhbCA9PiB2YWw7XG5cbiAgICBjYXNlICd2YWx1ZSc6XG4gICAgICByZXR1cm4gdmFsID0+IFJlY29pbF9zdGFibGVTdHJpbmdpZnkodmFsKTtcbiAgfVxuXG4gIHRocm93IFJlY29pbF9lcnIoYFVucmVjb2duaXplZCBlcXVhbGl0eSBwb2xpY3kgJHtlcXVhbGl0eX1gKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2FjaGUoZXZpY3Rpb24sIG1heFNpemUsIG1hcEtleSkge1xuICBzd2l0Y2ggKGV2aWN0aW9uKSB7XG4gICAgY2FzZSAna2VlcC1hbGwnOlxuICAgICAgcmV0dXJuIG5ldyBNYXBDYWNoZSQxKHtcbiAgICAgICAgbWFwS2V5XG4gICAgICB9KTtcblxuICAgIGNhc2UgJ2xydSc6XG4gICAgICByZXR1cm4gbmV3IExSVUNhY2hlJDIoe1xuICAgICAgICBtYXBLZXksXG4gICAgICAgIG1heFNpemU6IFJlY29pbF9udWxsdGhyb3dzKG1heFNpemUpXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ21vc3QtcmVjZW50JzpcbiAgICAgIHJldHVybiBuZXcgTFJVQ2FjaGUkMih7XG4gICAgICAgIG1hcEtleSxcbiAgICAgICAgbWF4U2l6ZTogMVxuICAgICAgfSk7XG4gIH1cblxuICB0aHJvdyBSZWNvaWxfZXJyKGBVbnJlY29nbml6ZWQgZXZpY3Rpb24gcG9saWN5ICR7ZXZpY3Rpb259YCk7XG59XG5cbnZhciBSZWNvaWxfY2FjaGVGcm9tUG9saWN5ID0gY2FjaGVGcm9tUG9saWN5O1xuXG4vLyBAZmItb25seTogaW1wb3J0IHR5cGUge1Njb3BlUnVsZXN9IGZyb20gJ1JlY29pbF9TY29wZWRBdG9tJztcblxuXG5jb25zdCB7XG4gIHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlcjogc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDJcbn0gPSBSZWNvaWxfTm9kZTtcblxuXG5cblxuXG4vLyBQcm9jZXNzIHNjb3BlUnVsZXMgdG8gaGFuZGxlIGFueSBlbnRyaWVzIHdoaWNoIGFyZSBmdW5jdGlvbnMgdGFraW5nIHBhcmFtZXRlcnNcbi8vIHByZXR0aWVyLWlnbm9yZVxuLy8gQGZiLW9ubHk6IGZ1bmN0aW9uIG1hcFNjb3BlUnVsZXM8UD4oXG4vLyBAZmItb25seTogc2NvcGVSdWxlcz86IFBhcmFtZXRlcml6ZWRTY29wZVJ1bGVzPFA+LFxuLy8gQGZiLW9ubHk6IHBhcmFtOiBQLFxuLy8gQGZiLW9ubHk6ICk6IFNjb3BlUnVsZXMgfCB2b2lkIHtcbi8vIEBmYi1vbmx5OiByZXR1cm4gc2NvcGVSdWxlcz8ubWFwKHJ1bGUgPT5cbi8vIEBmYi1vbmx5OiBBcnJheS5pc0FycmF5KHJ1bGUpXG4vLyBAZmItb25seTogPyBydWxlLm1hcChlbnRyeSA9PiAodHlwZW9mIGVudHJ5ID09PSAnZnVuY3Rpb24nID8gZW50cnkocGFyYW0pIDogZW50cnkpKVxuLy8gQGZiLW9ubHk6IDogcnVsZSxcbi8vIEBmYi1vbmx5OiApO1xuLy8gQGZiLW9ubHk6IH1cblxuLypcbkEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBhdG9tIGJhc2VkIG9uIHRoZSBpbnB1dCBwYXJhbWV0ZXIuXG5cbkVhY2ggdW5pcXVlIHBhcmFtZXRlciByZXR1cm5zIGEgdW5pcXVlIGF0b20uIEUuZy4sXG5cbiAgY29uc3QgZiA9IGF0b21GYW1pbHkoLi4uKTtcbiAgZih7YTogMX0pID0+IGFuIGF0b21cbiAgZih7YTogMn0pID0+IGEgZGlmZmVyZW50IGF0b21cblxuVGhpcyBhbGxvd3MgY29tcG9uZW50cyB0byBwZXJzaXN0IGxvY2FsLCBwcml2YXRlIHN0YXRlIHVzaW5nIGF0b21zLiAgRWFjaFxuaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudCBtYXkgaGF2ZSBhIGRpZmZlcmVudCBrZXksIHdoaWNoIGl0IHVzZXMgYXMgdGhlXG5wYXJhbWV0ZXIgZm9yIGEgZmFtaWx5IG9mIGF0b21zOyBpbiB0aGlzIHdheSwgZWFjaCBjb21wb25lbnQgd2lsbCBoYXZlXG5pdHMgb3duIGF0b20gbm90IHNoYXJlZCBieSBvdGhlciBpbnN0YW5jZXMuICBUaGVzZSBzdGF0ZSBrZXlzIG1heSBiZSBjb21wb3NlZFxuaW50byBjaGlsZHJlbidzIHN0YXRlIGtleXMgYXMgd2VsbC5cbiovXG5mdW5jdGlvbiBhdG9tRmFtaWx5KG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJGNhY2hlUG9saWN5RiwgX29wdGlvbnMkY2FjaGVQb2xpY3lGMjtcblxuICBjb25zdCBhdG9tQ2FjaGUgPSBSZWNvaWxfY2FjaGVGcm9tUG9saWN5KHtcbiAgICBlcXVhbGl0eTogKF9vcHRpb25zJGNhY2hlUG9saWN5RiA9IChfb3B0aW9ucyRjYWNoZVBvbGljeUYyID0gb3B0aW9ucy5jYWNoZVBvbGljeUZvclBhcmFtc19VTlNUQUJMRSkgPT09IG51bGwgfHwgX29wdGlvbnMkY2FjaGVQb2xpY3lGMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkY2FjaGVQb2xpY3lGMi5lcXVhbGl0eSkgIT09IG51bGwgJiYgX29wdGlvbnMkY2FjaGVQb2xpY3lGICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRjYWNoZVBvbGljeUYgOiAndmFsdWUnLFxuICAgIGV2aWN0aW9uOiAna2VlcC1hbGwnXG4gIH0pOyAvLyBTaW1wbGUgYXRvbUZhbWlseSBpbXBsZW1lbnRhdGlvbiB0byBjYWNoZSBpbmRpdmlkdWFsIGF0b21zIGJhc2VkXG4gIC8vIG9uIHRoZSBwYXJhbWV0ZXIgdmFsdWUgZXF1YWxpdHkuXG5cbiAgcmV0dXJuIHBhcmFtcyA9PiB7XG4gICAgdmFyIF9zdGFibGVTdHJpbmdpZnksIF9vcHRpb25zJGVmZmVjdHM7XG5cbiAgICBjb25zdCBjYWNoZWRBdG9tID0gYXRvbUNhY2hlLmdldChwYXJhbXMpO1xuXG4gICAgaWYgKGNhY2hlZEF0b20gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlZEF0b207XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgY2FjaGVQb2xpY3lGb3JQYXJhbXNfVU5TVEFCTEUsXG4gICAgICAuLi5hdG9tT3B0aW9uc1xuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IG9wdGlvbnNEZWZhdWx0ID0gJ2RlZmF1bHQnIGluIG9wdGlvbnMgPyAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS10eXBlXSBObyB3YXkgdG8gcmVmaW5lIGluIEZsb3cgdGhhdCBwcm9wZXJ0eSBpcyBub3QgZGVmaW5lZFxuICAgIG9wdGlvbnMuZGVmYXVsdCA6IG5ldyBQcm9taXNlKCgpID0+IHt9KTtcbiAgICBjb25zdCBuZXdBdG9tID0gUmVjb2lsX2F0b20oeyAuLi5hdG9tT3B0aW9ucyxcbiAgICAgIGtleTogYCR7b3B0aW9ucy5rZXl9X18keyhfc3RhYmxlU3RyaW5naWZ5ID0gUmVjb2lsX3N0YWJsZVN0cmluZ2lmeShwYXJhbXMpKSAhPT0gbnVsbCAmJiBfc3RhYmxlU3RyaW5naWZ5ICE9PSB2b2lkIDAgPyBfc3RhYmxlU3RyaW5naWZ5IDogJ3ZvaWQnfWAsXG4gICAgICBkZWZhdWx0OiB0eXBlb2Ygb3B0aW9uc0RlZmF1bHQgPT09ICdmdW5jdGlvbicgPyAvLyBUaGUgZGVmYXVsdCB3YXMgcGFyYW1ldGVyaXplZFxuICAgICAgLy8gRmxvdyBkb2Vzbid0IGtub3cgdGhhdCBUIGlzbid0IGEgZnVuY3Rpb24sIHNvIHdlIG5lZWQgdG8gY2FzZSB0byBhbnlcbiAgICAgIC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLXVzZV1cbiAgICAgIG9wdGlvbnNEZWZhdWx0KHBhcmFtcykgOiAvLyBEZWZhdWx0IG1heSBiZSBhIHN0YXRpYyB2YWx1ZSwgcHJvbWlzZSwgb3IgUmVjb2lsVmFsdWVcbiAgICAgIG9wdGlvbnNEZWZhdWx0LFxuICAgICAgcmV0YWluZWRCeV9VTlNUQUJMRTogdHlwZW9mIG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRShwYXJhbXMpIDogb3B0aW9ucy5yZXRhaW5lZEJ5X1VOU1RBQkxFLFxuICAgICAgZWZmZWN0czogdHlwZW9mIG9wdGlvbnMuZWZmZWN0cyA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZWZmZWN0cyhwYXJhbXMpIDogdHlwZW9mIG9wdGlvbnMuZWZmZWN0c19VTlNUQUJMRSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZWZmZWN0c19VTlNUQUJMRShwYXJhbXMpIDogKF9vcHRpb25zJGVmZmVjdHMgPSBvcHRpb25zLmVmZmVjdHMpICE9PSBudWxsICYmIF9vcHRpb25zJGVmZmVjdHMgIT09IHZvaWQgMCA/IF9vcHRpb25zJGVmZmVjdHMgOiBvcHRpb25zLmVmZmVjdHNfVU5TVEFCTEUgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAvLyBAZmItb25seTogc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTOiBtYXBTY29wZVJ1bGVzKFxuICAgICAgLy8gQGZiLW9ubHk6IG9wdGlvbnMuc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTLFxuICAgICAgLy8gQGZiLW9ubHk6IHBhcmFtcyxcbiAgICAgIC8vIEBmYi1vbmx5OiApLFxuXG4gICAgfSk7XG4gICAgYXRvbUNhY2hlLnNldChwYXJhbXMsIG5ld0F0b20pO1xuICAgIHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQyKG5ld0F0b20ua2V5LCAoKSA9PiB7XG4gICAgICBhdG9tQ2FjaGUuZGVsZXRlKHBhcmFtcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld0F0b207XG4gIH07XG59XG5cbnZhciBSZWNvaWxfYXRvbUZhbWlseSA9IGF0b21GYW1pbHk7XG5cbmNvbnN0IHtcbiAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyOiBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkM1xufSA9IFJlY29pbF9Ob2RlO1xuXG5cblxuXG5cbiAvLyBLZWVwIGluIG1pbmQgdGhlIHBhcmFtZXRlciBuZWVkcyB0byBiZSBzZXJpYWxpemFibGUgYXMgYSBjYWhjaGUga2V5XG4vLyB1c2luZyBSZWNvaWxfc3RhYmxlU3RyaW5naWZ5XG5cblxuLy8gQWRkIGEgdW5pcXVlIGluZGV4IHRvIGVhY2ggc2VsZWN0b3IgaW4gY2FzZSB0aGUgY2FjaGUgaW1wbGVtZW50YXRpb24gYWxsb3dzXG4vLyBkdXBsaWNhdGUga2V5cyBiYXNlZCBvbiBlcXVpdmFsZW50IHN0cmluZ2lmaWVkIHBhcmFtZXRlcnNcbmxldCBuZXh0SW5kZXggPSAwO1xuLyogZXNsaW50LWRpc2FibGUgbm8tcmVkZWNsYXJlICovXG5cbi8vIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBtZW1iZXJzIG9mIGEgZmFtaWx5IG9mIHNlbGVjdG9ycyBvZiB0aGUgc2FtZSB0eXBlXG4vLyBFLmcuLFxuLy9cbi8vIGNvbnN0IHMgPSBzZWxlY3RvckZhbWlseSguLi4pO1xuLy8gcyh7YTogMX0pID0+IGEgc2VsZWN0b3Jcbi8vIHMoe2E6IDJ9KSA9PiBhIGRpZmZlcmVudCBzZWxlY3RvclxuLy9cbi8vIEJ5IGRlZmF1bHQsIHRoZSBzZWxlY3RvcnMgYXJlIGRpc3Rpbmd1aXNoZWQgYnkgZGlzdGluY3QgdmFsdWVzIG9mIHRoZVxuLy8gcGFyYW1ldGVyIGJhc2VkIG9uIHZhbHVlIGVxdWFsaXR5LCBub3QgcmVmZXJlbmNlIGVxdWFsaXR5LiAgVGhpcyBhbGxvd3MgdXNpbmdcbi8vIG9iamVjdCBsaXRlcmFscyBvciBvdGhlciBlcXVpdmFsZW50IG9iamVjdHMgYXQgY2FsbHNpdGVzIHRvIG5vdCBjcmVhdGVcbi8vIGR1cGxpY2F0ZSBjYWNoZSBlbnRyaWVzLiAgVGhpcyBiZWhhdmlvciBtYXkgYmUgb3ZlcnJpZGRlbiB3aXRoIHRoZVxuLy8gY2FjaGVJbXBsZW1lbnRhdGlvbkZvclBhcmFtcyBvcHRpb24uXG5mdW5jdGlvbiBzZWxlY3RvckZhbWlseShvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRjYWNoZVBvbGljeUYsIF9vcHRpb25zJGNhY2hlUG9saWN5RjI7XG5cbiAgY29uc3Qgc2VsZWN0b3JDYWNoZSA9IFJlY29pbF9jYWNoZUZyb21Qb2xpY3koe1xuICAgIGVxdWFsaXR5OiAoX29wdGlvbnMkY2FjaGVQb2xpY3lGID0gKF9vcHRpb25zJGNhY2hlUG9saWN5RjIgPSBvcHRpb25zLmNhY2hlUG9saWN5Rm9yUGFyYW1zX1VOU1RBQkxFKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRjYWNoZVBvbGljeUYyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRjYWNoZVBvbGljeUYyLmVxdWFsaXR5KSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRjYWNoZVBvbGljeUYgIT09IHZvaWQgMCA/IF9vcHRpb25zJGNhY2hlUG9saWN5RiA6ICd2YWx1ZScsXG4gICAgZXZpY3Rpb246ICdrZWVwLWFsbCdcbiAgfSk7XG4gIHJldHVybiBwYXJhbXMgPT4ge1xuICAgIHZhciBfc3RhYmxlU3RyaW5naWZ5O1xuXG4gICAgLy8gVGhyb3cgYW4gZXJyb3Igd2l0aCBzZWxlY3RvciBrZXkgc28gdGhhdCBpdCBpcyBjbGVhciB3aGljaFxuICAgIC8vIHNlbGVjdG9yIGlzIGNhdXNpbmcgYW4gZXJyb3JcbiAgICBsZXQgY2FjaGVkU2VsZWN0b3I7XG5cbiAgICB0cnkge1xuICAgICAgY2FjaGVkU2VsZWN0b3IgPSBzZWxlY3RvckNhY2hlLmdldChwYXJhbXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKGBQcm9ibGVtIHdpdGggY2FjaGUgbG9va3VwIGZvciBzZWxlY3RvciAke29wdGlvbnMua2V5fTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cblxuICAgIGlmIChjYWNoZWRTZWxlY3RvciAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkU2VsZWN0b3I7XG4gICAgfVxuXG4gICAgY29uc3QgbXlLZXkgPSBgJHtvcHRpb25zLmtleX1fX3NlbGVjdG9yRmFtaWx5LyR7KF9zdGFibGVTdHJpbmdpZnkgPSBSZWNvaWxfc3RhYmxlU3RyaW5naWZ5KHBhcmFtcywge1xuICAgICAgLy8gSXQgaXMgcG9zc2libGUgdG8gdXNlIGZ1bmN0aW9ucyBpbiBwYXJhbWV0ZXJzIGlmIHRoZSB1c2VyIHVzZXNcbiAgICAgIC8vIGEgY2FjaGUgd2l0aCByZWZlcmVuY2UgZXF1YWxpdHkgdGhhbmtzIHRvIHRoZSBpbmNyZW1lbnRpbmcgaW5kZXguXG4gICAgICBhbGxvd0Z1bmN0aW9uczogdHJ1ZVxuICAgIH0pKSAhPT0gbnVsbCAmJiBfc3RhYmxlU3RyaW5naWZ5ICE9PSB2b2lkIDAgPyBfc3RhYmxlU3RyaW5naWZ5IDogJ3ZvaWQnfS8ke25leHRJbmRleCsrfWA7IC8vIEFwcGVuZCBpbmRleCBpbiBjYXNlIHZhbHVlcyBzZXJpYWxpemUgdG8gdGhlIHNhbWUga2V5IHN0cmluZ1xuXG4gICAgY29uc3QgbXlHZXQgPSBjYWxsYmFja3MgPT4gb3B0aW9ucy5nZXQocGFyYW1zKShjYWxsYmFja3MpO1xuXG4gICAgY29uc3QgbXlDYWNoZVBvbGljeSA9IG9wdGlvbnMuY2FjaGVQb2xpY3lfVU5TVEFCTEU7XG4gICAgY29uc3QgcmV0YWluZWRCeSA9IHR5cGVvZiBvcHRpb25zLnJldGFpbmVkQnlfVU5TVEFCTEUgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnJldGFpbmVkQnlfVU5TVEFCTEUocGFyYW1zKSA6IG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRTtcbiAgICBsZXQgbmV3U2VsZWN0b3I7XG5cbiAgICBpZiAob3B0aW9ucy5zZXQgIT0gbnVsbCkge1xuICAgICAgY29uc3Qgc2V0ID0gb3B0aW9ucy5zZXQ7XG5cbiAgICAgIGNvbnN0IG15U2V0ID0gKGNhbGxiYWNrcywgbmV3VmFsdWUpID0+IHNldChwYXJhbXMpKGNhbGxiYWNrcywgbmV3VmFsdWUpO1xuXG4gICAgICBuZXdTZWxlY3RvciA9IFJlY29pbF9zZWxlY3Rvcih7XG4gICAgICAgIGtleTogbXlLZXksXG4gICAgICAgIGdldDogbXlHZXQsXG4gICAgICAgIHNldDogbXlTZXQsXG4gICAgICAgIGNhY2hlUG9saWN5X1VOU1RBQkxFOiBteUNhY2hlUG9saWN5LFxuICAgICAgICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSxcbiAgICAgICAgcmV0YWluZWRCeV9VTlNUQUJMRTogcmV0YWluZWRCeVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1NlbGVjdG9yID0gUmVjb2lsX3NlbGVjdG9yKHtcbiAgICAgICAga2V5OiBteUtleSxcbiAgICAgICAgZ2V0OiBteUdldCxcbiAgICAgICAgY2FjaGVQb2xpY3lfVU5TVEFCTEU6IG15Q2FjaGVQb2xpY3ksXG4gICAgICAgIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiBvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5LFxuICAgICAgICByZXRhaW5lZEJ5X1VOU1RBQkxFOiByZXRhaW5lZEJ5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzZWxlY3RvckNhY2hlLnNldChwYXJhbXMsIG5ld1NlbGVjdG9yKTtcbiAgICBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMyhuZXdTZWxlY3Rvci5rZXksICgpID0+IHtcbiAgICAgIHNlbGVjdG9yQ2FjaGUuZGVsZXRlKHBhcmFtcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld1NlbGVjdG9yO1xuICB9O1xufVxuLyogZXNsaW50LWVuYWJsZSBuby1yZWRlY2xhcmUgKi9cblxuXG52YXIgUmVjb2lsX3NlbGVjdG9yRmFtaWx5ID0gc2VsZWN0b3JGYW1pbHk7XG5cbi8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5cblxuY29uc3QgY29uc3RhbnRTZWxlY3RvciA9IFJlY29pbF9zZWxlY3RvckZhbWlseSh7XG4gIGtleTogJ19fY29uc3RhbnQnLFxuICBnZXQ6IGNvbnN0YW50ID0+ICgpID0+IGNvbnN0YW50LFxuICBjYWNoZVBvbGljeUZvclBhcmFtc19VTlNUQUJMRToge1xuICAgIGVxdWFsaXR5OiAncmVmZXJlbmNlJ1xuICB9XG59KTsgLy8gRnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2VsZWN0b3Igd2hpY2ggYWx3YXlzIHByb2R1Y2VzIHRoZVxuLy8gc2FtZSBjb25zdGFudCB2YWx1ZS4gIEl0IG1heSBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgd2l0aCB0aGVcbi8vIHNhbWUgdmFsdWUsIGJhc2VkIG9uIHJlZmVyZW5jZSBlcXVhbGl0eSwgYW5kIHdpbGwgcHJvdmlkZSB0aGVcbi8vIHNhbWUgc2VsZWN0b3IuXG5cbmZ1bmN0aW9uIGNvbnN0U2VsZWN0b3IoY29uc3RhbnQpIHtcbiAgcmV0dXJuIGNvbnN0YW50U2VsZWN0b3IoY29uc3RhbnQpO1xufVxuXG52YXIgUmVjb2lsX2NvbnN0U2VsZWN0b3IgPSBjb25zdFNlbGVjdG9yO1xuXG4vLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuXG5cbmNvbnN0IHRocm93aW5nU2VsZWN0b3IgPSBSZWNvaWxfc2VsZWN0b3JGYW1pbHkoe1xuICBrZXk6ICdfX2Vycm9yJyxcbiAgZ2V0OiBtZXNzYWdlID0+ICgpID0+IHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKG1lc3NhZ2UpO1xuICB9LFxuICAvLyBUT0RPIFdoeT9cbiAgY2FjaGVQb2xpY3lGb3JQYXJhbXNfVU5TVEFCTEU6IHtcbiAgICBlcXVhbGl0eTogJ3JlZmVyZW5jZSdcbiAgfVxufSk7IC8vIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNlbGVjdG9yIHdoaWNoIGFsd2F5cyB0aHJvd3MgYW4gZXJyb3Jcbi8vIHdpdGggdGhlIHByb3ZpZGVkIG1lc3NhZ2UuXG5cbmZ1bmN0aW9uIGVycm9yU2VsZWN0b3IobWVzc2FnZSkge1xuICByZXR1cm4gdGhyb3dpbmdTZWxlY3RvcihtZXNzYWdlKTtcbn1cblxudmFyIFJlY29pbF9lcnJvclNlbGVjdG9yID0gZXJyb3JTZWxlY3RvcjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFdyYXBzIGFub3RoZXIgcmVjb2lsIHZhbHVlIGFuZCBwcmV2ZW50cyB3cml0aW5nIHRvIGl0LlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiByZWFkT25seVNlbGVjdG9yKGF0b20pIHtcbiAgLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTogb2ZmXG4gIHJldHVybiBhdG9tO1xufVxuXG52YXIgUmVjb2lsX3JlYWRPbmx5U2VsZWN0b3IgPSByZWFkT25seVNlbGVjdG9yO1xuXG5jb25zdCB7XG4gIGxvYWRhYmxlV2l0aEVycm9yOiBsb2FkYWJsZVdpdGhFcnJvciQzLFxuICBsb2FkYWJsZVdpdGhQcm9taXNlOiBsb2FkYWJsZVdpdGhQcm9taXNlJDMsXG4gIGxvYWRhYmxlV2l0aFZhbHVlOiBsb2FkYWJsZVdpdGhWYWx1ZSQ0XG59ID0gUmVjb2lsX0xvYWRhYmxlJDE7XG5cblxuXG5cblxuIC8vLy8vLy8vLy8vLy8vLy8vXG4vLyAgVFJVVEggVEFCTEVcbi8vLy8vLy8vLy8vLy8vLy8vXG4vLyBEZXBlbmRlbmNpZXMgICAgICAgIHdhaXRGb3JOb25lICAgICAgICAgd2FpdEZvckFueSAgICAgICAgd2FpdEZvckFsbCAgICAgICB3YWl0Rm9yQWxsU2V0dGxlZFxuLy8gIFtsb2FkaW5nLCBsb2FkaW5nXSAgW1Byb21pc2UsIFByb21pc2VdICBQcm9taXNlICAgICAgICAgICBQcm9taXNlICAgICAgICAgUHJvbWlzZVxuLy8gIFt2YWx1ZSwgbG9hZGluZ10gICAgW3ZhbHVlLCBQcm9taXNlXSAgICBbdmFsdWUsIFByb21pc2VdICBQcm9taXNlICAgICAgICAgUHJvbWlzZVxuLy8gIFt2YWx1ZSwgdmFsdWVdICAgICAgW3ZhbHVlLCB2YWx1ZV0gICAgICBbdmFsdWUsIHZhbHVlXSAgICBbdmFsdWUsIHZhbHVlXSAgW3ZhbHVlLCB2YWx1ZV1cbi8vXG4vLyAgW2Vycm9yLCBsb2FkaW5nXSAgICBbRXJyb3IsIFByb21pc2VdICAgIFtFcnJvciwgUHJvbWlzZV0gIEVycm9yICAgICAgICAgICBQcm9taXNlXG4vLyAgW2Vycm9yLCBlcnJvcl0gICAgICBbRXJyb3IsIEVycm9yXSAgICAgIFtFcnJvciwgRXJyb3JdICAgIEVycm9yICAgICAgICAgICBbZXJyb3IsIGVycm9yXVxuLy8gIFt2YWx1ZSwgZXJyb3JdICAgICAgW3ZhbHVlLCBFcnJvcl0gICAgICBbdmFsdWUsIEVycm9yXSAgICBFcnJvciAgICAgICAgICAgW3ZhbHVlLCBlcnJvcl1cbi8vIElzc3VlIHBhcmFsbGVsIHJlcXVlc3RzIGZvciBhbGwgZGVwZW5kZW5jaWVzIGFuZCByZXR1cm4gdGhlIGN1cnJlbnRcbi8vIHN0YXR1cyBpZiB0aGV5IGhhdmUgcmVzdWx0cywgaGF2ZSBzb21lIGVycm9yLCBvciBhcmUgc3RpbGwgcGVuZGluZy5cblxuXG5mdW5jdGlvbiBjb25jdXJyZW50UmVxdWVzdHMoZ2V0UmVjb2lsVmFsdWUsIGRlcHMpIHtcbiAgY29uc3QgcmVzdWx0cyA9IEFycmF5KGRlcHMubGVuZ3RoKS5maWxsKHVuZGVmaW5lZCk7XG4gIGNvbnN0IGV4Y2VwdGlvbnMgPSBBcnJheShkZXBzLmxlbmd0aCkuZmlsbCh1bmRlZmluZWQpO1xuXG4gIGZvciAoY29uc3QgW2ksIGRlcF0gb2YgZGVwcy5lbnRyaWVzKCkpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0c1tpXSA9IGdldFJlY29pbFZhbHVlKGRlcCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gZXhjZXB0aW9ucyBjYW4gZWl0aGVyIGJlIFByb21pc2VzIG9mIHBlbmRpbmcgcmVzdWx0cyBvciByZWFsIGVycm9yc1xuICAgICAgZXhjZXB0aW9uc1tpXSA9IGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtyZXN1bHRzLCBleGNlcHRpb25zXTtcbn1cblxuZnVuY3Rpb24gaXNFcnJvcihleHApIHtcbiAgcmV0dXJuIGV4cCAhPSBudWxsICYmICFSZWNvaWxfaXNQcm9taXNlKGV4cCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcERlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGVwZW5kZW5jaWVzKSA/IGRlcGVuZGVuY2llcyA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRlcGVuZGVuY2llcykubWFwKGtleSA9PiBkZXBlbmRlbmNpZXNba2V5XSk7XG59XG5cbmZ1bmN0aW9uIHdyYXBSZXN1bHRzKGRlcGVuZGVuY2llcyxcbi8qICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF0gVGhlIHR5cGUgYW5ub3RhdGlvbihzKSByZXF1aXJlZCBieSBGbG93J3NcbiAqIExUSSB1cGRhdGUgY291bGQgbm90IGJlIGFkZGVkIHZpYSBjb2RlbW9kICovXG5yZXN1bHRzKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGRlcGVuZGVuY2llcykgPyByZXN1bHRzIDogLy8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoKSBoYXMgY29uc2lzdGVudCBrZXkgb3JkZXJpbmcgd2l0aCBFUzZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGVwZW5kZW5jaWVzKS5yZWR1Y2UoKG91dCwga2V5LCBpZHgpID0+ICh7IC4uLm91dCxcbiAgICBba2V5XTogcmVzdWx0c1tpZHhdXG4gIH0pLCB7fSk7XG59XG5cbmZ1bmN0aW9uIHdyYXBMb2FkYWJsZXMoZGVwZW5kZW5jaWVzLCByZXN1bHRzLCBleGNlcHRpb25zKSB7XG4gIGNvbnN0IG91dHB1dCA9IGV4Y2VwdGlvbnMubWFwKChleGNlcHRpb24sIGlkeCkgPT4gZXhjZXB0aW9uID09IG51bGwgPyBsb2FkYWJsZVdpdGhWYWx1ZSQ0KHJlc3VsdHNbaWR4XSkgOiBSZWNvaWxfaXNQcm9taXNlKGV4Y2VwdGlvbikgPyBsb2FkYWJsZVdpdGhQcm9taXNlJDMoZXhjZXB0aW9uKSA6IGxvYWRhYmxlV2l0aEVycm9yJDMoZXhjZXB0aW9uKSk7XG4gIHJldHVybiB3cmFwUmVzdWx0cyhkZXBlbmRlbmNpZXMsIG91dHB1dCk7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVBc3luY1Jlc3VsdHNXaXRoU3luY1Jlc3VsdHMoc3luY1Jlc3VsdHMsIGFzeW5jUmVzdWx0cykge1xuICByZXR1cm4gYXN5bmNSZXN1bHRzLm1hcCgocmVzdWx0LCBpZHgpID0+XG4gIC8qKlxuICAgKiBpdCdzIGltcG9ydGFudCB3ZSB1c2UgPT09IHVuZGVmaW5lZCBhcyBvcHBvc2VkIHRvID09IG51bGwsIGJlY2F1c2UgdGhlXG4gICAqIHJlc29sdmVkIHZhbHVlIG9mIHRoZSBhc3luYyBwcm9taXNlIGNvdWxkIGJlIGBudWxsYCwgaW4gd2hpY2ggY2FzZSB3ZVxuICAgKiBkb24ndCB3YW50IHRvIHVzZSBzeW5jUmVzdWx0c1tpZHhdLCB3aGljaCB3b3VsZCBiZSB1bmRlZmluZWQuIElmIGFzeW5jXG4gICAqIHByb21pc2UgcmVzb2x2ZXMgdG8gYHVuZGVmaW5lZGAsIHRoYXQncyBvayBiZWNhdXNlIGBzeW5jUmVzdWx0c1tpZHhdYFxuICAgKiB3aWxsIGFsc28gYmUgYHVuZGVmaW5lZGAuIFRoYXQncyBhIGxpdHRsZSBoYWNreSwgYnV0IGl0IHdvcmtzLlxuICAgKi9cbiAgcmVzdWx0ID09PSB1bmRlZmluZWQgPyBzeW5jUmVzdWx0c1tpZHhdIDogcmVzdWx0KTtcbn0gLy8gU2VsZWN0b3IgdGhhdCByZXF1ZXN0cyBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsIGFuZCBpbW1lZGlhdGVseSByZXR1cm5zXG4vLyBjdXJyZW50IHJlc3VsdHMgd2l0aG91dCB3YWl0aW5nLlxuXG5cbmNvbnN0IHdhaXRGb3JOb25lID0gUmVjb2lsX3NlbGVjdG9yRmFtaWx5KHtcbiAga2V5OiAnX193YWl0Rm9yTm9uZScsXG4gIGdldDogZGVwZW5kZW5jaWVzID0+ICh7XG4gICAgZ2V0XG4gIH0pID0+IHtcbiAgICAvLyBJc3N1ZSByZXF1ZXN0cyBmb3IgYWxsIGRlcGVuZGVuY2llcyBpbiBwYXJhbGxlbC5cbiAgICBjb25zdCBkZXBzID0gdW53cmFwRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcyk7XG4gICAgY29uc3QgW3Jlc3VsdHMsIGV4Y2VwdGlvbnNdID0gY29uY3VycmVudFJlcXVlc3RzKGdldCwgZGVwcyk7IC8vIEFsd2F5cyByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSByZXN1bHRzOyBuZXZlciBibG9jay5cblxuICAgIHJldHVybiB3cmFwTG9hZGFibGVzKGRlcGVuZGVuY2llcywgcmVzdWx0cywgZXhjZXB0aW9ucyk7XG4gIH0sXG4gIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiB0cnVlXG59KTsgLy8gU2VsZWN0b3IgdGhhdCByZXF1ZXN0cyBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsIGFuZCB3YWl0cyBmb3IgYXQgbGVhc3Rcbi8vIG9uZSB0byBiZSBhdmFpbGFibGUgYmVmb3JlIHJldHVybmluZyByZXN1bHRzLiAgSXQgd2lsbCBvbmx5IGVycm9yIGlmIGFsbFxuLy8gZGVwZW5kZW5jaWVzIGhhdmUgZXJyb3JzLlxuXG5jb25zdCB3YWl0Rm9yQW55ID0gUmVjb2lsX3NlbGVjdG9yRmFtaWx5KHtcbiAga2V5OiAnX193YWl0Rm9yQW55JyxcbiAgZ2V0OiBkZXBlbmRlbmNpZXMgPT4gKHtcbiAgICBnZXRcbiAgfSkgPT4ge1xuICAgIC8vIElzc3VlIHJlcXVlc3RzIGZvciBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsLlxuICAgIC8vIEV4Y2VwdGlvbnMgY2FuIGVpdGhlciBiZSBQcm9taXNlcyBvZiBwZW5kaW5nIHJlc3VsdHMgb3IgcmVhbCBlcnJvcnNcbiAgICBjb25zdCBkZXBzID0gdW53cmFwRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcyk7XG4gICAgY29uc3QgW3Jlc3VsdHMsIGV4Y2VwdGlvbnNdID0gY29uY3VycmVudFJlcXVlc3RzKGdldCwgZGVwcyk7IC8vIElmIGFueSByZXN1bHRzIGFyZSBhdmFpbGFibGUsIHZhbHVlIG9yIGVycm9yLCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdHVzXG5cbiAgICBpZiAoZXhjZXB0aW9ucy5zb21lKGV4cCA9PiAhUmVjb2lsX2lzUHJvbWlzZShleHApKSkge1xuICAgICAgcmV0dXJuIHdyYXBMb2FkYWJsZXMoZGVwZW5kZW5jaWVzLCByZXN1bHRzLCBleGNlcHRpb25zKTtcbiAgICB9IC8vIE90aGVyd2lzZSwgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIHRoZSBuZXh0IHJlc3VsdCBpc1xuICAgIC8vIGF2YWlsYWJsZSwgd2hpY2hldmVyIG9uZSBoYXBwZW5zIHRvIGJlIG5leHQuICBCdXQsIGlmIGFsbCBwZW5kaW5nXG4gICAgLy8gZGVwZW5kZW5jaWVzIGVuZCB1cCB3aXRoIGVycm9ycywgdGhlbiByZWplY3QgdGhlIHByb21pc2UuXG5cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGZvciAoY29uc3QgW2ksIGV4cF0gb2YgZXhjZXB0aW9ucy5lbnRyaWVzKCkpIHtcbiAgICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UoZXhwKSkge1xuICAgICAgICAgIGV4cC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICByZXN1bHRzW2ldID0gcmVzdWx0O1xuICAgICAgICAgICAgZXhjZXB0aW9uc1tpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJlc29sdmUod3JhcExvYWRhYmxlcyhkZXBlbmRlbmNpZXMsIHJlc3VsdHMsIGV4Y2VwdGlvbnMpKTtcbiAgICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICBleGNlcHRpb25zW2ldID0gZXJyb3I7XG4gICAgICAgICAgICByZXNvbHZlKHdyYXBMb2FkYWJsZXMoZGVwZW5kZW5jaWVzLCByZXN1bHRzLCBleGNlcHRpb25zKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IHRydWVcbn0pOyAvLyBTZWxlY3RvciB0aGF0IHJlcXVlc3RzIGFsbCBkZXBlbmRlbmNpZXMgaW4gcGFyYWxsZWwgYW5kIHdhaXRzIGZvciBhbGwgdG8gYmVcbi8vIGF2YWlsYWJsZSBiZWZvcmUgcmV0dXJuaW5nIGEgdmFsdWUuICBJdCB3aWxsIGVycm9yIGlmIGFueSBkZXBlbmRlbmNpZXMgZXJyb3IuXG5cbmNvbnN0IHdhaXRGb3JBbGwgPSBSZWNvaWxfc2VsZWN0b3JGYW1pbHkoe1xuICBrZXk6ICdfX3dhaXRGb3JBbGwnLFxuICBnZXQ6IGRlcGVuZGVuY2llcyA9PiAoe1xuICAgIGdldFxuICB9KSA9PiB7XG4gICAgLy8gSXNzdWUgcmVxdWVzdHMgZm9yIGFsbCBkZXBlbmRlbmNpZXMgaW4gcGFyYWxsZWwuXG4gICAgLy8gRXhjZXB0aW9ucyBjYW4gZWl0aGVyIGJlIFByb21pc2VzIG9mIHBlbmRpbmcgcmVzdWx0cyBvciByZWFsIGVycm9yc1xuICAgIGNvbnN0IGRlcHMgPSB1bndyYXBEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKTtcbiAgICBjb25zdCBbcmVzdWx0cywgZXhjZXB0aW9uc10gPSBjb25jdXJyZW50UmVxdWVzdHMoZ2V0LCBkZXBzKTsgLy8gSWYgYWxsIHJlc3VsdHMgYXJlIGF2YWlsYWJsZSwgcmV0dXJuIHRoZSByZXN1bHRzXG5cbiAgICBpZiAoZXhjZXB0aW9ucy5ldmVyeShleHAgPT4gZXhwID09IG51bGwpKSB7XG4gICAgICByZXR1cm4gd3JhcFJlc3VsdHMoZGVwZW5kZW5jaWVzLCByZXN1bHRzKTtcbiAgICB9IC8vIElmIHdlIGhhdmUgYW55IGVycm9ycywgdGhyb3cgdGhlIGZpcnN0IGVycm9yXG5cblxuICAgIGNvbnN0IGVycm9yID0gZXhjZXB0aW9ucy5maW5kKGlzRXJyb3IpO1xuXG4gICAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gLy8gT3RoZXJ3aXNlLCByZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdoZW4gYWxsIHJlc3VsdHMgYXJlIGF2YWlsYWJsZVxuXG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoZXhjZXB0aW9ucykudGhlbihleGNlcHRpb25SZXN1bHRzID0+IHdyYXBSZXN1bHRzKGRlcGVuZGVuY2llcywgY29tYmluZUFzeW5jUmVzdWx0c1dpdGhTeW5jUmVzdWx0cyhyZXN1bHRzLCBleGNlcHRpb25SZXN1bHRzKSkpO1xuICB9LFxuICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogdHJ1ZVxufSk7XG5jb25zdCB3YWl0Rm9yQWxsU2V0dGxlZCA9IFJlY29pbF9zZWxlY3RvckZhbWlseSh7XG4gIGtleTogJ19fd2FpdEZvckFsbFNldHRsZWQnLFxuICBnZXQ6IGRlcGVuZGVuY2llcyA9PiAoe1xuICAgIGdldFxuICB9KSA9PiB7XG4gICAgLy8gSXNzdWUgcmVxdWVzdHMgZm9yIGFsbCBkZXBlbmRlbmNpZXMgaW4gcGFyYWxsZWwuXG4gICAgLy8gRXhjZXB0aW9ucyBjYW4gZWl0aGVyIGJlIFByb21pc2VzIG9mIHBlbmRpbmcgcmVzdWx0cyBvciByZWFsIGVycm9yc1xuICAgIGNvbnN0IGRlcHMgPSB1bndyYXBEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKTtcbiAgICBjb25zdCBbcmVzdWx0cywgZXhjZXB0aW9uc10gPSBjb25jdXJyZW50UmVxdWVzdHMoZ2V0LCBkZXBzKTsgLy8gSWYgYWxsIHJlc3VsdHMgYXJlIGF2YWlsYWJsZSwgcmV0dXJuIHRoZSByZXN1bHRzXG5cbiAgICBpZiAoZXhjZXB0aW9ucy5ldmVyeShleHAgPT4gIVJlY29pbF9pc1Byb21pc2UoZXhwKSkpIHtcbiAgICAgIHJldHVybiB3cmFwTG9hZGFibGVzKGRlcGVuZGVuY2llcywgcmVzdWx0cywgZXhjZXB0aW9ucyk7XG4gICAgfSAvLyBXYWl0IGZvciBhbGwgcmVzdWx0cyB0byBzZXR0bGVcblxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGV4Y2VwdGlvbnMubWFwKChleHAsIGkpID0+IFJlY29pbF9pc1Byb21pc2UoZXhwKSA/IGV4cC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICByZXN1bHRzW2ldID0gcmVzdWx0O1xuICAgICAgZXhjZXB0aW9uc1tpXSA9IHVuZGVmaW5lZDtcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICByZXN1bHRzW2ldID0gdW5kZWZpbmVkO1xuICAgICAgZXhjZXB0aW9uc1tpXSA9IGVycm9yO1xuICAgIH0pIDogbnVsbCkpIC8vIFRoZW4gd3JhcCB0aGVtIGFzIGxvYWRhYmxlc1xuICAgIC50aGVuKCgpID0+IHdyYXBMb2FkYWJsZXMoZGVwZW5kZW5jaWVzLCByZXN1bHRzLCBleGNlcHRpb25zKSk7XG4gIH0sXG4gIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiB0cnVlXG59KTtcbmNvbnN0IG5vV2FpdCA9IFJlY29pbF9zZWxlY3RvckZhbWlseSh7XG4gIGtleTogJ19fbm9XYWl0JyxcbiAgZ2V0OiBkZXBlbmRlbmN5ID0+ICh7XG4gICAgZ2V0XG4gIH0pID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFJlY29pbF9zZWxlY3Rvci52YWx1ZShsb2FkYWJsZVdpdGhWYWx1ZSQ0KGdldChkZXBlbmRlbmN5KSkpO1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgcmV0dXJuIFJlY29pbF9zZWxlY3Rvci52YWx1ZShSZWNvaWxfaXNQcm9taXNlKGV4Y2VwdGlvbikgPyBsb2FkYWJsZVdpdGhQcm9taXNlJDMoZXhjZXB0aW9uKSA6IGxvYWRhYmxlV2l0aEVycm9yJDMoZXhjZXB0aW9uKSk7XG4gICAgfVxuICB9LFxuICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogdHJ1ZVxufSk7XG52YXIgUmVjb2lsX1dhaXRGb3IgPSB7XG4gIHdhaXRGb3JOb25lLFxuICB3YWl0Rm9yQW55LFxuICB3YWl0Rm9yQWxsLFxuICB3YWl0Rm9yQWxsU2V0dGxlZCxcbiAgbm9XYWl0XG59O1xuXG5jb25zdCB7XG4gIFJlY29pbExvYWRhYmxlXG59ID0gUmVjb2lsX0xvYWRhYmxlJDE7XG5cbmNvbnN0IHtcbiAgRGVmYXVsdFZhbHVlOiBEZWZhdWx0VmFsdWUkM1xufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIFJlY29pbFJvb3Q6IFJlY29pbFJvb3QkMixcbiAgdXNlUmVjb2lsU3RvcmVJRDogdXNlUmVjb2lsU3RvcmVJRCQxXG59ID0gUmVjb2lsX1JlY29pbFJvb3Q7XG5cbmNvbnN0IHtcbiAgaXNSZWNvaWxWYWx1ZTogaXNSZWNvaWxWYWx1ZSQ1XG59ID0gUmVjb2lsX1JlY29pbFZhbHVlJDE7XG5cbmNvbnN0IHtcbiAgcmV0ZW50aW9uWm9uZTogcmV0ZW50aW9uWm9uZSQxXG59ID0gUmVjb2lsX1JldGVudGlvblpvbmU7XG5cbmNvbnN0IHtcbiAgZnJlc2hTbmFwc2hvdDogZnJlc2hTbmFwc2hvdCQyXG59ID0gUmVjb2lsX1NuYXBzaG90JDE7XG5cbmNvbnN0IHtcbiAgdXNlUmVjb2lsU3RhdGU6IHVzZVJlY29pbFN0YXRlJDEsXG4gIHVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRTogdXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFJDEsXG4gIHVzZVJlY29pbFN0YXRlTG9hZGFibGU6IHVzZVJlY29pbFN0YXRlTG9hZGFibGUkMSxcbiAgdXNlUmVjb2lsVmFsdWU6IHVzZVJlY29pbFZhbHVlJDEsXG4gIHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRTogdXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFJDEsXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGU6IHVzZVJlY29pbFZhbHVlTG9hZGFibGUkMSxcbiAgdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU6IHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFJDEsXG4gIHVzZVJlc2V0UmVjb2lsU3RhdGU6IHVzZVJlc2V0UmVjb2lsU3RhdGUkMSxcbiAgdXNlU2V0UmVjb2lsU3RhdGU6IHVzZVNldFJlY29pbFN0YXRlJDFcbn0gPSBSZWNvaWxfSG9va3M7XG5cbmNvbnN0IHtcbiAgdXNlR290b1JlY29pbFNuYXBzaG90OiB1c2VHb3RvUmVjb2lsU25hcHNob3QkMSxcbiAgdXNlUmVjb2lsU25hcHNob3Q6IHVzZVJlY29pbFNuYXBzaG90JDEsXG4gIHVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXI6IHVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXIkMVxufSA9IFJlY29pbF9TbmFwc2hvdEhvb2tzO1xuXG5cblxuXG5cbmNvbnN0IHtcbiAgdXNlUmVjb2lsQ2FsbGJhY2s6IHVzZVJlY29pbENhbGxiYWNrJDFcbn0gPSBSZWNvaWxfdXNlUmVjb2lsQ2FsbGJhY2s7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jb25zdCB7XG4gIG5vV2FpdDogbm9XYWl0JDEsXG4gIHdhaXRGb3JBbGw6IHdhaXRGb3JBbGwkMSxcbiAgd2FpdEZvckFsbFNldHRsZWQ6IHdhaXRGb3JBbGxTZXR0bGVkJDEsXG4gIHdhaXRGb3JBbnk6IHdhaXRGb3JBbnkkMSxcbiAgd2FpdEZvck5vbmU6IHdhaXRGb3JOb25lJDFcbn0gPSBSZWNvaWxfV2FpdEZvcjtcblxuXG5cbnZhciBSZWNvaWxfaW5kZXggPSB7XG4gIC8vIFR5cGVzXG4gIERlZmF1bHRWYWx1ZTogRGVmYXVsdFZhbHVlJDMsXG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkNSxcbiAgUmVjb2lsTG9hZGFibGUsXG4gIC8vIEdsb2JhbCBSZWNvaWwgZW52aXJvbm1lbnQgc2V0dGlvbmdzXG4gIFJlY29pbEVudjogUmVjb2lsX1JlY29pbEVudixcbiAgLy8gUmVjb2lsIFJvb3RcbiAgUmVjb2lsUm9vdDogUmVjb2lsUm9vdCQyLFxuICB1c2VSZWNvaWxTdG9yZUlEOiB1c2VSZWNvaWxTdG9yZUlEJDEsXG4gIHVzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHNfVU5TVEFCTEU6IFJlY29pbF91c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzLFxuICAvLyBBdG9tcy9TZWxlY3RvcnNcbiAgYXRvbTogUmVjb2lsX2F0b20sXG4gIHNlbGVjdG9yOiBSZWNvaWxfc2VsZWN0b3IsXG4gIC8vIENvbnZlbmllbmNlIEF0b21zL1NlbGVjdG9yc1xuICBhdG9tRmFtaWx5OiBSZWNvaWxfYXRvbUZhbWlseSxcbiAgc2VsZWN0b3JGYW1pbHk6IFJlY29pbF9zZWxlY3RvckZhbWlseSxcbiAgY29uc3RTZWxlY3RvcjogUmVjb2lsX2NvbnN0U2VsZWN0b3IsXG4gIGVycm9yU2VsZWN0b3I6IFJlY29pbF9lcnJvclNlbGVjdG9yLFxuICByZWFkT25seVNlbGVjdG9yOiBSZWNvaWxfcmVhZE9ubHlTZWxlY3RvcixcbiAgLy8gQ29uY3VycmVuY3kgSGVscGVycyBmb3IgQXRvbXMvU2VsZWN0b3JzXG4gIG5vV2FpdDogbm9XYWl0JDEsXG4gIHdhaXRGb3JOb25lOiB3YWl0Rm9yTm9uZSQxLFxuICB3YWl0Rm9yQW55OiB3YWl0Rm9yQW55JDEsXG4gIHdhaXRGb3JBbGw6IHdhaXRGb3JBbGwkMSxcbiAgd2FpdEZvckFsbFNldHRsZWQ6IHdhaXRGb3JBbGxTZXR0bGVkJDEsXG4gIC8vIEhvb2tzIGZvciBBdG9tcy9TZWxlY3RvcnNcbiAgdXNlUmVjb2lsVmFsdWU6IHVzZVJlY29pbFZhbHVlJDEsXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGU6IHVzZVJlY29pbFZhbHVlTG9hZGFibGUkMSxcbiAgdXNlUmVjb2lsU3RhdGU6IHVzZVJlY29pbFN0YXRlJDEsXG4gIHVzZVJlY29pbFN0YXRlTG9hZGFibGU6IHVzZVJlY29pbFN0YXRlTG9hZGFibGUkMSxcbiAgdXNlU2V0UmVjb2lsU3RhdGU6IHVzZVNldFJlY29pbFN0YXRlJDEsXG4gIHVzZVJlc2V0UmVjb2lsU3RhdGU6IHVzZVJlc2V0UmVjb2lsU3RhdGUkMSxcbiAgdXNlR2V0UmVjb2lsVmFsdWVJbmZvX1VOU1RBQkxFOiBSZWNvaWxfdXNlR2V0UmVjb2lsVmFsdWVJbmZvLFxuICB1c2VSZWNvaWxSZWZyZXNoZXJfVU5TVEFCTEU6IFJlY29pbF91c2VSZWNvaWxSZWZyZXNoZXIsXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxuICB1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU6IHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxuICB1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU6IHVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxuICAvLyBIb29rcyBmb3IgY29tcGxleCBvcGVyYXRpb25zXG4gIHVzZVJlY29pbENhbGxiYWNrOiB1c2VSZWNvaWxDYWxsYmFjayQxLFxuICB1c2VSZWNvaWxUcmFuc2FjdGlvbl9VTlNUQUJMRTogUmVjb2lsX3VzZVJlY29pbFRyYW5zYWN0aW9uLFxuICAvLyBTbmFwc2hvdHNcbiAgdXNlR290b1JlY29pbFNuYXBzaG90OiB1c2VHb3RvUmVjb2lsU25hcHNob3QkMSxcbiAgdXNlUmVjb2lsU25hcHNob3Q6IHVzZVJlY29pbFNuYXBzaG90JDEsXG4gIHVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXJfVU5TVEFCTEU6IHVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXIkMSxcbiAgc25hcHNob3RfVU5TVEFCTEU6IGZyZXNoU25hcHNob3QkMixcbiAgLy8gTWVtb3J5IE1hbmFnZW1lbnRcbiAgdXNlUmV0YWluOiBSZWNvaWxfdXNlUmV0YWluLFxuICByZXRlbnRpb25ab25lOiByZXRlbnRpb25ab25lJDFcbn07XG52YXIgUmVjb2lsX2luZGV4XzEgPSBSZWNvaWxfaW5kZXguRGVmYXVsdFZhbHVlO1xudmFyIFJlY29pbF9pbmRleF8yID0gUmVjb2lsX2luZGV4LmlzUmVjb2lsVmFsdWU7XG52YXIgUmVjb2lsX2luZGV4XzMgPSBSZWNvaWxfaW5kZXguUmVjb2lsTG9hZGFibGU7XG52YXIgUmVjb2lsX2luZGV4XzQgPSBSZWNvaWxfaW5kZXguUmVjb2lsRW52O1xudmFyIFJlY29pbF9pbmRleF81ID0gUmVjb2lsX2luZGV4LlJlY29pbFJvb3Q7XG52YXIgUmVjb2lsX2luZGV4XzYgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsU3RvcmVJRDtcbnZhciBSZWNvaWxfaW5kZXhfNyA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzX1VOU1RBQkxFO1xudmFyIFJlY29pbF9pbmRleF84ID0gUmVjb2lsX2luZGV4LmF0b207XG52YXIgUmVjb2lsX2luZGV4XzkgPSBSZWNvaWxfaW5kZXguc2VsZWN0b3I7XG52YXIgUmVjb2lsX2luZGV4XzEwID0gUmVjb2lsX2luZGV4LmF0b21GYW1pbHk7XG52YXIgUmVjb2lsX2luZGV4XzExID0gUmVjb2lsX2luZGV4LnNlbGVjdG9yRmFtaWx5O1xudmFyIFJlY29pbF9pbmRleF8xMiA9IFJlY29pbF9pbmRleC5jb25zdFNlbGVjdG9yO1xudmFyIFJlY29pbF9pbmRleF8xMyA9IFJlY29pbF9pbmRleC5lcnJvclNlbGVjdG9yO1xudmFyIFJlY29pbF9pbmRleF8xNCA9IFJlY29pbF9pbmRleC5yZWFkT25seVNlbGVjdG9yO1xudmFyIFJlY29pbF9pbmRleF8xNSA9IFJlY29pbF9pbmRleC5ub1dhaXQ7XG52YXIgUmVjb2lsX2luZGV4XzE2ID0gUmVjb2lsX2luZGV4LndhaXRGb3JOb25lO1xudmFyIFJlY29pbF9pbmRleF8xNyA9IFJlY29pbF9pbmRleC53YWl0Rm9yQW55O1xudmFyIFJlY29pbF9pbmRleF8xOCA9IFJlY29pbF9pbmRleC53YWl0Rm9yQWxsO1xudmFyIFJlY29pbF9pbmRleF8xOSA9IFJlY29pbF9pbmRleC53YWl0Rm9yQWxsU2V0dGxlZDtcbnZhciBSZWNvaWxfaW5kZXhfMjAgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsVmFsdWU7XG52YXIgUmVjb2lsX2luZGV4XzIxID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFZhbHVlTG9hZGFibGU7XG52YXIgUmVjb2lsX2luZGV4XzIyID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFN0YXRlO1xudmFyIFJlY29pbF9pbmRleF8yMyA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxTdGF0ZUxvYWRhYmxlO1xudmFyIFJlY29pbF9pbmRleF8yNCA9IFJlY29pbF9pbmRleC51c2VTZXRSZWNvaWxTdGF0ZTtcbnZhciBSZWNvaWxfaW5kZXhfMjUgPSBSZWNvaWxfaW5kZXgudXNlUmVzZXRSZWNvaWxTdGF0ZTtcbnZhciBSZWNvaWxfaW5kZXhfMjYgPSBSZWNvaWxfaW5kZXgudXNlR2V0UmVjb2lsVmFsdWVJbmZvX1VOU1RBQkxFO1xudmFyIFJlY29pbF9pbmRleF8yNyA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxSZWZyZXNoZXJfVU5TVEFCTEU7XG52YXIgUmVjb2lsX2luZGV4XzI4ID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFO1xudmFyIFJlY29pbF9pbmRleF8yOSA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU7XG52YXIgUmVjb2lsX2luZGV4XzMwID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRTtcbnZhciBSZWNvaWxfaW5kZXhfMzEgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsQ2FsbGJhY2s7XG52YXIgUmVjb2lsX2luZGV4XzMyID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFRyYW5zYWN0aW9uX1VOU1RBQkxFO1xudmFyIFJlY29pbF9pbmRleF8zMyA9IFJlY29pbF9pbmRleC51c2VHb3RvUmVjb2lsU25hcHNob3Q7XG52YXIgUmVjb2lsX2luZGV4XzM0ID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFNuYXBzaG90O1xudmFyIFJlY29pbF9pbmRleF8zNSA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyX1VOU1RBQkxFO1xudmFyIFJlY29pbF9pbmRleF8zNiA9IFJlY29pbF9pbmRleC5zbmFwc2hvdF9VTlNUQUJMRTtcbnZhciBSZWNvaWxfaW5kZXhfMzcgPSBSZWNvaWxfaW5kZXgudXNlUmV0YWluO1xudmFyIFJlY29pbF9pbmRleF8zOCA9IFJlY29pbF9pbmRleC5yZXRlbnRpb25ab25lO1xuXG5leHBvcnQgZGVmYXVsdCBSZWNvaWxfaW5kZXg7XG5leHBvcnQgeyBSZWNvaWxfaW5kZXhfMSBhcyBEZWZhdWx0VmFsdWUsIFJlY29pbF9pbmRleF80IGFzIFJlY29pbEVudiwgUmVjb2lsX2luZGV4XzMgYXMgUmVjb2lsTG9hZGFibGUsIFJlY29pbF9pbmRleF81IGFzIFJlY29pbFJvb3QsIFJlY29pbF9pbmRleF84IGFzIGF0b20sIFJlY29pbF9pbmRleF8xMCBhcyBhdG9tRmFtaWx5LCBSZWNvaWxfaW5kZXhfMTIgYXMgY29uc3RTZWxlY3RvciwgUmVjb2lsX2luZGV4XzEzIGFzIGVycm9yU2VsZWN0b3IsIFJlY29pbF9pbmRleF8yIGFzIGlzUmVjb2lsVmFsdWUsIFJlY29pbF9pbmRleF8xNSBhcyBub1dhaXQsIFJlY29pbF9pbmRleF8xNCBhcyByZWFkT25seVNlbGVjdG9yLCBSZWNvaWxfaW5kZXhfMzggYXMgcmV0ZW50aW9uWm9uZSwgUmVjb2lsX2luZGV4XzkgYXMgc2VsZWN0b3IsIFJlY29pbF9pbmRleF8xMSBhcyBzZWxlY3RvckZhbWlseSwgUmVjb2lsX2luZGV4XzM2IGFzIHNuYXBzaG90X1VOU1RBQkxFLCBSZWNvaWxfaW5kZXhfMjYgYXMgdXNlR2V0UmVjb2lsVmFsdWVJbmZvX1VOU1RBQkxFLCBSZWNvaWxfaW5kZXhfMzMgYXMgdXNlR290b1JlY29pbFNuYXBzaG90LCBSZWNvaWxfaW5kZXhfNyBhcyB1c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzX1VOU1RBQkxFLCBSZWNvaWxfaW5kZXhfMzEgYXMgdXNlUmVjb2lsQ2FsbGJhY2ssIFJlY29pbF9pbmRleF8yNyBhcyB1c2VSZWNvaWxSZWZyZXNoZXJfVU5TVEFCTEUsIFJlY29pbF9pbmRleF8zNCBhcyB1c2VSZWNvaWxTbmFwc2hvdCwgUmVjb2lsX2luZGV4XzIyIGFzIHVzZVJlY29pbFN0YXRlLCBSZWNvaWxfaW5kZXhfMjMgYXMgdXNlUmVjb2lsU3RhdGVMb2FkYWJsZSwgUmVjb2lsX2luZGV4XzMwIGFzIHVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSwgUmVjb2lsX2luZGV4XzYgYXMgdXNlUmVjb2lsU3RvcmVJRCwgUmVjb2lsX2luZGV4XzM1IGFzIHVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXJfVU5TVEFCTEUsIFJlY29pbF9pbmRleF8zMiBhcyB1c2VSZWNvaWxUcmFuc2FjdGlvbl9VTlNUQUJMRSwgUmVjb2lsX2luZGV4XzIwIGFzIHVzZVJlY29pbFZhbHVlLCBSZWNvaWxfaW5kZXhfMjEgYXMgdXNlUmVjb2lsVmFsdWVMb2FkYWJsZSwgUmVjb2lsX2luZGV4XzI4IGFzIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFLCBSZWNvaWxfaW5kZXhfMjkgYXMgdXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFLCBSZWNvaWxfaW5kZXhfMjUgYXMgdXNlUmVzZXRSZWNvaWxTdGF0ZSwgUmVjb2lsX2luZGV4XzM3IGFzIHVzZVJldGFpbiwgUmVjb2lsX2luZGV4XzI0IGFzIHVzZVNldFJlY29pbFN0YXRlLCBSZWNvaWxfaW5kZXhfMTggYXMgd2FpdEZvckFsbCwgUmVjb2lsX2luZGV4XzE5IGFzIHdhaXRGb3JBbGxTZXR0bGVkLCBSZWNvaWxfaW5kZXhfMTcgYXMgd2FpdEZvckFueSwgUmVjb2lsX2luZGV4XzE2IGFzIHdhaXRGb3JOb25lIH07XG4iXSwibmFtZXMiOlsicmVhY3QiLCJyZWFjdERvbSIsImVyciIsIm1lc3NhZ2UiLCJlcnJvciIsIkVycm9yIiwic3RhY2siLCJ1bmRlZmluZWQiLCJfIiwiZXJyXzEiLCJSZWNvaWxfZXJyIiwiaXNQcm9taXNlIiwicCIsInRoZW4iLCJSZWNvaWxfaXNQcm9taXNlIiwibnVsbHRocm93cyIsIngiLCJSZWNvaWxfbnVsbHRocm93cyIsIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJCYXNlTG9hZGFibGUiLCJnZXRWYWx1ZSIsInRvUHJvbWlzZSIsInZhbHVlTWF5YmUiLCJ2YWx1ZU9yVGhyb3ciLCJzdGF0ZSIsInByb21pc2VNYXliZSIsInByb21pc2VPclRocm93IiwiZXJyb3JNYXliZSIsImVycm9yT3JUaHJvdyIsImlzIiwib3RoZXIiLCJjb250ZW50cyIsIm1hcCIsIl9tYXAiLCJWYWx1ZUxvYWRhYmxlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJuZXh0IiwibG9hZGFibGVXaXRoUHJvbWlzZSIsImlzTG9hZGFibGUiLCJsb2FkYWJsZVdpdGhWYWx1ZSIsImUiLCJsb2FkYWJsZVdpdGhFcnJvciIsImNvbnN0cnVjdG9yIiwiRXJyb3JMb2FkYWJsZSIsInJlamVjdCIsIkxvYWRpbmdMb2FkYWJsZSIsIm5leHRMb2FkYWJsZSIsImNhdGNoIiwicHJvbWlzZSIsImZyZWV6ZSIsImxvYWRhYmxlTG9hZGluZyIsImxvYWRhYmxlQWxsQXJyYXkiLCJpbnB1dHMiLCJldmVyeSIsImkiLCJzb21lIiwiZmluZCIsImFsbCIsImxvYWRhYmxlQWxsIiwidW53cmFwZWRJbnB1dHMiLCJBcnJheSIsImlzQXJyYXkiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwibm9ybWFsaXplZElucHV0cyIsIm91dHB1dCIsIm91dHB1dHMiLCJyZWR1Y2UiLCJvdXQiLCJpZHgiLCJMb2FkYWJsZVN0YXRpY0ludGVyZmFjZSIsIm9mIiwibG9hZGluZyIsIlJlY29pbF9Mb2FkYWJsZSIsIlJlY29pbExvYWRhYmxlIiwiUmVjb2lsX0xvYWRhYmxlXzEiLCJSZWNvaWxfTG9hZGFibGVfMiIsIlJlY29pbF9Mb2FkYWJsZV8zIiwiUmVjb2lsX0xvYWRhYmxlXzQiLCJSZWNvaWxfTG9hZGFibGVfNSIsIlJlY29pbF9Mb2FkYWJsZV82IiwiUmVjb2lsX0xvYWRhYmxlXzciLCJSZWNvaWxfTG9hZGFibGUkMSIsIl9fcHJvdG9fXyIsImVudiIsIlJFQ09JTF9EVVBMSUNBVEVfQVRPTV9LRVlfQ0hFQ0tJTkdfRU5BQkxFRCIsIlJFQ09JTF9HS1NfRU5BQkxFRCIsIlNldCIsInJlYWRQcm9jZXNzRW52Qm9vbGVhbkZsYWciLCJuYW1lIiwic2V0IiwiX3Byb2Nlc3MkZW52JG5hbWUiLCJfcHJvY2VzcyRlbnYkbmFtZSR0b0wiLCJzYW5pdGl6ZWRWYWx1ZSIsInByb2Nlc3MiLCJ0b0xvd2VyQ2FzZSIsInRyaW0iLCJhbGxvd2VkVmFsdWVzIiwiaW5jbHVkZXMiLCJyZWFkUHJvY2Vzc0VudlN0cmluZ0FycmF5RmxhZyIsIl9wcm9jZXNzJGVudiRuYW1lMiIsInNwbGl0IiwiYXBwbHlQcm9jZXNzRW52RmxhZ092ZXJyaWRlcyIsIl9wcm9jZXNzIiwiZm9yRWFjaCIsImdrIiwiYWRkIiwiUmVjb2lsX1JlY29pbEVudiIsIlJlY29pbF9na3hfT1NTIiwiaGFzIiwic2V0UGFzcyIsInNldEZhaWwiLCJkZWxldGUiLCJjbGVhciIsIlJlY29pbF9na3giLCJyZWNvdmVyYWJsZVZpb2xhdGlvbiIsIl9wcm9qZWN0TmFtZSIsImNvbnNvbGUiLCJyZWNvdmVyYWJsZVZpb2xhdGlvbl8xIiwiUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uIiwiX2NyZWF0ZU11dGFibGVTb3VyY2UiLCJfdXNlTXV0YWJsZVNvdXJjZSIsIl91c2VTeW5jRXh0ZXJuYWxTdG9yZSIsImNyZWF0ZU11dGFibGVTb3VyY2UiLCJ1bnN0YWJsZV9jcmVhdGVNdXRhYmxlU291cmNlIiwidXNlTXV0YWJsZVNvdXJjZSIsInVuc3RhYmxlX3VzZU11dGFibGVTb3VyY2UiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInVuc3RhYmxlX3VzZVN5bmNFeHRlcm5hbFN0b3JlIiwiUmVhY3RSZW5kZXJlclZlcnNpb25NaXNtYXRjaFdhcm5PbmNlIiwiY3VycmVudFJlbmRlcmVyU3VwcG9ydHNVc2VTeW5jRXh0ZXJuYWxTdG9yZSIsIl9SZWFjdEN1cnJlbnREaXNwYXRjaCIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJSZWFjdEN1cnJlbnRPd25lciIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZGlzcGF0Y2hlciIsImN1cnJlbnQiLCJjdXJyZW50RGlzcGF0Y2hlciIsImlzVXNlU3luY0V4dGVybmFsU3RvcmVTdXBwb3J0ZWQiLCJyZWFjdE1vZGUiLCJtb2RlIiwiZWFybHkiLCJjb25jdXJyZW50Iiwid2luZG93IiwiJGRpc2FibGVSZWNvaWxWYWx1ZU11dGFibGVTb3VyY2VfVEVNUF9IQUNLX0RPX05PVF9VU0UiLCJpc0Zhc3RSZWZyZXNoRW5hYmxlZCIsIlJlY29pbF9SZWFjdE1vZGUiLCJBYnN0cmFjdFJlY29pbFZhbHVlIiwidG9KU09OIiwibmV3S2V5IiwiUmVjb2lsU3RhdGUiLCJSZWNvaWxWYWx1ZVJlYWRPbmx5IiwiaXNSZWNvaWxWYWx1ZSIsIlJlY29pbF9SZWNvaWxWYWx1ZSIsIlJlY29pbF9SZWNvaWxWYWx1ZV8xIiwiUmVjb2lsX1JlY29pbFZhbHVlXzIiLCJSZWNvaWxfUmVjb2lsVmFsdWVfMyIsIlJlY29pbF9SZWNvaWxWYWx1ZV80IiwiUmVjb2lsX1JlY29pbFZhbHVlJDEiLCJzcHJpbnRmIiwiZm9ybWF0IiwiYXJncyIsImluZGV4IiwicmVwbGFjZSIsIlN0cmluZyIsInNwcmludGZfMSIsImV4cGVjdGF0aW9uVmlvbGF0aW9uIiwiY2FsbCIsImV4cGVjdGF0aW9uVmlvbGF0aW9uXzEiLCJSZWNvaWxfZXhwZWN0YXRpb25WaW9sYXRpb24iLCJtYXBJdGVyYWJsZSIsIml0ZXJhYmxlIiwiY2FsbGJhY2siLCJSZWNvaWxfbWFwSXRlcmFibGUiLCJpc0Zhc3RSZWZyZXNoRW5hYmxlZCQxIiwiRGVmYXVsdFZhbHVlIiwiREVGQVVMVF9WQUxVRSIsIm5vZGVzIiwiTWFwIiwicmVjb2lsVmFsdWVzIiwicmVjb2lsVmFsdWVzRm9yS2V5cyIsImtleXMiLCJnZXQiLCJjaGVja0ZvckR1cGxpY2F0ZUF0b21LZXkiLCJ3YXJuIiwicmVnaXN0ZXJOb2RlIiwibm9kZSIsInJlY29pbFZhbHVlIiwiTm9kZU1pc3NpbmdFcnJvciIsImdldE5vZGUiLCJnZXROb2RlTWF5YmUiLCJjb25maWdEZWxldGlvbkhhbmRsZXJzIiwiZGVsZXRlTm9kZUNvbmZpZ0lmUG9zc2libGUiLCJfbm9kZSRzaG91bGREZWxldGVDb24iLCJzaG91bGREZWxldGVDb25maWdPblJlbGVhc2UiLCJfZ2V0Q29uZmlnRGVsZXRpb25IYW4iLCJnZXRDb25maWdEZWxldGlvbkhhbmRsZXIiLCJzZXRDb25maWdEZWxldGlvbkhhbmRsZXIiLCJmbiIsIlJlY29pbF9Ob2RlIiwiZW5xdWV1ZUV4ZWN1dGlvbiIsInMiLCJmIiwiUmVjb2lsX1F1ZXVlIiwiY3JlYXRlQ29tbW9uanNNb2R1bGUiLCJtb2R1bGUiLCJleHBvcnRzIiwiaGFtdF8xIiwiX3R5cGVvZiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwicHJvdG90eXBlIiwiaGFtdCIsIlNJWkUiLCJCVUNLRVRfU0laRSIsIk1hdGgiLCJwb3ciLCJNQVNLIiwiTUFYX0lOREVYX05PREUiLCJNSU5fQVJSQVlfTk9ERSIsIm5vdGhpbmciLCJjb25zdGFudCIsImhhc2giLCJzdHIiLCJ0eXBlIiwibGVuIiwibGVuZ3RoIiwiYyIsImNoYXJDb2RlQXQiLCJwb3Bjb3VudCIsImhhc2hGcmFnbWVudCIsInNoaWZ0IiwiaCIsInRvQml0bWFwIiwiZnJvbUJpdG1hcCIsImJpdG1hcCIsImJpdCIsImFycmF5VXBkYXRlIiwibXV0YXRlIiwiYXQiLCJ2IiwiYXJyIiwiYXJyYXlTcGxpY2VPdXQiLCJuZXdMZW4iLCJnIiwiYXJyYXlTcGxpY2VJbiIsIl9pIiwiTEVBRiIsIkNPTExJU0lPTiIsIklOREVYIiwiQVJSQVkiLCJlbXB0eSIsIl9faGFtdF9pc0VtcHR5IiwiaXNFbXB0eU5vZGUiLCJMZWFmIiwiZWRpdCIsIl9tb2RpZnkiLCJMZWFmX19tb2RpZnkiLCJDb2xsaXNpb24iLCJjaGlsZHJlbiIsIkNvbGxpc2lvbl9fbW9kaWZ5IiwiSW5kZXhlZE5vZGUiLCJtYXNrIiwiSW5kZXhlZE5vZGVfX21vZGlmeSIsIkFycmF5Tm9kZSIsInNpemUiLCJBcnJheU5vZGVfX21vZGlmeSIsImlzTGVhZiIsImV4cGFuZCIsImZyYWciLCJjaGlsZCIsInN1Yk5vZGVzIiwiY291bnQiLCJwYWNrIiwicmVtb3ZlZCIsImVsZW1lbnRzIiwiZWxlbSIsIm1lcmdlTGVhdmVzIiwiaDEiLCJuMSIsImgyIiwibjIiLCJzdWJIMSIsInN1YkgyIiwidXBkYXRlQ29sbGlzaW9uTGlzdCIsImtleUVxIiwibGlzdCIsImsiLCJfbmV3VmFsdWUiLCJuZXdWYWx1ZSIsImNhbkVkaXROb2RlIiwiX3YiLCJjYW5FZGl0IiwiaW5keCIsImV4aXN0cyIsIm5ld0NoaWxkcmVuIiwibmV3Q2hpbGQiLCJlZGl0YWJsZSIsImNvbmZpZyIsInJvb3QiLCJfZWRpdGFibGUiLCJfZWRpdCIsIl9jb25maWciLCJfcm9vdCIsIl9zaXplIiwic2V0VHJlZSIsIm5ld1Jvb3QiLCJuZXdTaXplIiwidHJ5R2V0SGFzaCIsImFsdCIsInRyeUdldCIsImdldEhhc2giLCJoYXNIYXNoIiwiZGVmS2V5Q29tcGFyZSIsInkiLCJtYWtlIiwiaXNFbXB0eSIsIm1vZGlmeUhhc2giLCJOYU4iLCJtb2RpZnkiLCJzZXRIYXNoIiwiZGVsIiwicmVtb3ZlSGFzaCIsImRlbGV0ZUhhc2giLCJyZW1vdmUiLCJiZWdpbk11dGF0aW9uIiwiZW5kTXV0YXRpb24iLCJ0cmFuc2llbnQiLCJhcHBrIiwibGF6eVZpc2l0Q2hpbGRyZW4iLCJsYXp5VmlzaXQiLCJyZXN0IiwiRE9ORSIsImRvbmUiLCJNYXBJdGVyYXRvciIsInYwIiwidmlzaXQiLCJidWlsZFBhaXJzIiwiZW50cmllcyIsImJ1aWxkS2V5cyIsImJ1aWxkVmFsdWVzIiwidmFsdWVzIiwiZm9sZCIsInoiLCJtIiwidG9WaXNpdCIsInBvcCIsInB1c2giLCJCdWlsdEluTWFwIiwiY2xvbmUiLCJwZXJzaXN0ZW50TWFwIiwidG9NYXAiLCJleGlzdGluZyIsIkhhc2hBcnJheU1hcHBlZFRyaWVNYXAiLCJfaGFtdCIsIlJlY29pbF9QZXJzaXN0ZW50TWFwIiwiUmVjb2lsX1BlcnNpc3RlbnRNYXBfMSIsIlJlY29pbF9QZXJzaXN0ZW50TWFwJDEiLCJkaWZmZXJlbmNlU2V0cyIsInNldHNXaXRoVmFsdWVzVG9SZW1vdmUiLCJyZXQiLCJGSVJTVCIsIm90aGVyU2V0IiwiUmVjb2lsX2RpZmZlcmVuY2VTZXRzIiwibWFwTWFwIiwicmVzdWx0IiwiUmVjb2lsX21hcE1hcCIsIm1ha2VHcmFwaCIsIm5vZGVEZXBzIiwibm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMiLCJjbG9uZUdyYXBoIiwiZ3JhcGgiLCJtZXJnZURlcHNJbnRvR3JhcGgiLCJuZXdEZXBzIiwib2xkZXJHcmFwaCIsIm9sZERlcHMiLCJhZGRlZERlcHMiLCJkZXAiLCJyZW1vdmVkRGVwcyIsInNhdmVEZXBzVG9TdG9yZSIsImRlcHMiLCJzdG9yZSIsInZlcnNpb24iLCJfc3RvcmVTdGF0ZSRuZXh0VHJlZSIsIl9zdG9yZVN0YXRlJHByZXZpb3VzVCIsIl9zdG9yZVN0YXRlJHByZXZpb3VzVDIiLCJfc3RvcmVTdGF0ZSRwcmV2aW91c1QzIiwic3RvcmVTdGF0ZSIsImdldFN0YXRlIiwiY3VycmVudFRyZWUiLCJuZXh0VHJlZSIsInByZXZpb3VzVHJlZSIsImdldEdyYXBoIiwiY3VycmVudEdyYXBoIiwiX3N0b3JlU3RhdGUkbmV4dFRyZWUyIiwibmV4dFZlcnNpb24iLCJuZXh0R3JhcGgiLCJSZWNvaWxfR3JhcGgiLCJuZXh0VHJlZVN0YXRlVmVyc2lvbiIsImdldE5leHRUcmVlU3RhdGVWZXJzaW9uIiwibmV4dFN0b3JlSUQiLCJnZXROZXh0U3RvcmVJRCIsIm5leHRDb21wb25lbnRJRCIsImdldE5leHRDb21wb25lbnRJRCIsIlJlY29pbF9LZXlzIiwicGVyc2lzdGVudE1hcCQxIiwiZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMSIsIm1ha2VFbXB0eVRyZWVTdGF0ZSIsInN0YXRlSUQiLCJ0cmFuc2FjdGlvbk1ldGFkYXRhIiwiZGlydHlBdG9tcyIsImF0b21WYWx1ZXMiLCJub252YWxpZGF0ZWRBdG9tcyIsIm1ha2VFbXB0eVN0b3JlU3RhdGUiLCJjb21taXREZXB0aCIsImtub3duQXRvbXMiLCJrbm93blNlbGVjdG9ycyIsInRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucyIsIm5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnMiLCJub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zIiwicXVldWVkQ29tcG9uZW50Q2FsbGJhY2tzX0RFUFJFQ0FURUQiLCJzdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnMiLCJncmFwaHNCeVZlcnNpb24iLCJyZXRlbnRpb24iLCJyZWZlcmVuY2VDb3VudHMiLCJub2Rlc1JldGFpbmVkQnlab25lIiwicmV0YWluYWJsZXNUb0NoZWNrRm9yUmVsZWFzZSIsIm5vZGVDbGVhbnVwRnVuY3Rpb25zIiwiUmVjb2lsX1N0YXRlIiwiUmV0ZW50aW9uWm9uZSIsInJldGVudGlvblpvbmUiLCJSZWNvaWxfUmV0ZW50aW9uWm9uZSIsInNldEJ5QWRkaW5nVG9TZXQiLCJzZXRCeURlbGV0aW5nRnJvbVNldCIsIm1hcEJ5U2V0dGluZ0luTWFwIiwibWFwQnlVcGRhdGluZ0luTWFwIiwidXBkYXRlciIsIm1hcEJ5RGVsZXRpbmdGcm9tTWFwIiwibWFwQnlEZWxldGluZ011bHRpcGxlRnJvbU1hcCIsImtzIiwiUmVjb2lsX0NvcHlPbldyaXRlIiwiZmlsdGVySXRlcmFibGUiLCJwcmVkaWNhdGUiLCJSZWNvaWxfZmlsdGVySXRlcmFibGUiLCJsYXp5UHJveHkiLCJiYXNlIiwiZmFjdG9yaWVzIiwicHJveHkiLCJQcm94eSIsInRhcmdldCIsInByb3AiLCJvd25LZXlzIiwiUmVjb2lsX2xhenlQcm94eSIsImdldE5vZGUkMSIsImdldE5vZGVNYXliZSQxIiwicmVjb2lsVmFsdWVzRm9yS2V5cyQxIiwiUmV0ZW50aW9uWm9uZSQxIiwic2V0QnlBZGRpbmdUb1NldCQxIiwiZW1wdHlTZXQiLCJSZWFkT25seVJlY29pbFZhbHVlRXJyb3IiLCJpbml0aWFsaXplUmV0ZW50aW9uRm9yTm9kZSIsIm5vZGVLZXkiLCJyZXRhaW5lZEJ5IiwiYWRkVG9ab25lIiwiem9uZSIsImRlbGV0ZUZyb21ab25lIiwiaW5pdGlhbGl6ZU5vZGVJZk5ld1RvU3RvcmUiLCJ0cmVlU3RhdGUiLCJ0cmlnZ2VyIiwicmV0ZW50aW9uQ2xlYW51cCIsIm5vZGVDbGVhbnVwIiwiaW5pdCIsImluaXRpYWxpemVOb2RlIiwiY2xlYW5VcE5vZGUiLCJfc3RhdGUkbm9kZUNsZWFudXBGdW4iLCJnZXROb2RlTG9hZGFibGUiLCJwZWVrTm9kZUxvYWRhYmxlIiwicGVlayIsInNldFVudmFsaWRhdGVkQXRvbVZhbHVlX0RFUFJFQ0FURUQiLCJfbm9kZSRpbnZhbGlkYXRlIiwiaW52YWxpZGF0ZSIsInNldE5vZGVWYWx1ZSIsInBlZWtOb2RlSW5mbyIsIm5vZGVUeXBlIiwibG9hZGFibGUiLCJpc0FjdGl2ZSIsImlzU2V0IiwiaXNNb2RpZmllZCIsIl9ncmFwaCRub2RlRGVwcyRnZXQiLCJzdWJzY3JpYmVycyIsIl9zdG9yZVN0YXRlJG5vZGVUb0NvbSIsIl9zdG9yZVN0YXRlJG5vZGVUb0NvbTIiLCJnZXREb3duc3RyZWFtTm9kZXMiLCJjb21wb25lbnRzIiwidmlzaXRlZE5vZGVzIiwidmlzaXRpbmdOb2RlcyIsImZyb20iLCJfZ3JhcGgkbm9kZVRvTm9kZVN1YnMiLCJzdWJzY3JpYmVkTm9kZXMiLCJkb3duc3RyZWFtTm9kZSIsIlJlY29pbF9GdW5jdGlvbmFsQ29yZSIsIl9pbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCIsInNldEludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90IiwiaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QiLCJfaW52YWxpZGF0ZU1lbW9pemVkU24iLCJSZWNvaWxfU25hcHNob3RDYWNoZSIsImdldERvd25zdHJlYW1Ob2RlcyQxIiwiZ2V0Tm9kZUxvYWRhYmxlJDEiLCJzZXROb2RlVmFsdWUkMSIsImdldE5leHRDb21wb25lbnRJRCQxIiwiZ2V0Tm9kZSQyIiwiZ2V0Tm9kZU1heWJlJDIiLCJEZWZhdWx0VmFsdWUkMSIsInJlYWN0TW9kZSQxIiwiQWJzdHJhY3RSZWNvaWxWYWx1ZSQxIiwiUmVjb2lsU3RhdGUkMSIsIlJlY29pbFZhbHVlUmVhZE9ubHkkMSIsImlzUmVjb2lsVmFsdWUkMSIsImludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDEiLCJnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUiLCJhcHBseUF0b21WYWx1ZVdyaXRlcyIsIndyaXRlcyIsInZhbHVlRnJvbVZhbHVlT3JVcGRhdGVyIiwidmFsdWVPclVwZGF0ZXIiLCJtc2ciLCJhcHBseUFjdGlvbiIsImFjdGlvbiIsIndyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZSIsInVudmFsaWRhdGVkVmFsdWUiLCJhcHBseUFjdGlvbnNUb1N0b3JlIiwiYWN0aW9ucyIsInJlcGxhY2VTdGF0ZSIsIm5ld1N0YXRlIiwiY29weVRyZWVTdGF0ZSIsImludmFsaWRhdGVEb3duc3RyZWFtcyIsInF1ZXVlT3JQZXJmb3JtU3RhdGVVcGRhdGUiLCJiYXRjaFN0YWNrIiwiYWN0aW9uc0J5U3RvcmUiLCJiYXRjaFN0YXJ0IiwicG9wcGVkIiwiZG93bnN0cmVhbXMiLCJfZ2V0Tm9kZU1heWJlIiwiX2dldE5vZGVNYXliZSRpbnZhbGlkIiwic2V0UmVjb2lsVmFsdWUiLCJzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlIiwibWFya1JlY29pbFZhbHVlTW9kaWZpZWQiLCJzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlIiwic3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSIsImNvbXBvbmVudERlYnVnTmFtZSIsInN1YklEIiwicmVsZWFzZSIsInJlbGVhc2VTdG9yZVN0YXRlIiwic3VicyIsInJlZnJlc2hSZWNvaWxWYWx1ZSIsIl9ub2RlJGNsZWFyQ2FjaGUiLCJjbGVhckNhY2hlIiwiUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlIiwic29tZVNldCIsImNvbnRleHQiLCJlbnRyeSIsIlJlY29pbF9zb21lU2V0IiwiY2xlYW5VcE5vZGUkMSIsImRlbGV0ZU5vZGVDb25maWdJZlBvc3NpYmxlJDEiLCJnZXROb2RlJDMiLCJSZXRlbnRpb25ab25lJDIiLCJTVVNQRU5TRV9USU1FT1VUX01TIiwiZW1wdHlTZXQkMSIsInJlbGVhc2VSZXRhaW5hYmxlc05vd09uQ3VycmVudFRyZWUiLCJyZXRhaW5hYmxlcyIsInIiLCJuIiwicmVsZWFzYWJsZU5vZGVzIiwiZmluZFJlbGVhc2FibGVOb2RlcyIsInJlbGVhc2VOb2RlIiwic2VhcmNoRnJvbU5vZGVzIiwibm9uUmVsZWFzYWJsZU5vZGVzIiwiZmluZFJlbGVhc2FibGVOb2Rlc0lubmVyIiwicmVsZWFzYWJsZU5vZGVzRm91bmRUaGlzSXRlcmF0aW9uIiwiZ2V0RG93bnN0cmVhbU5vZGVzSW5Ub3BvbG9naWNhbE9yZGVyIiwiX3N0b3JlU3RhdGUkcmV0ZW50aW9uIiwiem9uZXNUaGF0Q291bGRSZXRhaW5Ob2RlIiwibm9kZUNoaWxkcmVuIiwicGFyZW50cyIsInBhcmVudCIsImRvTm90RGVzY2VuZEludG8xIiwiZG9Ob3REZXNjZW5kSW50bzIiLCJhbnN3ZXIiLCJ2aXNpdGVkIiwiem9uZXMiLCJfc3RvcmVTdGF0ZSRyZXRlbnRpb24yIiwiX3N0b3JlU3RhdGUkcmV0ZW50aW9uMyIsInNjaGVkdWxlT3JQZXJmb3JtUG9zc2libGVSZWxlYXNlT2ZSZXRhaW5hYmxlIiwicmV0YWluYWJsZSIsInVwZGF0ZVJldGFpbkNvdW50IiwiZGVsdGEiLCJfbWFwJGdldCIsIm5ld0NvdW50IiwidXBkYXRlUmV0YWluQ291bnRUb1plcm8iLCJyZWxlYXNlU2NoZWR1bGVkUmV0YWluYWJsZXNOb3ciLCJyZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHQiLCJSZWNvaWxfUmV0ZW50aW9uIiwidW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMiLCJSZWFjdEJhdGNoZWRVcGRhdGVzIiwidW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMkMSIsIlJlY29pbF9SZWFjdEJhdGNoZWRVcGRhdGVzIiwiYmF0Y2hTdGFydCQxIiwidW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMkMiIsImJhdGNoZXIiLCJiYXRjaEZuIiwic2V0QmF0Y2hlciIsIm5ld0JhdGNoZXIiLCJnZXRCYXRjaGVyIiwiYmF0Y2hVcGRhdGVzIiwiYmF0Y2hFbmQiLCJSZWNvaWxfQmF0Y2hpbmciLCJjb25jYXRJdGVyYWJsZXMiLCJpdGVycyIsIml0ZXIiLCJ2YWwiLCJSZWNvaWxfY29uY2F0SXRlcmFibGVzIiwiaXNTU1IiLCJXaW5kb3ciLCJpc1dpbmRvdyIsImlzUmVhY3ROYXRpdmUiLCJuYXZpZ2F0b3IiLCJwcm9kdWN0IiwiUmVjb2lsX0Vudmlyb25tZW50IiwibWVtb2l6ZVdpdGhBcmdzSGFzaCIsImhhc2hGdW5jdGlvbiIsImNhY2hlIiwiaGFzT3duUHJvcGVydHkiLCJtZW1vaXplT25lV2l0aEFyZ3NIYXNoIiwibGFzdEtleSIsImxhc3RSZXN1bHQiLCJtZW1vaXplT25lV2l0aEFyZ3NIYXNoQW5kSW52YWxpZGF0aW9uIiwibWVtb2l6ZWRGbiIsIlJlY29pbF9NZW1vaXplIiwiYmF0Y2hVcGRhdGVzJDEiLCJpbml0aWFsaXplTm9kZSQxIiwicGVla05vZGVJbmZvJDEiLCJncmFwaCQxIiwiZ2V0TmV4dFN0b3JlSUQkMSIsIkRFRkFVTFRfVkFMVUUkMSIsInJlY29pbFZhbHVlcyQxIiwicmVjb2lsVmFsdWVzRm9yS2V5cyQyIiwiQWJzdHJhY3RSZWNvaWxWYWx1ZSQyIiwiZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDEiLCJzZXRSZWNvaWxWYWx1ZSQxIiwic2V0VW52YWxpZGF0ZWRSZWNvaWxWYWx1ZSQxIiwidXBkYXRlUmV0YWluQ291bnQkMSIsInNldEludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDEiLCJnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQyIiwibWFrZUVtcHR5U3RvcmVTdGF0ZSQxIiwiaXNTU1IkMSIsIm1lbW9pemVPbmVXaXRoQXJnc0hhc2hBbmRJbnZhbGlkYXRpb24kMSIsInJldGFpbldhcm5pbmciLCJTbmFwc2hvdCIsInJldGFpbiIsIl9yZWZDb3VudCIsInJlbGVhc2VkIiwiX3JlbGVhc2UiLCJhdXRvUmVsZWFzZV9JTlRFUk5BTCIsInNldFRpbWVvdXQiLCJfc3RvcmUiLCJjbGVhbnVwIiwiaXNSZXRhaW5lZCIsImNoZWNrUmVmQ291bnRfSU5URVJOQUwiLCJnZXRTdG9yZV9JTlRFUk5BTCIsImdldElEIiwiZ2V0U3RvcmVJRCIsInN0b3JlSUQiLCJwYXJlbnRTdG9yZUlEIiwiZ2V0TG9hZGFibGUiLCJvcHQiLCJpc0luaXRpYWxpemVkIiwibWFwcGVyIiwibXV0YWJsZVNuYXBzaG90IiwiTXV0YWJsZVNuYXBzaG90IiwicmVwbGFjZXIiLCJncmFwaHMiLCJuZXdHcmFwaCIsInN1YnNjcmliZVRvVHJhbnNhY3Rpb25zIiwiYWRkVHJhbnNhY3Rpb25NZXRhZGF0YSIsImNsb25lU3RvcmVTdGF0ZSIsImJ1bXBWZXJzaW9uIiwiZnJlc2hTbmFwc2hvdCIsImluaXRpYWxpemVTdGF0ZSIsInNuYXBzaG90IiwibWVtb2l6ZWRDbG9uZVNuYXBzaG90IiwiaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMiIsIl9zdG9yZSRnZXRTdGF0ZSRuZXh0VCIsIl9zdG9yZSRnZXRTdGF0ZSRwcmV2aSIsImNsb25lU25hcHNob3QiLCJiYXRjaCIsInJlY29pbFN0YXRlIiwibmV3VmFsdWVPclVwZGF0ZXIiLCJfYmF0Y2giLCJSZWNvaWxfU25hcHNob3QiLCJSZWNvaWxfU25hcHNob3RfMSIsIlJlY29pbF9TbmFwc2hvdF8yIiwiUmVjb2lsX1NuYXBzaG90XzMiLCJSZWNvaWxfU25hcHNob3RfNCIsIlJlY29pbF9TbmFwc2hvdCQxIiwidW5pb25TZXRzIiwic2V0cyIsIlJlY29pbF91bmlvblNldHMiLCJ1c2VSZWYiLCJ1c2VSZWZJbml0T25jZSIsImluaXRpYWxWYWx1ZSIsInJlZiIsIlJlY29pbF91c2VSZWZJbml0T25jZSIsImdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDMiLCJtYWtlRW1wdHlTdG9yZVN0YXRlJDIiLCJjbGVhblVwTm9kZSQyIiwiZ2V0RG93bnN0cmVhbU5vZGVzJDIiLCJpbml0aWFsaXplTm9kZSQyIiwic2V0Tm9kZVZhbHVlJDIiLCJzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZV9ERVBSRUNBVEVEJDEiLCJncmFwaCQyIiwiY2xvbmVHcmFwaCQxIiwiZ2V0TmV4dFN0b3JlSUQkMiIsImNyZWF0ZU11dGFibGVTb3VyY2UkMSIsInJlYWN0TW9kZSQyIiwiYXBwbHlBdG9tVmFsdWVXcml0ZXMkMSIsInJlbGVhc2VTY2hlZHVsZWRSZXRhaW5hYmxlc05vdyQxIiwiZnJlc2hTbmFwc2hvdCQxIiwidXNlQ2FsbGJhY2siLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZiQxIiwidXNlU3RhdGUiLCJub3RJbkFDb250ZXh0IiwiZGVmYXVsdFN0b3JlIiwic3RhdGVSZXBsYWNlcklzQmVpbmdFeGVjdXRlZCIsInN0YXJ0TmV4dFRyZWVJZk5lZWRlZCIsIkFwcENvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlU3RvcmVSZWYiLCJNdXRhYmxlU291cmNlQ29udGV4dCIsInVzZVJlY29pbE11dGFibGVTb3VyY2UiLCJtdXRhYmxlU291cmNlIiwibm90aWZ5Q29tcG9uZW50cyIsImRlcGVuZGVudE5vZGVzIiwiY29tcHMiLCJfc3ViSUQiLCJfZGVidWdOYW1lIiwic2VuZEVuZE9mQmF0Y2hOb3RpZmljYXRpb25zIiwic3Vic2NyaXB0aW9ucyIsInN1YnNjcmlwdGlvbiIsImNiIiwic3BsaWNlIiwiZW5kQmF0Y2giLCJCYXRjaGVyIiwic2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlIiwic3RvcmVSZWYiLCJzZXRTdGF0ZSIsIiRyZWNvaWxEZWJ1Z1N0YXRlcyIsImluaXRpYWxTdG9yZVN0YXRlX0RFUFJFQ0FURUQiLCJpbml0aWFsIiwiYXRvbSIsIndyaXR0ZW5Ob2RlcyIsInNldFVudmFsaWRhdGVkQXRvbVZhbHVlcyIsImluaXRpYWxTdG9yZVN0YXRlIiwibmV4dElEIiwiUmVjb2lsUm9vdF9JTlRFUk5BTCIsImluaXRpYWxpemVTdGF0ZV9ERVBSRUNBVEVEIiwic3RvcmVfSU5URVJOQUwiLCJzdG9yZVByb3AiLCJzdG9yZVN0YXRlUmVmIiwiaWQiLCJtZXRhZGF0YSIsInJlcGxhY2VkIiwibm90aWZ5QmF0Y2hlck9mQ2hhbmdlIiwiYXRvbUtleSIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsIlJlY29pbFJvb3QiLCJwcm9wcyIsIm92ZXJyaWRlIiwicHJvcHNFeGNlcHRPdmVycmlkZSIsImFuY2VzdG9yU3RvcmVSZWYiLCJ1c2VSZWNvaWxTdG9yZUlEIiwiUmVjb2lsX1JlY29pbFJvb3QiLCJub3RpZnlDb21wb25lbnRzX0ZPUl9URVNUSU5HIiwic2VuZEVuZE9mQmF0Y2hOb3RpZmljYXRpb25zX0ZPUl9URVNUSU5HIiwic2hhbGxvd0FycmF5RXF1YWwiLCJhIiwiYiIsImwiLCJSZWNvaWxfc2hhbGxvd0FycmF5RXF1YWwiLCJ1c2VFZmZlY3QkMSIsInVzZVJlZiQyIiwidXNlUHJldmlvdXMiLCJSZWNvaWxfdXNlUHJldmlvdXMiLCJ1c2VTdG9yZVJlZiQxIiwiU1VTUEVOU0VfVElNRU9VVF9NUyQxIiwidXBkYXRlUmV0YWluQ291bnQkMiIsIlJldGVudGlvblpvbmUkMyIsInVzZUVmZmVjdCQyIiwidXNlUmVmJDMiLCJpc1NTUiQyIiwidXNlUmV0YWluIiwidG9SZXRhaW4iLCJ1c2VSZXRhaW5fQUNUVUFMIiwiYXJyYXkiLCJ0aW1lb3V0SUQiLCJjbGVhclRpbWVvdXQiLCJwcmV2aW91c1JldGFpbmFibGVzIiwiUmVjb2lsX3VzZVJldGFpbiIsInVzZUNvbXBvbmVudE5hbWUiLCJSZWNvaWxfdXNlQ29tcG9uZW50TmFtZSIsImJhdGNoVXBkYXRlcyQyIiwiREVGQVVMVF9WQUxVRSQyIiwiY3VycmVudFJlbmRlcmVyU3VwcG9ydHNVc2VTeW5jRXh0ZXJuYWxTdG9yZSQxIiwicmVhY3RNb2RlJDMiLCJ1c2VNdXRhYmxlU291cmNlJDEiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxIiwidXNlUmVjb2lsTXV0YWJsZVNvdXJjZSQxIiwidXNlU3RvcmVSZWYkMiIsImlzUmVjb2lsVmFsdWUkMiIsIkFic3RyYWN0UmVjb2lsVmFsdWUkMyIsImdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQyIiwic2V0UmVjb2lsVmFsdWUkMiIsInNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUkMiIsInN1YnNjcmliZVRvUmVjb2lsVmFsdWUkMSIsInVzZUNhbGxiYWNrJDEiLCJ1c2VFZmZlY3QkMyIsInVzZU1lbW8kMSIsInVzZVJlZiQ0IiwidXNlU3RhdGUkMSIsInNldEJ5QWRkaW5nVG9TZXQkMiIsImlzU1NSJDMiLCJoYW5kbGVMb2FkYWJsZSIsImZpbmFsbHkiLCJ2YWxpZGF0ZVJlY29pbFZhbHVlIiwiaG9va05hbWUiLCJ1c2VSZWNvaWxJbnRlcmZhY2VfREVQUkVDQVRFRCIsImNvbXBvbmVudE5hbWUiLCJmb3JjZVVwZGF0ZSIsInJlY29pbFZhbHVlc1VzZWQiLCJwcmV2aW91c1N1YnNjcmlwdGlvbnMiLCJ1bnN1YnNjcmliZUZyb20iLCJzdWIiLCJ1cGRhdGVTdGF0ZSIsIl9zdGF0ZSIsImN1cnJlbnRTdWJzY3JpcHRpb25zIiwidXNlU2V0UmVjb2lsU3RhdGUiLCJ1c2VSZXNldFJlY29pbFN0YXRlIiwidXNlUmVjb2lsVmFsdWVMb2FkYWJsZSIsInVzZVJlY29pbFZhbHVlIiwidXNlUmVjb2lsU3RhdGUiLCJ1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlIiwiZ2V0UmVjb2lsVmFsdWUiLCJnZXRSZWNvaWxWYWx1ZUxvYWRhYmxlIiwiZ2V0UmVjb2lsU3RhdGUiLCJnZXRSZWNvaWxTdGF0ZUxvYWRhYmxlIiwiZ2V0U2V0UmVjb2lsU3RhdGUiLCJnZXRSZXNldFJlY29pbFN0YXRlIiwicmVjb2lsQ29tcG9uZW50R2V0UmVjb2lsVmFsdWVDb3VudF9GT1JfVEVTVElORyIsInVzZVJlY29pbFZhbHVlTG9hZGFibGVfU1lOQ19FWFRFUk5BTF9TVE9SRSIsImdldFNuYXBzaG90IiwibWVtb2l6ZVByZXZpb3VzU25hcHNob3QiLCJwcmV2U3RhdGUiLCJfcHJldlN0YXRlIiwiX3ByZXZTdGF0ZTIiLCJuZXh0U3RhdGUiLCJnZXRNZW1vaXplZFNuYXBzaG90Iiwic3Vic2NyaWJlIiwibm90aWZ5IiwidXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9NVVRBQkxFX1NPVVJDRSIsIl9zdG9yZVN0YXRlJG5leHRUcmVlMyIsImdldExvYWRhYmxlV2l0aFRlc3RpbmciLCJfc3RvcmVTdGF0ZSIsIm5ld0xvYWRhYmxlIiwicHJldkxvYWRhYmxlUmVmIiwic291cmNlIiwidXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlQiLCJfc3RvcmVTdGF0ZSRuZXh0VHJlZTQiLCJ1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX0xFR0FDWSIsIl9zdG9yZVN0YXRlJG5leHRUcmVlNSIsIl9wcmV2TG9hZGFibGVSZWYkY3VyciIsIl9wcmV2TG9hZGFibGVSZWYkY3VycjIiLCJUUkFOU0lUSU9OX1NVUFBPUlQiLCJTWU5DX0VYVEVSTkFMX1NUT1JFIiwiTVVUQUJMRV9TT1VSQ0UiLCJMRUdBQ1kiLCJ1c2VTZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXMiLCJ1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSIsInVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSIsInVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSIsIlJlY29pbF9Ib29rcyIsInVzZVJlY29pbEludGVyZmFjZSIsImZpbHRlck1hcCIsIlJlY29pbF9maWx0ZXJNYXAiLCJmaWx0ZXJTZXQiLCJSZWNvaWxfZmlsdGVyU2V0IiwibWVyZ2VNYXBzIiwibWFwcyIsIm5leHRLZXkiLCJSZWNvaWxfbWVyZ2VNYXBzIiwiYmF0Y2hVcGRhdGVzJDMiLCJERUZBVUxUX1ZBTFVFJDMiLCJnZXROb2RlJDQiLCJub2RlcyQxIiwidXNlU3RvcmVSZWYkMyIsIkFic3RyYWN0UmVjb2lsVmFsdWUkNCIsInNldFJlY29pbFZhbHVlTG9hZGFibGUkMSIsIlNVU1BFTlNFX1RJTUVPVVRfTVMkMiIsImNsb25lU25hcHNob3QkMSIsInVzZUNhbGxiYWNrJDIiLCJ1c2VFZmZlY3QkNCIsInVzZVJlZiQ1IiwidXNlU3RhdGUkMiIsImlzU1NSJDQiLCJ1c2VUcmFuc2FjdGlvblN1YnNjcmlwdGlvbiIsImV4dGVybmFsbHlWaXNpYmxlQXRvbVZhbHVlc0luU3RhdGUiLCJwZXJzaXN0ZWRBdG9tQ29udGVudHNWYWx1ZXMiLCJwZXJzaXN0ZW5jZSIsInBlcnNpc3RlbmNlX1VOU1RBQkxFIiwidXNlVHJhbnNhY3Rpb25PYnNlcnZhdGlvbl9ERVBSRUNBVEVEIiwicHJldmlvdXNBdG9tVmFsdWVzIiwiYXRvbUluZm8iLCJfbm9kZSRwZXJzaXN0ZW5jZV9VTlMiLCJfbm9kZSRwZXJzaXN0ZW5jZV9VTlMyIiwiX25vZGUkcGVyc2lzdGVuY2VfVU5TMyIsIl9ub2RlJHBlcnNpc3RlbmNlX1VOUzQiLCJiYWNrQnV0dG9uIiwibW9kaWZpZWRBdG9tcyIsInVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXIiLCJwcmV2aW91c1NuYXBzaG90IiwidXNlUmVjb2lsU25hcHNob3QiLCJzZXRTbmFwc2hvdCIsInJlbGVhc2VSZWYiLCJfcmVsZWFzZVJlZiRjdXJyZW50IiwiX3JlbGVhc2VSZWYkY3VycmVudDIiLCJfcmVsZWFzZVJlZiRjdXJyZW50MyIsImdvdG9TbmFwc2hvdCIsInByZXYiLCJrZXlzVG9VcGRhdGUiLCJfcHJldiRhdG9tVmFsdWVzJGdldCIsIl9uZXh0JGF0b21WYWx1ZXMkZ2V0Iiwic2hvdWxkUmVzdG9yZUZyb21TbmFwc2hvdHMiLCJ1c2VHb3RvUmVjb2lsU25hcHNob3QiLCJSZWNvaWxfU25hcHNob3RIb29rcyIsInVzZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uX0RFUFJFQ0FURUQiLCJwZWVrTm9kZUluZm8kMiIsInVzZVN0b3JlUmVmJDQiLCJ1c2VHZXRSZWNvaWxWYWx1ZUluZm8iLCJSZWNvaWxfdXNlR2V0UmVjb2lsVmFsdWVJbmZvIiwicmVhY3RNb2RlJDQiLCJSZWNvaWxSb290JDEiLCJ1c2VTdG9yZVJlZiQ1IiwidXNlTWVtbyQyIiwidXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290cyIsIlJlY29pbEJyaWRnZSIsIlJlY29pbF91c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzIiwibG9hZGFibGVXaXRoVmFsdWUkMSIsImluaXRpYWxpemVOb2RlJDMiLCJERUZBVUxUX1ZBTFVFJDQiLCJnZXROb2RlJDUiLCJjb3B5VHJlZVN0YXRlJDEiLCJnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMyIsImludmFsaWRhdGVEb3duc3RyZWFtcyQxIiwid3JpdGVMb2FkYWJsZVRvVHJlZVN0YXRlJDEiLCJpc0F0b20iLCJUcmFuc2FjdGlvbkludGVyZmFjZUltcGwiLCJuZXdUcmVlU3RhdGVfSU5URVJOQUwiLCJfY2hhbmdlcyIsIl90cmVlU3RhdGUiLCJhdG9taWNVcGRhdGVyIiwiY2hhbmdlc2V0IiwiUmVjb2lsX0F0b21pY1VwZGF0ZXMiLCJSZWNvaWxfQXRvbWljVXBkYXRlc18xIiwiUmVjb2lsX0F0b21pY1VwZGF0ZXMkMSIsImludmFyaWFudCIsImNvbmRpdGlvbiIsImludmFyaWFudF8xIiwiUmVjb2lsX2ludmFyaWFudCIsImF0b21pY1VwZGF0ZXIkMSIsImJhdGNoVXBkYXRlcyQ0IiwiREVGQVVMVF9WQUxVRSQ1IiwidXNlU3RvcmVSZWYkNiIsInJlZnJlc2hSZWNvaWxWYWx1ZSQxIiwic2V0UmVjb2lsVmFsdWUkMyIsImNsb25lU25hcHNob3QkMiIsImdvdG9TbmFwc2hvdCQxIiwidXNlQ2FsbGJhY2skMyIsIlNlbnRpbmVsIiwiU0VOVElORUwiLCJyZWNvaWxDYWxsYmFjayIsImV4dHJhSW50ZXJmYWNlIiwicmVsZWFzZVNuYXBzaG90IiwiZXJyTXNnIiwiY2FsbGJhY2tJbnRlcmZhY2UiLCJyZXNldCIsInJlZnJlc2giLCJ0cmFuc2FjdF9VTlNUQUJMRSIsInRyYW5zYWN0aW9uIiwiX3JlbGVhc2VTbmFwc2hvdCIsIl9yZWxlYXNlU25hcHNob3QyIiwidXNlUmVjb2lsQ2FsbGJhY2siLCJSZWNvaWxfdXNlUmVjb2lsQ2FsbGJhY2siLCJ1c2VTdG9yZVJlZiQ3IiwicmVmcmVzaFJlY29pbFZhbHVlJDIiLCJ1c2VDYWxsYmFjayQ0IiwidXNlUmVjb2lsUmVmcmVzaGVyIiwiUmVjb2lsX3VzZVJlY29pbFJlZnJlc2hlciIsImF0b21pY1VwZGF0ZXIkMiIsInVzZVN0b3JlUmVmJDgiLCJ1c2VNZW1vJDMiLCJ1c2VSZWNvaWxUcmFuc2FjdGlvbiIsImF0b21pY1VwZGF0ZSIsInRyYW5zYWN0aW9uSW50ZXJmYWNlIiwiUmVjb2lsX3VzZVJlY29pbFRyYW5zYWN0aW9uIiwiV3JhcHBlZFZhbHVlIiwiUmVjb2lsX1dyYXBwZXIiLCJSZWNvaWxfV3JhcHBlcl8xIiwiUmVjb2lsX1dyYXBwZXIkMSIsImlzRmFzdFJlZnJlc2hFbmFibGVkJDIiLCJDaGFuZ2VkUGF0aEVycm9yIiwiVHJlZUNhY2hlIiwiX251bUxlYWZzIiwiZ2V0Tm9kZVZhbHVlIiwiaGFuZGxlcnMiLCJfdGhpcyRnZXRMZWFmTm9kZSIsImdldExlYWZOb2RlIiwib25Ob2RlVmlzaXQiLCJfb25IaXQiLCJub2RlVmFsdWUiLCJfbWFwTm9kZVZhbHVlIiwiYnJhbmNoZXMiLCJyb3V0ZSIsImFkZExlYWYiLCJfbm9kZTIiLCJfbm9kZTMiLCJfdGhpcyRfcm9vdDIiLCJfaGFuZGxlcnMkb25Ob2RlVmlzaXQyIiwiYnJhbmNoS2V5IiwiX25vZGUiLCJfaGFuZGxlcnMkb25Ob2RlVmlzaXQiLCJfdGhpcyRfcm9vdCIsImludmFsaWRDYWNoZUVycm9yIiwib2xkTGVhZiIsImxlYWZOb2RlIiwiX29uU2V0IiwibGVhZiIsIl9ub2RlNCIsIkNIQU5HRURfUEFUSF9FUlJPUl9NRVNTQUdFIiwiX25hbWUiLCJvcHRpb25zIiwiX29wdGlvbnMkb25IaXQiLCJfb3B0aW9ucyRvblNldCIsIl9vcHRpb25zJG1hcE5vZGVWYWx1ZSIsIm9uSGl0Iiwib25TZXQiLCJtYXBOb2RlVmFsdWUiLCJSZWNvaWxfVHJlZUNhY2hlIiwiUmVjb2lsX1RyZWVDYWNoZV8xIiwiUmVjb2lsX1RyZWVDYWNoZSQxIiwiTFJVQ2FjaGUiLCJoZWFkIiwiX2hlYWQiLCJ0YWlsIiwiX3RhaWwiLCJtYXhTaXplIiwiX21heFNpemUiLCJfa2V5TWFwcGVyIiwibWFwcGVkS2V5IiwiZXhpc3RpbmdOb2RlIiwicmlnaHQiLCJsZWZ0IiwiX21heWJlRGVsZXRlTFJVIiwiZGVsZXRlTHJ1IiwiX29wdGlvbnMkbWFwS2V5IiwibWFwS2V5IiwiUmVjb2lsX0xSVUNhY2hlIiwiUmVjb2lsX0xSVUNhY2hlXzEiLCJSZWNvaWxfTFJVQ2FjaGUkMSIsIkxSVUNhY2hlJDEiLCJUcmVlQ2FjaGUkMSIsInRyZWVDYWNoZUxSVSIsImxydUNhY2hlIiwibHJ1Tm9kZSIsIlJlY29pbF90cmVlQ2FjaGVMUlUiLCJUSU1FX1dBUk5JTkdfVEhSRVNIT0xEX01TIiwic3RyaW5naWZ5IiwiSlNPTiIsImFsbG93RnVuY3Rpb25zIiwiX0pTT04kc3RyaW5naWZ5IiwidG9TdHJpbmciLCJzb3J0IiwibG9jYWxlQ29tcGFyZSIsImZpbHRlciIsImpvaW4iLCJzdGFibGVTdHJpbmdpZnkiLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImVuZFRpbWUiLCJncm91cENvbGxhcHNlZCIsImdyb3VwRW5kIiwiUmVjb2lsX3N0YWJsZVN0cmluZ2lmeSIsIlRyZWVDYWNoZSQyIiwiZGVmYXVsdFBvbGljeSIsImVxdWFsaXR5IiwiZXZpY3Rpb24iLCJJbmZpbml0eSIsInRyZWVDYWNoZUZyb21Qb2xpY3kiLCJ2YWx1ZU1hcHBlciIsImdldFZhbHVlTWFwcGVyIiwiZ2V0VHJlZUNhY2hlIiwiUmVjb2lsX3RyZWVDYWNoZUZyb21Qb2xpY3kiLCJpc05vZGUiLCJvYmplY3QiLCJfb3duZXJEb2N1bWVudCIsIl9kb2MkZGVmYXVsdFZpZXciLCJkb2MiLCJvd25lckRvY3VtZW50IiwiZG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsIk5vZGUiLCJub2RlTmFtZSIsIlJlY29pbF9pc05vZGUiLCJpc1JlYWN0TmF0aXZlJDEiLCJpc1dpbmRvdyQxIiwic2hvdWxkTm90QmVGcm96ZW4iLCIkJHR5cGVvZiIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiZGVlcEZyZWV6ZVZhbHVlIiwiaXNGcm96ZW4iLCJzZWFsIiwiUmVjb2lsX2RlZXBGcmVlemVWYWx1ZSIsInN0YXJ0UGVyZkJsb2NrIiwiX2lkIiwiUmVjb2lsX1BlcmZvcm1hbmNlVGltaW5ncyIsImlzTG9hZGFibGUkMSIsImxvYWRhYmxlV2l0aEVycm9yJDEiLCJsb2FkYWJsZVdpdGhQcm9taXNlJDEiLCJsb2FkYWJsZVdpdGhWYWx1ZSQyIiwiV3JhcHBlZFZhbHVlJDEiLCJnZXROb2RlTG9hZGFibGUkMiIsInBlZWtOb2RlTG9hZGFibGUkMSIsInNldE5vZGVWYWx1ZSQzIiwic2F2ZURlcHNUb1N0b3JlJDEiLCJERUZBVUxUX1ZBTFVFJDYiLCJnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMSIsImdldE5vZGUkNiIsInJlZ2lzdGVyTm9kZSQxIiwiaXNSZWNvaWxWYWx1ZSQzIiwibWFya1JlY29pbFZhbHVlTW9kaWZpZWQkMSIsInJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdCQxIiwicmVjb2lsQ2FsbGJhY2skMSIsInN0YXJ0UGVyZkJsb2NrJDEiLCJDYW5jZWxlZCIsIkNBTkNFTEVEIiwiZGVwZW5kZW5jeVN0YWNrIiwid2FpdGluZ1N0b3JlcyIsImdldE5ld0V4ZWN1dGlvbklEIiwiZXhlY3V0aW9uSUQiLCJzZWxlY3RvciIsImNhY2hlUG9saWN5X1VOU1RBQkxFIiwiY2FjaGVQb2xpY3kiLCJkaXNjb3ZlcmVkRGVwZW5kZW5jeU5vZGVLZXlzIiwicmV0YWluZWRCeV9VTlNUQUJMRSIsImV4ZWN1dGlvbkluZm9NYXAiLCJsaXZlU3RvcmVzQ291bnQiLCJzZWxlY3RvcklzTGl2ZSIsInNlbGVjdG9ySW5pdCIsInNlbGVjdG9yU2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlIiwicmVzb2x2ZUFzeW5jIiwiZGVwVmFsdWVzIiwic2V0Q2FjaGUiLCJub3RpZnlTdG9yZXNPZlJlc29sdmVkQXN5bmMiLCJpc0xhdGVzdEV4ZWN1dGlvbiIsImNsZWFyRXhlY3V0aW9uSW5mbyIsIm5vdGlmeVdhaXRpbmdTdG9yZXMiLCJub3RpZnlTdG9yZXNPZk5ld0FzeW5jRGVwIiwiZXhlY3V0aW9uSW5mbyIsImdldEV4ZWN1dGlvbkluZm8iLCJzdGF0ZVZlcnNpb25zIiwiY2xlYXJXYWl0bGlzdCIsInN0b3JlcyIsIndhaXRpbmdTdG9yZSIsIm1hcmtTdG9yZVdhaXRpbmdGb3JSZXNvbHZlZEFzeW5jIiwid3JhcFJlc3VsdFByb21pc2UiLCJsb2FkaW5nRGVwc1N0YXRlIiwiZXJyb3JPclByb21pc2UiLCJ3cmFwUGVuZGluZ0RlcGVuZGVuY3lQcm9taXNlIiwiZXhpc3RpbmdEZXBzIiwicmVzb2x2ZWREZXAiLCJsb2FkaW5nRGVwS2V5IiwibG9hZGluZ0RlcFByb21pc2UiLCJjYWNoZWRMb2FkYWJsZSIsImdldExvYWRhYmxlRnJvbUNhY2hlQW5kVXBkYXRlRGVwcyIsImdldEluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvIiwibG9hZGluZ0xvYWRhYmxlIiwiZXZhbHVhdGVTZWxlY3RvckdldHRlciIsInVwZGF0ZURlcHMiLCJfc3RvcmUkZ2V0U3RhdGUiLCJfc3RvcmUkZ2V0U3RhdGUkY3VycmUiLCJfc3RvcmUkZ2V0U3RhdGUyIiwiX3N0b3JlJGdldFN0YXRlMiRuZXh0IiwiX3N0b3JlJGdldFN0YXRlMyIsIl9zdG9yZSRnZXRTdGF0ZTMkbmV4dCIsImVuZFBlcmZCbG9jayIsImR1cmluZ1N5bmNocm9ub3VzRXhlY3V0aW9uIiwiZHVyaW5nQXN5bmNocm9ub3VzRXhlY3V0aW9uIiwiZmluaXNoRXZhbHVhdGlvbiIsInJlc3VsdElzRXJyb3IiLCJkZXBLZXkiLCJkZXBMb2FkYWJsZSIsImdldENhbGxiYWNrIiwiZXJyb3JPckRlcFByb21pc2UiLCJ1cGRhdGVFeGVjdXRpb25JbmZvRGVwVmFsdWVzIiwiZGVwc0FmdGVyQ2FjaGVMb29rdXAiLCJfZ2V0RXhlY3V0aW9uSW5mbyIsImdldFNlbGVjdG9yTG9hZGFibGVBbmRVcGRhdGVEZXBzIiwiY2FjaGVkVmFsIiwiaW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8iLCJfaW5Qcm9ncmVzc0V4ZWN1dGlvbkkiLCJuZXdFeGVjdXRpb25JRCIsIm5ld0RlcFZhbHVlcyIsInNldEV4ZWN1dGlvbkluZm8iLCJwZW5kaW5nRXhlY3V0aW9ucyIsImV4ZWNJbmZvIiwiYW55RGVwQ2hhbmdlZCIsImV4ZWNEZXBWYWx1ZXMiLCJleGVjTG9hZGFibGUiLCJkZXBWYWx1ZXNEaXNjb3ZlcmVkU29GYXJEdXJpbmdBc3luY1dvcmsiLCJfZ2V0RXhlY3V0aW9uSW5mbzIiLCJkZXBWYWx1ZXNUb0RlcFJvdXRlIiwidmFsTG9hZGFibGUiLCJCb29sZWFuIiwiZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHkiLCJkZXRlY3RDaXJjdWxhckRlcGVuZGVuY2llcyIsInNsaWNlIiwiaW5kZXhPZiIsInNlbGVjdG9yUGVlayIsIl9wZWVrTm9kZUxvYWRhYmxlIiwic2VsZWN0b3JHZXQiLCJpbnZhbGlkYXRlU2VsZWN0b3IiLCJjbGVhclNlbGVjdG9yQ2FjaGUiLCJzZWxlY3RvclNldCIsInN5bmNTZWxlY3RvclNldEZpbmlzaGVkIiwic2V0UmVjb2lsU3RhdGUiLCJzZXRWYWx1ZSIsInVwc3RyZWFtV3JpdGVzIiwicmVzZXRSZWNvaWxTdGF0ZSIsIlJlY29pbF9zZWxlY3RvciIsImlzTG9hZGFibGUkMiIsImxvYWRhYmxlV2l0aEVycm9yJDIiLCJsb2FkYWJsZVdpdGhQcm9taXNlJDIiLCJsb2FkYWJsZVdpdGhWYWx1ZSQzIiwiV3JhcHBlZFZhbHVlJDIiLCJwZWVrTm9kZUluZm8kMyIsIkRFRkFVTFRfVkFMVUUkNyIsIkRlZmF1bHRWYWx1ZSQyIiwiZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDIiLCJyZWdpc3Rlck5vZGUkMiIsInNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQxIiwiaXNSZWNvaWxWYWx1ZSQ0IiwiZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDQiLCJtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCQyIiwic2V0UmVjb2lsVmFsdWUkNCIsInNldFJlY29pbFZhbHVlTG9hZGFibGUkMiIsInJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdCQyIiwidW53cmFwIiwiYmFzZUF0b20iLCJ1bndyYXBQcm9taXNlIiwiZGVmYXVsdExvYWRhYmxlIiwiZGVmYXVsdCIsIm1heWJlRnJlZXplVmFsdWVPclByb21pc2UiLCJjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlIiwiY2xlYW51cEVmZmVjdHNCeVN0b3JlIiwidmFsdWVPclByb21pc2UiLCJ3cmFwUGVuZGluZ1Byb21pc2UiLCJ3cmFwcGVkUHJvbWlzZSIsIl9zdGF0ZSRhdG9tVmFsdWVzJGdldCIsIl9zdG9yZSRnZXRTdGF0ZSRuZXh0VDIiLCJfc3RhdGUkYXRvbVZhbHVlcyRnZXQyIiwiaW5pdEF0b20iLCJpbml0U3RhdGUiLCJfb3B0aW9ucyRlZmZlY3RzIiwiY2xlYW51cEF0b20iLCJfY2xlYW51cEVmZmVjdHNCeVN0b3IiLCJub3RpZnlEZWZhdWx0U3Vic2NyaWJlcnMiLCJfc3RvcmUkZ2V0U3RhdGUkbmV4dFQzIiwiZWZmZWN0cyIsImVmZmVjdHNfVU5TVEFCTEUiLCJpbml0VmFsdWUiLCJpc0R1cmluZ0luaXQiLCJpc0luaXRFcnJvciIsInBlbmRpbmdTZXRTZWxmIiwicmV0VmFsdWUiLCJwZWVrQXRvbSIsImdldFByb21pc2UiLCJnZXRJbmZvX1VOU1RBQkxFIiwiX3N0b3JlJGdldFN0YXRlJG5leHRUNCIsImluZm8iLCJzZXRTZWxmIiwiZWZmZWN0IiwiY3VycmVudExvYWRhYmxlIiwiY3VycmVudFZhbHVlIiwicmVzZXRTZWxmIiwiaGFuZGxlciIsIl9jbGVhbnVwRWZmZWN0c0J5U3RvcjIiLCJjdXJyZW50U3RvcmUiLCJfY3VycmVudFRyZWUkYXRvbVZhbHUiLCJfcHJldmlvdXNUcmVlJGF0b21WYWwiLCJfcGVuZGluZ1NldFNlbGYiLCJfcGVuZGluZ1NldFNlbGYyIiwiX3BlbmRpbmdTZXRTZWxmMyIsIm9sZExvYWRhYmxlIiwib2xkVmFsdWUiLCJwYXJlbnRTdG9yZUlEX1VOU1RBQkxFIiwiX2NsZWFudXBFZmZlY3RzQnlTdG9yMyIsIl9zdG9yZSRnZXRTdGF0ZSRuZXh0VDUiLCJpbml0TG9hZGFibGUiLCJfcmVmIiwiX3N0YXRlJGF0b21WYWx1ZXMkZ2V0MyIsImdldEF0b20iLCJub252YWxpZGF0ZWRWYWx1ZSIsInZhbGlkYXRvclJlc3VsdCIsInZhbGlkYXRvciIsInZhbGlkYXRlZFZhbHVlTG9hZGFibGUiLCJpbnZhbGlkYXRlQXRvbSIsInNldEF0b20iLCJzaG91bGREZWxldGVDb25maWdPblJlbGVhc2VBdG9tIiwicmVzdE9wdGlvbnMiLCJvcHRpb25zRGVmYXVsdCIsImF0b21XaXRoRmFsbGJhY2siLCJzdG9yZWRWYWx1ZSIsInNlbCIsImJhc2VWYWx1ZSIsIlJlY29pbF9hdG9tIiwiTWFwQ2FjaGUiLCJSZWNvaWxfTWFwQ2FjaGUiLCJSZWNvaWxfTWFwQ2FjaGVfMSIsIlJlY29pbF9NYXBDYWNoZSQxIiwiTFJVQ2FjaGUkMiIsIk1hcENhY2hlJDEiLCJkZWZhdWx0UG9saWN5JDEiLCJjYWNoZUZyb21Qb2xpY3kiLCJnZXRWYWx1ZU1hcHBlciQxIiwiZ2V0Q2FjaGUiLCJSZWNvaWxfY2FjaGVGcm9tUG9saWN5Iiwic2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDIiLCJhdG9tRmFtaWx5IiwiX29wdGlvbnMkY2FjaGVQb2xpY3lGIiwiX29wdGlvbnMkY2FjaGVQb2xpY3lGMiIsImF0b21DYWNoZSIsImNhY2hlUG9saWN5Rm9yUGFyYW1zX1VOU1RBQkxFIiwicGFyYW1zIiwiX3N0YWJsZVN0cmluZ2lmeSIsImNhY2hlZEF0b20iLCJhdG9tT3B0aW9ucyIsIm5ld0F0b20iLCJSZWNvaWxfYXRvbUZhbWlseSIsInNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQzIiwibmV4dEluZGV4Iiwic2VsZWN0b3JGYW1pbHkiLCJzZWxlY3RvckNhY2hlIiwiY2FjaGVkU2VsZWN0b3IiLCJteUtleSIsIm15R2V0IiwiY2FsbGJhY2tzIiwibXlDYWNoZVBvbGljeSIsIm5ld1NlbGVjdG9yIiwibXlTZXQiLCJSZWNvaWxfc2VsZWN0b3JGYW1pbHkiLCJjb25zdGFudFNlbGVjdG9yIiwiY29uc3RTZWxlY3RvciIsIlJlY29pbF9jb25zdFNlbGVjdG9yIiwidGhyb3dpbmdTZWxlY3RvciIsImVycm9yU2VsZWN0b3IiLCJSZWNvaWxfZXJyb3JTZWxlY3RvciIsInJlYWRPbmx5U2VsZWN0b3IiLCJSZWNvaWxfcmVhZE9ubHlTZWxlY3RvciIsImxvYWRhYmxlV2l0aEVycm9yJDMiLCJsb2FkYWJsZVdpdGhQcm9taXNlJDMiLCJsb2FkYWJsZVdpdGhWYWx1ZSQ0IiwiY29uY3VycmVudFJlcXVlc3RzIiwicmVzdWx0cyIsImZpbGwiLCJleGNlcHRpb25zIiwiaXNFcnJvciIsImV4cCIsInVud3JhcERlcGVuZGVuY2llcyIsImRlcGVuZGVuY2llcyIsIndyYXBSZXN1bHRzIiwid3JhcExvYWRhYmxlcyIsImV4Y2VwdGlvbiIsImNvbWJpbmVBc3luY1Jlc3VsdHNXaXRoU3luY1Jlc3VsdHMiLCJzeW5jUmVzdWx0cyIsImFzeW5jUmVzdWx0cyIsIndhaXRGb3JOb25lIiwid2FpdEZvckFueSIsIndhaXRGb3JBbGwiLCJleGNlcHRpb25SZXN1bHRzIiwid2FpdEZvckFsbFNldHRsZWQiLCJub1dhaXQiLCJkZXBlbmRlbmN5IiwiUmVjb2lsX1dhaXRGb3IiLCJEZWZhdWx0VmFsdWUkMyIsIlJlY29pbFJvb3QkMiIsInVzZVJlY29pbFN0b3JlSUQkMSIsImlzUmVjb2lsVmFsdWUkNSIsInJldGVudGlvblpvbmUkMSIsImZyZXNoU25hcHNob3QkMiIsInVzZVJlY29pbFN0YXRlJDEiLCJ1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUkMSIsInVzZVJlY29pbFN0YXRlTG9hZGFibGUkMSIsInVzZVJlY29pbFZhbHVlJDEiLCJ1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUkMSIsInVzZVJlY29pbFZhbHVlTG9hZGFibGUkMSIsInVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFJDEiLCJ1c2VSZXNldFJlY29pbFN0YXRlJDEiLCJ1c2VTZXRSZWNvaWxTdGF0ZSQxIiwidXNlR290b1JlY29pbFNuYXBzaG90JDEiLCJ1c2VSZWNvaWxTbmFwc2hvdCQxIiwidXNlUmVjb2lsVHJhbnNhY3Rpb25PYnNlcnZlciQxIiwidXNlUmVjb2lsQ2FsbGJhY2skMSIsIm5vV2FpdCQxIiwid2FpdEZvckFsbCQxIiwid2FpdEZvckFsbFNldHRsZWQkMSIsIndhaXRGb3JBbnkkMSIsIndhaXRGb3JOb25lJDEiLCJSZWNvaWxfaW5kZXgiLCJSZWNvaWxFbnYiLCJ1c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzX1VOU1RBQkxFIiwidXNlR2V0UmVjb2lsVmFsdWVJbmZvX1VOU1RBQkxFIiwidXNlUmVjb2lsUmVmcmVzaGVyX1VOU1RBQkxFIiwidXNlUmVjb2lsVHJhbnNhY3Rpb25fVU5TVEFCTEUiLCJ1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyX1VOU1RBQkxFIiwic25hcHNob3RfVU5TVEFCTEUiLCJSZWNvaWxfaW5kZXhfMSIsIlJlY29pbF9pbmRleF8yIiwiUmVjb2lsX2luZGV4XzMiLCJSZWNvaWxfaW5kZXhfNCIsIlJlY29pbF9pbmRleF81IiwiUmVjb2lsX2luZGV4XzYiLCJSZWNvaWxfaW5kZXhfNyIsIlJlY29pbF9pbmRleF84IiwiUmVjb2lsX2luZGV4XzkiLCJSZWNvaWxfaW5kZXhfMTAiLCJSZWNvaWxfaW5kZXhfMTEiLCJSZWNvaWxfaW5kZXhfMTIiLCJSZWNvaWxfaW5kZXhfMTMiLCJSZWNvaWxfaW5kZXhfMTQiLCJSZWNvaWxfaW5kZXhfMTUiLCJSZWNvaWxfaW5kZXhfMTYiLCJSZWNvaWxfaW5kZXhfMTciLCJSZWNvaWxfaW5kZXhfMTgiLCJSZWNvaWxfaW5kZXhfMTkiLCJSZWNvaWxfaW5kZXhfMjAiLCJSZWNvaWxfaW5kZXhfMjEiLCJSZWNvaWxfaW5kZXhfMjIiLCJSZWNvaWxfaW5kZXhfMjMiLCJSZWNvaWxfaW5kZXhfMjQiLCJSZWNvaWxfaW5kZXhfMjUiLCJSZWNvaWxfaW5kZXhfMjYiLCJSZWNvaWxfaW5kZXhfMjciLCJSZWNvaWxfaW5kZXhfMjgiLCJSZWNvaWxfaW5kZXhfMjkiLCJSZWNvaWxfaW5kZXhfMzAiLCJSZWNvaWxfaW5kZXhfMzEiLCJSZWNvaWxfaW5kZXhfMzIiLCJSZWNvaWxfaW5kZXhfMzMiLCJSZWNvaWxfaW5kZXhfMzQiLCJSZWNvaWxfaW5kZXhfMzUiLCJSZWNvaWxfaW5kZXhfMzYiLCJSZWNvaWxfaW5kZXhfMzciLCJSZWNvaWxfaW5kZXhfMzgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/recoil/es/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/shallowequal/index.js":
/*!********************************************!*\
  !*** ./node_modules/shallowequal/index.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("//\n\nmodule.exports = function shallowEqual(objA, objB, compare, compareContext) {\n    var ret = compare ? compare.call(compareContext, objA, objB) : void 0;\n    if (ret !== void 0) {\n        return !!ret;\n    }\n    if (objA === objB) {\n        return true;\n    }\n    if (typeof objA !== \"object\" || !objA || typeof objB !== \"object\" || !objB) {\n        return false;\n    }\n    var keysA = Object.keys(objA);\n    var keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n    var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);\n    // Test for A's keys different from B.\n    for(var idx = 0; idx < keysA.length; idx++){\n        var key = keysA[idx];\n        if (!bHasOwnProperty(key)) {\n            return false;\n        }\n        var valueA = objA[key];\n        var valueB = objB[key];\n        ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;\n        if (ret === false || ret === void 0 && valueA !== valueB) {\n            return false;\n        }\n    }\n    return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zaGFsbG93ZXF1YWwvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsRUFBRTs7QUFFRkEsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLGFBQWFDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLGNBQWM7SUFDeEUsSUFBSUMsTUFBTUYsVUFBVUEsUUFBUUcsSUFBSSxDQUFDRixnQkFBZ0JILE1BQU1DLFFBQVEsS0FBSztJQUVwRSxJQUFJRyxRQUFRLEtBQUssR0FBRztRQUNsQixPQUFPLENBQUMsQ0FBQ0E7SUFDWDtJQUVBLElBQUlKLFNBQVNDLE1BQU07UUFDakIsT0FBTztJQUNUO0lBRUEsSUFBSSxPQUFPRCxTQUFTLFlBQVksQ0FBQ0EsUUFBUSxPQUFPQyxTQUFTLFlBQVksQ0FBQ0EsTUFBTTtRQUMxRSxPQUFPO0lBQ1Q7SUFFQSxJQUFJSyxRQUFRQyxPQUFPQyxJQUFJLENBQUNSO0lBQ3hCLElBQUlTLFFBQVFGLE9BQU9DLElBQUksQ0FBQ1A7SUFFeEIsSUFBSUssTUFBTUksTUFBTSxLQUFLRCxNQUFNQyxNQUFNLEVBQUU7UUFDakMsT0FBTztJQUNUO0lBRUEsSUFBSUMsa0JBQWtCSixPQUFPSyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDYjtJQUUzRCxzQ0FBc0M7SUFDdEMsSUFBSyxJQUFJYyxNQUFNLEdBQUdBLE1BQU1ULE1BQU1JLE1BQU0sRUFBRUssTUFBTztRQUMzQyxJQUFJQyxNQUFNVixLQUFLLENBQUNTLElBQUk7UUFFcEIsSUFBSSxDQUFDSixnQkFBZ0JLLE1BQU07WUFDekIsT0FBTztRQUNUO1FBRUEsSUFBSUMsU0FBU2pCLElBQUksQ0FBQ2dCLElBQUk7UUFDdEIsSUFBSUUsU0FBU2pCLElBQUksQ0FBQ2UsSUFBSTtRQUV0QlosTUFBTUYsVUFBVUEsUUFBUUcsSUFBSSxDQUFDRixnQkFBZ0JjLFFBQVFDLFFBQVFGLE9BQU8sS0FBSztRQUV6RSxJQUFJWixRQUFRLFNBQVVBLFFBQVEsS0FBSyxLQUFLYSxXQUFXQyxRQUFTO1lBQzFELE9BQU87UUFDVDtJQUNGO0lBRUEsT0FBTztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zaGFsbG93ZXF1YWwvaW5kZXguanM/NzE4MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCLCBjb21wYXJlLCBjb21wYXJlQ29udGV4dCkge1xuICB2YXIgcmV0ID0gY29tcGFyZSA/IGNvbXBhcmUuY2FsbChjb21wYXJlQ29udGV4dCwgb2JqQSwgb2JqQikgOiB2b2lkIDA7XG5cbiAgaWYgKHJldCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuICEhcmV0O1xuICB9XG5cbiAgaWYgKG9iakEgPT09IG9iakIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gXCJvYmplY3RcIiB8fCAhb2JqQSB8fCB0eXBlb2Ygb2JqQiAhPT0gXCJvYmplY3RcIiB8fCAhb2JqQikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgYkhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5iaW5kKG9iakIpO1xuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGtleXNBLmxlbmd0aDsgaWR4KyspIHtcbiAgICB2YXIga2V5ID0ga2V5c0FbaWR4XTtcblxuICAgIGlmICghYkhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVBID0gb2JqQVtrZXldO1xuICAgIHZhciB2YWx1ZUIgPSBvYmpCW2tleV07XG5cbiAgICByZXQgPSBjb21wYXJlID8gY29tcGFyZS5jYWxsKGNvbXBhcmVDb250ZXh0LCB2YWx1ZUEsIHZhbHVlQiwga2V5KSA6IHZvaWQgMDtcblxuICAgIGlmIChyZXQgPT09IGZhbHNlIHx8IChyZXQgPT09IHZvaWQgMCAmJiB2YWx1ZUEgIT09IHZhbHVlQikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInNoYWxsb3dFcXVhbCIsIm9iakEiLCJvYmpCIiwiY29tcGFyZSIsImNvbXBhcmVDb250ZXh0IiwicmV0IiwiY2FsbCIsImtleXNBIiwiT2JqZWN0Iiwia2V5cyIsImtleXNCIiwibGVuZ3RoIiwiYkhhc093blByb3BlcnR5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJiaW5kIiwiaWR4Iiwia2V5IiwidmFsdWVBIiwidmFsdWVCIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/shallowequal/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/styled-components/dist/styled-components.browser.esm.js":
/*!******************************************************************************!*\
  !*** ./node_modules/styled-components/dist/styled-components.browser.esm.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ServerStyleSheet: function() { return /* binding */ mt; },\n/* harmony export */   StyleSheetConsumer: function() { return /* binding */ $e; },\n/* harmony export */   StyleSheetContext: function() { return /* binding */ Me; },\n/* harmony export */   StyleSheetManager: function() { return /* binding */ Le; },\n/* harmony export */   ThemeConsumer: function() { return /* binding */ Qe; },\n/* harmony export */   ThemeContext: function() { return /* binding */ Ke; },\n/* harmony export */   ThemeProvider: function() { return /* binding */ tt; },\n/* harmony export */   __PRIVATE__: function() { return /* binding */ yt; },\n/* harmony export */   createGlobalStyle: function() { return /* binding */ dt; },\n/* harmony export */   css: function() { return /* binding */ at; },\n/* harmony export */   \"default\": function() { return /* binding */ ut; },\n/* harmony export */   isStyledComponent: function() { return /* binding */ se; },\n/* harmony export */   keyframes: function() { return /* binding */ ht; },\n/* harmony export */   styled: function() { return /* binding */ ut; },\n/* harmony export */   useTheme: function() { return /* binding */ et; },\n/* harmony export */   version: function() { return /* binding */ v; },\n/* harmony export */   withTheme: function() { return /* binding */ ft; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/styled-components/node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _emotion_is_prop_valid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @emotion/is-prop-valid */ \"(app-pages-browser)/./node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var shallowequal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! shallowequal */ \"(app-pages-browser)/./node_modules/shallowequal/index.js\");\n/* harmony import */ var shallowequal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(shallowequal__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var stylis__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! stylis */ \"(app-pages-browser)/./node_modules/stylis/src/Enum.js\");\n/* harmony import */ var stylis__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! stylis */ \"(app-pages-browser)/./node_modules/stylis/src/Middleware.js\");\n/* harmony import */ var stylis__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! stylis */ \"(app-pages-browser)/./node_modules/stylis/src/Serializer.js\");\n/* harmony import */ var stylis__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! stylis */ \"(app-pages-browser)/./node_modules/stylis/src/Parser.js\");\n/* harmony import */ var _emotion_unitless__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @emotion/unitless */ \"(app-pages-browser)/./node_modules/@emotion/unitless/dist/emotion-unitless.esm.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar _s = $RefreshSig$();\n\n\n\n\n\n\nvar f = \"undefined\" != typeof process && void 0 !== process.env && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || \"data-styled\", m = \"active\", y = \"data-styled-version\", v = \"6.1.8\", g = \"/*!sc*/\\n\", S =  true && \"HTMLElement\" in window, w = Boolean(\"boolean\" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : \"undefined\" != typeof process && void 0 !== process.env && void 0 !== process.env.REACT_APP_SC_DISABLE_SPEEDY && \"\" !== process.env.REACT_APP_SC_DISABLE_SPEEDY ? \"false\" !== process.env.REACT_APP_SC_DISABLE_SPEEDY && process.env.REACT_APP_SC_DISABLE_SPEEDY : \"undefined\" != typeof process && void 0 !== process.env && void 0 !== process.env.SC_DISABLE_SPEEDY && \"\" !== process.env.SC_DISABLE_SPEEDY ? \"false\" !== process.env.SC_DISABLE_SPEEDY && process.env.SC_DISABLE_SPEEDY : \"production\" !== \"development\"), b = {}, E = /invalid hook call/i, N = new Set, P = function(t, n) {\n    if (true) {\n        var o = n ? ' with the id of \"'.concat(n, '\"') : \"\", s = \"The component \".concat(t).concat(o, \" has been created dynamically.\\n\") + \"You may see this warning because you've called styled inside another component.\\nTo resolve this only create new StyledComponents outside of any render method and function component.\", i = console.error;\n        try {\n            var a = !0;\n            console.error = function(t) {\n                for(var n = [], o = 1; o < arguments.length; o++)n[o - 1] = arguments[o];\n                E.test(t) ? (a = !1, N.delete(s)) : i.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__spreadArray)([\n                    t\n                ], n, !1));\n            }, (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(), a && !N.has(s) && (console.warn(s), N.add(s));\n        } catch (e) {\n            E.test(e.message) && N.delete(s);\n        } finally{\n            console.error = i;\n        }\n    }\n}, _ = Object.freeze([]), C = Object.freeze({});\nfunction I(e, t, n) {\n    return void 0 === n && (n = C), e.theme !== n.theme && e.theme || t || n.theme;\n}\n_c = I;\nvar A = new Set([\n    \"a\",\n    \"abbr\",\n    \"address\",\n    \"area\",\n    \"article\",\n    \"aside\",\n    \"audio\",\n    \"b\",\n    \"base\",\n    \"bdi\",\n    \"bdo\",\n    \"big\",\n    \"blockquote\",\n    \"body\",\n    \"br\",\n    \"button\",\n    \"canvas\",\n    \"caption\",\n    \"cite\",\n    \"code\",\n    \"col\",\n    \"colgroup\",\n    \"data\",\n    \"datalist\",\n    \"dd\",\n    \"del\",\n    \"details\",\n    \"dfn\",\n    \"dialog\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"em\",\n    \"embed\",\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"header\",\n    \"hgroup\",\n    \"hr\",\n    \"html\",\n    \"i\",\n    \"iframe\",\n    \"img\",\n    \"input\",\n    \"ins\",\n    \"kbd\",\n    \"keygen\",\n    \"label\",\n    \"legend\",\n    \"li\",\n    \"link\",\n    \"main\",\n    \"map\",\n    \"mark\",\n    \"menu\",\n    \"menuitem\",\n    \"meta\",\n    \"meter\",\n    \"nav\",\n    \"noscript\",\n    \"object\",\n    \"ol\",\n    \"optgroup\",\n    \"option\",\n    \"output\",\n    \"p\",\n    \"param\",\n    \"picture\",\n    \"pre\",\n    \"progress\",\n    \"q\",\n    \"rp\",\n    \"rt\",\n    \"ruby\",\n    \"s\",\n    \"samp\",\n    \"script\",\n    \"section\",\n    \"select\",\n    \"small\",\n    \"source\",\n    \"span\",\n    \"strong\",\n    \"style\",\n    \"sub\",\n    \"summary\",\n    \"sup\",\n    \"table\",\n    \"tbody\",\n    \"td\",\n    \"textarea\",\n    \"tfoot\",\n    \"th\",\n    \"thead\",\n    \"time\",\n    \"tr\",\n    \"track\",\n    \"u\",\n    \"ul\",\n    \"use\",\n    \"var\",\n    \"video\",\n    \"wbr\",\n    \"circle\",\n    \"clipPath\",\n    \"defs\",\n    \"ellipse\",\n    \"foreignObject\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"linearGradient\",\n    \"marker\",\n    \"mask\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"radialGradient\",\n    \"rect\",\n    \"stop\",\n    \"svg\",\n    \"text\",\n    \"tspan\"\n]), O = /[!\"#$%&'()*+,./:;<=>?@[\\\\\\]^`{|}~-]+/g, D = /(^-|-$)/g;\nfunction R(e) {\n    return e.replace(O, \"-\").replace(D, \"\");\n}\n_c1 = R;\nvar T = /(a)(d)/gi, k = 52, j = function(e) {\n    return String.fromCharCode(e + (e > 25 ? 39 : 97));\n};\nfunction x(e) {\n    var t, n = \"\";\n    for(t = Math.abs(e); t > k; t = t / k | 0)n = j(t % k) + n;\n    return (j(t % k) + n).replace(T, \"$1-$2\");\n}\nvar V, F = 5381, M = function(e, t) {\n    for(var n = t.length; n;)e = 33 * e ^ t.charCodeAt(--n);\n    return e;\n}, $ = function(e) {\n    return M(F, e);\n};\nfunction z(e) {\n    return x($(e) >>> 0);\n}\nfunction B(e) {\n    return  true && \"string\" == typeof e && e || e.displayName || e.name || \"Component\";\n}\n_c2 = B;\nfunction L(e) {\n    return \"string\" == typeof e && ( false || e.charAt(0) === e.charAt(0).toLowerCase());\n}\n_c3 = L;\nvar G = \"function\" == typeof Symbol && Symbol.for, Y = G ? Symbol.for(\"react.memo\") : 60115, W = G ? Symbol.for(\"react.forward_ref\") : 60112, q = {\n    childContextTypes: !0,\n    contextType: !0,\n    contextTypes: !0,\n    defaultProps: !0,\n    displayName: !0,\n    getDefaultProps: !0,\n    getDerivedStateFromError: !0,\n    getDerivedStateFromProps: !0,\n    mixins: !0,\n    propTypes: !0,\n    type: !0\n}, H = {\n    name: !0,\n    length: !0,\n    prototype: !0,\n    caller: !0,\n    callee: !0,\n    arguments: !0,\n    arity: !0\n}, U = {\n    $$typeof: !0,\n    compare: !0,\n    defaultProps: !0,\n    displayName: !0,\n    propTypes: !0,\n    type: !0\n}, J = ((V = {})[W] = {\n    $$typeof: !0,\n    render: !0,\n    defaultProps: !0,\n    displayName: !0,\n    propTypes: !0\n}, V[Y] = U, V);\nfunction X(e) {\n    return (\"type\" in (t = e) && t.type.$$typeof) === Y ? U : \"$$typeof\" in e ? J[e.$$typeof] : q;\n    var t;\n}\n_c4 = X;\nvar Z = Object.defineProperty, K = Object.getOwnPropertyNames, Q = Object.getOwnPropertySymbols, ee = Object.getOwnPropertyDescriptor, te = Object.getPrototypeOf, ne = Object.prototype;\nfunction oe(e, t, n) {\n    if (\"string\" != typeof t) {\n        if (ne) {\n            var o = te(t);\n            o && o !== ne && oe(e, o, n);\n        }\n        var r = K(t);\n        Q && (r = r.concat(Q(t)));\n        for(var s = X(e), i = X(t), a = 0; a < r.length; ++a){\n            var c = r[a];\n            if (!(c in H || n && n[c] || i && c in i || s && c in s)) {\n                var l = ee(t, c);\n                try {\n                    Z(e, c, l);\n                } catch (e) {}\n            }\n        }\n    }\n    return e;\n}\nfunction re(e) {\n    return \"function\" == typeof e;\n}\nfunction se(e) {\n    return \"object\" == typeof e && \"styledComponentId\" in e;\n}\nfunction ie(e, t) {\n    return e && t ? \"\".concat(e, \" \").concat(t) : e || t || \"\";\n}\nfunction ae(e, t) {\n    if (0 === e.length) return \"\";\n    for(var n = e[0], o = 1; o < e.length; o++)n += t ? t + e[o] : e[o];\n    return n;\n}\nfunction ce(e) {\n    return null !== e && \"object\" == typeof e && e.constructor.name === Object.name && !(\"props\" in e && e.$$typeof);\n}\nfunction le(e, t, n) {\n    if (void 0 === n && (n = !1), !n && !ce(e) && !Array.isArray(e)) return t;\n    if (Array.isArray(t)) for(var o = 0; o < t.length; o++)e[o] = le(e[o], t[o]);\n    else if (ce(t)) for(var o in t)e[o] = le(e[o], t[o]);\n    return e;\n}\nfunction ue(e, t) {\n    Object.defineProperty(e, \"toString\", {\n        value: t\n    });\n}\nvar pe =  true ? {\n    1: \"Cannot create styled-component for component: %s.\\n\\n\",\n    2: \"Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\\n\\n- Are you trying to reuse it across renders?\\n- Are you accidentally calling collectStyles twice?\\n\\n\",\n    3: \"Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\\n\\n\",\n    4: \"The `StyleSheetManager` expects a valid target or sheet prop!\\n\\n- Does this error occur on the client and is your target falsy?\\n- Does this error occur on the server and is the sheet falsy?\\n\\n\",\n    5: \"The clone method cannot be used on the client!\\n\\n- Are you running in a client-like environment on the server?\\n- Are you trying to run SSR on the client?\\n\\n\",\n    6: \"Trying to insert a new style tag, but the given Node is unmounted!\\n\\n- Are you using a custom target that isn't mounted?\\n- Does your document not have a valid head element?\\n- Have you accidentally removed a style tag manually?\\n\\n\",\n    7: 'ThemeProvider: Please return an object from your \"theme\" prop function, e.g.\\n\\n```js\\ntheme={() => ({})}\\n```\\n\\n',\n    8: 'ThemeProvider: Please make your \"theme\" prop an object.\\n\\n',\n    9: \"Missing document `<head>`\\n\\n\",\n    10: \"Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\\n\\n\",\n    11: \"_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\\n\\n\",\n    12: \"It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\\\`\\\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\\n\\n\",\n    13: \"%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\\n\\n\",\n    14: 'ThemeProvider: \"theme\" prop is required.\\n\\n',\n    15: \"A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\\n\\n```js\\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\\n```\\n\\n\",\n    16: \"Reached the limit of how many styled components may be created at group %s.\\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\\nas for instance in your render method then you may be running into this limitation.\\n\\n\",\n    17: \"CSSStyleSheet could not be found on HTMLStyleElement.\\nHas styled-components' style tag been unmounted or altered by another script?\\n\",\n    18: \"ThemeProvider: Please make sure your useTheme hook is within a `<ThemeProvider>`\"\n} : 0;\nfunction de() {\n    for(var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t];\n    for(var n = e[0], o = [], r = 1, s = e.length; r < s; r += 1)o.push(e[r]);\n    return o.forEach(function(e) {\n        n = n.replace(/%[a-z]/, e);\n    }), n;\n}\nfunction he(t) {\n    for(var n = [], o = 1; o < arguments.length; o++)n[o - 1] = arguments[o];\n    return  false ? 0 : new Error(de.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__spreadArray)([\n        pe[t]\n    ], n, !1)).trim());\n}\nvar fe = function() {\n    function e(e) {\n        this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e;\n    }\n    return e.prototype.indexOfGroup = function(e) {\n        for(var t = 0, n = 0; n < e; n++)t += this.groupSizes[n];\n        return t;\n    }, e.prototype.insertRules = function(e, t) {\n        if (e >= this.groupSizes.length) {\n            for(var n = this.groupSizes, o = n.length, r = o; e >= r;)if ((r <<= 1) < 0) throw he(16, \"\".concat(e));\n            this.groupSizes = new Uint32Array(r), this.groupSizes.set(n), this.length = r;\n            for(var s = o; s < r; s++)this.groupSizes[s] = 0;\n        }\n        for(var i = this.indexOfGroup(e + 1), a = (s = 0, t.length); s < a; s++)this.tag.insertRule(i, t[s]) && (this.groupSizes[e]++, i++);\n    }, e.prototype.clearGroup = function(e) {\n        if (e < this.length) {\n            var t = this.groupSizes[e], n = this.indexOfGroup(e), o = n + t;\n            this.groupSizes[e] = 0;\n            for(var r = n; r < o; r++)this.tag.deleteRule(n);\n        }\n    }, e.prototype.getGroup = function(e) {\n        var t = \"\";\n        if (e >= this.length || 0 === this.groupSizes[e]) return t;\n        for(var n = this.groupSizes[e], o = this.indexOfGroup(e), r = o + n, s = o; s < r; s++)t += \"\".concat(this.tag.getRule(s)).concat(g);\n        return t;\n    }, e;\n}(), me = new Map, ye = new Map, ve = 1, ge = function(e) {\n    if (me.has(e)) return me.get(e);\n    for(; ye.has(ve);)ve++;\n    var t = ve++;\n    if ( true && ((0 | t) < 0 || t > 1073741824)) throw he(16, \"\".concat(t));\n    return me.set(e, t), ye.set(t, e), t;\n}, Se = function(e, t) {\n    ve = t + 1, me.set(e, t), ye.set(t, e);\n}, we = \"style[\".concat(f, \"][\").concat(y, '=\"').concat(v, '\"]'), be = new RegExp(\"^\".concat(f, '\\\\.g(\\\\d+)\\\\[id=\"([\\\\w\\\\d-]+)\"\\\\].*?\"([^\"]*)')), Ee = function(e, t, n) {\n    for(var o, r = n.split(\",\"), s = 0, i = r.length; s < i; s++)(o = r[s]) && e.registerName(t, o);\n}, Ne = function(e, t) {\n    for(var n, o = (null !== (n = t.textContent) && void 0 !== n ? n : \"\").split(g), r = [], s = 0, i = o.length; s < i; s++){\n        var a = o[s].trim();\n        if (a) {\n            var c = a.match(be);\n            if (c) {\n                var l = 0 | parseInt(c[1], 10), u = c[2];\n                0 !== l && (Se(u, l), Ee(e, u, c[3]), e.getTag().insertRules(l, r)), r.length = 0;\n            } else r.push(a);\n        }\n    }\n};\nfunction Pe() {\n    return  true ? __webpack_require__.nc : 0;\n}\n_c5 = Pe;\nvar _e = function(e) {\n    var t = document.head, n = e || t, o = document.createElement(\"style\"), r = function(e) {\n        var t = Array.from(e.querySelectorAll(\"style[\".concat(f, \"]\")));\n        return t[t.length - 1];\n    }(n), s = void 0 !== r ? r.nextSibling : null;\n    o.setAttribute(f, m), o.setAttribute(y, v);\n    var i = Pe();\n    return i && o.setAttribute(\"nonce\", i), n.insertBefore(o, s), o;\n}, Ce = function() {\n    function e(e) {\n        this.element = _e(e), this.element.appendChild(document.createTextNode(\"\")), this.sheet = function(e) {\n            if (e.sheet) return e.sheet;\n            for(var t = document.styleSheets, n = 0, o = t.length; n < o; n++){\n                var r = t[n];\n                if (r.ownerNode === e) return r;\n            }\n            throw he(17);\n        }(this.element), this.length = 0;\n    }\n    return e.prototype.insertRule = function(e, t) {\n        try {\n            return this.sheet.insertRule(t, e), this.length++, !0;\n        } catch (e) {\n            return !1;\n        }\n    }, e.prototype.deleteRule = function(e) {\n        this.sheet.deleteRule(e), this.length--;\n    }, e.prototype.getRule = function(e) {\n        var t = this.sheet.cssRules[e];\n        return t && t.cssText ? t.cssText : \"\";\n    }, e;\n}(), Ie = function() {\n    function e(e) {\n        this.element = _e(e), this.nodes = this.element.childNodes, this.length = 0;\n    }\n    return e.prototype.insertRule = function(e, t) {\n        if (e <= this.length && e >= 0) {\n            var n = document.createTextNode(t);\n            return this.element.insertBefore(n, this.nodes[e] || null), this.length++, !0;\n        }\n        return !1;\n    }, e.prototype.deleteRule = function(e) {\n        this.element.removeChild(this.nodes[e]), this.length--;\n    }, e.prototype.getRule = function(e) {\n        return e < this.length ? this.nodes[e].textContent : \"\";\n    }, e;\n}(), Ae = function() {\n    function e(e) {\n        this.rules = [], this.length = 0;\n    }\n    return e.prototype.insertRule = function(e, t) {\n        return e <= this.length && (this.rules.splice(e, 0, t), this.length++, !0);\n    }, e.prototype.deleteRule = function(e) {\n        this.rules.splice(e, 1), this.length--;\n    }, e.prototype.getRule = function(e) {\n        return e < this.length ? this.rules[e] : \"\";\n    }, e;\n}(), Oe = S, De = {\n    isServer: !S,\n    useCSSOMInjection: !w\n}, Re = function() {\n    function e(e, n, o) {\n        void 0 === e && (e = C), void 0 === n && (n = {});\n        var r = this;\n        this.options = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, De), e), this.gs = n, this.names = new Map(o), this.server = !!e.isServer, !this.server && S && Oe && (Oe = !1, function(e) {\n            for(var t = document.querySelectorAll(we), n = 0, o = t.length; n < o; n++){\n                var r = t[n];\n                r && r.getAttribute(f) !== m && (Ne(e, r), r.parentNode && r.parentNode.removeChild(r));\n            }\n        }(this)), ue(this, function() {\n            return function(e) {\n                for(var t = e.getTag(), n = t.length, o = \"\", r = function(n) {\n                    var r = function(e) {\n                        return ye.get(e);\n                    }(n);\n                    if (void 0 === r) return \"continue\";\n                    var s = e.names.get(r), i = t.getGroup(n);\n                    if (void 0 === s || 0 === i.length) return \"continue\";\n                    var a = \"\".concat(f, \".g\").concat(n, '[id=\"').concat(r, '\"]'), c = \"\";\n                    void 0 !== s && s.forEach(function(e) {\n                        e.length > 0 && (c += \"\".concat(e, \",\"));\n                    }), o += \"\".concat(i).concat(a, '{content:\"').concat(c, '\"}').concat(g);\n                }, s = 0; s < n; s++)r(s);\n                return o;\n            }(r);\n        });\n    }\n    return e.registerId = function(e) {\n        return ge(e);\n    }, e.prototype.reconstructWithOptions = function(n, o) {\n        return void 0 === o && (o = !0), new e((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, this.options), n), this.gs, o && this.names || void 0);\n    }, e.prototype.allocateGSInstance = function(e) {\n        return this.gs[e] = (this.gs[e] || 0) + 1;\n    }, e.prototype.getTag = function() {\n        return this.tag || (this.tag = (e = function(e) {\n            var t = e.useCSSOMInjection, n = e.target;\n            return e.isServer ? new Ae(n) : t ? new Ce(n) : new Ie(n);\n        }(this.options), new fe(e)));\n        var e;\n    }, e.prototype.hasNameForId = function(e, t) {\n        return this.names.has(e) && this.names.get(e).has(t);\n    }, e.prototype.registerName = function(e, t) {\n        if (ge(e), this.names.has(e)) this.names.get(e).add(t);\n        else {\n            var n = new Set;\n            n.add(t), this.names.set(e, n);\n        }\n    }, e.prototype.insertRules = function(e, t, n) {\n        this.registerName(e, t), this.getTag().insertRules(ge(e), n);\n    }, e.prototype.clearNames = function(e) {\n        this.names.has(e) && this.names.get(e).clear();\n    }, e.prototype.clearRules = function(e) {\n        this.getTag().clearGroup(ge(e)), this.clearNames(e);\n    }, e.prototype.clearTag = function() {\n        this.tag = void 0;\n    }, e;\n}(), Te = /&/g, ke = /^\\s*\\/\\/.*$/gm;\nfunction je(e, t) {\n    return e.map(function(e) {\n        return \"rule\" === e.type && (e.value = \"\".concat(t, \" \").concat(e.value), e.value = e.value.replaceAll(\",\", \",\".concat(t, \" \")), e.props = e.props.map(function(e) {\n            return \"\".concat(t, \" \").concat(e);\n        })), Array.isArray(e.children) && \"@keyframes\" !== e.type && (e.children = je(e.children, t)), e;\n    });\n}\nfunction xe(e) {\n    var t, n, o, r = void 0 === e ? C : e, s = r.options, i = void 0 === s ? C : s, a = r.plugins, c = void 0 === a ? _ : a, l = function(e, o, r) {\n        return r.startsWith(n) && r.endsWith(n) && r.replaceAll(n, \"\").length > 0 ? \".\".concat(t) : e;\n    }, u = c.slice();\n    u.push(function(e) {\n        e.type === stylis__WEBPACK_IMPORTED_MODULE_5__.RULESET && e.value.includes(\"&\") && (e.props[0] = e.props[0].replace(Te, n).replace(o, l));\n    }), i.prefix && u.push(stylis__WEBPACK_IMPORTED_MODULE_6__.prefixer), u.push(stylis__WEBPACK_IMPORTED_MODULE_7__.stringify);\n    var p = function(e, r, s, a) {\n        void 0 === r && (r = \"\"), void 0 === s && (s = \"\"), void 0 === a && (a = \"&\"), t = a, n = r, o = new RegExp(\"\\\\\".concat(n, \"\\\\b\"), \"g\");\n        var c = e.replace(ke, \"\"), l = stylis__WEBPACK_IMPORTED_MODULE_8__.compile(s || r ? \"\".concat(s, \" \").concat(r, \" { \").concat(c, \" }\") : c);\n        i.namespace && (l = je(l, i.namespace));\n        var p = [];\n        return stylis__WEBPACK_IMPORTED_MODULE_7__.serialize(l, stylis__WEBPACK_IMPORTED_MODULE_6__.middleware(u.concat(stylis__WEBPACK_IMPORTED_MODULE_6__.rulesheet(function(e) {\n            return p.push(e);\n        })))), p;\n    };\n    return p.hash = c.length ? c.reduce(function(e, t) {\n        return t.name || he(15), M(e, t.name);\n    }, F).toString() : \"\", p;\n}\nvar Ve = new Re, Fe = xe(), Me = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createContext({\n    shouldForwardProp: void 0,\n    styleSheet: Ve,\n    stylis: Fe\n}), $e = Me.Consumer, ze = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createContext(void 0);\nfunction Be() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(Me);\n}\n_c6 = Be;\nfunction Le(e) {\n    var t = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(e.stylisPlugins), n = t[0], r = t[1], c = Be().styleSheet, l = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function() {\n        var t = c;\n        return e.sheet ? t = e.sheet : e.target && (t = t.reconstructWithOptions({\n            target: e.target\n        }, !1)), e.disableCSSOMInjection && (t = t.reconstructWithOptions({\n            useCSSOMInjection: !1\n        })), t;\n    }, [\n        e.disableCSSOMInjection,\n        e.sheet,\n        e.target,\n        c\n    ]), u = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function() {\n        return xe({\n            options: {\n                namespace: e.namespace,\n                prefix: e.enableVendorPrefixes\n            },\n            plugins: n\n        });\n    }, [\n        e.enableVendorPrefixes,\n        e.namespace,\n        n\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        shallowequal__WEBPACK_IMPORTED_MODULE_2___default()(n, e.stylisPlugins) || r(e.stylisPlugins);\n    }, [\n        e.stylisPlugins\n    ]);\n    var d = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function() {\n        return {\n            shouldForwardProp: e.shouldForwardProp,\n            styleSheet: l,\n            stylis: u\n        };\n    }, [\n        e.shouldForwardProp,\n        l,\n        u\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Me.Provider, {\n        value: d\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(ze.Provider, {\n        value: u\n    }, e.children));\n}\n_c7 = Le;\nvar Ge = function() {\n    function e(e, t) {\n        var n = this;\n        this.inject = function(e, t) {\n            void 0 === t && (t = Fe);\n            var o = n.name + t.hash;\n            e.hasNameForId(n.id, o) || e.insertRules(n.id, o, t(n.rules, o, \"@keyframes\"));\n        }, this.name = e, this.id = \"sc-keyframes-\".concat(e), this.rules = t, ue(this, function() {\n            throw he(12, String(n.name));\n        });\n    }\n    return e.prototype.getName = function(e) {\n        return void 0 === e && (e = Fe), this.name + e.hash;\n    }, e;\n}(), Ye = function(e) {\n    return e >= \"A\" && e <= \"Z\";\n};\nfunction We(e) {\n    for(var t = \"\", n = 0; n < e.length; n++){\n        var o = e[n];\n        if (1 === n && \"-\" === o && \"-\" === e[0]) return e;\n        Ye(o) ? t += \"-\" + o.toLowerCase() : t += o;\n    }\n    return t.startsWith(\"ms-\") ? \"-\" + t : t;\n}\n_c8 = We;\nvar qe = function(e) {\n    return null == e || !1 === e || \"\" === e;\n}, He = function(t) {\n    var n, o, r = [];\n    for(var s in t){\n        var i = t[s];\n        t.hasOwnProperty(s) && !qe(i) && (Array.isArray(i) && i.isCss || re(i) ? r.push(\"\".concat(We(s), \":\"), i, \";\") : ce(i) ? r.push.apply(r, (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__spreadArray)([\n            \"\".concat(s, \" {\")\n        ], He(i), !1), [\n            \"}\"\n        ], !1)) : r.push(\"\".concat(We(s), \": \").concat((n = s, null == (o = i) || \"boolean\" == typeof o || \"\" === o ? \"\" : \"number\" != typeof o || 0 === o || n in _emotion_unitless__WEBPACK_IMPORTED_MODULE_3__[\"default\"] || n.startsWith(\"--\") ? String(o).trim() : \"\".concat(o, \"px\")), \";\")));\n    }\n    return r;\n};\nfunction Ue(e, t, n, o) {\n    if (qe(e)) return [];\n    if (se(e)) return [\n        \".\".concat(e.styledComponentId)\n    ];\n    if (re(e)) {\n        if (!re(s = e) || s.prototype && s.prototype.isReactComponent || !t) return [\n            e\n        ];\n        var r = e(t);\n        return  false || \"object\" != typeof r || Array.isArray(r) || r instanceof Ge || ce(r) || null === r || console.error(\"\".concat(B(e), \" is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\")), Ue(r, t, n, o);\n    }\n    var s;\n    return e instanceof Ge ? n ? (e.inject(n, o), [\n        e.getName(o)\n    ]) : [\n        e\n    ] : ce(e) ? He(e) : Array.isArray(e) ? Array.prototype.concat.apply(_, e.map(function(e) {\n        return Ue(e, t, n, o);\n    })) : [\n        e.toString()\n    ];\n}\n_c9 = Ue;\nfunction Je(e) {\n    for(var t = 0; t < e.length; t += 1){\n        var n = e[t];\n        if (re(n) && !se(n)) return !1;\n    }\n    return !0;\n}\n_c10 = Je;\nvar Xe = $(v), Ze = function() {\n    function e(e, t, n) {\n        this.rules = e, this.staticRulesId = \"\", this.isStatic =  false && 0, this.componentId = t, this.baseHash = M(Xe, t), this.baseStyle = n, Re.registerId(t);\n    }\n    return e.prototype.generateAndInjectStyles = function(e, t, n) {\n        var o = this.baseStyle ? this.baseStyle.generateAndInjectStyles(e, t, n) : \"\";\n        if (this.isStatic && !n.hash) if (this.staticRulesId && t.hasNameForId(this.componentId, this.staticRulesId)) o = ie(o, this.staticRulesId);\n        else {\n            var r = ae(Ue(this.rules, e, t, n)), s = x(M(this.baseHash, r) >>> 0);\n            if (!t.hasNameForId(this.componentId, s)) {\n                var i = n(r, \".\".concat(s), void 0, this.componentId);\n                t.insertRules(this.componentId, s, i);\n            }\n            o = ie(o, s), this.staticRulesId = s;\n        }\n        else {\n            for(var a = M(this.baseHash, n.hash), c = \"\", l = 0; l < this.rules.length; l++){\n                var u = this.rules[l];\n                if (\"string\" == typeof u) c += u,  true && (a = M(a, u));\n                else if (u) {\n                    var p = ae(Ue(u, e, t, n));\n                    a = M(a, p + l), c += p;\n                }\n            }\n            if (c) {\n                var d = x(a >>> 0);\n                t.hasNameForId(this.componentId, d) || t.insertRules(this.componentId, d, n(c, \".\".concat(d), void 0, this.componentId)), o = ie(o, d);\n            }\n        }\n        return o;\n    }, e;\n}(), Ke = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createContext(void 0), Qe = Ke.Consumer;\nfunction et() {\n    var e = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(Ke);\n    if (!e) throw he(18);\n    return e;\n}\nfunction tt(e) {\n    _s();\n    var n = react__WEBPACK_IMPORTED_MODULE_1___default().useContext(Ke), r = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function() {\n        return function(e, n) {\n            if (!e) throw he(14);\n            if (re(e)) {\n                var o = e(n);\n                if ( true && (null === o || Array.isArray(o) || \"object\" != typeof o)) throw he(7);\n                return o;\n            }\n            if (Array.isArray(e) || \"object\" != typeof e) throw he(8);\n            return n ? (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, n), e) : e;\n        }(e.theme, n);\n    }, [\n        e.theme,\n        n\n    ]);\n    return e.children ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Ke.Provider, {\n        value: r\n    }, e.children) : null;\n}\n_s(tt, \"werOdKA4d5f8b/b73MfquM3ptOE=\");\nvar nt = {}, ot = new Set;\nfunction rt(e, r, s) {\n    var i = se(e), a = e, c = !L(e), p = r.attrs, d = void 0 === p ? _ : p, h = r.componentId, f = void 0 === h ? function(e, t) {\n        var n = \"string\" != typeof e ? \"sc\" : R(e);\n        nt[n] = (nt[n] || 0) + 1;\n        var o = \"\".concat(n, \"-\").concat(z(v + n + nt[n]));\n        return t ? \"\".concat(t, \"-\").concat(o) : o;\n    }(r.displayName, r.parentComponentId) : h, m = r.displayName, y = void 0 === m ? function(e) {\n        return L(e) ? \"styled.\".concat(e) : \"Styled(\".concat(B(e), \")\");\n    }(e) : m, g = r.displayName && r.componentId ? \"\".concat(R(r.displayName), \"-\").concat(r.componentId) : r.componentId || f, S = i && a.attrs ? a.attrs.concat(d).filter(Boolean) : d, w = r.shouldForwardProp;\n    if (i && a.shouldForwardProp) {\n        var b = a.shouldForwardProp;\n        if (r.shouldForwardProp) {\n            var E = r.shouldForwardProp;\n            w = function(e, t) {\n                return b(e, t) && E(e, t);\n            };\n        } else w = b;\n    }\n    var N = new Ze(s, g, i ? a.componentStyle : void 0);\n    function O(e, r) {\n        var _s = $RefreshSig$();\n        return _s(function(e, r, s) {\n            _s();\n            var i = e.attrs, a = e.componentStyle, c = e.defaultProps, p = e.foldedComponentIds, d = e.styledComponentId, h = e.target, f = react__WEBPACK_IMPORTED_MODULE_1___default().useContext(Ke), m = Be(), y = e.shouldForwardProp || m.shouldForwardProp;\n             true && (0,react__WEBPACK_IMPORTED_MODULE_1__.useDebugValue)(d);\n            var v = I(r, f, c) || C, g = function(e, n, o) {\n                for(var r, s = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, n), {\n                    className: void 0,\n                    theme: o\n                }), i = 0; i < e.length; i += 1){\n                    var a = re(r = e[i]) ? r(s) : r;\n                    for(var c in a)s[c] = \"className\" === c ? ie(s[c], a[c]) : \"style\" === c ? (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, s[c]), a[c]) : a[c];\n                }\n                return n.className && (s.className = ie(s.className, n.className)), s;\n            }(i, r, v), S = g.as || h, w = {};\n            for(var b in g)void 0 === g[b] || \"$\" === b[0] || \"as\" === b || \"theme\" === b && g.theme === v || (\"forwardedAs\" === b ? w.as = g.forwardedAs : y && !y(b, S) || (w[b] = g[b], y || \"development\" !== \"development\" || (0,_emotion_is_prop_valid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(b) || ot.has(b) || !A.has(S) || (ot.add(b), console.warn('styled-components: it looks like an unknown prop \"'.concat(b, '\" is being sent through to the DOM, which will likely trigger a React console error. If you would like automatic filtering of unknown props, you can opt-into that behavior via `<StyleSheetManager shouldForwardProp={...}>` (connect an API like `@emotion/is-prop-valid`) or consider using transient props (`$` prefix for automatic filtering.)')))));\n            var E = function(e, t) {\n                var n = Be(), o = e.generateAndInjectStyles(t, n.styleSheet, n.stylis);\n                return  true && (0,react__WEBPACK_IMPORTED_MODULE_1__.useDebugValue)(o), o;\n            }(a, g);\n             true && e.warnTooManyClasses && e.warnTooManyClasses(E);\n            var N = ie(p, d);\n            return E && (N += \" \" + E), g.className && (N += \" \" + g.className), w[L(S) && !A.has(S) ? \"class\" : \"className\"] = N, w.ref = s, /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(S, w);\n        }, \"0XcqZxOn07XYHtCs/oJRawzYapc=\")(D, e, r);\n    }\n    O.displayName = y;\n    var D = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef(O);\n    return D.attrs = S, D.componentStyle = N, D.displayName = y, D.shouldForwardProp = w, D.foldedComponentIds = i ? ie(a.foldedComponentIds, a.styledComponentId) : \"\", D.styledComponentId = g, D.target = i ? a.target : e, Object.defineProperty(D, \"defaultProps\", {\n        get: function() {\n            return this._foldedDefaultProps;\n        },\n        set: function(e) {\n            this._foldedDefaultProps = i ? function(e) {\n                for(var t = [], n = 1; n < arguments.length; n++)t[n - 1] = arguments[n];\n                for(var o = 0, r = t; o < r.length; o++)le(e, r[o], !0);\n                return e;\n            }({}, a.defaultProps, e) : e;\n        }\n    }),  true && (P(y, g), D.warnTooManyClasses = function(e, t) {\n        var n = {}, o = !1;\n        return function(r) {\n            if (!o && (n[r] = !0, Object.keys(n).length >= 200)) {\n                var s = t ? ' with the id of \"'.concat(t, '\"') : \"\";\n                console.warn(\"Over \".concat(200, \" classes were generated for component \").concat(e).concat(s, \".\\n\") + \"Consider using the attrs method, together with a style object for frequently changed styles.\\nExample:\\n  const Component = styled.div.attrs(props => ({\\n    style: {\\n      background: props.background,\\n    },\\n  }))`width: 100%;`\\n\\n  <Component />\"), o = !0, n = {};\n            }\n        };\n    }(y, g)), ue(D, function() {\n        return \".\".concat(D.styledComponentId);\n    }), c && oe(D, e, {\n        attrs: !0,\n        componentStyle: !0,\n        displayName: !0,\n        foldedComponentIds: !0,\n        shouldForwardProp: !0,\n        styledComponentId: !0,\n        target: !0\n    }), D;\n}\nfunction st(e, t) {\n    for(var n = [\n        e[0]\n    ], o = 0, r = t.length; o < r; o += 1)n.push(t[o], e[o + 1]);\n    return n;\n}\nvar it = function(e) {\n    return Object.assign(e, {\n        isCss: !0\n    });\n};\nfunction at(t) {\n    for(var n = [], o = 1; o < arguments.length; o++)n[o - 1] = arguments[o];\n    if (re(t) || ce(t)) return it(Ue(st(_, (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__spreadArray)([\n        t\n    ], n, !0))));\n    var r = t;\n    return 0 === n.length && 1 === r.length && \"string\" == typeof r[0] ? Ue(r) : it(Ue(st(r, n)));\n}\nfunction ct(n, o, r) {\n    if (void 0 === r && (r = C), !o) throw he(1, o);\n    var s = function(t) {\n        for(var s = [], i = 1; i < arguments.length; i++)s[i - 1] = arguments[i];\n        return n(o, r, at.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__spreadArray)([\n            t\n        ], s, !1)));\n    };\n    return s.attrs = function(e) {\n        return ct(n, o, (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, r), {\n            attrs: Array.prototype.concat(r.attrs, e).filter(Boolean)\n        }));\n    }, s.withConfig = function(e) {\n        return ct(n, o, (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, r), e));\n    }, s;\n}\nvar lt = function(e) {\n    return ct(rt, e);\n}, ut = lt;\nA.forEach(function(e) {\n    ut[e] = lt(e);\n});\nvar pt = function() {\n    function e(e, t) {\n        this.rules = e, this.componentId = t, this.isStatic = Je(e), Re.registerId(this.componentId + 1);\n    }\n    return e.prototype.createStyles = function(e, t, n, o) {\n        var r = o(ae(Ue(this.rules, t, n, o)), \"\"), s = this.componentId + e;\n        n.insertRules(s, s, r);\n    }, e.prototype.removeStyles = function(e, t) {\n        t.clearRules(this.componentId + e);\n    }, e.prototype.renderStyles = function(e, t, n, o) {\n        e > 2 && Re.registerId(this.componentId + e), this.removeStyles(e, n), this.createStyles(e, t, n, o);\n    }, e;\n}();\nfunction dt(n) {\n    var _s = $RefreshSig$();\n    for(var r = [], s = 1; s < arguments.length; s++)r[s - 1] = arguments[s];\n    var i = at.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__spreadArray)([\n        n\n    ], r, !1)), a = \"sc-global-\".concat(z(JSON.stringify(i))), c = new pt(i, a);\n     true && P(a);\n    var l = function(e) {\n        _s();\n        var t = Be(), n = react__WEBPACK_IMPORTED_MODULE_1___default().useContext(Ke), r = react__WEBPACK_IMPORTED_MODULE_1___default().useRef(t.styleSheet.allocateGSInstance(a)).current;\n        return  true && react__WEBPACK_IMPORTED_MODULE_1___default().Children.count(e.children) && console.warn(\"The global style component \".concat(a, \" was given child JSX. createGlobalStyle does not render children.\")),  true && i.some(function(e) {\n            return \"string\" == typeof e && -1 !== e.indexOf(\"@import\");\n        }) && console.warn(\"Please do not use @import CSS syntax in createGlobalStyle at this time, as the CSSOM APIs we use in production do not handle it well. Instead, we recommend using a library such as react-helmet to inject a typical <link> meta tag to the stylesheet, or simply embedding it manually in your index.html <head> section for a simpler app.\"), t.styleSheet.server && u(r, e, t.styleSheet, n, t.stylis), react__WEBPACK_IMPORTED_MODULE_1___default().useLayoutEffect(function() {\n            if (!t.styleSheet.server) return u(r, e, t.styleSheet, n, t.stylis), function() {\n                return c.removeStyles(r, t.styleSheet);\n            };\n        }, [\n            r,\n            e,\n            t.styleSheet,\n            n,\n            t.stylis\n        ]), null;\n    };\n    _s(l, \"2UHINdfzx1jpe1GPXKNI8tENfcU=\");\n    function u(e, n, o, r, s) {\n        if (c.isStatic) c.renderStyles(e, b, o, s);\n        else {\n            var i = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, n), {\n                theme: I(n, r, l.defaultProps)\n            });\n            c.renderStyles(e, i, o, s);\n        }\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().memo(l);\n}\nfunction ht(t) {\n    for(var n = [], o = 1; o < arguments.length; o++)n[o - 1] = arguments[o];\n     true && \"undefined\" != typeof navigator && \"ReactNative\" === navigator.product && console.warn(\"`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.\");\n    var r = ae(at.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__spreadArray)([\n        t\n    ], n, !1))), s = z(r);\n    return new Ge(s, r);\n}\nfunction ft(e) {\n    var _s = $RefreshSig$();\n    var n = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef(_s(function(n, r) {\n        _s();\n        var s = I(n, react__WEBPACK_IMPORTED_MODULE_1___default().useContext(Ke), e.defaultProps);\n        return  true && void 0 === s && console.warn('[withTheme] You are not using a ThemeProvider nor passing a theme prop or a theme in defaultProps in component class \"'.concat(B(e), '\"')), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(e, (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, n, {\n            theme: s,\n            ref: r\n        }));\n    }, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\"));\n    return n.displayName = \"WithTheme(\".concat(B(e), \")\"), oe(n, e);\n}\nvar mt = function() {\n    function e() {\n        var e = this;\n        this._emitSheetCSS = function() {\n            var t = e.instance.toString(), n = Pe(), o = ae([\n                n && 'nonce=\"'.concat(n, '\"'),\n                \"\".concat(f, '=\"true\"'),\n                \"\".concat(y, '=\"').concat(v, '\"')\n            ].filter(Boolean), \" \");\n            return \"<style \".concat(o, \">\").concat(t, \"</style>\");\n        }, this.getStyleTags = function() {\n            if (e.sealed) throw he(2);\n            return e._emitSheetCSS();\n        }, this.getStyleElement = function() {\n            var n;\n            if (e.sealed) throw he(2);\n            var r = ((n = {})[f] = \"\", n[y] = v, n.dangerouslySetInnerHTML = {\n                __html: e.instance.toString()\n            }, n), s = Pe();\n            return s && (r.nonce = s), [\n                /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"style\", (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, r, {\n                    key: \"sc-0-0\"\n                }))\n            ];\n        }, this.seal = function() {\n            e.sealed = !0;\n        }, this.instance = new Re({\n            isServer: !0\n        }), this.sealed = !1;\n    }\n    return e.prototype.collectStyles = function(e) {\n        if (this.sealed) throw he(2);\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Le, {\n            sheet: this.instance\n        }, e);\n    }, e.prototype.interleaveWithNodeStream = function(e) {\n        throw he(3);\n    }, e;\n}(), yt = {\n    StyleSheet: Re,\n    mainSheet: Ve\n};\n true && \"undefined\" != typeof navigator && \"ReactNative\" === navigator.product && console.warn(\"It looks like you've imported 'styled-components' on React Native.\\nPerhaps you're looking to import 'styled-components/native'?\\nRead more about this at https://www.styled-components.com/docs/basics#react-native\");\nvar vt = \"__sc-\".concat(f, \"__\");\n true && (window[vt] || (window[vt] = 0), 1 === window[vt] && console.warn(\"It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\\n\\nSee https://s-c.sh/2BAXzed for more info.\"), window[vt] += 1);\n //# sourceMappingURL=styled-components.browser.esm.js.map\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10;\n$RefreshReg$(_c, \"I\");\n$RefreshReg$(_c1, \"R\");\n$RefreshReg$(_c2, \"B\");\n$RefreshReg$(_c3, \"L\");\n$RefreshReg$(_c4, \"X\");\n$RefreshReg$(_c5, \"Pe\");\n$RefreshReg$(_c6, \"Be\");\n$RefreshReg$(_c7, \"Le\");\n$RefreshReg$(_c8, \"We\");\n$RefreshReg$(_c9, \"Ue\");\n$RefreshReg$(_c10, \"Je\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtY29tcG9uZW50cy9kaXN0L3N0eWxlZC1jb21wb25lbnRzLmJyb3dzZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUFzQztBQUFrSTtBQUE0QjtBQUF5QjtBQUFpQztBQUFBLElBQUl1QixJQUFFLGVBQWEsT0FBT0MsT0FBT0EsSUFBRSxLQUFLLE1BQUlBLE9BQU9BLENBQUNDLEdBQUcsSUFBR0QsQ0FBQUEsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxpQkFBaUIsSUFBRUYsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDRSxPQUFPLEtBQUcsZUFBY0MsSUFBRSxVQUFTQyxJQUFFLHVCQUFzQkMsSUFBRSxTQUFRQyxJQUFFLGFBQVlDLElBQUUsS0FBYSxJQUFlLGlCQUFnQkMsUUFBT0MsSUFBRUMsUUFBUSxhQUFXLE9BQU9DLG9CQUFrQkEsb0JBQWtCLGVBQWEsT0FBT1osT0FBT0EsSUFBRSxLQUFLLE1BQUlBLE9BQU9BLENBQUNDLEdBQUcsSUFBRSxLQUFLLE1BQUlELE9BQU9BLENBQUNDLEdBQUcsQ0FBQ1ksMkJBQTJCLElBQUUsT0FBS2IsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDWSwyQkFBMkIsR0FBQyxZQUFVYixPQUFPQSxDQUFDQyxHQUFHLENBQUNZLDJCQUEyQixJQUFFYixPQUFPQSxDQUFDQyxHQUFHLENBQUNZLDJCQUEyQixHQUFDLGVBQWEsT0FBT2IsT0FBT0EsSUFBRSxLQUFLLE1BQUlBLE9BQU9BLENBQUNDLEdBQUcsSUFBRSxLQUFLLE1BQUlELE9BQU9BLENBQUNDLEdBQUcsQ0FBQ1csaUJBQWlCLElBQUUsT0FBS1osT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDVyxpQkFBaUIsR0FBQyxZQUFVWixPQUFPQSxDQUFDQyxHQUFHLENBQUNXLGlCQUFpQixJQUFFWixPQUFPQSxDQUFDQyxHQUFHLENBQUNXLGlCQUFpQixHQUFDLGlC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QUFDLEdBQUUsSUFBSSxDQUFDRixRQUFRLEdBQUMsSUFBSTlILEdBQUc7WUFBQ0YsVUFBUyxDQUFDO1FBQUMsSUFBRyxJQUFJLENBQUNrSSxNQUFNLEdBQUMsQ0FBQztJQUFDO0lBQUMsT0FBTzNVLEVBQUVzRyxTQUFTLENBQUM0TyxhQUFhLEdBQUMsU0FBU2xWLENBQUM7UUFBRSxJQUFHLElBQUksQ0FBQzJVLE1BQU0sRUFBQyxNQUFNaE0sR0FBRztRQUFHLHFCQUFPdkksMERBQWUsQ0FBQzJQLElBQUc7WUFBQ3BFLE9BQU0sSUFBSSxDQUFDOEksUUFBUTtRQUFBLEdBQUV6VTtJQUFFLEdBQUVBLEVBQUVzRyxTQUFTLENBQUM2Tyx3QkFBd0IsR0FBQyxTQUFTblYsQ0FBQztRQUFFLE1BQU0ySSxHQUFHO0lBQUUsR0FBRTNJO0FBQUMsS0FBSW9WLEtBQUc7SUFBQ0MsWUFBVzFJO0lBQUcySSxXQUFVbEc7QUFBRTtBQUFFLEtBQXgzMkIsSUFBNjUyQixlQUFhLE9BQU9nRixhQUFXLGtCQUFnQkEsVUFBVUMsT0FBTyxJQUFFMVIsUUFBUVEsSUFBSSxDQUFDO0FBQXdOLElBQUlvUyxLQUFHLFFBQVE3UyxNQUFNLENBQUNwQixHQUFFO0FBQU0sS0FBaUYsSUFBZ0JVLENBQUFBLE1BQU0sQ0FBQ3VULEdBQUcsSUFBR3ZULENBQUFBLE1BQU0sQ0FBQ3VULEdBQUcsR0FBQyxJQUFHLE1BQUl2VCxNQUFNLENBQUN1VCxHQUFHLElBQUU1UyxRQUFRUSxJQUFJLENBQUMsNlRBQTRUbkIsTUFBTSxDQUFDdVQsR0FBRyxJQUFFO0FBQXlVLENBQzVnNUIseURBQXlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtY29tcG9uZW50cy9kaXN0L3N0eWxlZC1jb21wb25lbnRzLmJyb3dzZXIuZXNtLmpzP2VlZTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0e19fc3ByZWFkQXJyYXkgYXMgZSxfX2Fzc2lnbiBhcyB0fWZyb21cInRzbGliXCI7aW1wb3J0IG4gZnJvbVwiQGVtb3Rpb24vaXMtcHJvcC12YWxpZFwiO2ltcG9ydCBvLHt1c2VSZWYgYXMgcix1c2VTdGF0ZSBhcyBzLHVzZU1lbW8gYXMgaSx1c2VFZmZlY3QgYXMgYSx1c2VDb250ZXh0IGFzIGMsdXNlRGVidWdWYWx1ZSBhcyBsLGNyZWF0ZUVsZW1lbnQgYXMgdX1mcm9tXCJyZWFjdFwiO2ltcG9ydCBwIGZyb21cInNoYWxsb3dlcXVhbFwiO2ltcG9ydCphcyBkIGZyb21cInN0eWxpc1wiO2ltcG9ydCBoIGZyb21cIkBlbW90aW9uL3VuaXRsZXNzXCI7dmFyIGY9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHByb2Nlc3MmJnZvaWQgMCE9PXByb2Nlc3MuZW52JiYocHJvY2Vzcy5lbnYuUkVBQ1RfQVBQX1NDX0FUVFJ8fHByb2Nlc3MuZW52LlNDX0FUVFIpfHxcImRhdGEtc3R5bGVkXCIsbT1cImFjdGl2ZVwiLHk9XCJkYXRhLXN0eWxlZC12ZXJzaW9uXCIsdj1cIjYuMS44XCIsZz1cIi8qIXNjKi9cXG5cIixTPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJlwiSFRNTEVsZW1lbnRcImluIHdpbmRvdyx3PUJvb2xlYW4oXCJib29sZWFuXCI9PXR5cGVvZiBTQ19ESVNBQkxFX1NQRUVEWT9TQ19ESVNBQkxFX1NQRUVEWTpcInVuZGVmaW5lZFwiIT10eXBlb2YgcHJvY2VzcyYmdm9pZCAwIT09cHJvY2Vzcy5lbnYmJnZvaWQgMCE9PXByb2Nlc3MuZW52LlJFQUNUX0FQUF9TQ19ESVNBQkxFX1NQRUVEWSYmXCJcIiE9PXByb2Nlc3MuZW52LlJFQUNUX0FQUF9TQ19ESVNBQkxFX1NQRUVEWT9cImZhbHNlXCIhPT1wcm9jZXNzLmVudi5SRUFDVF9BUFBfU0NfRElTQUJMRV9TUEVFRFkmJnByb2Nlc3MuZW52LlJFQUNUX0FQUF9TQ19ESVNBQkxFX1NQRUVEWTpcInVuZGVmaW5lZFwiIT10eXBlb2YgcHJvY2VzcyYmdm9pZCAwIT09cHJvY2Vzcy5lbnYmJnZvaWQgMCE9PXByb2Nlc3MuZW52LlNDX0RJU0FCTEVfU1BFRURZJiZcIlwiIT09cHJvY2Vzcy5lbnYuU0NfRElTQUJMRV9TUEVFRFk/XCJmYWxzZVwiIT09cHJvY2Vzcy5lbnYuU0NfRElTQUJMRV9TUEVFRFkmJnByb2Nlc3MuZW52LlNDX0RJU0FCTEVfU1BFRURZOlwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYpLGI9e30sRT0vaW52YWxpZCBob29rIGNhbGwvaSxOPW5ldyBTZXQsUD1mdW5jdGlvbih0LG4pe2lmKFwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYpe3ZhciBvPW4/JyB3aXRoIHRoZSBpZCBvZiBcIicuY29uY2F0KG4sJ1wiJyk6XCJcIixzPVwiVGhlIGNvbXBvbmVudCBcIi5jb25jYXQodCkuY29uY2F0KG8sXCIgaGFzIGJlZW4gY3JlYXRlZCBkeW5hbWljYWxseS5cXG5cIikrXCJZb3UgbWF5IHNlZSB0aGlzIHdhcm5pbmcgYmVjYXVzZSB5b3UndmUgY2FsbGVkIHN0eWxlZCBpbnNpZGUgYW5vdGhlciBjb21wb25lbnQuXFxuVG8gcmVzb2x2ZSB0aGlzIG9ubHkgY3JlYXRlIG5ldyBTdHlsZWRDb21wb25lbnRzIG91dHNpZGUgb2YgYW55IHJlbmRlciBtZXRob2QgYW5kIGZ1bmN0aW9uIGNvbXBvbmVudC5cIixpPWNvbnNvbGUuZXJyb3I7dHJ5e3ZhciBhPSEwO2NvbnNvbGUuZXJyb3I9ZnVuY3Rpb24odCl7Zm9yKHZhciBuPVtdLG89MTtvPGFyZ3VtZW50cy5sZW5ndGg7bysrKW5bby0xXT1hcmd1bWVudHNbb107RS50ZXN0KHQpPyhhPSExLE4uZGVsZXRlKHMpKTppLmFwcGx5KHZvaWQgMCxlKFt0XSxuLCExKSl9LHIoKSxhJiYhTi5oYXMocykmJihjb25zb2xlLndhcm4ocyksTi5hZGQocykpfWNhdGNoKGUpe0UudGVzdChlLm1lc3NhZ2UpJiZOLmRlbGV0ZShzKX1maW5hbGx5e2NvbnNvbGUuZXJyb3I9aX19fSxfPU9iamVjdC5mcmVlemUoW10pLEM9T2JqZWN0LmZyZWV6ZSh7fSk7ZnVuY3Rpb24gSShlLHQsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPUMpLGUudGhlbWUhPT1uLnRoZW1lJiZlLnRoZW1lfHx0fHxuLnRoZW1lfXZhciBBPW5ldyBTZXQoW1wiYVwiLFwiYWJiclwiLFwiYWRkcmVzc1wiLFwiYXJlYVwiLFwiYXJ0aWNsZVwiLFwiYXNpZGVcIixcImF1ZGlvXCIsXCJiXCIsXCJiYXNlXCIsXCJiZGlcIixcImJkb1wiLFwiYmlnXCIsXCJibG9ja3F1b3RlXCIsXCJib2R5XCIsXCJiclwiLFwiYnV0dG9uXCIsXCJjYW52YXNcIixcImNhcHRpb25cIixcImNpdGVcIixcImNvZGVcIixcImNvbFwiLFwiY29sZ3JvdXBcIixcImRhdGFcIixcImRhdGFsaXN0XCIsXCJkZFwiLFwiZGVsXCIsXCJkZXRhaWxzXCIsXCJkZm5cIixcImRpYWxvZ1wiLFwiZGl2XCIsXCJkbFwiLFwiZHRcIixcImVtXCIsXCJlbWJlZFwiLFwiZmllbGRzZXRcIixcImZpZ2NhcHRpb25cIixcImZpZ3VyZVwiLFwiZm9vdGVyXCIsXCJmb3JtXCIsXCJoMVwiLFwiaDJcIixcImgzXCIsXCJoNFwiLFwiaDVcIixcImg2XCIsXCJoZWFkZXJcIixcImhncm91cFwiLFwiaHJcIixcImh0bWxcIixcImlcIixcImlmcmFtZVwiLFwiaW1nXCIsXCJpbnB1dFwiLFwiaW5zXCIsXCJrYmRcIixcImtleWdlblwiLFwibGFiZWxcIixcImxlZ2VuZFwiLFwibGlcIixcImxpbmtcIixcIm1haW5cIixcIm1hcFwiLFwibWFya1wiLFwibWVudVwiLFwibWVudWl0ZW1cIixcIm1ldGFcIixcIm1ldGVyXCIsXCJuYXZcIixcIm5vc2NyaXB0XCIsXCJvYmplY3RcIixcIm9sXCIsXCJvcHRncm91cFwiLFwib3B0aW9uXCIsXCJvdXRwdXRcIixcInBcIixcInBhcmFtXCIsXCJwaWN0dXJlXCIsXCJwcmVcIixcInByb2dyZXNzXCIsXCJxXCIsXCJycFwiLFwicnRcIixcInJ1YnlcIixcInNcIixcInNhbXBcIixcInNjcmlwdFwiLFwic2VjdGlvblwiLFwic2VsZWN0XCIsXCJzbWFsbFwiLFwic291cmNlXCIsXCJzcGFuXCIsXCJzdHJvbmdcIixcInN0eWxlXCIsXCJzdWJcIixcInN1bW1hcnlcIixcInN1cFwiLFwidGFibGVcIixcInRib2R5XCIsXCJ0ZFwiLFwidGV4dGFyZWFcIixcInRmb290XCIsXCJ0aFwiLFwidGhlYWRcIixcInRpbWVcIixcInRyXCIsXCJ0cmFja1wiLFwidVwiLFwidWxcIixcInVzZVwiLFwidmFyXCIsXCJ2aWRlb1wiLFwid2JyXCIsXCJjaXJjbGVcIixcImNsaXBQYXRoXCIsXCJkZWZzXCIsXCJlbGxpcHNlXCIsXCJmb3JlaWduT2JqZWN0XCIsXCJnXCIsXCJpbWFnZVwiLFwibGluZVwiLFwibGluZWFyR3JhZGllbnRcIixcIm1hcmtlclwiLFwibWFza1wiLFwicGF0aFwiLFwicGF0dGVyblwiLFwicG9seWdvblwiLFwicG9seWxpbmVcIixcInJhZGlhbEdyYWRpZW50XCIsXCJyZWN0XCIsXCJzdG9wXCIsXCJzdmdcIixcInRleHRcIixcInRzcGFuXCJdKSxPPS9bIVwiIyQlJicoKSorLC4vOjs8PT4/QFtcXFxcXFxdXmB7fH1+LV0rL2csRD0vKF4tfC0kKS9nO2Z1bmN0aW9uIFIoZSl7cmV0dXJuIGUucmVwbGFjZShPLFwiLVwiKS5yZXBsYWNlKEQsXCJcIil9dmFyIFQ9LyhhKShkKS9naSxrPTUyLGo9ZnVuY3Rpb24oZSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZSsoZT4yNT8zOTo5NykpfTtmdW5jdGlvbiB4KGUpe3ZhciB0LG49XCJcIjtmb3IodD1NYXRoLmFicyhlKTt0Pms7dD10L2t8MCluPWoodCVrKStuO3JldHVybihqKHQlaykrbikucmVwbGFjZShULFwiJDEtJDJcIil9dmFyIFYsRj01MzgxLE09ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49dC5sZW5ndGg7bjspZT0zMyplXnQuY2hhckNvZGVBdCgtLW4pO3JldHVybiBlfSwkPWZ1bmN0aW9uKGUpe3JldHVybiBNKEYsZSl9O2Z1bmN0aW9uIHooZSl7cmV0dXJuIHgoJChlKT4+PjApfWZ1bmN0aW9uIEIoZSl7cmV0dXJuXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmXCJzdHJpbmdcIj09dHlwZW9mIGUmJmV8fGUuZGlzcGxheU5hbWV8fGUubmFtZXx8XCJDb21wb25lbnRcIn1mdW5jdGlvbiBMKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlJiYoXCJwcm9kdWN0aW9uXCI9PT1wcm9jZXNzLmVudi5OT0RFX0VOVnx8ZS5jaGFyQXQoMCk9PT1lLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpKX12YXIgRz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5mb3IsWT1HP1N5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpOjYwMTE1LFc9Rz9TeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIik6NjAxMTIscT17Y2hpbGRDb250ZXh0VHlwZXM6ITAsY29udGV4dFR5cGU6ITAsY29udGV4dFR5cGVzOiEwLGRlZmF1bHRQcm9wczohMCxkaXNwbGF5TmFtZTohMCxnZXREZWZhdWx0UHJvcHM6ITAsZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yOiEwLGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczohMCxtaXhpbnM6ITAscHJvcFR5cGVzOiEwLHR5cGU6ITB9LEg9e25hbWU6ITAsbGVuZ3RoOiEwLHByb3RvdHlwZTohMCxjYWxsZXI6ITAsY2FsbGVlOiEwLGFyZ3VtZW50czohMCxhcml0eTohMH0sVT17JCR0eXBlb2Y6ITAsY29tcGFyZTohMCxkZWZhdWx0UHJvcHM6ITAsZGlzcGxheU5hbWU6ITAscHJvcFR5cGVzOiEwLHR5cGU6ITB9LEo9KChWPXt9KVtXXT17JCR0eXBlb2Y6ITAscmVuZGVyOiEwLGRlZmF1bHRQcm9wczohMCxkaXNwbGF5TmFtZTohMCxwcm9wVHlwZXM6ITB9LFZbWV09VSxWKTtmdW5jdGlvbiBYKGUpe3JldHVybihcInR5cGVcImluKHQ9ZSkmJnQudHlwZS4kJHR5cGVvZik9PT1ZP1U6XCIkJHR5cGVvZlwiaW4gZT9KW2UuJCR0eXBlb2ZdOnE7dmFyIHR9dmFyIFo9T2JqZWN0LmRlZmluZVByb3BlcnR5LEs9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsUT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLGVlPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsdGU9T2JqZWN0LmdldFByb3RvdHlwZU9mLG5lPU9iamVjdC5wcm90b3R5cGU7ZnVuY3Rpb24gb2UoZSx0LG4pe2lmKFwic3RyaW5nXCIhPXR5cGVvZiB0KXtpZihuZSl7dmFyIG89dGUodCk7byYmbyE9PW5lJiZvZShlLG8sbil9dmFyIHI9Syh0KTtRJiYocj1yLmNvbmNhdChRKHQpKSk7Zm9yKHZhciBzPVgoZSksaT1YKHQpLGE9MDthPHIubGVuZ3RoOysrYSl7dmFyIGM9clthXTtpZighKGMgaW4gSHx8biYmbltjXXx8aSYmYyBpbiBpfHxzJiZjIGluIHMpKXt2YXIgbD1lZSh0LGMpO3RyeXtaKGUsYyxsKX1jYXRjaChlKXt9fX19cmV0dXJuIGV9ZnVuY3Rpb24gcmUoZSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZX1mdW5jdGlvbiBzZShlKXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgZSYmXCJzdHlsZWRDb21wb25lbnRJZFwiaW4gZX1mdW5jdGlvbiBpZShlLHQpe3JldHVybiBlJiZ0P1wiXCIuY29uY2F0KGUsXCIgXCIpLmNvbmNhdCh0KTplfHx0fHxcIlwifWZ1bmN0aW9uIGFlKGUsdCl7aWYoMD09PWUubGVuZ3RoKXJldHVyblwiXCI7Zm9yKHZhciBuPWVbMF0sbz0xO288ZS5sZW5ndGg7bysrKW4rPXQ/dCtlW29dOmVbb107cmV0dXJuIG59ZnVuY3Rpb24gY2UoZSl7cmV0dXJuIG51bGwhPT1lJiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZS5jb25zdHJ1Y3Rvci5uYW1lPT09T2JqZWN0Lm5hbWUmJiEoXCJwcm9wc1wiaW4gZSYmZS4kJHR5cGVvZil9ZnVuY3Rpb24gbGUoZSx0LG4pe2lmKHZvaWQgMD09PW4mJihuPSExKSwhbiYmIWNlKGUpJiYhQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gdDtpZihBcnJheS5pc0FycmF5KHQpKWZvcih2YXIgbz0wO288dC5sZW5ndGg7bysrKWVbb109bGUoZVtvXSx0W29dKTtlbHNlIGlmKGNlKHQpKWZvcih2YXIgbyBpbiB0KWVbb109bGUoZVtvXSx0W29dKTtyZXR1cm4gZX1mdW5jdGlvbiB1ZShlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwidG9TdHJpbmdcIix7dmFsdWU6dH0pfXZhciBwZT1cInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WP3sxOlwiQ2Fubm90IGNyZWF0ZSBzdHlsZWQtY29tcG9uZW50IGZvciBjb21wb25lbnQ6ICVzLlxcblxcblwiLDI6XCJDYW4ndCBjb2xsZWN0IHN0eWxlcyBvbmNlIHlvdSd2ZSBjb25zdW1lZCBhIGBTZXJ2ZXJTdHlsZVNoZWV0YCdzIHN0eWxlcyEgYFNlcnZlclN0eWxlU2hlZXRgIGlzIGEgb25lIG9mZiBpbnN0YW5jZSBmb3IgZWFjaCBzZXJ2ZXItc2lkZSByZW5kZXIgY3ljbGUuXFxuXFxuLSBBcmUgeW91IHRyeWluZyB0byByZXVzZSBpdCBhY3Jvc3MgcmVuZGVycz9cXG4tIEFyZSB5b3UgYWNjaWRlbnRhbGx5IGNhbGxpbmcgY29sbGVjdFN0eWxlcyB0d2ljZT9cXG5cXG5cIiwzOlwiU3RyZWFtaW5nIFNTUiBpcyBvbmx5IHN1cHBvcnRlZCBpbiBhIE5vZGUuanMgZW52aXJvbm1lbnQ7IFBsZWFzZSBkbyBub3QgdHJ5IHRvIGNhbGwgdGhpcyBtZXRob2QgaW4gdGhlIGJyb3dzZXIuXFxuXFxuXCIsNDpcIlRoZSBgU3R5bGVTaGVldE1hbmFnZXJgIGV4cGVjdHMgYSB2YWxpZCB0YXJnZXQgb3Igc2hlZXQgcHJvcCFcXG5cXG4tIERvZXMgdGhpcyBlcnJvciBvY2N1ciBvbiB0aGUgY2xpZW50IGFuZCBpcyB5b3VyIHRhcmdldCBmYWxzeT9cXG4tIERvZXMgdGhpcyBlcnJvciBvY2N1ciBvbiB0aGUgc2VydmVyIGFuZCBpcyB0aGUgc2hlZXQgZmFsc3k/XFxuXFxuXCIsNTpcIlRoZSBjbG9uZSBtZXRob2QgY2Fubm90IGJlIHVzZWQgb24gdGhlIGNsaWVudCFcXG5cXG4tIEFyZSB5b3UgcnVubmluZyBpbiBhIGNsaWVudC1saWtlIGVudmlyb25tZW50IG9uIHRoZSBzZXJ2ZXI/XFxuLSBBcmUgeW91IHRyeWluZyB0byBydW4gU1NSIG9uIHRoZSBjbGllbnQ/XFxuXFxuXCIsNjpcIlRyeWluZyB0byBpbnNlcnQgYSBuZXcgc3R5bGUgdGFnLCBidXQgdGhlIGdpdmVuIE5vZGUgaXMgdW5tb3VudGVkIVxcblxcbi0gQXJlIHlvdSB1c2luZyBhIGN1c3RvbSB0YXJnZXQgdGhhdCBpc24ndCBtb3VudGVkP1xcbi0gRG9lcyB5b3VyIGRvY3VtZW50IG5vdCBoYXZlIGEgdmFsaWQgaGVhZCBlbGVtZW50P1xcbi0gSGF2ZSB5b3UgYWNjaWRlbnRhbGx5IHJlbW92ZWQgYSBzdHlsZSB0YWcgbWFudWFsbHk/XFxuXFxuXCIsNzonVGhlbWVQcm92aWRlcjogUGxlYXNlIHJldHVybiBhbiBvYmplY3QgZnJvbSB5b3VyIFwidGhlbWVcIiBwcm9wIGZ1bmN0aW9uLCBlLmcuXFxuXFxuYGBganNcXG50aGVtZT17KCkgPT4gKHt9KX1cXG5gYGBcXG5cXG4nLDg6J1RoZW1lUHJvdmlkZXI6IFBsZWFzZSBtYWtlIHlvdXIgXCJ0aGVtZVwiIHByb3AgYW4gb2JqZWN0LlxcblxcbicsOTpcIk1pc3NpbmcgZG9jdW1lbnQgYDxoZWFkPmBcXG5cXG5cIiwxMDpcIkNhbm5vdCBmaW5kIGEgU3R5bGVTaGVldCBpbnN0YW5jZS4gVXN1YWxseSB0aGlzIGhhcHBlbnMgaWYgdGhlcmUgYXJlIG11bHRpcGxlIGNvcGllcyBvZiBzdHlsZWQtY29tcG9uZW50cyBsb2FkZWQgYXQgb25jZS4gQ2hlY2sgb3V0IHRoaXMgaXNzdWUgZm9yIGhvdyB0byB0cm91Ymxlc2hvb3QgYW5kIGZpeCB0aGUgY29tbW9uIGNhc2VzIHdoZXJlIHRoaXMgc2l0dWF0aW9uIGNhbiBoYXBwZW46IGh0dHBzOi8vZ2l0aHViLmNvbS9zdHlsZWQtY29tcG9uZW50cy9zdHlsZWQtY29tcG9uZW50cy9pc3N1ZXMvMTk0MSNpc3N1ZWNvbW1lbnQtNDE3ODYyMDIxXFxuXFxuXCIsMTE6XCJfVGhpcyBlcnJvciB3YXMgcmVwbGFjZWQgd2l0aCBhIGRldi10aW1lIHdhcm5pbmcsIGl0IHdpbGwgYmUgZGVsZXRlZCBmb3IgdjQgZmluYWwuXyBbY3JlYXRlR2xvYmFsU3R5bGVdIHJlY2VpdmVkIGNoaWxkcmVuIHdoaWNoIHdpbGwgbm90IGJlIHJlbmRlcmVkLiBQbGVhc2UgdXNlIHRoZSBjb21wb25lbnQgd2l0aG91dCBwYXNzaW5nIGNoaWxkcmVuIGVsZW1lbnRzLlxcblxcblwiLDEyOlwiSXQgc2VlbXMgeW91IGFyZSBpbnRlcnBvbGF0aW5nIGEga2V5ZnJhbWUgZGVjbGFyYXRpb24gKCVzKSBpbnRvIGFuIHVudGFnZ2VkIHN0cmluZy4gVGhpcyB3YXMgc3VwcG9ydGVkIGluIHN0eWxlZC1jb21wb25lbnRzIHYzLCBidXQgaXMgbm90IGxvbmdlciBzdXBwb3J0ZWQgaW4gdjQgYXMga2V5ZnJhbWVzIGFyZSBub3cgaW5qZWN0ZWQgb24tZGVtYW5kLiBQbGVhc2Ugd3JhcCB5b3VyIHN0cmluZyBpbiB0aGUgY3NzXFxcXGBcXFxcYCBoZWxwZXIgd2hpY2ggZW5zdXJlcyB0aGUgc3R5bGVzIGFyZSBpbmplY3RlZCBjb3JyZWN0bHkuIFNlZSBodHRwczovL3d3dy5zdHlsZWQtY29tcG9uZW50cy5jb20vZG9jcy9hcGkjY3NzXFxuXFxuXCIsMTM6XCIlcyBpcyBub3QgYSBzdHlsZWQgY29tcG9uZW50IGFuZCBjYW5ub3QgYmUgcmVmZXJyZWQgdG8gdmlhIGNvbXBvbmVudCBzZWxlY3Rvci4gU2VlIGh0dHBzOi8vd3d3LnN0eWxlZC1jb21wb25lbnRzLmNvbS9kb2NzL2FkdmFuY2VkI3JlZmVycmluZy10by1vdGhlci1jb21wb25lbnRzIGZvciBtb3JlIGRldGFpbHMuXFxuXFxuXCIsMTQ6J1RoZW1lUHJvdmlkZXI6IFwidGhlbWVcIiBwcm9wIGlzIHJlcXVpcmVkLlxcblxcbicsMTU6XCJBIHN0eWxpcyBwbHVnaW4gaGFzIGJlZW4gc3VwcGxpZWQgdGhhdCBpcyBub3QgbmFtZWQuIFdlIG5lZWQgYSBuYW1lIGZvciBlYWNoIHBsdWdpbiB0byBiZSBhYmxlIHRvIHByZXZlbnQgc3R5bGluZyBjb2xsaXNpb25zIGJldHdlZW4gZGlmZmVyZW50IHN0eWxpcyBjb25maWd1cmF0aW9ucyB3aXRoaW4gdGhlIHNhbWUgYXBwLiBCZWZvcmUgeW91IHBhc3MgeW91ciBwbHVnaW4gdG8gYDxTdHlsZVNoZWV0TWFuYWdlciBzdHlsaXNQbHVnaW5zPXtbXX0+YCwgcGxlYXNlIG1ha2Ugc3VyZSBlYWNoIHBsdWdpbiBpcyB1bmlxdWVseS1uYW1lZCwgZS5nLlxcblxcbmBgYGpzXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGltcG9ydGVkUGx1Z2luLCAnbmFtZScsIHsgdmFsdWU6ICdzb21lLXVuaXF1ZS1uYW1lJyB9KTtcXG5gYGBcXG5cXG5cIiwxNjpcIlJlYWNoZWQgdGhlIGxpbWl0IG9mIGhvdyBtYW55IHN0eWxlZCBjb21wb25lbnRzIG1heSBiZSBjcmVhdGVkIGF0IGdyb3VwICVzLlxcbllvdSBtYXkgb25seSBjcmVhdGUgdXAgdG8gMSwwNzMsNzQxLDgyNCBjb21wb25lbnRzLiBJZiB5b3UncmUgY3JlYXRpbmcgY29tcG9uZW50cyBkeW5hbWljYWxseSxcXG5hcyBmb3IgaW5zdGFuY2UgaW4geW91ciByZW5kZXIgbWV0aG9kIHRoZW4geW91IG1heSBiZSBydW5uaW5nIGludG8gdGhpcyBsaW1pdGF0aW9uLlxcblxcblwiLDE3OlwiQ1NTU3R5bGVTaGVldCBjb3VsZCBub3QgYmUgZm91bmQgb24gSFRNTFN0eWxlRWxlbWVudC5cXG5IYXMgc3R5bGVkLWNvbXBvbmVudHMnIHN0eWxlIHRhZyBiZWVuIHVubW91bnRlZCBvciBhbHRlcmVkIGJ5IGFub3RoZXIgc2NyaXB0P1xcblwiLDE4OlwiVGhlbWVQcm92aWRlcjogUGxlYXNlIG1ha2Ugc3VyZSB5b3VyIHVzZVRoZW1lIGhvb2sgaXMgd2l0aGluIGEgYDxUaGVtZVByb3ZpZGVyPmBcIn06e307ZnVuY3Rpb24gZGUoKXtmb3IodmFyIGU9W10sdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspZVt0XT1hcmd1bWVudHNbdF07Zm9yKHZhciBuPWVbMF0sbz1bXSxyPTEscz1lLmxlbmd0aDtyPHM7cis9MSlvLnB1c2goZVtyXSk7cmV0dXJuIG8uZm9yRWFjaChmdW5jdGlvbihlKXtuPW4ucmVwbGFjZSgvJVthLXpdLyxlKX0pLG59ZnVuY3Rpb24gaGUodCl7Zm9yKHZhciBuPVtdLG89MTtvPGFyZ3VtZW50cy5sZW5ndGg7bysrKW5bby0xXT1hcmd1bWVudHNbb107cmV0dXJuXCJwcm9kdWN0aW9uXCI9PT1wcm9jZXNzLmVudi5OT0RFX0VOVj9uZXcgRXJyb3IoXCJBbiBlcnJvciBvY2N1cnJlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdHlsZWQtY29tcG9uZW50cy9zdHlsZWQtY29tcG9uZW50cy9ibG9iL21haW4vcGFja2FnZXMvc3R5bGVkLWNvbXBvbmVudHMvc3JjL3V0aWxzL2Vycm9ycy5tZCNcIi5jb25jYXQodCxcIiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIikuY29uY2F0KG4ubGVuZ3RoPjA/XCIgQXJnczogXCIuY29uY2F0KG4uam9pbihcIiwgXCIpKTpcIlwiKSk6bmV3IEVycm9yKGRlLmFwcGx5KHZvaWQgMCxlKFtwZVt0XV0sbiwhMSkpLnRyaW0oKSl9dmFyIGZlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt0aGlzLmdyb3VwU2l6ZXM9bmV3IFVpbnQzMkFycmF5KDUxMiksdGhpcy5sZW5ndGg9NTEyLHRoaXMudGFnPWV9cmV0dXJuIGUucHJvdG90eXBlLmluZGV4T2ZHcm91cD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9MCxuPTA7bjxlO24rKyl0Kz10aGlzLmdyb3VwU2l6ZXNbbl07cmV0dXJuIHR9LGUucHJvdG90eXBlLmluc2VydFJ1bGVzPWZ1bmN0aW9uKGUsdCl7aWYoZT49dGhpcy5ncm91cFNpemVzLmxlbmd0aCl7Zm9yKHZhciBuPXRoaXMuZ3JvdXBTaXplcyxvPW4ubGVuZ3RoLHI9bztlPj1yOylpZigocjw8PTEpPDApdGhyb3cgaGUoMTYsXCJcIi5jb25jYXQoZSkpO3RoaXMuZ3JvdXBTaXplcz1uZXcgVWludDMyQXJyYXkociksdGhpcy5ncm91cFNpemVzLnNldChuKSx0aGlzLmxlbmd0aD1yO2Zvcih2YXIgcz1vO3M8cjtzKyspdGhpcy5ncm91cFNpemVzW3NdPTB9Zm9yKHZhciBpPXRoaXMuaW5kZXhPZkdyb3VwKGUrMSksYT0ocz0wLHQubGVuZ3RoKTtzPGE7cysrKXRoaXMudGFnLmluc2VydFJ1bGUoaSx0W3NdKSYmKHRoaXMuZ3JvdXBTaXplc1tlXSsrLGkrKyl9LGUucHJvdG90eXBlLmNsZWFyR3JvdXA9ZnVuY3Rpb24oZSl7aWYoZTx0aGlzLmxlbmd0aCl7dmFyIHQ9dGhpcy5ncm91cFNpemVzW2VdLG49dGhpcy5pbmRleE9mR3JvdXAoZSksbz1uK3Q7dGhpcy5ncm91cFNpemVzW2VdPTA7Zm9yKHZhciByPW47cjxvO3IrKyl0aGlzLnRhZy5kZWxldGVSdWxlKG4pfX0sZS5wcm90b3R5cGUuZ2V0R3JvdXA9ZnVuY3Rpb24oZSl7dmFyIHQ9XCJcIjtpZihlPj10aGlzLmxlbmd0aHx8MD09PXRoaXMuZ3JvdXBTaXplc1tlXSlyZXR1cm4gdDtmb3IodmFyIG49dGhpcy5ncm91cFNpemVzW2VdLG89dGhpcy5pbmRleE9mR3JvdXAoZSkscj1vK24scz1vO3M8cjtzKyspdCs9XCJcIi5jb25jYXQodGhpcy50YWcuZ2V0UnVsZShzKSkuY29uY2F0KGcpO3JldHVybiB0fSxlfSgpLG1lPW5ldyBNYXAseWU9bmV3IE1hcCx2ZT0xLGdlPWZ1bmN0aW9uKGUpe2lmKG1lLmhhcyhlKSlyZXR1cm4gbWUuZ2V0KGUpO2Zvcig7eWUuaGFzKHZlKTspdmUrKzt2YXIgdD12ZSsrO2lmKFwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJigoMHx0KTwwfHx0PjEwNzM3NDE4MjQpKXRocm93IGhlKDE2LFwiXCIuY29uY2F0KHQpKTtyZXR1cm4gbWUuc2V0KGUsdCkseWUuc2V0KHQsZSksdH0sU2U9ZnVuY3Rpb24oZSx0KXt2ZT10KzEsbWUuc2V0KGUsdCkseWUuc2V0KHQsZSl9LHdlPVwic3R5bGVbXCIuY29uY2F0KGYsXCJdW1wiKS5jb25jYXQoeSwnPVwiJykuY29uY2F0KHYsJ1wiXScpLGJlPW5ldyBSZWdFeHAoXCJeXCIuY29uY2F0KGYsJ1xcXFwuZyhcXFxcZCspXFxcXFtpZD1cIihbXFxcXHdcXFxcZC1dKylcIlxcXFxdLio/XCIoW15cIl0qKScpKSxFZT1mdW5jdGlvbihlLHQsbil7Zm9yKHZhciBvLHI9bi5zcGxpdChcIixcIikscz0wLGk9ci5sZW5ndGg7czxpO3MrKykobz1yW3NdKSYmZS5yZWdpc3Rlck5hbWUodCxvKX0sTmU9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG4sbz0obnVsbCE9PShuPXQudGV4dENvbnRlbnQpJiZ2b2lkIDAhPT1uP246XCJcIikuc3BsaXQoZykscj1bXSxzPTAsaT1vLmxlbmd0aDtzPGk7cysrKXt2YXIgYT1vW3NdLnRyaW0oKTtpZihhKXt2YXIgYz1hLm1hdGNoKGJlKTtpZihjKXt2YXIgbD0wfHBhcnNlSW50KGNbMV0sMTApLHU9Y1syXTswIT09bCYmKFNlKHUsbCksRWUoZSx1LGNbM10pLGUuZ2V0VGFnKCkuaW5zZXJ0UnVsZXMobCxyKSksci5sZW5ndGg9MH1lbHNlIHIucHVzaChhKX19fTtmdW5jdGlvbiBQZSgpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXz9fX3dlYnBhY2tfbm9uY2VfXzpudWxsfXZhciBfZT1mdW5jdGlvbihlKXt2YXIgdD1kb2N1bWVudC5oZWFkLG49ZXx8dCxvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKSxyPWZ1bmN0aW9uKGUpe3ZhciB0PUFycmF5LmZyb20oZS5xdWVyeVNlbGVjdG9yQWxsKFwic3R5bGVbXCIuY29uY2F0KGYsXCJdXCIpKSk7cmV0dXJuIHRbdC5sZW5ndGgtMV19KG4pLHM9dm9pZCAwIT09cj9yLm5leHRTaWJsaW5nOm51bGw7by5zZXRBdHRyaWJ1dGUoZixtKSxvLnNldEF0dHJpYnV0ZSh5LHYpO3ZhciBpPVBlKCk7cmV0dXJuIGkmJm8uc2V0QXR0cmlidXRlKFwibm9uY2VcIixpKSxuLmluc2VydEJlZm9yZShvLHMpLG99LENlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt0aGlzLmVsZW1lbnQ9X2UoZSksdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpKSx0aGlzLnNoZWV0PWZ1bmN0aW9uKGUpe2lmKGUuc2hlZXQpcmV0dXJuIGUuc2hlZXQ7Zm9yKHZhciB0PWRvY3VtZW50LnN0eWxlU2hlZXRzLG49MCxvPXQubGVuZ3RoO248bztuKyspe3ZhciByPXRbbl07aWYoci5vd25lck5vZGU9PT1lKXJldHVybiByfXRocm93IGhlKDE3KX0odGhpcy5lbGVtZW50KSx0aGlzLmxlbmd0aD0wfXJldHVybiBlLnByb3RvdHlwZS5pbnNlcnRSdWxlPWZ1bmN0aW9uKGUsdCl7dHJ5e3JldHVybiB0aGlzLnNoZWV0Lmluc2VydFJ1bGUodCxlKSx0aGlzLmxlbmd0aCsrLCEwfWNhdGNoKGUpe3JldHVybiExfX0sZS5wcm90b3R5cGUuZGVsZXRlUnVsZT1mdW5jdGlvbihlKXt0aGlzLnNoZWV0LmRlbGV0ZVJ1bGUoZSksdGhpcy5sZW5ndGgtLX0sZS5wcm90b3R5cGUuZ2V0UnVsZT1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnNoZWV0LmNzc1J1bGVzW2VdO3JldHVybiB0JiZ0LmNzc1RleHQ/dC5jc3NUZXh0OlwiXCJ9LGV9KCksSWU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3RoaXMuZWxlbWVudD1fZShlKSx0aGlzLm5vZGVzPXRoaXMuZWxlbWVudC5jaGlsZE5vZGVzLHRoaXMubGVuZ3RoPTB9cmV0dXJuIGUucHJvdG90eXBlLmluc2VydFJ1bGU9ZnVuY3Rpb24oZSx0KXtpZihlPD10aGlzLmxlbmd0aCYmZT49MCl7dmFyIG49ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodCk7cmV0dXJuIHRoaXMuZWxlbWVudC5pbnNlcnRCZWZvcmUobix0aGlzLm5vZGVzW2VdfHxudWxsKSx0aGlzLmxlbmd0aCsrLCEwfXJldHVybiExfSxlLnByb3RvdHlwZS5kZWxldGVSdWxlPWZ1bmN0aW9uKGUpe3RoaXMuZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLm5vZGVzW2VdKSx0aGlzLmxlbmd0aC0tfSxlLnByb3RvdHlwZS5nZXRSdWxlPWZ1bmN0aW9uKGUpe3JldHVybiBlPHRoaXMubGVuZ3RoP3RoaXMubm9kZXNbZV0udGV4dENvbnRlbnQ6XCJcIn0sZX0oKSxBZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7dGhpcy5ydWxlcz1bXSx0aGlzLmxlbmd0aD0wfXJldHVybiBlLnByb3RvdHlwZS5pbnNlcnRSdWxlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU8PXRoaXMubGVuZ3RoJiYodGhpcy5ydWxlcy5zcGxpY2UoZSwwLHQpLHRoaXMubGVuZ3RoKyssITApfSxlLnByb3RvdHlwZS5kZWxldGVSdWxlPWZ1bmN0aW9uKGUpe3RoaXMucnVsZXMuc3BsaWNlKGUsMSksdGhpcy5sZW5ndGgtLX0sZS5wcm90b3R5cGUuZ2V0UnVsZT1mdW5jdGlvbihlKXtyZXR1cm4gZTx0aGlzLmxlbmd0aD90aGlzLnJ1bGVzW2VdOlwiXCJ9LGV9KCksT2U9UyxEZT17aXNTZXJ2ZXI6IVMsdXNlQ1NTT01JbmplY3Rpb246IXd9LFJlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLG4sbyl7dm9pZCAwPT09ZSYmKGU9Qyksdm9pZCAwPT09biYmKG49e30pO3ZhciByPXRoaXM7dGhpcy5vcHRpb25zPXQodCh7fSxEZSksZSksdGhpcy5ncz1uLHRoaXMubmFtZXM9bmV3IE1hcChvKSx0aGlzLnNlcnZlcj0hIWUuaXNTZXJ2ZXIsIXRoaXMuc2VydmVyJiZTJiZPZSYmKE9lPSExLGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHdlKSxuPTAsbz10Lmxlbmd0aDtuPG87bisrKXt2YXIgcj10W25dO3ImJnIuZ2V0QXR0cmlidXRlKGYpIT09bSYmKE5lKGUsciksci5wYXJlbnROb2RlJiZyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocikpfX0odGhpcykpLHVlKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWUuZ2V0VGFnKCksbj10Lmxlbmd0aCxvPVwiXCIscj1mdW5jdGlvbihuKXt2YXIgcj1mdW5jdGlvbihlKXtyZXR1cm4geWUuZ2V0KGUpfShuKTtpZih2b2lkIDA9PT1yKXJldHVyblwiY29udGludWVcIjt2YXIgcz1lLm5hbWVzLmdldChyKSxpPXQuZ2V0R3JvdXAobik7aWYodm9pZCAwPT09c3x8MD09PWkubGVuZ3RoKXJldHVyblwiY29udGludWVcIjt2YXIgYT1cIlwiLmNvbmNhdChmLFwiLmdcIikuY29uY2F0KG4sJ1tpZD1cIicpLmNvbmNhdChyLCdcIl0nKSxjPVwiXCI7dm9pZCAwIT09cyYmcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UubGVuZ3RoPjAmJihjKz1cIlwiLmNvbmNhdChlLFwiLFwiKSl9KSxvKz1cIlwiLmNvbmNhdChpKS5jb25jYXQoYSwne2NvbnRlbnQ6XCInKS5jb25jYXQoYywnXCJ9JykuY29uY2F0KGcpfSxzPTA7czxuO3MrKylyKHMpO3JldHVybiBvfShyKX0pfXJldHVybiBlLnJlZ2lzdGVySWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGdlKGUpfSxlLnByb3RvdHlwZS5yZWNvbnN0cnVjdFdpdGhPcHRpb25zPWZ1bmN0aW9uKG4sbyl7cmV0dXJuIHZvaWQgMD09PW8mJihvPSEwKSxuZXcgZSh0KHQoe30sdGhpcy5vcHRpb25zKSxuKSx0aGlzLmdzLG8mJnRoaXMubmFtZXN8fHZvaWQgMCl9LGUucHJvdG90eXBlLmFsbG9jYXRlR1NJbnN0YW5jZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5nc1tlXT0odGhpcy5nc1tlXXx8MCkrMX0sZS5wcm90b3R5cGUuZ2V0VGFnPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGFnfHwodGhpcy50YWc9KGU9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS51c2VDU1NPTUluamVjdGlvbixuPWUudGFyZ2V0O3JldHVybiBlLmlzU2VydmVyP25ldyBBZShuKTp0P25ldyBDZShuKTpuZXcgSWUobil9KHRoaXMub3B0aW9ucyksbmV3IGZlKGUpKSk7dmFyIGV9LGUucHJvdG90eXBlLmhhc05hbWVGb3JJZD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLm5hbWVzLmhhcyhlKSYmdGhpcy5uYW1lcy5nZXQoZSkuaGFzKHQpfSxlLnByb3RvdHlwZS5yZWdpc3Rlck5hbWU9ZnVuY3Rpb24oZSx0KXtpZihnZShlKSx0aGlzLm5hbWVzLmhhcyhlKSl0aGlzLm5hbWVzLmdldChlKS5hZGQodCk7ZWxzZXt2YXIgbj1uZXcgU2V0O24uYWRkKHQpLHRoaXMubmFtZXMuc2V0KGUsbil9fSxlLnByb3RvdHlwZS5pbnNlcnRSdWxlcz1mdW5jdGlvbihlLHQsbil7dGhpcy5yZWdpc3Rlck5hbWUoZSx0KSx0aGlzLmdldFRhZygpLmluc2VydFJ1bGVzKGdlKGUpLG4pfSxlLnByb3RvdHlwZS5jbGVhck5hbWVzPWZ1bmN0aW9uKGUpe3RoaXMubmFtZXMuaGFzKGUpJiZ0aGlzLm5hbWVzLmdldChlKS5jbGVhcigpfSxlLnByb3RvdHlwZS5jbGVhclJ1bGVzPWZ1bmN0aW9uKGUpe3RoaXMuZ2V0VGFnKCkuY2xlYXJHcm91cChnZShlKSksdGhpcy5jbGVhck5hbWVzKGUpfSxlLnByb3RvdHlwZS5jbGVhclRhZz1mdW5jdGlvbigpe3RoaXMudGFnPXZvaWQgMH0sZX0oKSxUZT0vJi9nLGtlPS9eXFxzKlxcL1xcLy4qJC9nbTtmdW5jdGlvbiBqZShlLHQpe3JldHVybiBlLm1hcChmdW5jdGlvbihlKXtyZXR1cm5cInJ1bGVcIj09PWUudHlwZSYmKGUudmFsdWU9XCJcIi5jb25jYXQodCxcIiBcIikuY29uY2F0KGUudmFsdWUpLGUudmFsdWU9ZS52YWx1ZS5yZXBsYWNlQWxsKFwiLFwiLFwiLFwiLmNvbmNhdCh0LFwiIFwiKSksZS5wcm9wcz1lLnByb3BzLm1hcChmdW5jdGlvbihlKXtyZXR1cm5cIlwiLmNvbmNhdCh0LFwiIFwiKS5jb25jYXQoZSl9KSksQXJyYXkuaXNBcnJheShlLmNoaWxkcmVuKSYmXCJAa2V5ZnJhbWVzXCIhPT1lLnR5cGUmJihlLmNoaWxkcmVuPWplKGUuY2hpbGRyZW4sdCkpLGV9KX1mdW5jdGlvbiB4ZShlKXt2YXIgdCxuLG8scj12b2lkIDA9PT1lP0M6ZSxzPXIub3B0aW9ucyxpPXZvaWQgMD09PXM/QzpzLGE9ci5wbHVnaW5zLGM9dm9pZCAwPT09YT9fOmEsbD1mdW5jdGlvbihlLG8scil7cmV0dXJuIHIuc3RhcnRzV2l0aChuKSYmci5lbmRzV2l0aChuKSYmci5yZXBsYWNlQWxsKG4sXCJcIikubGVuZ3RoPjA/XCIuXCIuY29uY2F0KHQpOmV9LHU9Yy5zbGljZSgpO3UucHVzaChmdW5jdGlvbihlKXtlLnR5cGU9PT1kLlJVTEVTRVQmJmUudmFsdWUuaW5jbHVkZXMoXCImXCIpJiYoZS5wcm9wc1swXT1lLnByb3BzWzBdLnJlcGxhY2UoVGUsbikucmVwbGFjZShvLGwpKX0pLGkucHJlZml4JiZ1LnB1c2goZC5wcmVmaXhlciksdS5wdXNoKGQuc3RyaW5naWZ5KTt2YXIgcD1mdW5jdGlvbihlLHIscyxhKXt2b2lkIDA9PT1yJiYocj1cIlwiKSx2b2lkIDA9PT1zJiYocz1cIlwiKSx2b2lkIDA9PT1hJiYoYT1cIiZcIiksdD1hLG49cixvPW5ldyBSZWdFeHAoXCJcXFxcXCIuY29uY2F0KG4sXCJcXFxcYlwiKSxcImdcIik7dmFyIGM9ZS5yZXBsYWNlKGtlLFwiXCIpLGw9ZC5jb21waWxlKHN8fHI/XCJcIi5jb25jYXQocyxcIiBcIikuY29uY2F0KHIsXCIgeyBcIikuY29uY2F0KGMsXCIgfVwiKTpjKTtpLm5hbWVzcGFjZSYmKGw9amUobCxpLm5hbWVzcGFjZSkpO3ZhciBwPVtdO3JldHVybiBkLnNlcmlhbGl6ZShsLGQubWlkZGxld2FyZSh1LmNvbmNhdChkLnJ1bGVzaGVldChmdW5jdGlvbihlKXtyZXR1cm4gcC5wdXNoKGUpfSkpKSkscH07cmV0dXJuIHAuaGFzaD1jLmxlbmd0aD9jLnJlZHVjZShmdW5jdGlvbihlLHQpe3JldHVybiB0Lm5hbWV8fGhlKDE1KSxNKGUsdC5uYW1lKX0sRikudG9TdHJpbmcoKTpcIlwiLHB9dmFyIFZlPW5ldyBSZSxGZT14ZSgpLE1lPW8uY3JlYXRlQ29udGV4dCh7c2hvdWxkRm9yd2FyZFByb3A6dm9pZCAwLHN0eWxlU2hlZXQ6VmUsc3R5bGlzOkZlfSksJGU9TWUuQ29uc3VtZXIsemU9by5jcmVhdGVDb250ZXh0KHZvaWQgMCk7ZnVuY3Rpb24gQmUoKXtyZXR1cm4gYyhNZSl9ZnVuY3Rpb24gTGUoZSl7dmFyIHQ9cyhlLnN0eWxpc1BsdWdpbnMpLG49dFswXSxyPXRbMV0sYz1CZSgpLnN0eWxlU2hlZXQsbD1pKGZ1bmN0aW9uKCl7dmFyIHQ9YztyZXR1cm4gZS5zaGVldD90PWUuc2hlZXQ6ZS50YXJnZXQmJih0PXQucmVjb25zdHJ1Y3RXaXRoT3B0aW9ucyh7dGFyZ2V0OmUudGFyZ2V0fSwhMSkpLGUuZGlzYWJsZUNTU09NSW5qZWN0aW9uJiYodD10LnJlY29uc3RydWN0V2l0aE9wdGlvbnMoe3VzZUNTU09NSW5qZWN0aW9uOiExfSkpLHR9LFtlLmRpc2FibGVDU1NPTUluamVjdGlvbixlLnNoZWV0LGUudGFyZ2V0LGNdKSx1PWkoZnVuY3Rpb24oKXtyZXR1cm4geGUoe29wdGlvbnM6e25hbWVzcGFjZTplLm5hbWVzcGFjZSxwcmVmaXg6ZS5lbmFibGVWZW5kb3JQcmVmaXhlc30scGx1Z2luczpufSl9LFtlLmVuYWJsZVZlbmRvclByZWZpeGVzLGUubmFtZXNwYWNlLG5dKTthKGZ1bmN0aW9uKCl7cChuLGUuc3R5bGlzUGx1Z2lucyl8fHIoZS5zdHlsaXNQbHVnaW5zKX0sW2Uuc3R5bGlzUGx1Z2luc10pO3ZhciBkPWkoZnVuY3Rpb24oKXtyZXR1cm57c2hvdWxkRm9yd2FyZFByb3A6ZS5zaG91bGRGb3J3YXJkUHJvcCxzdHlsZVNoZWV0Omwsc3R5bGlzOnV9fSxbZS5zaG91bGRGb3J3YXJkUHJvcCxsLHVdKTtyZXR1cm4gby5jcmVhdGVFbGVtZW50KE1lLlByb3ZpZGVyLHt2YWx1ZTpkfSxvLmNyZWF0ZUVsZW1lbnQoemUuUHJvdmlkZXIse3ZhbHVlOnV9LGUuY2hpbGRyZW4pKX12YXIgR2U9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7dmFyIG49dGhpczt0aGlzLmluamVjdD1mdW5jdGlvbihlLHQpe3ZvaWQgMD09PXQmJih0PUZlKTt2YXIgbz1uLm5hbWUrdC5oYXNoO2UuaGFzTmFtZUZvcklkKG4uaWQsbyl8fGUuaW5zZXJ0UnVsZXMobi5pZCxvLHQobi5ydWxlcyxvLFwiQGtleWZyYW1lc1wiKSl9LHRoaXMubmFtZT1lLHRoaXMuaWQ9XCJzYy1rZXlmcmFtZXMtXCIuY29uY2F0KGUpLHRoaXMucnVsZXM9dCx1ZSh0aGlzLGZ1bmN0aW9uKCl7dGhyb3cgaGUoMTIsU3RyaW5nKG4ubmFtZSkpfSl9cmV0dXJuIGUucHJvdG90eXBlLmdldE5hbWU9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPUZlKSx0aGlzLm5hbWUrZS5oYXNofSxlfSgpLFllPWZ1bmN0aW9uKGUpe3JldHVybiBlPj1cIkFcIiYmZTw9XCJaXCJ9O2Z1bmN0aW9uIFdlKGUpe2Zvcih2YXIgdD1cIlwiLG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIG89ZVtuXTtpZigxPT09biYmXCItXCI9PT1vJiZcIi1cIj09PWVbMF0pcmV0dXJuIGU7WWUobyk/dCs9XCItXCIrby50b0xvd2VyQ2FzZSgpOnQrPW99cmV0dXJuIHQuc3RhcnRzV2l0aChcIm1zLVwiKT9cIi1cIit0OnR9dmFyIHFlPWZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lfHwhMT09PWV8fFwiXCI9PT1lfSxIZT1mdW5jdGlvbih0KXt2YXIgbixvLHI9W107Zm9yKHZhciBzIGluIHQpe3ZhciBpPXRbc107dC5oYXNPd25Qcm9wZXJ0eShzKSYmIXFlKGkpJiYoQXJyYXkuaXNBcnJheShpKSYmaS5pc0Nzc3x8cmUoaSk/ci5wdXNoKFwiXCIuY29uY2F0KFdlKHMpLFwiOlwiKSxpLFwiO1wiKTpjZShpKT9yLnB1c2guYXBwbHkocixlKGUoW1wiXCIuY29uY2F0KHMsXCIge1wiKV0sSGUoaSksITEpLFtcIn1cIl0sITEpKTpyLnB1c2goXCJcIi5jb25jYXQoV2UocyksXCI6IFwiKS5jb25jYXQoKG49cyxudWxsPT0obz1pKXx8XCJib29sZWFuXCI9PXR5cGVvZiBvfHxcIlwiPT09bz9cIlwiOlwibnVtYmVyXCIhPXR5cGVvZiBvfHwwPT09b3x8biBpbiBofHxuLnN0YXJ0c1dpdGgoXCItLVwiKT9TdHJpbmcobykudHJpbSgpOlwiXCIuY29uY2F0KG8sXCJweFwiKSksXCI7XCIpKSl9cmV0dXJuIHJ9O2Z1bmN0aW9uIFVlKGUsdCxuLG8pe2lmKHFlKGUpKXJldHVybltdO2lmKHNlKGUpKXJldHVybltcIi5cIi5jb25jYXQoZS5zdHlsZWRDb21wb25lbnRJZCldO2lmKHJlKGUpKXtpZighcmUocz1lKXx8cy5wcm90b3R5cGUmJnMucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnR8fCF0KXJldHVybltlXTt2YXIgcj1lKHQpO3JldHVyblwicHJvZHVjdGlvblwiPT09cHJvY2Vzcy5lbnYuTk9ERV9FTlZ8fFwib2JqZWN0XCIhPXR5cGVvZiByfHxBcnJheS5pc0FycmF5KHIpfHxyIGluc3RhbmNlb2YgR2V8fGNlKHIpfHxudWxsPT09cnx8Y29uc29sZS5lcnJvcihcIlwiLmNvbmNhdChCKGUpLFwiIGlzIG5vdCBhIHN0eWxlZCBjb21wb25lbnQgYW5kIGNhbm5vdCBiZSByZWZlcnJlZCB0byB2aWEgY29tcG9uZW50IHNlbGVjdG9yLiBTZWUgaHR0cHM6Ly93d3cuc3R5bGVkLWNvbXBvbmVudHMuY29tL2RvY3MvYWR2YW5jZWQjcmVmZXJyaW5nLXRvLW90aGVyLWNvbXBvbmVudHMgZm9yIG1vcmUgZGV0YWlscy5cIikpLFVlKHIsdCxuLG8pfXZhciBzO3JldHVybiBlIGluc3RhbmNlb2YgR2U/bj8oZS5pbmplY3QobixvKSxbZS5nZXROYW1lKG8pXSk6W2VdOmNlKGUpP0hlKGUpOkFycmF5LmlzQXJyYXkoZSk/QXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShfLGUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBVZShlLHQsbixvKX0pKTpbZS50b1N0cmluZygpXX1mdW5jdGlvbiBKZShlKXtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoO3QrPTEpe3ZhciBuPWVbdF07aWYocmUobikmJiFzZShuKSlyZXR1cm4hMX1yZXR1cm4hMH12YXIgWGU9JCh2KSxaZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LG4pe3RoaXMucnVsZXM9ZSx0aGlzLnN0YXRpY1J1bGVzSWQ9XCJcIix0aGlzLmlzU3RhdGljPVwicHJvZHVjdGlvblwiPT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJih2b2lkIDA9PT1ufHxuLmlzU3RhdGljKSYmSmUoZSksdGhpcy5jb21wb25lbnRJZD10LHRoaXMuYmFzZUhhc2g9TShYZSx0KSx0aGlzLmJhc2VTdHlsZT1uLFJlLnJlZ2lzdGVySWQodCl9cmV0dXJuIGUucHJvdG90eXBlLmdlbmVyYXRlQW5kSW5qZWN0U3R5bGVzPWZ1bmN0aW9uKGUsdCxuKXt2YXIgbz10aGlzLmJhc2VTdHlsZT90aGlzLmJhc2VTdHlsZS5nZW5lcmF0ZUFuZEluamVjdFN0eWxlcyhlLHQsbik6XCJcIjtpZih0aGlzLmlzU3RhdGljJiYhbi5oYXNoKWlmKHRoaXMuc3RhdGljUnVsZXNJZCYmdC5oYXNOYW1lRm9ySWQodGhpcy5jb21wb25lbnRJZCx0aGlzLnN0YXRpY1J1bGVzSWQpKW89aWUobyx0aGlzLnN0YXRpY1J1bGVzSWQpO2Vsc2V7dmFyIHI9YWUoVWUodGhpcy5ydWxlcyxlLHQsbikpLHM9eChNKHRoaXMuYmFzZUhhc2gscik+Pj4wKTtpZighdC5oYXNOYW1lRm9ySWQodGhpcy5jb21wb25lbnRJZCxzKSl7dmFyIGk9bihyLFwiLlwiLmNvbmNhdChzKSx2b2lkIDAsdGhpcy5jb21wb25lbnRJZCk7dC5pbnNlcnRSdWxlcyh0aGlzLmNvbXBvbmVudElkLHMsaSl9bz1pZShvLHMpLHRoaXMuc3RhdGljUnVsZXNJZD1zfWVsc2V7Zm9yKHZhciBhPU0odGhpcy5iYXNlSGFzaCxuLmhhc2gpLGM9XCJcIixsPTA7bDx0aGlzLnJ1bGVzLmxlbmd0aDtsKyspe3ZhciB1PXRoaXMucnVsZXNbbF07aWYoXCJzdHJpbmdcIj09dHlwZW9mIHUpYys9dSxcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiYoYT1NKGEsdSkpO2Vsc2UgaWYodSl7dmFyIHA9YWUoVWUodSxlLHQsbikpO2E9TShhLHArbCksYys9cH19aWYoYyl7dmFyIGQ9eChhPj4+MCk7dC5oYXNOYW1lRm9ySWQodGhpcy5jb21wb25lbnRJZCxkKXx8dC5pbnNlcnRSdWxlcyh0aGlzLmNvbXBvbmVudElkLGQsbihjLFwiLlwiLmNvbmNhdChkKSx2b2lkIDAsdGhpcy5jb21wb25lbnRJZCkpLG89aWUobyxkKX19cmV0dXJuIG99LGV9KCksS2U9by5jcmVhdGVDb250ZXh0KHZvaWQgMCksUWU9S2UuQ29uc3VtZXI7ZnVuY3Rpb24gZXQoKXt2YXIgZT1jKEtlKTtpZighZSl0aHJvdyBoZSgxOCk7cmV0dXJuIGV9ZnVuY3Rpb24gdHQoZSl7dmFyIG49by51c2VDb250ZXh0KEtlKSxyPWkoZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSxuKXtpZighZSl0aHJvdyBoZSgxNCk7aWYocmUoZSkpe3ZhciBvPWUobik7aWYoXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmKG51bGw9PT1vfHxBcnJheS5pc0FycmF5KG8pfHxcIm9iamVjdFwiIT10eXBlb2YgbykpdGhyb3cgaGUoNyk7cmV0dXJuIG99aWYoQXJyYXkuaXNBcnJheShlKXx8XCJvYmplY3RcIiE9dHlwZW9mIGUpdGhyb3cgaGUoOCk7cmV0dXJuIG4/dCh0KHt9LG4pLGUpOmV9KGUudGhlbWUsbil9LFtlLnRoZW1lLG5dKTtyZXR1cm4gZS5jaGlsZHJlbj9vLmNyZWF0ZUVsZW1lbnQoS2UuUHJvdmlkZXIse3ZhbHVlOnJ9LGUuY2hpbGRyZW4pOm51bGx9dmFyIG50PXt9LG90PW5ldyBTZXQ7ZnVuY3Rpb24gcnQoZSxyLHMpe3ZhciBpPXNlKGUpLGE9ZSxjPSFMKGUpLHA9ci5hdHRycyxkPXZvaWQgMD09PXA/XzpwLGg9ci5jb21wb25lbnRJZCxmPXZvaWQgMD09PWg/ZnVuY3Rpb24oZSx0KXt2YXIgbj1cInN0cmluZ1wiIT10eXBlb2YgZT9cInNjXCI6UihlKTtudFtuXT0obnRbbl18fDApKzE7dmFyIG89XCJcIi5jb25jYXQobixcIi1cIikuY29uY2F0KHoodituK250W25dKSk7cmV0dXJuIHQ/XCJcIi5jb25jYXQodCxcIi1cIikuY29uY2F0KG8pOm99KHIuZGlzcGxheU5hbWUsci5wYXJlbnRDb21wb25lbnRJZCk6aCxtPXIuZGlzcGxheU5hbWUseT12b2lkIDA9PT1tP2Z1bmN0aW9uKGUpe3JldHVybiBMKGUpP1wic3R5bGVkLlwiLmNvbmNhdChlKTpcIlN0eWxlZChcIi5jb25jYXQoQihlKSxcIilcIil9KGUpOm0sZz1yLmRpc3BsYXlOYW1lJiZyLmNvbXBvbmVudElkP1wiXCIuY29uY2F0KFIoci5kaXNwbGF5TmFtZSksXCItXCIpLmNvbmNhdChyLmNvbXBvbmVudElkKTpyLmNvbXBvbmVudElkfHxmLFM9aSYmYS5hdHRycz9hLmF0dHJzLmNvbmNhdChkKS5maWx0ZXIoQm9vbGVhbik6ZCx3PXIuc2hvdWxkRm9yd2FyZFByb3A7aWYoaSYmYS5zaG91bGRGb3J3YXJkUHJvcCl7dmFyIGI9YS5zaG91bGRGb3J3YXJkUHJvcDtpZihyLnNob3VsZEZvcndhcmRQcm9wKXt2YXIgRT1yLnNob3VsZEZvcndhcmRQcm9wO3c9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gYihlLHQpJiZFKGUsdCl9fWVsc2Ugdz1ifXZhciBOPW5ldyBaZShzLGcsaT9hLmNvbXBvbmVudFN0eWxlOnZvaWQgMCk7ZnVuY3Rpb24gTyhlLHIpe3JldHVybiBmdW5jdGlvbihlLHIscyl7dmFyIGk9ZS5hdHRycyxhPWUuY29tcG9uZW50U3R5bGUsYz1lLmRlZmF1bHRQcm9wcyxwPWUuZm9sZGVkQ29tcG9uZW50SWRzLGQ9ZS5zdHlsZWRDb21wb25lbnRJZCxoPWUudGFyZ2V0LGY9by51c2VDb250ZXh0KEtlKSxtPUJlKCkseT1lLnNob3VsZEZvcndhcmRQcm9wfHxtLnNob3VsZEZvcndhcmRQcm9wO1wicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJmwoZCk7dmFyIHY9SShyLGYsYyl8fEMsZz1mdW5jdGlvbihlLG4sbyl7Zm9yKHZhciByLHM9dCh0KHt9LG4pLHtjbGFzc05hbWU6dm9pZCAwLHRoZW1lOm99KSxpPTA7aTxlLmxlbmd0aDtpKz0xKXt2YXIgYT1yZShyPWVbaV0pP3Iocyk6cjtmb3IodmFyIGMgaW4gYSlzW2NdPVwiY2xhc3NOYW1lXCI9PT1jP2llKHNbY10sYVtjXSk6XCJzdHlsZVwiPT09Yz90KHQoe30sc1tjXSksYVtjXSk6YVtjXX1yZXR1cm4gbi5jbGFzc05hbWUmJihzLmNsYXNzTmFtZT1pZShzLmNsYXNzTmFtZSxuLmNsYXNzTmFtZSkpLHN9KGkscix2KSxTPWcuYXN8fGgsdz17fTtmb3IodmFyIGIgaW4gZyl2b2lkIDA9PT1nW2JdfHxcIiRcIj09PWJbMF18fFwiYXNcIj09PWJ8fFwidGhlbWVcIj09PWImJmcudGhlbWU9PT12fHwoXCJmb3J3YXJkZWRBc1wiPT09Yj93LmFzPWcuZm9yd2FyZGVkQXM6eSYmIXkoYixTKXx8KHdbYl09Z1tiXSx5fHxcImRldmVsb3BtZW50XCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOVnx8bihiKXx8b3QuaGFzKGIpfHwhQS5oYXMoUyl8fChvdC5hZGQoYiksY29uc29sZS53YXJuKCdzdHlsZWQtY29tcG9uZW50czogaXQgbG9va3MgbGlrZSBhbiB1bmtub3duIHByb3AgXCInLmNvbmNhdChiLCdcIiBpcyBiZWluZyBzZW50IHRocm91Z2ggdG8gdGhlIERPTSwgd2hpY2ggd2lsbCBsaWtlbHkgdHJpZ2dlciBhIFJlYWN0IGNvbnNvbGUgZXJyb3IuIElmIHlvdSB3b3VsZCBsaWtlIGF1dG9tYXRpYyBmaWx0ZXJpbmcgb2YgdW5rbm93biBwcm9wcywgeW91IGNhbiBvcHQtaW50byB0aGF0IGJlaGF2aW9yIHZpYSBgPFN0eWxlU2hlZXRNYW5hZ2VyIHNob3VsZEZvcndhcmRQcm9wPXsuLi59PmAgKGNvbm5lY3QgYW4gQVBJIGxpa2UgYEBlbW90aW9uL2lzLXByb3AtdmFsaWRgKSBvciBjb25zaWRlciB1c2luZyB0cmFuc2llbnQgcHJvcHMgKGAkYCBwcmVmaXggZm9yIGF1dG9tYXRpYyBmaWx0ZXJpbmcuKScpKSkpKTt2YXIgRT1mdW5jdGlvbihlLHQpe3ZhciBuPUJlKCksbz1lLmdlbmVyYXRlQW5kSW5qZWN0U3R5bGVzKHQsbi5zdHlsZVNoZWV0LG4uc3R5bGlzKTtyZXR1cm5cInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZsKG8pLG99KGEsZyk7XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmZS53YXJuVG9vTWFueUNsYXNzZXMmJmUud2FyblRvb01hbnlDbGFzc2VzKEUpO3ZhciBOPWllKHAsZCk7cmV0dXJuIEUmJihOKz1cIiBcIitFKSxnLmNsYXNzTmFtZSYmKE4rPVwiIFwiK2cuY2xhc3NOYW1lKSx3W0woUykmJiFBLmhhcyhTKT9cImNsYXNzXCI6XCJjbGFzc05hbWVcIl09Tix3LnJlZj1zLHUoUyx3KX0oRCxlLHIpfU8uZGlzcGxheU5hbWU9eTt2YXIgRD1vLmZvcndhcmRSZWYoTyk7cmV0dXJuIEQuYXR0cnM9UyxELmNvbXBvbmVudFN0eWxlPU4sRC5kaXNwbGF5TmFtZT15LEQuc2hvdWxkRm9yd2FyZFByb3A9dyxELmZvbGRlZENvbXBvbmVudElkcz1pP2llKGEuZm9sZGVkQ29tcG9uZW50SWRzLGEuc3R5bGVkQ29tcG9uZW50SWQpOlwiXCIsRC5zdHlsZWRDb21wb25lbnRJZD1nLEQudGFyZ2V0PWk/YS50YXJnZXQ6ZSxPYmplY3QuZGVmaW5lUHJvcGVydHkoRCxcImRlZmF1bHRQcm9wc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZm9sZGVkRGVmYXVsdFByb3BzfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fZm9sZGVkRGVmYXVsdFByb3BzPWk/ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVtdLG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXRbbi0xXT1hcmd1bWVudHNbbl07Zm9yKHZhciBvPTAscj10O288ci5sZW5ndGg7bysrKWxlKGUscltvXSwhMCk7cmV0dXJuIGV9KHt9LGEuZGVmYXVsdFByb3BzLGUpOmV9fSksXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmKFAoeSxnKSxELndhcm5Ub29NYW55Q2xhc3Nlcz1mdW5jdGlvbihlLHQpe3ZhciBuPXt9LG89ITE7cmV0dXJuIGZ1bmN0aW9uKHIpe2lmKCFvJiYobltyXT0hMCxPYmplY3Qua2V5cyhuKS5sZW5ndGg+PTIwMCkpe3ZhciBzPXQ/JyB3aXRoIHRoZSBpZCBvZiBcIicuY29uY2F0KHQsJ1wiJyk6XCJcIjtjb25zb2xlLndhcm4oXCJPdmVyIFwiLmNvbmNhdCgyMDAsXCIgY2xhc3NlcyB3ZXJlIGdlbmVyYXRlZCBmb3IgY29tcG9uZW50IFwiKS5jb25jYXQoZSkuY29uY2F0KHMsXCIuXFxuXCIpK1wiQ29uc2lkZXIgdXNpbmcgdGhlIGF0dHJzIG1ldGhvZCwgdG9nZXRoZXIgd2l0aCBhIHN0eWxlIG9iamVjdCBmb3IgZnJlcXVlbnRseSBjaGFuZ2VkIHN0eWxlcy5cXG5FeGFtcGxlOlxcbiAgY29uc3QgQ29tcG9uZW50ID0gc3R5bGVkLmRpdi5hdHRycyhwcm9wcyA9PiAoe1xcbiAgICBzdHlsZToge1xcbiAgICAgIGJhY2tncm91bmQ6IHByb3BzLmJhY2tncm91bmQsXFxuICAgIH0sXFxuICB9KSlgd2lkdGg6IDEwMCU7YFxcblxcbiAgPENvbXBvbmVudCAvPlwiKSxvPSEwLG49e319fX0oeSxnKSksdWUoRCxmdW5jdGlvbigpe3JldHVyblwiLlwiLmNvbmNhdChELnN0eWxlZENvbXBvbmVudElkKX0pLGMmJm9lKEQsZSx7YXR0cnM6ITAsY29tcG9uZW50U3R5bGU6ITAsZGlzcGxheU5hbWU6ITAsZm9sZGVkQ29tcG9uZW50SWRzOiEwLHNob3VsZEZvcndhcmRQcm9wOiEwLHN0eWxlZENvbXBvbmVudElkOiEwLHRhcmdldDohMH0pLER9ZnVuY3Rpb24gc3QoZSx0KXtmb3IodmFyIG49W2VbMF1dLG89MCxyPXQubGVuZ3RoO288cjtvKz0xKW4ucHVzaCh0W29dLGVbbysxXSk7cmV0dXJuIG59dmFyIGl0PWZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuYXNzaWduKGUse2lzQ3NzOiEwfSl9O2Z1bmN0aW9uIGF0KHQpe2Zvcih2YXIgbj1bXSxvPTE7bzxhcmd1bWVudHMubGVuZ3RoO28rKyluW28tMV09YXJndW1lbnRzW29dO2lmKHJlKHQpfHxjZSh0KSlyZXR1cm4gaXQoVWUoc3QoXyxlKFt0XSxuLCEwKSkpKTt2YXIgcj10O3JldHVybiAwPT09bi5sZW5ndGgmJjE9PT1yLmxlbmd0aCYmXCJzdHJpbmdcIj09dHlwZW9mIHJbMF0/VWUocik6aXQoVWUoc3QocixuKSkpfWZ1bmN0aW9uIGN0KG4sbyxyKXtpZih2b2lkIDA9PT1yJiYocj1DKSwhbyl0aHJvdyBoZSgxLG8pO3ZhciBzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgcz1bXSxpPTE7aTxhcmd1bWVudHMubGVuZ3RoO2krKylzW2ktMV09YXJndW1lbnRzW2ldO3JldHVybiBuKG8scixhdC5hcHBseSh2b2lkIDAsZShbdF0scywhMSkpKX07cmV0dXJuIHMuYXR0cnM9ZnVuY3Rpb24oZSl7cmV0dXJuIGN0KG4sbyx0KHQoe30scikse2F0dHJzOkFycmF5LnByb3RvdHlwZS5jb25jYXQoci5hdHRycyxlKS5maWx0ZXIoQm9vbGVhbil9KSl9LHMud2l0aENvbmZpZz1mdW5jdGlvbihlKXtyZXR1cm4gY3QobixvLHQodCh7fSxyKSxlKSl9LHN9dmFyIGx0PWZ1bmN0aW9uKGUpe3JldHVybiBjdChydCxlKX0sdXQ9bHQ7QS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3V0W2VdPWx0KGUpfSk7dmFyIHB0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3RoaXMucnVsZXM9ZSx0aGlzLmNvbXBvbmVudElkPXQsdGhpcy5pc1N0YXRpYz1KZShlKSxSZS5yZWdpc3RlcklkKHRoaXMuY29tcG9uZW50SWQrMSl9cmV0dXJuIGUucHJvdG90eXBlLmNyZWF0ZVN0eWxlcz1mdW5jdGlvbihlLHQsbixvKXt2YXIgcj1vKGFlKFVlKHRoaXMucnVsZXMsdCxuLG8pKSxcIlwiKSxzPXRoaXMuY29tcG9uZW50SWQrZTtuLmluc2VydFJ1bGVzKHMscyxyKX0sZS5wcm90b3R5cGUucmVtb3ZlU3R5bGVzPWZ1bmN0aW9uKGUsdCl7dC5jbGVhclJ1bGVzKHRoaXMuY29tcG9uZW50SWQrZSl9LGUucHJvdG90eXBlLnJlbmRlclN0eWxlcz1mdW5jdGlvbihlLHQsbixvKXtlPjImJlJlLnJlZ2lzdGVySWQodGhpcy5jb21wb25lbnRJZCtlKSx0aGlzLnJlbW92ZVN0eWxlcyhlLG4pLHRoaXMuY3JlYXRlU3R5bGVzKGUsdCxuLG8pfSxlfSgpO2Z1bmN0aW9uIGR0KG4pe2Zvcih2YXIgcj1bXSxzPTE7czxhcmd1bWVudHMubGVuZ3RoO3MrKylyW3MtMV09YXJndW1lbnRzW3NdO3ZhciBpPWF0LmFwcGx5KHZvaWQgMCxlKFtuXSxyLCExKSksYT1cInNjLWdsb2JhbC1cIi5jb25jYXQoeihKU09OLnN0cmluZ2lmeShpKSkpLGM9bmV3IHB0KGksYSk7XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmUChhKTt2YXIgbD1mdW5jdGlvbihlKXt2YXIgdD1CZSgpLG49by51c2VDb250ZXh0KEtlKSxyPW8udXNlUmVmKHQuc3R5bGVTaGVldC5hbGxvY2F0ZUdTSW5zdGFuY2UoYSkpLmN1cnJlbnQ7cmV0dXJuXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmby5DaGlsZHJlbi5jb3VudChlLmNoaWxkcmVuKSYmY29uc29sZS53YXJuKFwiVGhlIGdsb2JhbCBzdHlsZSBjb21wb25lbnQgXCIuY29uY2F0KGEsXCIgd2FzIGdpdmVuIGNoaWxkIEpTWC4gY3JlYXRlR2xvYmFsU3R5bGUgZG9lcyBub3QgcmVuZGVyIGNoaWxkcmVuLlwiKSksXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmaS5zb21lKGZ1bmN0aW9uKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlJiYtMSE9PWUuaW5kZXhPZihcIkBpbXBvcnRcIil9KSYmY29uc29sZS53YXJuKFwiUGxlYXNlIGRvIG5vdCB1c2UgQGltcG9ydCBDU1Mgc3ludGF4IGluIGNyZWF0ZUdsb2JhbFN0eWxlIGF0IHRoaXMgdGltZSwgYXMgdGhlIENTU09NIEFQSXMgd2UgdXNlIGluIHByb2R1Y3Rpb24gZG8gbm90IGhhbmRsZSBpdCB3ZWxsLiBJbnN0ZWFkLCB3ZSByZWNvbW1lbmQgdXNpbmcgYSBsaWJyYXJ5IHN1Y2ggYXMgcmVhY3QtaGVsbWV0IHRvIGluamVjdCBhIHR5cGljYWwgPGxpbms+IG1ldGEgdGFnIHRvIHRoZSBzdHlsZXNoZWV0LCBvciBzaW1wbHkgZW1iZWRkaW5nIGl0IG1hbnVhbGx5IGluIHlvdXIgaW5kZXguaHRtbCA8aGVhZD4gc2VjdGlvbiBmb3IgYSBzaW1wbGVyIGFwcC5cIiksdC5zdHlsZVNoZWV0LnNlcnZlciYmdShyLGUsdC5zdHlsZVNoZWV0LG4sdC5zdHlsaXMpLG8udXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uKCl7aWYoIXQuc3R5bGVTaGVldC5zZXJ2ZXIpcmV0dXJuIHUocixlLHQuc3R5bGVTaGVldCxuLHQuc3R5bGlzKSxmdW5jdGlvbigpe3JldHVybiBjLnJlbW92ZVN0eWxlcyhyLHQuc3R5bGVTaGVldCl9fSxbcixlLHQuc3R5bGVTaGVldCxuLHQuc3R5bGlzXSksbnVsbH07ZnVuY3Rpb24gdShlLG4sbyxyLHMpe2lmKGMuaXNTdGF0aWMpYy5yZW5kZXJTdHlsZXMoZSxiLG8scyk7ZWxzZXt2YXIgaT10KHQoe30sbikse3RoZW1lOkkobixyLGwuZGVmYXVsdFByb3BzKX0pO2MucmVuZGVyU3R5bGVzKGUsaSxvLHMpfX1yZXR1cm4gby5tZW1vKGwpfWZ1bmN0aW9uIGh0KHQpe2Zvcih2YXIgbj1bXSxvPTE7bzxhcmd1bWVudHMubGVuZ3RoO28rKyluW28tMV09YXJndW1lbnRzW29dO1wicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3ImJlwiUmVhY3ROYXRpdmVcIj09PW5hdmlnYXRvci5wcm9kdWN0JiZjb25zb2xlLndhcm4oXCJga2V5ZnJhbWVzYCBjYW5ub3QgYmUgdXNlZCBvbiBSZWFjdE5hdGl2ZSwgb25seSBvbiB0aGUgd2ViLiBUbyBkbyBhbmltYXRpb24gaW4gUmVhY3ROYXRpdmUgcGxlYXNlIHVzZSBBbmltYXRlZC5cIik7dmFyIHI9YWUoYXQuYXBwbHkodm9pZCAwLGUoW3RdLG4sITEpKSkscz16KHIpO3JldHVybiBuZXcgR2UocyxyKX1mdW5jdGlvbiBmdChlKXt2YXIgbj1vLmZvcndhcmRSZWYoZnVuY3Rpb24obixyKXt2YXIgcz1JKG4sby51c2VDb250ZXh0KEtlKSxlLmRlZmF1bHRQcm9wcyk7cmV0dXJuXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmdm9pZCAwPT09cyYmY29uc29sZS53YXJuKCdbd2l0aFRoZW1lXSBZb3UgYXJlIG5vdCB1c2luZyBhIFRoZW1lUHJvdmlkZXIgbm9yIHBhc3NpbmcgYSB0aGVtZSBwcm9wIG9yIGEgdGhlbWUgaW4gZGVmYXVsdFByb3BzIGluIGNvbXBvbmVudCBjbGFzcyBcIicuY29uY2F0KEIoZSksJ1wiJykpLG8uY3JlYXRlRWxlbWVudChlLHQoe30sbix7dGhlbWU6cyxyZWY6cn0pKX0pO3JldHVybiBuLmRpc3BsYXlOYW1lPVwiV2l0aFRoZW1lKFwiLmNvbmNhdChCKGUpLFwiKVwiKSxvZShuLGUpfXZhciBtdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt2YXIgZT10aGlzO3RoaXMuX2VtaXRTaGVldENTUz1mdW5jdGlvbigpe3ZhciB0PWUuaW5zdGFuY2UudG9TdHJpbmcoKSxuPVBlKCksbz1hZShbbiYmJ25vbmNlPVwiJy5jb25jYXQobiwnXCInKSxcIlwiLmNvbmNhdChmLCc9XCJ0cnVlXCInKSxcIlwiLmNvbmNhdCh5LCc9XCInKS5jb25jYXQodiwnXCInKV0uZmlsdGVyKEJvb2xlYW4pLFwiIFwiKTtyZXR1cm5cIjxzdHlsZSBcIi5jb25jYXQobyxcIj5cIikuY29uY2F0KHQsXCI8L3N0eWxlPlwiKX0sdGhpcy5nZXRTdHlsZVRhZ3M9ZnVuY3Rpb24oKXtpZihlLnNlYWxlZCl0aHJvdyBoZSgyKTtyZXR1cm4gZS5fZW1pdFNoZWV0Q1NTKCl9LHRoaXMuZ2V0U3R5bGVFbGVtZW50PWZ1bmN0aW9uKCl7dmFyIG47aWYoZS5zZWFsZWQpdGhyb3cgaGUoMik7dmFyIHI9KChuPXt9KVtmXT1cIlwiLG5beV09dixuLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXtfX2h0bWw6ZS5pbnN0YW5jZS50b1N0cmluZygpfSxuKSxzPVBlKCk7cmV0dXJuIHMmJihyLm5vbmNlPXMpLFtvLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLHQoe30scix7a2V5Olwic2MtMC0wXCJ9KSldfSx0aGlzLnNlYWw9ZnVuY3Rpb24oKXtlLnNlYWxlZD0hMH0sdGhpcy5pbnN0YW5jZT1uZXcgUmUoe2lzU2VydmVyOiEwfSksdGhpcy5zZWFsZWQ9ITF9cmV0dXJuIGUucHJvdG90eXBlLmNvbGxlY3RTdHlsZXM9ZnVuY3Rpb24oZSl7aWYodGhpcy5zZWFsZWQpdGhyb3cgaGUoMik7cmV0dXJuIG8uY3JlYXRlRWxlbWVudChMZSx7c2hlZXQ6dGhpcy5pbnN0YW5jZX0sZSl9LGUucHJvdG90eXBlLmludGVybGVhdmVXaXRoTm9kZVN0cmVhbT1mdW5jdGlvbihlKXt0aHJvdyBoZSgzKX0sZX0oKSx5dD17U3R5bGVTaGVldDpSZSxtYWluU2hlZXQ6VmV9O1wicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3ImJlwiUmVhY3ROYXRpdmVcIj09PW5hdmlnYXRvci5wcm9kdWN0JiZjb25zb2xlLndhcm4oXCJJdCBsb29rcyBsaWtlIHlvdSd2ZSBpbXBvcnRlZCAnc3R5bGVkLWNvbXBvbmVudHMnIG9uIFJlYWN0IE5hdGl2ZS5cXG5QZXJoYXBzIHlvdSdyZSBsb29raW5nIHRvIGltcG9ydCAnc3R5bGVkLWNvbXBvbmVudHMvbmF0aXZlJz9cXG5SZWFkIG1vcmUgYWJvdXQgdGhpcyBhdCBodHRwczovL3d3dy5zdHlsZWQtY29tcG9uZW50cy5jb20vZG9jcy9iYXNpY3MjcmVhY3QtbmF0aXZlXCIpO3ZhciB2dD1cIl9fc2MtXCIuY29uY2F0KGYsXCJfX1wiKTtcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZcInRlc3RcIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiYod2luZG93W3Z0XXx8KHdpbmRvd1t2dF09MCksMT09PXdpbmRvd1t2dF0mJmNvbnNvbGUud2FybihcIkl0IGxvb2tzIGxpa2UgdGhlcmUgYXJlIHNldmVyYWwgaW5zdGFuY2VzIG9mICdzdHlsZWQtY29tcG9uZW50cycgaW5pdGlhbGl6ZWQgaW4gdGhpcyBhcHBsaWNhdGlvbi4gVGhpcyBtYXkgY2F1c2UgZHluYW1pYyBzdHlsZXMgdG8gbm90IHJlbmRlciBwcm9wZXJseSwgZXJyb3JzIGR1cmluZyB0aGUgcmVoeWRyYXRpb24gcHJvY2VzcywgYSBtaXNzaW5nIHRoZW1lIHByb3AsIGFuZCBtYWtlcyB5b3VyIGFwcGxpY2F0aW9uIGJpZ2dlciB3aXRob3V0IGdvb2QgcmVhc29uLlxcblxcblNlZSBodHRwczovL3MtYy5zaC8yQkFYemVkIGZvciBtb3JlIGluZm8uXCIpLHdpbmRvd1t2dF0rPTEpO2V4cG9ydHttdCBhcyBTZXJ2ZXJTdHlsZVNoZWV0LCRlIGFzIFN0eWxlU2hlZXRDb25zdW1lcixNZSBhcyBTdHlsZVNoZWV0Q29udGV4dCxMZSBhcyBTdHlsZVNoZWV0TWFuYWdlcixRZSBhcyBUaGVtZUNvbnN1bWVyLEtlIGFzIFRoZW1lQ29udGV4dCx0dCBhcyBUaGVtZVByb3ZpZGVyLHl0IGFzIF9fUFJJVkFURV9fLGR0IGFzIGNyZWF0ZUdsb2JhbFN0eWxlLGF0IGFzIGNzcyx1dCBhcyBkZWZhdWx0LHNlIGFzIGlzU3R5bGVkQ29tcG9uZW50LGh0IGFzIGtleWZyYW1lcyx1dCBhcyBzdHlsZWQsZXQgYXMgdXNlVGhlbWUsdiBhcyB2ZXJzaW9uLGZ0IGFzIHdpdGhUaGVtZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHlsZWQtY29tcG9uZW50cy5icm93c2VyLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfX3NwcmVhZEFycmF5IiwiZSIsIl9fYXNzaWduIiwidCIsIm4iLCJvIiwidXNlUmVmIiwiciIsInVzZVN0YXRlIiwicyIsInVzZU1lbW8iLCJpIiwidXNlRWZmZWN0IiwiYSIsInVzZUNvbnRleHQiLCJjIiwidXNlRGVidWdWYWx1ZSIsImwiLCJjcmVhdGVFbGVtZW50IiwidSIsInAiLCJkIiwiaCIsImYiLCJwcm9jZXNzIiwiZW52IiwiUkVBQ1RfQVBQX1NDX0FUVFIiLCJTQ19BVFRSIiwibSIsInkiLCJ2IiwiZyIsIlMiLCJ3aW5kb3ciLCJ3IiwiQm9vbGVhbiIsIlNDX0RJU0FCTEVfU1BFRURZIiwiUkVBQ1RfQVBQX1NDX0RJU0FCTEVfU1BFRURZIiwiYiIsIkUiLCJOIiwiU2V0IiwiUCIsImNvbmNhdCIsImNvbnNvbGUiLCJlcnJvciIsImFyZ3VtZW50cyIsImxlbmd0aCIsInRlc3QiLCJkZWxldGUiLCJhcHBseSIsImhhcyIsIndhcm4iLCJhZGQiLCJtZXNzYWdlIiwiXyIsIk9iamVjdCIsImZyZWV6ZSIsIkMiLCJJIiwidGhlbWUiLCJBIiwiTyIsIkQiLCJSIiwicmVwbGFjZSIsIlQiLCJrIiwiaiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIngiLCJNYXRoIiwiYWJzIiwiViIsIkYiLCJNIiwiY2hhckNvZGVBdCIsIiQiLCJ6IiwiQiIsImRpc3BsYXlOYW1lIiwibmFtZSIsIkwiLCJjaGFyQXQiLCJ0b0xvd2VyQ2FzZSIsIkciLCJTeW1ib2wiLCJmb3IiLCJZIiwiVyIsInEiLCJjaGlsZENvbnRleHRUeXBlcyIsImNvbnRleHRUeXBlIiwiY29udGV4dFR5cGVzIiwiZGVmYXVsdFByb3BzIiwiZ2V0RGVmYXVsdFByb3BzIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwibWl4aW5zIiwicHJvcFR5cGVzIiwidHlwZSIsIkgiLCJwcm90b3R5cGUiLCJjYWxsZXIiLCJjYWxsZWUiLCJhcml0eSIsIlUiLCIkJHR5cGVvZiIsImNvbXBhcmUiLCJKIiwicmVuZGVyIiwiWCIsIloiLCJkZWZpbmVQcm9wZXJ0eSIsIksiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiUSIsImdldE93blByb3BlcnR5U3ltYm9scyIsImVlIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidGUiLCJnZXRQcm90b3R5cGVPZiIsIm5lIiwib2UiLCJyZSIsInNlIiwiaWUiLCJhZSIsImNlIiwiY29uc3RydWN0b3IiLCJsZSIsIkFycmF5IiwiaXNBcnJheSIsInVlIiwidmFsdWUiLCJwZSIsImRlIiwicHVzaCIsImZvckVhY2giLCJoZSIsIkVycm9yIiwiam9pbiIsInRyaW0iLCJmZSIsImdyb3VwU2l6ZXMiLCJVaW50MzJBcnJheSIsInRhZyIsImluZGV4T2ZHcm91cCIsImluc2VydFJ1bGVzIiwic2V0IiwiaW5zZXJ0UnVsZSIsImNsZWFyR3JvdXAiLCJkZWxldGVSdWxlIiwiZ2V0R3JvdXAiLCJnZXRSdWxlIiwibWUiLCJNYXAiLCJ5ZSIsInZlIiwiZ2UiLCJnZXQiLCJTZSIsIndlIiwiYmUiLCJSZWdFeHAiLCJFZSIsInNwbGl0IiwicmVnaXN0ZXJOYW1lIiwiTmUiLCJ0ZXh0Q29udGVudCIsIm1hdGNoIiwicGFyc2VJbnQiLCJnZXRUYWciLCJQZSIsIl9fd2VicGFja19ub25jZV9fIiwiX2UiLCJkb2N1bWVudCIsImhlYWQiLCJmcm9tIiwicXVlcnlTZWxlY3RvckFsbCIsIm5leHRTaWJsaW5nIiwic2V0QXR0cmlidXRlIiwiaW5zZXJ0QmVmb3JlIiwiQ2UiLCJlbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVUZXh0Tm9kZSIsInNoZWV0Iiwic3R5bGVTaGVldHMiLCJvd25lck5vZGUiLCJjc3NSdWxlcyIsImNzc1RleHQiLCJJZSIsIm5vZGVzIiwiY2hpbGROb2RlcyIsInJlbW92ZUNoaWxkIiwiQWUiLCJydWxlcyIsInNwbGljZSIsIk9lIiwiRGUiLCJpc1NlcnZlciIsInVzZUNTU09NSW5qZWN0aW9uIiwiUmUiLCJvcHRpb25zIiwiZ3MiLCJuYW1lcyIsInNlcnZlciIsImdldEF0dHJpYnV0ZSIsInBhcmVudE5vZGUiLCJyZWdpc3RlcklkIiwicmVjb25zdHJ1Y3RXaXRoT3B0aW9ucyIsImFsbG9jYXRlR1NJbnN0YW5jZSIsInRhcmdldCIsImhhc05hbWVGb3JJZCIsImNsZWFyTmFtZXMiLCJjbGVhciIsImNsZWFyUnVsZXMiLCJjbGVhclRhZyIsIlRlIiwia2UiLCJqZSIsIm1hcCIsInJlcGxhY2VBbGwiLCJwcm9wcyIsImNoaWxkcmVuIiwieGUiLCJwbHVnaW5zIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwic2xpY2UiLCJSVUxFU0VUIiwiaW5jbHVkZXMiLCJwcmVmaXgiLCJwcmVmaXhlciIsInN0cmluZ2lmeSIsImNvbXBpbGUiLCJuYW1lc3BhY2UiLCJzZXJpYWxpemUiLCJtaWRkbGV3YXJlIiwicnVsZXNoZWV0IiwiaGFzaCIsInJlZHVjZSIsInRvU3RyaW5nIiwiVmUiLCJGZSIsIk1lIiwiY3JlYXRlQ29udGV4dCIsInNob3VsZEZvcndhcmRQcm9wIiwic3R5bGVTaGVldCIsInN0eWxpcyIsIiRlIiwiQ29uc3VtZXIiLCJ6ZSIsIkJlIiwiTGUiLCJzdHlsaXNQbHVnaW5zIiwiZGlzYWJsZUNTU09NSW5qZWN0aW9uIiwiZW5hYmxlVmVuZG9yUHJlZml4ZXMiLCJQcm92aWRlciIsIkdlIiwiaW5qZWN0IiwiaWQiLCJnZXROYW1lIiwiWWUiLCJXZSIsInFlIiwiSGUiLCJoYXNPd25Qcm9wZXJ0eSIsImlzQ3NzIiwiVWUiLCJzdHlsZWRDb21wb25lbnRJZCIsImlzUmVhY3RDb21wb25lbnQiLCJKZSIsIlhlIiwiWmUiLCJzdGF0aWNSdWxlc0lkIiwiaXNTdGF0aWMiLCJjb21wb25lbnRJZCIsImJhc2VIYXNoIiwiYmFzZVN0eWxlIiwiZ2VuZXJhdGVBbmRJbmplY3RTdHlsZXMiLCJLZSIsIlFlIiwiZXQiLCJ0dCIsIm50Iiwib3QiLCJydCIsImF0dHJzIiwicGFyZW50Q29tcG9uZW50SWQiLCJmaWx0ZXIiLCJjb21wb25lbnRTdHlsZSIsImZvbGRlZENvbXBvbmVudElkcyIsImNsYXNzTmFtZSIsImFzIiwiZm9yd2FyZGVkQXMiLCJ3YXJuVG9vTWFueUNsYXNzZXMiLCJyZWYiLCJmb3J3YXJkUmVmIiwiX2ZvbGRlZERlZmF1bHRQcm9wcyIsImtleXMiLCJzdCIsIml0IiwiYXNzaWduIiwiYXQiLCJjdCIsIndpdGhDb25maWciLCJsdCIsInV0IiwicHQiLCJjcmVhdGVTdHlsZXMiLCJyZW1vdmVTdHlsZXMiLCJyZW5kZXJTdHlsZXMiLCJkdCIsIkpTT04iLCJjdXJyZW50IiwiQ2hpbGRyZW4iLCJjb3VudCIsInNvbWUiLCJpbmRleE9mIiwidXNlTGF5b3V0RWZmZWN0IiwibWVtbyIsImh0IiwibmF2aWdhdG9yIiwicHJvZHVjdCIsImZ0IiwibXQiLCJfZW1pdFNoZWV0Q1NTIiwiaW5zdGFuY2UiLCJnZXRTdHlsZVRhZ3MiLCJzZWFsZWQiLCJnZXRTdHlsZUVsZW1lbnQiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCIsIm5vbmNlIiwia2V5Iiwic2VhbCIsImNvbGxlY3RTdHlsZXMiLCJpbnRlcmxlYXZlV2l0aE5vZGVTdHJlYW0iLCJ5dCIsIlN0eWxlU2hlZXQiLCJtYWluU2hlZXQiLCJ2dCIsIlNlcnZlclN0eWxlU2hlZXQiLCJTdHlsZVNoZWV0Q29uc3VtZXIiLCJTdHlsZVNoZWV0Q29udGV4dCIsIlN0eWxlU2hlZXRNYW5hZ2VyIiwiVGhlbWVDb25zdW1lciIsIlRoZW1lQ29udGV4dCIsIlRoZW1lUHJvdmlkZXIiLCJfX1BSSVZBVEVfXyIsImNyZWF0ZUdsb2JhbFN0eWxlIiwiY3NzIiwiZGVmYXVsdCIsImlzU3R5bGVkQ29tcG9uZW50Iiwia2V5ZnJhbWVzIiwic3R5bGVkIiwidXNlVGhlbWUiLCJ2ZXJzaW9uIiwid2l0aFRoZW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/styled-components/dist/styled-components.browser.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/styled-components/node_modules/tslib/tslib.es6.js":
/*!************************************************************************!*\
  !*** ./node_modules/styled-components/node_modules/tslib/tslib.es6.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __assign: function() { return /* binding */ __assign; },\n/* harmony export */   __asyncDelegator: function() { return /* binding */ __asyncDelegator; },\n/* harmony export */   __asyncGenerator: function() { return /* binding */ __asyncGenerator; },\n/* harmony export */   __asyncValues: function() { return /* binding */ __asyncValues; },\n/* harmony export */   __await: function() { return /* binding */ __await; },\n/* harmony export */   __awaiter: function() { return /* binding */ __awaiter; },\n/* harmony export */   __classPrivateFieldGet: function() { return /* binding */ __classPrivateFieldGet; },\n/* harmony export */   __classPrivateFieldIn: function() { return /* binding */ __classPrivateFieldIn; },\n/* harmony export */   __classPrivateFieldSet: function() { return /* binding */ __classPrivateFieldSet; },\n/* harmony export */   __createBinding: function() { return /* binding */ __createBinding; },\n/* harmony export */   __decorate: function() { return /* binding */ __decorate; },\n/* harmony export */   __esDecorate: function() { return /* binding */ __esDecorate; },\n/* harmony export */   __exportStar: function() { return /* binding */ __exportStar; },\n/* harmony export */   __extends: function() { return /* binding */ __extends; },\n/* harmony export */   __generator: function() { return /* binding */ __generator; },\n/* harmony export */   __importDefault: function() { return /* binding */ __importDefault; },\n/* harmony export */   __importStar: function() { return /* binding */ __importStar; },\n/* harmony export */   __makeTemplateObject: function() { return /* binding */ __makeTemplateObject; },\n/* harmony export */   __metadata: function() { return /* binding */ __metadata; },\n/* harmony export */   __param: function() { return /* binding */ __param; },\n/* harmony export */   __propKey: function() { return /* binding */ __propKey; },\n/* harmony export */   __read: function() { return /* binding */ __read; },\n/* harmony export */   __rest: function() { return /* binding */ __rest; },\n/* harmony export */   __runInitializers: function() { return /* binding */ __runInitializers; },\n/* harmony export */   __setFunctionName: function() { return /* binding */ __setFunctionName; },\n/* harmony export */   __spread: function() { return /* binding */ __spread; },\n/* harmony export */   __spreadArray: function() { return /* binding */ __spreadArray; },\n/* harmony export */   __spreadArrays: function() { return /* binding */ __spreadArrays; },\n/* harmony export */   __values: function() { return /* binding */ __values; }\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __decorate(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction __param(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n}\nfunction __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) {\n        if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n        return f;\n    }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for(var i = decorators.length - 1; i >= 0; i--){\n        var context = {};\n        for(var p in contextIn)context[p] = p === \"access\" ? {} : contextIn[p];\n        for(var p in contextIn.access)context.access[p] = contextIn.access[p];\n        context.addInitializer = function(f) {\n            if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n            extraInitializers.push(accept(f || null));\n        };\n        var result = (0, decorators[i])(kind === \"accessor\" ? {\n            get: descriptor.get,\n            set: descriptor.set\n        } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.push(_);\n        } else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.push(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n}\n;\nfunction __runInitializers(thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for(var i = 0; i < initializers.length; i++){\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n}\n;\nfunction __propKey(x) {\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\n}\n;\nfunction __setFunctionName(f, name, prefix) {\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n    return Object.defineProperty(f, \"name\", {\n        configurable: true,\n        value: prefix ? \"\".concat(prefix, \" \", name) : name\n    });\n}\n;\nfunction __metadata(metadataKey, metadataValue) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __generator(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nvar __createBinding = Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n};\nfunction __exportStar(m, o) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __read(o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);\n    } catch (error) {\n        e = {\n            error: error\n        };\n    } finally{\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        } finally{\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n}\n/** @deprecated */ function __spread() {\n    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));\n    return ar;\n}\n/** @deprecated */ function __spreadArrays() {\n    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;\n    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];\n    return r;\n}\nfunction __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\nfunction __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function verb(n) {\n        if (g[n]) i[n] = function(v) {\n            return new Promise(function(a, b) {\n                q.push([\n                    n,\n                    v,\n                    a,\n                    b\n                ]) > 1 || resume(n, v);\n            });\n        };\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n}\nfunction __asyncDelegator(o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function(e) {\n        throw e;\n    }), verb(\"return\"), i[Symbol.iterator] = function() {\n        return this;\n    }, i;\n    function verb(n, f) {\n        i[n] = o[n] ? function(v) {\n            return (p = !p) ? {\n                value: __await(o[n](v)),\n                done: false\n            } : f ? f(v) : v;\n        } : f;\n    }\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\nfunction __makeTemplateObject(cooked, raw) {\n    if (Object.defineProperty) {\n        Object.defineProperty(cooked, \"raw\", {\n            value: raw\n        });\n    } else {\n        cooked.raw = raw;\n    }\n    return cooked;\n}\n;\nvar __setModuleDefault = Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n};\nfunction __importStar(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n}\nfunction __importDefault(mod) {\n    return mod && mod.__esModule ? mod : {\n        default: mod\n    };\n}\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n}\nfunction __classPrivateFieldIn(state, receiver) {\n    if (receiver === null || typeof receiver !== \"object\" && typeof receiver !== \"function\") throw new TypeError(\"Cannot use 'in' operator on non-object\");\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBQzlFLDJCQUEyQixHQUUzQixJQUFJQSxnQkFBZ0IsU0FBU0MsQ0FBQyxFQUFFQyxDQUFDO0lBQzdCRixnQkFBZ0JHLE9BQU9DLGNBQWMsSUFDaEM7UUFBRUMsV0FBVyxFQUFFO0lBQUMsY0FBYUMsU0FBUyxTQUFVTCxDQUFDLEVBQUVDLENBQUM7UUFBSUQsRUFBRUksU0FBUyxHQUFHSDtJQUFHLEtBQzFFLFNBQVVELENBQUMsRUFBRUMsQ0FBQztRQUFJLElBQUssSUFBSUssS0FBS0wsRUFBRyxJQUFJQyxPQUFPSyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUixHQUFHSyxJQUFJTixDQUFDLENBQUNNLEVBQUUsR0FBR0wsQ0FBQyxDQUFDSyxFQUFFO0lBQUU7SUFDcEcsT0FBT1AsY0FBY0MsR0FBR0M7QUFDNUI7QUFFTyxTQUFTUyxVQUFVVixDQUFDLEVBQUVDLENBQUM7SUFDMUIsSUFBSSxPQUFPQSxNQUFNLGNBQWNBLE1BQU0sTUFDakMsTUFBTSxJQUFJVSxVQUFVLHlCQUF5QkMsT0FBT1gsS0FBSztJQUM3REYsY0FBY0MsR0FBR0M7SUFDakIsU0FBU1k7UUFBTyxJQUFJLENBQUNDLFdBQVcsR0FBR2Q7SUFBRztJQUN0Q0EsRUFBRU8sU0FBUyxHQUFHTixNQUFNLE9BQU9DLE9BQU9hLE1BQU0sQ0FBQ2QsS0FBTVksQ0FBQUEsR0FBR04sU0FBUyxHQUFHTixFQUFFTSxTQUFTLEVBQUUsSUFBSU0sSUFBRztBQUN0RjtBQUVPLElBQUlHLFdBQVc7SUFDbEJBLFdBQVdkLE9BQU9lLE1BQU0sSUFBSSxTQUFTRCxTQUFTRSxDQUFDO1FBQzNDLElBQUssSUFBSUMsR0FBR0MsSUFB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QWFELGFBQWFDLFFBQVFBLE1BQU1DLEdBQUcsQ0FBQ0Y7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0eWxlZC1jb21wb25lbnRzL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanM/Zjc5OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXNEZWNvcmF0ZShjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xyXG4gICAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XHJcbiAgICB2YXIga2luZCA9IGNvbnRleHRJbi5raW5kLCBrZXkgPSBraW5kID09PSBcImdldHRlclwiID8gXCJnZXRcIiA6IGtpbmQgPT09IFwic2V0dGVyXCIgPyBcInNldFwiIDogXCJ2YWx1ZVwiO1xyXG4gICAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XHJcbiAgICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcclxuICAgIHZhciBfLCBkb25lID0gZmFsc2U7XHJcbiAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4pIGNvbnRleHRbcF0gPSBwID09PSBcImFjY2Vzc1wiID8ge30gOiBjb250ZXh0SW5bcF07XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XHJcbiAgICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gKDAsIGRlY29yYXRvcnNbaV0pKGtpbmQgPT09IFwiYWNjZXNzb3JcIiA/IHsgZ2V0OiBkZXNjcmlwdG9yLmdldCwgc2V0OiBkZXNjcmlwdG9yLnNldCB9IDogZGVzY3JpcHRvcltrZXldLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgdHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZFwiKTtcclxuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcclxuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcclxuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmluaXQpKSBpbml0aWFsaXplcnMucHVzaChfKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIGlmIChraW5kID09PSBcImZpZWxkXCIpIGluaXRpYWxpemVycy5wdXNoKF8pO1xyXG4gICAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xyXG4gICAgZG9uZSA9IHRydWU7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19ydW5Jbml0aWFsaXplcnModGhpc0FyZywgaW5pdGlhbGl6ZXJzLCB2YWx1ZSkge1xyXG4gICAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhbHVlID0gdXNlVmFsdWUgPyBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnLCB2YWx1ZSkgOiBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcHJvcEtleSh4KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHggPT09IFwic3ltYm9sXCIgPyB4IDogXCJcIi5jb25jYXQoeCk7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zZXRGdW5jdGlvbk5hbWUoZiwgbmFtZSwgcHJlZml4KSB7XHJcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIG5hbWUgPSBuYW1lLmRlc2NyaXB0aW9uID8gXCJbXCIuY29uY2F0KG5hbWUuZGVzY3JpcHRpb24sIFwiXVwiKSA6IFwiXCI7XHJcbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwibmFtZVwiLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHByZWZpeCA/IFwiXCIuY29uY2F0KHByZWZpeCwgXCIgXCIsIG5hbWUpIDogbmFtZSB9KTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IGZhbHNlIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEluKHN0YXRlLCByZWNlaXZlcikge1xyXG4gICAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XHJcbiAgICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJleHRlbmRTdGF0aWNzIiwiZCIsImIiLCJPYmplY3QiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIkFycmF5IiwicCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIl9fZXh0ZW5kcyIsIlR5cGVFcnJvciIsIlN0cmluZyIsIl9fIiwiY29uc3RydWN0b3IiLCJjcmVhdGUiLCJfX2Fzc2lnbiIsImFzc2lnbiIsInQiLCJzIiwiaSIsIm4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcHBseSIsIl9fcmVzdCIsImUiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfX2RlY29yYXRlIiwiZGVjb3JhdG9ycyIsInRhcmdldCIsImtleSIsImRlc2MiLCJjIiwiciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIlJlZmxlY3QiLCJkZWNvcmF0ZSIsImRlZmluZVByb3BlcnR5IiwiX19wYXJhbSIsInBhcmFtSW5kZXgiLCJkZWNvcmF0b3IiLCJfX2VzRGVjb3JhdGUiLCJjdG9yIiwiZGVzY3JpcHRvckluIiwiY29udGV4dEluIiwiaW5pdGlhbGl6ZXJzIiwiZXh0cmFJbml0aWFsaXplcnMiLCJhY2NlcHQiLCJmIiwia2luZCIsImRlc2NyaXB0b3IiLCJuYW1lIiwiXyIsImRvbmUiLCJjb250ZXh0IiwiYWNjZXNzIiwiYWRkSW5pdGlhbGl6ZXIiLCJwdXNoIiwicmVzdWx0IiwiZ2V0Iiwic2V0IiwiaW5pdCIsIl9fcnVuSW5pdGlhbGl6ZXJzIiwidGhpc0FyZyIsInZhbHVlIiwidXNlVmFsdWUiLCJfX3Byb3BLZXkiLCJ4IiwiY29uY2F0IiwiX19zZXRGdW5jdGlvbk5hbWUiLCJwcmVmaXgiLCJkZXNjcmlwdGlvbiIsImNvbmZpZ3VyYWJsZSIsIl9fbWV0YWRhdGEiLCJtZXRhZGF0YUtleSIsIm1ldGFkYXRhVmFsdWUiLCJtZXRhZGF0YSIsIl9fYXdhaXRlciIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwicmVqZWN0ZWQiLCJ0aGVuIiwiX19nZW5lcmF0b3IiLCJib2R5IiwibGFiZWwiLCJzZW50IiwidHJ5cyIsIm9wcyIsInkiLCJnIiwidmVyYiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwidiIsIm9wIiwicG9wIiwiX19jcmVhdGVCaW5kaW5nIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJlbnVtZXJhYmxlIiwiX19leHBvcnRTdGFyIiwiX192YWx1ZXMiLCJfX3JlYWQiLCJhciIsImVycm9yIiwiX19zcHJlYWQiLCJfX3NwcmVhZEFycmF5cyIsImlsIiwiYSIsImoiLCJqbCIsIl9fc3ByZWFkQXJyYXkiLCJ0byIsImZyb20iLCJwYWNrIiwibCIsInNsaWNlIiwiX19hd2FpdCIsIl9fYXN5bmNHZW5lcmF0b3IiLCJhc3luY0l0ZXJhdG9yIiwicSIsInJlc3VtZSIsInNldHRsZSIsImZ1bGZpbGwiLCJzaGlmdCIsIl9fYXN5bmNEZWxlZ2F0b3IiLCJfX2FzeW5jVmFsdWVzIiwiX19tYWtlVGVtcGxhdGVPYmplY3QiLCJjb29rZWQiLCJyYXciLCJfX3NldE1vZHVsZURlZmF1bHQiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJfX2ltcG9ydERlZmF1bHQiLCJkZWZhdWx0IiwiX19jbGFzc1ByaXZhdGVGaWVsZEdldCIsInJlY2VpdmVyIiwic3RhdGUiLCJoYXMiLCJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0IiwiX19jbGFzc1ByaXZhdGVGaWVsZEluIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/styled-components/node_modules/tslib/tslib.es6.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/map/bg.png":
/*!***************************!*\
  !*** ./public/map/bg.png ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/bg.d66df490.png\",\"height\":416,\"width\":599,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fbg.d66df490.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":6});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9tYXAvYmcucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLHdMQUF3TCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvbWFwL2JnLnBuZz9lZGI5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9iZy5kNjZkZjQ5MC5wbmdcIixcImhlaWdodFwiOjQxNixcIndpZHRoXCI6NTk5LFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRmJnLmQ2NmRmNDkwLnBuZyZ3PTgmcT03MFwiLFwiYmx1cldpZHRoXCI6OCxcImJsdXJIZWlnaHRcIjo2fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/map/bg.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/map/bs.png":
/*!***************************!*\
  !*** ./public/map/bs.png ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/bs.c6f25c17.png\",\"height\":58,\"width\":127,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fbs.c6f25c17.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":4});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9tYXAvYnMucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLHVMQUF1TCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvbWFwL2JzLnBuZz9lYzhjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9icy5jNmYyNWMxNy5wbmdcIixcImhlaWdodFwiOjU4LFwid2lkdGhcIjoxMjcsXCJibHVyRGF0YVVSTFwiOlwiL19uZXh0L2ltYWdlP3VybD0lMkZfbmV4dCUyRnN0YXRpYyUyRm1lZGlhJTJGYnMuYzZmMjVjMTcucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjR9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/map/bs.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/map/cb.png":
/*!***************************!*\
  !*** ./public/map/cb.png ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/cb.69f1837f.png\",\"height\":490,\"width\":509,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fcb.69f1837f.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9tYXAvY2IucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLHdMQUF3TCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvbWFwL2NiLnBuZz82OTg4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9jYi42OWYxODM3Zi5wbmdcIixcImhlaWdodFwiOjQ5MCxcIndpZHRoXCI6NTA5LFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRmNiLjY5ZjE4MzdmLnBuZyZ3PTgmcT03MFwiLFwiYmx1cldpZHRoXCI6OCxcImJsdXJIZWlnaHRcIjo4fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/map/cb.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/map/cn.png":
/*!***************************!*\
  !*** ./public/map/cn.png ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/cn.a143a3e9.png\",\"height\":316,\"width\":352,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fcn.a143a3e9.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":7});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9tYXAvY24ucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLHdMQUF3TCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvbWFwL2NuLnBuZz8wNTczIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9jbi5hMTQzYTNlOS5wbmdcIixcImhlaWdodFwiOjMxNixcIndpZHRoXCI6MzUyLFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRmNuLmExNDNhM2U5LnBuZyZ3PTgmcT03MFwiLFwiYmx1cldpZHRoXCI6OCxcImJsdXJIZWlnaHRcIjo3fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/map/cn.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/map/dg.png":
/*!***************************!*\
  !*** ./public/map/dg.png ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/dg.d443015a.png\",\"height\":89,\"width\":137,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fdg.d443015a.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":5});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9tYXAvZGcucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLHVMQUF1TCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvbWFwL2RnLnBuZz84OWI5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9kZy5kNDQzMDE1YS5wbmdcIixcImhlaWdodFwiOjg5LFwid2lkdGhcIjoxMzcsXCJibHVyRGF0YVVSTFwiOlwiL19uZXh0L2ltYWdlP3VybD0lMkZfbmV4dCUyRnN0YXRpYyUyRm1lZGlhJTJGZGcuZDQ0MzAxNWEucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjV9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/map/dg.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/map/dj.png":
/*!***************************!*\
  !*** ./public/map/dj.png ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/dj.cd07c362.png\",\"height\":100,\"width\":73,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fdj.cd07c362.png&w=6&q=70\",\"blurWidth\":6,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9tYXAvZGoucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLHVMQUF1TCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvbWFwL2RqLnBuZz9lOGEwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9kai5jZDA3YzM2Mi5wbmdcIixcImhlaWdodFwiOjEwMCxcIndpZHRoXCI6NzMsXCJibHVyRGF0YVVSTFwiOlwiL19uZXh0L2ltYWdlP3VybD0lMkZfbmV4dCUyRnN0YXRpYyUyRm1lZGlhJTJGZGouY2QwN2MzNjIucG5nJnc9NiZxPTcwXCIsXCJibHVyV2lkdGhcIjo2LFwiYmx1ckhlaWdodFwiOjh9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/map/dj.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/map/gg.png":
/*!***************************!*\
  !*** ./public/map/gg.png ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/gg.1b983cf0.png\",\"height\":394,\"width\":304,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fgg.1b983cf0.png&w=6&q=70\",\"blurWidth\":6,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9tYXAvZ2cucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLHdMQUF3TCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvbWFwL2dnLnBuZz83Zjk1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9nZy4xYjk4M2NmMC5wbmdcIixcImhlaWdodFwiOjM5NCxcIndpZHRoXCI6MzA0LFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRmdnLjFiOTgzY2YwLnBuZyZ3PTYmcT03MFwiLFwiYmx1cldpZHRoXCI6NixcImJsdXJIZWlnaHRcIjo4fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/map/gg.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/map/gj.png":
/*!***************************!*\
  !*** ./public/map/gj.png ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/gj.134822b6.png\",\"height\":68,\"width\":96,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fgj.134822b6.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":6});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9tYXAvZ2oucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLHNMQUFzTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvbWFwL2dqLnBuZz8xMjI3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9nai4xMzQ4MjJiNi5wbmdcIixcImhlaWdodFwiOjY4LFwid2lkdGhcIjo5NixcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZnai4xMzQ4MjJiNi5wbmcmdz04JnE9NzBcIixcImJsdXJXaWR0aFwiOjgsXCJibHVySGVpZ2h0XCI6Nn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/map/gj.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/map/gw.png":
/*!***************************!*\
  !*** ./public/map/gw.png ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/gw.332db5a4.png\",\"height\":398,\"width\":481,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fgw.332db5a4.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":7});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9tYXAvZ3cucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLHdMQUF3TCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvbWFwL2d3LnBuZz9lZWJjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9ndy4zMzJkYjVhNC5wbmdcIixcImhlaWdodFwiOjM5OCxcIndpZHRoXCI6NDgxLFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRmd3LjMzMmRiNWE0LnBuZyZ3PTgmcT03MFwiLFwiYmx1cldpZHRoXCI6OCxcImJsdXJIZWlnaHRcIjo3fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/map/gw.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/map/ic.png":
/*!***************************!*\
  !*** ./public/map/ic.png ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/ic.5a3a3a93.png\",\"height\":74,\"width\":43,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fic.5a3a3a93.png&w=5&q=70\",\"blurWidth\":5,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9tYXAvaWMucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLHNMQUFzTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvbWFwL2ljLnBuZz9hNThlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9pYy41YTNhM2E5My5wbmdcIixcImhlaWdodFwiOjc0LFwid2lkdGhcIjo0MyxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZpYy41YTNhM2E5My5wbmcmdz01JnE9NzBcIixcImJsdXJXaWR0aFwiOjUsXCJibHVySGVpZ2h0XCI6OH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/map/ic.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/map/ic2.png":
/*!****************************!*\
  !*** ./public/map/ic2.png ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/ic2.8dfc73d4.png\",\"height\":75,\"width\":47,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fic2.8dfc73d4.png&w=5&q=70\",\"blurWidth\":5,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9tYXAvaWMyLnBuZyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsQ0FBQyx3TEFBd0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcHVibGljL21hcC9pYzIucG5nP2U5MTQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1wic3JjXCI6XCIvX25leHQvc3RhdGljL21lZGlhL2ljMi44ZGZjNzNkNC5wbmdcIixcImhlaWdodFwiOjc1LFwid2lkdGhcIjo0NyxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZpYzIuOGRmYzczZDQucG5nJnc9NSZxPTcwXCIsXCJibHVyV2lkdGhcIjo1LFwiYmx1ckhlaWdodFwiOjh9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/map/ic2.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/map/jb.png":
/*!***************************!*\
  !*** ./public/map/jb.png ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/jb.acd24ffe.png\",\"height\":242,\"width\":348,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fjb.acd24ffe.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":6});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9tYXAvamIucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLHdMQUF3TCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvbWFwL2piLnBuZz9mNjIxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9qYi5hY2QyNGZmZS5wbmdcIixcImhlaWdodFwiOjI0MixcIndpZHRoXCI6MzQ4LFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRmpiLmFjZDI0ZmZlLnBuZyZ3PTgmcT03MFwiLFwiYmx1cldpZHRoXCI6OCxcImJsdXJIZWlnaHRcIjo2fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/map/jb.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/map/jj.png":
/*!***************************!*\
  !*** ./public/map/jj.png ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/jj.06250b0b.png\",\"height\":198,\"width\":353,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fjj.06250b0b.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":4});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9tYXAvamoucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLHdMQUF3TCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvbWFwL2pqLnBuZz9kNTE3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9qai4wNjI1MGIwYi5wbmdcIixcImhlaWdodFwiOjE5OCxcIndpZHRoXCI6MzUzLFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRmpqLjA2MjUwYjBiLnBuZyZ3PTgmcT03MFwiLFwiYmx1cldpZHRoXCI6OCxcImJsdXJIZWlnaHRcIjo0fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/map/jj.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/map/jn.png":
/*!***************************!*\
  !*** ./public/map/jn.png ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/jn.641c1040.png\",\"height\":328,\"width\":402,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fjn.641c1040.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":7});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9tYXAvam4ucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLHdMQUF3TCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvbWFwL2puLnBuZz85OWEyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9qbi42NDFjMTA0MC5wbmdcIixcImhlaWdodFwiOjMyOCxcIndpZHRoXCI6NDAyLFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRmpuLjY0MWMxMDQwLnBuZyZ3PTgmcT03MFwiLFwiYmx1cldpZHRoXCI6OCxcImJsdXJIZWlnaHRcIjo3fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/map/jn.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/map/kb.png":
/*!***************************!*\
  !*** ./public/map/kb.png ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/kb.3d3648bd.png\",\"height\":416,\"width\":392,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fkb.3d3648bd.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9tYXAva2IucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLHdMQUF3TCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvbWFwL2tiLnBuZz8zMjgzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9rYi4zZDM2NDhiZC5wbmdcIixcImhlaWdodFwiOjQxNixcIndpZHRoXCI6MzkyLFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRmtiLjNkMzY0OGJkLnBuZyZ3PTgmcT03MFwiLFwiYmx1cldpZHRoXCI6OCxcImJsdXJIZWlnaHRcIjo4fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/map/kb.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/map/kn.png":
/*!***************************!*\
  !*** ./public/map/kn.png ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/kn.c1f02883.png\",\"height\":343,\"width\":384,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fkn.c1f02883.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":7});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9tYXAva24ucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLHdMQUF3TCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvbWFwL2tuLnBuZz84OWZjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9rbi5jMWYwMjg4My5wbmdcIixcImhlaWdodFwiOjM0MyxcIndpZHRoXCI6Mzg0LFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRmtuLmMxZjAyODgzLnBuZyZ3PTgmcT03MFwiLFwiYmx1cldpZHRoXCI6OCxcImJsdXJIZWlnaHRcIjo3fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/map/kn.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/map/su.png":
/*!***************************!*\
  !*** ./public/map/su.png ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/su.20aa6f72.png\",\"height\":78,\"width\":98,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fsu.20aa6f72.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":6});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9tYXAvc3UucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLHNMQUFzTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvbWFwL3N1LnBuZz9jYWI1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9zdS4yMGFhNmY3Mi5wbmdcIixcImhlaWdodFwiOjc4LFwid2lkdGhcIjo5OCxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZzdS4yMGFhNmY3Mi5wbmcmdz04JnE9NzBcIixcImJsdXJXaWR0aFwiOjgsXCJibHVySGVpZ2h0XCI6Nn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/map/su.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/map/us.png":
/*!***************************!*\
  !*** ./public/map/us.png ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/us.ce057203.png\",\"height\":104,\"width\":105,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fus.ce057203.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9tYXAvdXMucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLHdMQUF3TCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvbWFwL3VzLnBuZz82NjhhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS91cy5jZTA1NzIwMy5wbmdcIixcImhlaWdodFwiOjEwNCxcIndpZHRoXCI6MTA1LFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRnVzLmNlMDU3MjAzLnBuZyZ3PTgmcT03MFwiLFwiYmx1cldpZHRoXCI6OCxcImJsdXJIZWlnaHRcIjo4fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/map/us.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/components/map/map.tsx":
/*!************************************!*\
  !*** ./app/components/map/map.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Map; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_tagged_template_literal */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_tagged_template_literal.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _public_map_su_png__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/public/map/su.png */ \"(app-pages-browser)/./public/map/su.png\");\n/* harmony import */ var _public_map_ic_png__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/public/map/ic.png */ \"(app-pages-browser)/./public/map/ic.png\");\n/* harmony import */ var _public_map_ic2_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/public/map/ic2.png */ \"(app-pages-browser)/./public/map/ic2.png\");\n/* harmony import */ var _public_map_gg_png__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/public/map/gg.png */ \"(app-pages-browser)/./public/map/gg.png\");\n/* harmony import */ var _public_map_gw_png__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/public/map/gw.png */ \"(app-pages-browser)/./public/map/gw.png\");\n/* harmony import */ var _public_map_cn_png__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/public/map/cn.png */ \"(app-pages-browser)/./public/map/cn.png\");\n/* harmony import */ var _public_map_cb_png__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/public/map/cb.png */ \"(app-pages-browser)/./public/map/cb.png\");\n/* harmony import */ var _public_map_dj_png__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/public/map/dj.png */ \"(app-pages-browser)/./public/map/dj.png\");\n/* harmony import */ var _public_map_kn_png__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @/public/map/kn.png */ \"(app-pages-browser)/./public/map/kn.png\");\n/* harmony import */ var _public_map_kb_png__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @/public/map/kb.png */ \"(app-pages-browser)/./public/map/kb.png\");\n/* harmony import */ var _public_map_dg_png__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @/public/map/dg.png */ \"(app-pages-browser)/./public/map/dg.png\");\n/* harmony import */ var _public_map_us_png__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @/public/map/us.png */ \"(app-pages-browser)/./public/map/us.png\");\n/* harmony import */ var _public_map_bs_png__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @/public/map/bs.png */ \"(app-pages-browser)/./public/map/bs.png\");\n/* harmony import */ var _public_map_jj_png__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @/public/map/jj.png */ \"(app-pages-browser)/./public/map/jj.png\");\n/* harmony import */ var _public_map_gj_png__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @/public/map/gj.png */ \"(app-pages-browser)/./public/map/gj.png\");\n/* harmony import */ var _public_map_jn_png__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @/public/map/jn.png */ \"(app-pages-browser)/./public/map/jn.png\");\n/* harmony import */ var _public_map_jb_png__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @/public/map/jb.png */ \"(app-pages-browser)/./public/map/jb.png\");\n/* harmony import */ var _public_map_bg_png__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @/public/map/bg.png */ \"(app-pages-browser)/./public/map/bg.png\");\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! styled-components */ \"(app-pages-browser)/./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_20__);\n/* harmony import */ var recoil__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! recoil */ \"(app-pages-browser)/./node_modules/recoil/es/index.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/./node_modules/next/dist/api/image.js\");\n/* harmony import */ var _app_recoilContextProvider__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @/app/recoilContextProvider */ \"(app-pages-browser)/./app/recoilContextProvider.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nfunction _templateObject() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n    transform: translate(\",\n        \"px, \",\n        \"px);\\n    scale: 1.4;\\n\"\n    ]);\n    _templateObject = function() {\n        return data;\n    };\n    return data;\n}\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// ssr   \nfunction Map() {\n    _s();\n    const [cursorX, setCursorX] = (0,react__WEBPACK_IMPORTED_MODULE_20__.useState)(0);\n    const [cursorY, setCursorY] = (0,react__WEBPACK_IMPORTED_MODULE_20__.useState)(0);\n    let pivotX, pivotY;\n    // const [selectedIndex, setSelectedIndex] = useState(\"\");\n    const handleOver = ()=>{\n        if (window !== undefined) {\n            window.addEventListener(\"mousemove\", onMouseMove);\n        }\n    };\n    const onMouseMove = (event)=>{\n        if (window !== undefined) {\n            pivotX = window.innerWidth / 2;\n            pivotY = window.innerHeight / 2;\n        }\n        setCursorX(pivotX - event.clientX);\n        setCursorY(pivotY - event.clientY);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(MovingMap, {\n        x: cursorX * 0.1,\n        y: cursorY * 0.2,\n        onMouseOver: handleOver,\n        className: \"flex justify-center items-center w-[300px] h-[200px] scale-[1.4]\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_23__[\"default\"], {\n                src: _public_map_bg_png__WEBPACK_IMPORTED_MODULE_19__[\"default\"],\n                alt: \"bg\",\n                className: \" absolute mt-[450px] ml-[300px] rotate-[-2deg] z-[1] scale-[4.5]\"\n            }, void 0, false, {\n                fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/map.tsx\",\n                lineNumber: 53,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(MapImage, {\n                src: _public_map_ic_png__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n                alt: \"incheon\",\n                width: 22,\n                position: \"map-elem mb-[40px] mr-[160px] z-[100]\"\n            }, void 0, false, {\n                fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/map.tsx\",\n                lineNumber: 54,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(MapImage, {\n                src: _public_map_ic2_png__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n                alt: \"incheon\",\n                width: 24,\n                position: \"map-elem mb-[-32px] ml-[-150px] z-[100]\"\n            }, void 0, false, {\n                fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/map.tsx\",\n                lineNumber: 55,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(MapImage, {\n                src: _public_map_gg_png__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n                alt: \"gyeonggi\",\n                width: 160,\n                position: \"map-elem ml-[-31px] z-[80]\"\n            }, void 0, false, {\n                fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/map.tsx\",\n                lineNumber: 56,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(MapImage, {\n                src: _public_map_su_png__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n                alt: \"seoul\",\n                width: 48,\n                position: \"map-elem ml-[-128px] mb-[-10px] z-[100]\"\n            }, void 0, false, {\n                fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/map.tsx\",\n                lineNumber: 57,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(MapImage, {\n                src: _public_map_gw_png__WEBPACK_IMPORTED_MODULE_6__[\"default\"],\n                alt: \"gangwon\",\n                width: 270,\n                position: \"map-elem mb-[69px] ml-[-8px] z-[80]\"\n            }, void 0, false, {\n                fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/map.tsx\",\n                lineNumber: 58,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(MapImage, {\n                src: _public_map_cn_png__WEBPACK_IMPORTED_MODULE_7__[\"default\"],\n                alt: \"chungnam\",\n                width: 170,\n                position: \"map-elem mt-[315px] ml-[-375px] rotate-[-10deg] z-[100]\"\n            }, void 0, false, {\n                fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/map.tsx\",\n                lineNumber: 59,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(MapImage, {\n                src: _public_map_dj_png__WEBPACK_IMPORTED_MODULE_9__[\"default\"],\n                alt: \"daejeon\",\n                width: 35,\n                position: \"map-elem ml-[-40px] mb-[-340px] rotate-[6deg] z-[100]\"\n            }, void 0, false, {\n                fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/map.tsx\",\n                lineNumber: 60,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(MapImage, {\n                src: _public_map_cb_png__WEBPACK_IMPORTED_MODULE_8__[\"default\"],\n                alt: \"chungnam\",\n                width: 162,\n                position: \"map-elem ml-[-32px] mb-[-253px] rotate-[-19deg] z-[80]\"\n            }, void 0, false, {\n                fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/map.tsx\",\n                lineNumber: 61,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(MapImage, {\n                src: _public_map_kb_png__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n                alt: \"kyungbuk\",\n                width: 209,\n                position: \"map-elem mt-[330px] ml-[-105px] rotate-[-2deg] z-[90]\"\n            }, void 0, false, {\n                fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/map.tsx\",\n                lineNumber: 62,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(MapImage, {\n                src: _public_map_dg_png__WEBPACK_IMPORTED_MODULE_12__[\"default\"],\n                alt: \"daegu\",\n                width: 70,\n                position: \"map-elem mt-[490px] ml-[-155px] rotate-[-47deg] z-[100]\"\n            }, void 0, false, {\n                fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/map.tsx\",\n                lineNumber: 63,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(MapImage, {\n                src: _public_map_jb_png__WEBPACK_IMPORTED_MODULE_18__[\"default\"],\n                alt: \"jeonbuk\",\n                width: 162,\n                position: \"map-elem mb-[-500px] ml-[-275px] z-[80]\"\n            }, void 0, false, {\n                fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/map.tsx\",\n                lineNumber: 64,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(MapImage, {\n                src: _public_map_jn_png__WEBPACK_IMPORTED_MODULE_17__[\"default\"],\n                alt: \"jeonnam\",\n                width: 188,\n                position: \"map-elem ml-[-200px] mb-[-724px] z-[80]\"\n            }, void 0, false, {\n                fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/map.tsx\",\n                lineNumber: 65,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(MapImage, {\n                src: _public_map_gj_png__WEBPACK_IMPORTED_MODULE_16__[\"default\"],\n                alt: \"gwangju\",\n                width: 40,\n                position: \"map-elem mb-[-650px] ml-[-126px] z-[100]\"\n            }, void 0, false, {\n                fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/map.tsx\",\n                lineNumber: 66,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(MapImage, {\n                src: _public_map_kn_png__WEBPACK_IMPORTED_MODULE_10__[\"default\"],\n                alt: \"kyungnam\",\n                width: 178,\n                position: \"map-elem mb-[-610px] ml-[62px] z-[80]\"\n            }, void 0, false, {\n                fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/map.tsx\",\n                lineNumber: 67,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(MapImage, {\n                src: _public_map_us_png__WEBPACK_IMPORTED_MODULE_13__[\"default\"],\n                alt: \"ulsan\",\n                width: 58,\n                position: \"map-elem mt-[550px] ml-[-22px] rotate-[25deg] z-[100]\"\n            }, void 0, false, {\n                fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/map.tsx\",\n                lineNumber: 68,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(MapImage, {\n                src: _public_map_bs_png__WEBPACK_IMPORTED_MODULE_14__[\"default\"],\n                alt: \"busan\",\n                width: 60,\n                position: \"map-elem mt-[630px] ml-[-80px] rotate-[-30deg] z-[110]\"\n            }, void 0, false, {\n                fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/map.tsx\",\n                lineNumber: 69,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(MapImage, {\n                src: _public_map_jj_png__WEBPACK_IMPORTED_MODULE_15__[\"default\"],\n                alt: \"jeju\",\n                width: 100,\n                position: \"map-elem mt-[980px] ml-[-370px] z-[80]\"\n            }, void 0, false, {\n                fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/map.tsx\",\n                lineNumber: 70,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/map.tsx\",\n        lineNumber: 52,\n        columnNumber: 9\n    }, this);\n}\n_s(Map, \"/gtTc70h1eoSh3s2ooG8KcYIkDE=\");\n_c = Map;\nfunction MapImage(props) {\n    _s1();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_22__.useRouter)();\n    const { src, alt, width, position } = props;\n    const set = (0,recoil__WEBPACK_IMPORTED_MODULE_21__.useSetRecoilState)(_app_recoilContextProvider__WEBPACK_IMPORTED_MODULE_24__.selectedPointStore);\n    const handleClick = (e)=>{\n        router.push(\"/\".concat(e.target.alt));\n    };\n    const handleMouseOver = (e)=>{\n        set(e.target.alt);\n    };\n    const handleMouseOut = (e)=>{\n        set(\"\");\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_23__[\"default\"], {\n        src: src,\n        alt: alt,\n        width: width,\n        className: position,\n        onClick: handleClick,\n        onMouseOver: handleMouseOver,\n        onMouseOut: handleMouseOut\n    }, void 0, false, {\n        fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/map.tsx\",\n        lineNumber: 99,\n        columnNumber: 12\n    }, this);\n}\n_s1(MapImage, \"InEi1RY1Q7HxUq4i+kZIYfzscKc=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_22__.useRouter,\n        recoil__WEBPACK_IMPORTED_MODULE_21__.useSetRecoilState\n    ];\n});\n_c1 = MapImage;\nconst MovingMap = styled_components__WEBPACK_IMPORTED_MODULE_25__[\"default\"].div(_templateObject(), (props)=>props.x, (props)=>props.y);\n_c2 = MovingMap;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"Map\");\n$RefreshReg$(_c1, \"MapImage\");\n$RefreshReg$(_c2, \"MovingMap\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL21hcC9tYXAudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVxQztBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNOO0FBQ1U7QUFDQztBQUNRO0FBQ2E7QUFHakUsaUJBQWlCO0FBQ0YsU0FBU3dCOztJQUNwQixNQUFNLENBQUNDLFNBQVNDLFdBQVcsR0FBR1AsZ0RBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDUSxTQUFTQyxXQUFXLEdBQUdULGdEQUFRQSxDQUFDO0lBQ3ZDLElBQUlVLFFBQWVDO0lBQ25CLDBEQUEwRDtJQUUxRCxNQUFNQyxhQUFhO1FBQ2YsSUFBR0MsV0FBV0MsV0FBVztZQUNyQkQsT0FBT0UsZ0JBQWdCLENBQUMsYUFBYUM7UUFDekM7SUFDSjtJQUVBLE1BQU1BLGNBQWMsQ0FBQ0M7UUFDakIsSUFBR0osV0FBV0MsV0FBVztZQUNyQkosU0FBU0csT0FBT0ssVUFBVSxHQUFHO1lBQzdCUCxTQUFTRSxPQUFPTSxXQUFXLEdBQUc7UUFDbEM7UUFDQVosV0FBV0csU0FBU08sTUFBTUcsT0FBTztRQUNqQ1gsV0FBV0UsU0FBU00sTUFBTUksT0FBTztJQUNyQztJQUVBLHFCQUNJLDhEQUFDQztRQUFVQyxHQUFHakIsVUFBUTtRQUFLa0IsR0FBR2hCLFVBQVE7UUFBS2lCLGFBQWFiO1FBQVljLFdBQVU7OzBCQUMxRSw4REFBQ3ZCLG1EQUFLQTtnQkFBQ3dCLEtBQUs3QiwyREFBRUE7Z0JBQUU4QixLQUFJO2dCQUFLRixXQUFVOzs7Ozs7MEJBQ25DLDhEQUFDRztnQkFBU0YsS0FBSzdDLDBEQUFFQTtnQkFBRThDLEtBQUk7Z0JBQVVFLE9BQU87Z0JBQUlDLFVBQVM7Ozs7OzswQkFDckQsOERBQUNGO2dC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QUcsb0JBQ0QsQ0FBQ1gsUUFBVUEsTUFBTVQsQ0FBQyxFQUFPLENBQUNTLFFBQVVBLE1BQU1SLENBQUM7TUFEaEVGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9jb21wb25lbnRzL21hcC9tYXAudHN4PzFhZmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgc3UgZnJvbSAnQC9wdWJsaWMvbWFwL3N1LnBuZyc7IFxuaW1wb3J0IGljIGZyb20gJ0AvcHVibGljL21hcC9pYy5wbmcnOyBcbmltcG9ydCBpYzIgZnJvbSAnQC9wdWJsaWMvbWFwL2ljMi5wbmcnOyBcbmltcG9ydCBnZyBmcm9tICdAL3B1YmxpYy9tYXAvZ2cucG5nJzsgXG5pbXBvcnQgZ3cgZnJvbSAnQC9wdWJsaWMvbWFwL2d3LnBuZyc7IFxuaW1wb3J0IGNuIGZyb20gJ0AvcHVibGljL21hcC9jbi5wbmcnOyBcbmltcG9ydCBjYiBmcm9tICdAL3B1YmxpYy9tYXAvY2IucG5nJzsgXG5pbXBvcnQgZGogZnJvbSAnQC9wdWJsaWMvbWFwL2RqLnBuZyc7IFxuaW1wb3J0IGtuIGZyb20gJ0AvcHVibGljL21hcC9rbi5wbmcnOyBcbmltcG9ydCBrYiBmcm9tICdAL3B1YmxpYy9tYXAva2IucG5nJzsgXG5pbXBvcnQgZGcgZnJvbSAnQC9wdWJsaWMvbWFwL2RnLnBuZyc7IFxuaW1wb3J0IHVzIGZyb20gJ0AvcHVibGljL21hcC91cy5wbmcnOyBcbmltcG9ydCBicyBmcm9tICdAL3B1YmxpYy9tYXAvYnMucG5nJzsgXG5pbXBvcnQgamogZnJvbSAnQC9wdWJsaWMvbWFwL2pqLnBuZyc7IFxuaW1wb3J0IGdqIGZyb20gJ0AvcHVibGljL21hcC9nai5wbmcnOyBcbmltcG9ydCBqbiBmcm9tICdAL3B1YmxpYy9tYXAvam4ucG5nJzsgXG5pbXBvcnQgamIgZnJvbSAnQC9wdWJsaWMvbWFwL2piLnBuZyc7IFxuaW1wb3J0IGJnIGZyb20gJ0AvcHVibGljL21hcC9iZy5wbmcnO1xuaW1wb3J0IHN0eWxlZCBmcm9tICdzdHlsZWQtY29tcG9uZW50cyc7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVNldFJlY29pbFN0YXRlIH0gZnJvbSAncmVjb2lsJztcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvbmF2aWdhdGlvbic7XG5pbXBvcnQgSW1hZ2UsIHsgU3RhdGljSW1hZ2VEYXRhIH0gZnJvbSAnbmV4dC9pbWFnZSc7XG5pbXBvcnQgeyBzZWxlY3RlZFBvaW50U3RvcmUgfSBmcm9tICdAL2FwcC9yZWNvaWxDb250ZXh0UHJvdmlkZXInO1xuXG5cbi8vIHNzcuuhnCDtnojtirjrp7Ug7KCV67O0IOuwm+q4sFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWFwKCkge1xuICAgIGNvbnN0IFtjdXJzb3JYLCBzZXRDdXJzb3JYXSA9IHVzZVN0YXRlKDApO1xuICAgIGNvbnN0IFtjdXJzb3JZLCBzZXRDdXJzb3JZXSA9IHVzZVN0YXRlKDApO1xuICAgIGxldCBwaXZvdFg6bnVtYmVyLCBwaXZvdFk6bnVtYmVyO1xuICAgIC8vIGNvbnN0IFtzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4XSA9IHVzZVN0YXRlKFwiXCIpO1xuXG4gICAgY29uc3QgaGFuZGxlT3ZlciA9ICgpID0+IHtcbiAgICAgICAgaWYod2luZG93ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc3Qgb25Nb3VzZU1vdmUgPSAoZXZlbnQ6YW55KSA9PiB7XG4gICAgICAgIGlmKHdpbmRvdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwaXZvdFggPSB3aW5kb3cuaW5uZXJXaWR0aCAvIDI7XG4gICAgICAgICAgICBwaXZvdFkgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgICAgIHNldEN1cnNvclgocGl2b3RYIC0gZXZlbnQuY2xpZW50WCk7XG4gICAgICAgIHNldEN1cnNvclkocGl2b3RZIC0gZXZlbnQuY2xpZW50WSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPE1vdmluZ01hcCB4PXtjdXJzb3JYKjAuMX0geT17Y3Vyc29yWSowLjJ9IG9uTW91c2VPdmVyPXtoYW5kbGVPdmVyfSBjbGFzc05hbWU9J2ZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHctWzMwMHB4XSBoLVsyMDBweF0gc2NhbGUtWzEuNF0nPlxuICAgICAgICAgICAgPEltYWdlIHNyYz17Ymd9IGFsdD0nYmcnIGNsYXNzTmFtZT0nIGFic29sdXRlIG10LVs0NTBweF0gbWwtWzMwMHB4XSByb3RhdGUtWy0yZGVnXSB6LVsxXSBzY2FsZS1bNC41XScgLz5cbiAgICAgICAgICAgIDxNYXBJbWFnZSBzcmM9e2ljfSBhbHQ9XCJpbmNoZW9uXCIgd2lkdGg9ezIyfSBwb3NpdGlvbj0nbWFwLWVsZW0gbWItWzQwcHhdIG1yLVsxNjBweF0gei1bMTAwXScgLz5cbiAgICAgICAgICAgIDxNYXBJbWFnZSBzcmM9e2ljMn0gYWx0PVwiaW5jaGVvblwiIHdpZHRoPXsyNH0gcG9zaXRpb249J21hcC1lbGVtIG1iLVstMzJweF0gbWwtWy0xNTBweF0gei1bMTAwXScgLz5cbiAgICAgICAgICAgIDxNYXBJbWFnZSBzcmM9e2dnfSBhbHQ9XCJneWVvbmdnaVwiIHdpZHRoPXsxNjB9IHBvc2l0aW9uPSdtYXAtZWxlbSBtbC1bLTMxcHhdIHotWzgwXScgLz5cbiAgICAgICAgICAgIDxNYXBJbWFnZSBzcmM9e3N1fSBhbHQ9XCJzZW91bFwiIHdpZHRoPXs0OH0gcG9zaXRpb249J21hcC1lbGVtIG1sLVstMTI4cHhdIG1iLVstMTBweF0gei1bMTAwXScgLz5cbiAgICAgICAgICAgIDxNYXBJbWFnZSBzcmM9e2d3fSBhbHQ9XCJnYW5nd29uXCIgd2lkdGg9ezI3MH0gcG9zaXRpb249J21hcC1lbGVtIG1iLVs2OXB4XSBtbC1bLThweF0gei1bODBdJyAvPlxuICAgICAgICAgICAgPE1hcEltYWdlIHNyYz17Y259IGFsdD1cImNodW5nbmFtXCIgd2lkdGg9ezE3MH0gcG9zaXRpb249J21hcC1lbGVtIG10LVszMTVweF0gbWwtWy0zNzVweF0gcm90YXRlLVstMTBkZWddIHotWzEwMF0nIC8+XG4gICAgICAgICAgICA8TWFwSW1hZ2Ugc3JjPXtkan0gYWx0PVwiZGFlamVvblwiIHdpZHRoPXszNX0gcG9zaXRpb249J21hcC1lbGVtIG1sLVstNDBweF0gbWItWy0zNDBweF0gcm90YXRlLVs2ZGVnXSB6LVsxMDBdJyAvPlxuICAgICAgICAgICAgPE1hcEltYWdlIHNyYz17Y2J9IGFsdD1cImNodW5nbmFtXCIgd2lkdGg9ezE2Mn0gcG9zaXRpb249J21hcC1lbGVtIG1sLVstMzJweF0gbWItWy0yNTNweF0gcm90YXRlLVstMTlkZWddIHotWzgwXScgLz5cbiAgICAgICAgICAgIDxNYXBJbWFnZSBzcmM9e2tifSBhbHQ9XCJreXVuZ2J1a1wiIHdpZHRoPXsyMDl9IHBvc2l0aW9uPSdtYXAtZWxlbSBtdC1bMzMwcHhdIG1sLVstMTA1cHhdIHJvdGF0ZS1bLTJkZWddIHotWzkwXScgLz5cbiAgICAgICAgICAgIDxNYXBJbWFnZSBzcmM9e2RnfSBhbHQ9XCJkYWVndVwiIHdpZHRoPXs3MH0gcG9zaXRpb249J21hcC1lbGVtIG10LVs0OTBweF0gbWwtWy0xNTVweF0gcm90YXRlLVstNDdkZWddIHotWzEwMF0nIC8+XG4gICAgICAgICAgICA8TWFwSW1hZ2Ugc3JjPXtqYn0gYWx0PVwiamVvbmJ1a1wiIHdpZHRoPXsxNjJ9IHBvc2l0aW9uPSdtYXAtZWxlbSBtYi1bLTUwMHB4XSBtbC1bLTI3NXB4XSB6LVs4MF0nIC8+XG4gICAgICAgICAgICA8TWFwSW1hZ2Ugc3JjPXtqbn0gYWx0PVwiamVvbm5hbVwiIHdpZHRoPXsxODh9IHBvc2l0aW9uPSdtYXAtZWxlbSBtbC1bLTIwMHB4XSBtYi1bLTcyNHB4XSB6LVs4MF0nIC8+XG4gICAgICAgICAgICA8TWFwSW1hZ2Ugc3JjPXtnan0gYWx0PVwiZ3dhbmdqdVwiIHdpZHRoPXs0MH0gcG9zaXRpb249J21hcC1lbGVtIG1iLVstNjUwcHhdIG1sLVstMTI2cHhdIHotWzEwMF0nIC8+XG4gICAgICAgICAgICA8TWFwSW1hZ2Ugc3JjPXtrbn0gYWx0PVwia3l1bmduYW1cIiB3aWR0aD17MTc4fSBwb3NpdGlvbj0nbWFwLWVsZW0gbWItWy02MTBweF0gbWwtWzYycHhdIHotWzgwXScgLz5cbiAgICAgICAgICAgIDxNYXBJbWFnZSBzcmM9e3VzfSBhbHQ9XCJ1bHNhblwiIHdpZHRoPXs1OH0gcG9zaXRpb249J21hcC1lbGVtIG10LVs1NTBweF0gbWwtWy0yMnB4XSByb3RhdGUtWzI1ZGVnXSB6LVsxMDBdJyAvPiBcbiAgICAgICAgICAgIDxNYXBJbWFnZSBzcmM9e2JzfSBhbHQ9XCJidXNhblwiIHdpZHRoPXs2MH0gcG9zaXRpb249J21hcC1lbGVtIG10LVs2MzBweF0gbWwtWy04MHB4XSByb3RhdGUtWy0zMGRlZ10gei1bMTEwXScgLz5cbiAgICAgICAgICAgIDxNYXBJbWFnZSBzcmM9e2pqfSBhbHQ9XCJqZWp1XCIgd2lkdGg9ezEwMH0gcG9zaXRpb249J21hcC1lbGVtIG10LVs5ODBweF0gbWwtWy0zNzBweF0gei1bODBdJyAvPlxuICAgICAgICA8L01vdmluZ01hcD5cbiAgICApXG59XG5cbmludGVyZmFjZSBNYXBJbWFnZVByb3BzVHlwZSB7XG4gICAgc3JjOiBTdGF0aWNJbWFnZURhdGE7XG4gICAgYWx0OiBzdHJpbmc7XG4gICAgd2lkdGg6IG51bWJlcjtcbiAgICBwb3NpdGlvbjogc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBNYXBJbWFnZShwcm9wczpNYXBJbWFnZVByb3BzVHlwZSkge1xuICAgIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuICAgIGNvbnN0IHsgc3JjLCBhbHQsIHdpZHRoLCBwb3NpdGlvbiB9ID0gcHJvcHM7XG4gICAgY29uc3Qgc2V0ID0gdXNlU2V0UmVjb2lsU3RhdGUoc2VsZWN0ZWRQb2ludFN0b3JlKTtcblxuICAgIGNvbnN0IGhhbmRsZUNsaWNrID0gKGU6YW55KSA9PiB7XG4gICAgICAgIHJvdXRlci5wdXNoKGAvJHtlLnRhcmdldC5hbHR9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlTW91c2VPdmVyID0gKGU6YW55KSA9PiB7XG4gICAgICAgIHNldChlLnRhcmdldC5hbHQpO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZU1vdXNlT3V0ID0gKGU6YW55KSA9PiB7XG4gICAgICAgIHNldChcIlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gPEltYWdlIFxuICAgICAgICAgICAgc3JjPXtzcmN9IFxuICAgICAgICAgICAgYWx0PXthbHR9IFxuICAgICAgICAgICAgd2lkdGg9e3dpZHRofSBcbiAgICAgICAgICAgIGNsYXNzTmFtZT17cG9zaXRpb259IFxuICAgICAgICAgICAgb25DbGljaz17aGFuZGxlQ2xpY2t9XG4gICAgICAgICAgICBvbk1vdXNlT3Zlcj17aGFuZGxlTW91c2VPdmVyfVxuICAgICAgICAgICAgb25Nb3VzZU91dD17aGFuZGxlTW91c2VPdXR9XG4gICAgICAgICAgICAvPlxufVxuXG5jb25zdCBNb3ZpbmdNYXAgPSBzdHlsZWQuZGl2PHt4Om51bWJlciwgeTpudW1iZXJ9PmBcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgkeyhwcm9wcykgPT4gcHJvcHMueH1weCwgJHsocHJvcHMpID0+IHByb3BzLnl9cHgpO1xuICAgIHNjYWxlOiAxLjQ7XG5gIl0sIm5hbWVzIjpbInN1IiwiaWMiLCJpYzIiLCJnZyIsImd3IiwiY24iLCJjYiIsImRqIiwia24iLCJrYiIsImRnIiwidXMiLCJicyIsImpqIiwiZ2oiLCJqbiIsImpiIiwiYmciLCJzdHlsZWQiLCJ1c2VTdGF0ZSIsInVzZVNldFJlY29pbFN0YXRlIiwidXNlUm91dGVyIiwiSW1hZ2UiLCJzZWxlY3RlZFBvaW50U3RvcmUiLCJNYXAiLCJjdXJzb3JYIiwic2V0Q3Vyc29yWCIsImN1cnNvclkiLCJzZXRDdXJzb3JZIiwicGl2b3RYIiwicGl2b3RZIiwiaGFuZGxlT3ZlciIsIndpbmRvdyIsInVuZGVmaW5lZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbk1vdXNlTW92ZSIsImV2ZW50IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiY2xpZW50WCIsImNsaWVudFkiLCJNb3ZpbmdNYXAiLCJ4IiwieSIsIm9uTW91c2VPdmVyIiwiY2xhc3NOYW1lIiwic3JjIiwiYWx0IiwiTWFwSW1hZ2UiLCJ3aWR0aCIsInBvc2l0aW9uIiwicHJvcHMiLCJyb3V0ZXIiLCJzZXQiLCJoYW5kbGVDbGljayIsImUiLCJwdXNoIiwidGFyZ2V0IiwiaGFuZGxlTW91c2VPdmVyIiwiaGFuZGxlTW91c2VPdXQiLCJvbkNsaWNrIiwib25Nb3VzZU91dCIsImRpdiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/map/map.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/components/map/mapLayout.tsx":
/*!******************************************!*\
  !*** ./app/components/map/mapLayout.tsx ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ MapLayout; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map */ \"(app-pages-browser)/./app/components/map/map.tsx\");\n/* harmony import */ var recoil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! recoil */ \"(app-pages-browser)/./node_modules/recoil/es/index.js\");\n/* harmony import */ var _app_recoilContextProvider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/app/recoilContextProvider */ \"(app-pages-browser)/./app/recoilContextProvider.tsx\");\n/* harmony import */ var _app_functions_switchName__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/app/functions/switchName */ \"(app-pages-browser)/./app/functions/switchName.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\nfunction MapLayout() {\n    _s();\n    const selectedPoint = (0,recoil__WEBPACK_IMPORTED_MODULE_3__.useRecoilValue)(_app_recoilContextProvider__WEBPACK_IMPORTED_MODULE_4__.selectedPointStore);\n    const [displayName, setDisplayName] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\" \");\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setDisplayName((0,_app_functions_switchName__WEBPACK_IMPORTED_MODULE_5__.swtichName)(selectedPoint));\n    }, [\n        selectedPoint\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mr-[10vw] ml-[-10vw] mt-[20vh] w-[10vw]\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"pre\", {\n                    className: \"nnn text-[3rem] text-white\",\n                    children: displayName\n                }, void 0, false, {\n                    fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/mapLayout.tsx\",\n                    lineNumber: 20,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/mapLayout.tsx\",\n                lineNumber: 19,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_map__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/mapLayout.tsx\",\n                lineNumber: 22,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/components/map/mapLayout.tsx\",\n        lineNumber: 18,\n        columnNumber: 9\n    }, this);\n}\n_s(MapLayout, \"UoE3iQ9GebpyE/bm5gvwmSVqYac=\", false, function() {\n    return [\n        recoil__WEBPACK_IMPORTED_MODULE_3__.useRecoilValue\n    ];\n});\n_c = MapLayout;\nvar _c;\n$RefreshReg$(_c, \"MapLayout\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL21hcC9tYXBMYXlvdXQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFNEM7QUFDcEI7QUFDZ0I7QUFDeUI7QUFDVDtBQUV6QyxTQUFTTTs7SUFDcEIsTUFBTUMsZ0JBQWdCSixzREFBY0EsQ0FBQ0MsMEVBQWtCQTtJQUN2RCxNQUFNLENBQUNJLGFBQWFDLGVBQWUsR0FBR1IsK0NBQVFBLENBQXFCO0lBRW5FRCxnREFBU0EsQ0FBQztRQUNOUyxlQUFlSixxRUFBVUEsQ0FBQ0U7SUFDOUIsR0FBRztRQUFDQTtLQUFjO0lBRWxCLHFCQUNJLDhEQUFDRztRQUFJQyxXQUFVOzswQkFDWCw4REFBQ0Q7Z0JBQUlDLFdBQVU7MEJBQ1gsNEVBQUNDO29CQUFJRCxXQUFVOzhCQUE4Qkg7Ozs7Ozs7Ozs7OzBCQUVqRCw4REFBQ04sNENBQUdBOzs7Ozs7Ozs7OztBQUdoQjtHQWhCd0JJOztRQUNFSCxrREFBY0E7OztLQURoQkciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2NvbXBvbmVudHMvbWFwL21hcExheW91dC50c3g/NjJhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBNYXAgZnJvbSBcIi4vbWFwXCI7XG5pbXBvcnQgeyB1c2VSZWNvaWxWYWx1ZSB9IGZyb20gXCJyZWNvaWxcIjtcbmltcG9ydCB7IHNlbGVjdGVkUG9pbnRTdG9yZSB9IGZyb20gXCJAL2FwcC9yZWNvaWxDb250ZXh0UHJvdmlkZXJcIjtcbmltcG9ydCB7IHN3dGljaE5hbWUgfSBmcm9tIFwiQC9hcHAvZnVuY3Rpb25zL3N3aXRjaE5hbWVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWFwTGF5b3V0KCkge1xuICAgIGNvbnN0IHNlbGVjdGVkUG9pbnQgPSB1c2VSZWNvaWxWYWx1ZShzZWxlY3RlZFBvaW50U3RvcmUpO1xuICAgIGNvbnN0IFtkaXNwbGF5TmFtZSwgc2V0RGlzcGxheU5hbWVdID0gdXNlU3RhdGU8c3RyaW5nIHwgdW5kZWZpbmVkPihcIiBcIik7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzZXREaXNwbGF5TmFtZShzd3RpY2hOYW1lKHNlbGVjdGVkUG9pbnQpKTtcbiAgICB9LCBbc2VsZWN0ZWRQb2ludF0pXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nZmxleCc+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1yLVsxMHZ3XSBtbC1bLTEwdnddIG10LVsyMHZoXSB3LVsxMHZ3XVwiPlxuICAgICAgICAgICAgICAgIDxwcmUgY2xhc3NOYW1lPVwibm5uIHRleHQtWzNyZW1dIHRleHQtd2hpdGVcIj57ZGlzcGxheU5hbWV9PC9wcmU+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxNYXAgLz4gXG4gICAgICAgIDwvZGl2PlxuICAgIClcbn0iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJNYXAiLCJ1c2VSZWNvaWxWYWx1ZSIsInNlbGVjdGVkUG9pbnRTdG9yZSIsInN3dGljaE5hbWUiLCJNYXBMYXlvdXQiLCJzZWxlY3RlZFBvaW50IiwiZGlzcGxheU5hbWUiLCJzZXREaXNwbGF5TmFtZSIsImRpdiIsImNsYXNzTmFtZSIsInByZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/map/mapLayout.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/functions/switchName.tsx":
/*!**************************************!*\
  !*** ./app/functions/switchName.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   swtichName: function() { return /* binding */ swtichName; }\n/* harmony export */ });\nconst swtichName = (name)=>{\n    let after;\n    switch(name){\n        case \"gyeonggi\" || 0:\n            after = \"\";\n            return after;\n        case \"incheon\" || 0:\n            after = \"\";\n            return after;\n        case \"seoul\" || 0:\n            after = \"\";\n            return after;\n        case \"kyungnam\" || 0:\n            after = \"\";\n            return after;\n        case \"kyungbuk\" || 0:\n            after = \"\";\n            return after;\n        case \"jeonnam\" || 0:\n            after = \"\";\n            return after;\n        case \"jeonbuk\" || 0:\n            after = \"\";\n            return after;\n        case \"busan\" || 0:\n            after = \"\";\n            return after;\n        case \"ulsan\" || 0:\n            after = \"\";\n            return after;\n        case \"daegu\" || 0:\n            after = \"\";\n            return after;\n        case \"chungbuk\" || 0:\n            after = \"\";\n            return after;\n        case \"chungnam\" || 0:\n            after = \"\";\n            return after;\n        case \"gangwon\" || 0:\n            after = \"\";\n            return after;\n        case \"gwangju\" || 0:\n            after = \"\";\n            return after;\n        case \"daejeon\" || 0:\n            after = \"\";\n            return after;\n        case \"jeju\" || 0:\n            after = \"\";\n            return after;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9mdW5jdGlvbnMvc3dpdGNoTmFtZS50c3giLCJtYXBwaW5ncyI6Ijs7OztBQUVPLE1BQU1BLGFBQWEsQ0FBQ0M7SUFDdkIsSUFBSUM7SUFDSixPQUFPRDtRQUNILEtBQUssY0FBYztZQUFPQyxRQUFRO1lBQU0sT0FBT0E7UUFDL0MsS0FBSyxhQUFhO1lBQU9BLFFBQVE7WUFBTSxPQUFPQTtRQUM5QyxLQUFLLFdBQVc7WUFBT0EsUUFBUTtZQUFNLE9BQU9BO1FBQzVDLEtBQUssY0FBYztZQUFPQSxRQUFRO1lBQVEsT0FBT0E7UUFDakQsS0FBSyxjQUFjO1lBQU9BLFFBQVE7WUFBUSxPQUFPQTtRQUNqRCxLQUFLLGFBQWE7WUFBT0EsUUFBUTtZQUFRLE9BQU9BO1FBQ2hELEtBQUssYUFBYTtZQUFPQSxRQUFRO1lBQVEsT0FBT0E7UUFDaEQsS0FBSyxXQUFXO1lBQU9BLFFBQVE7WUFBTSxPQUFPQTtRQUM1QyxLQUFLLFdBQVc7WUFBT0EsUUFBUTtZQUFNLE9BQU9BO1FBQzVDLEtBQUssV0FBVztZQUFPQSxRQUFRO1lBQU0sT0FBT0E7UUFDNUMsS0FBSyxjQUFjO1lBQU9BLFFBQVE7WUFBUSxPQUFPQTtRQUNqRCxLQUFLLGNBQWM7WUFBT0EsUUFBUTtZQUFRLE9BQU9BO1FBQ2pELEtBQUssYUFBYTtZQUFPQSxRQUFRO1lBQU0sT0FBT0E7UUFDOUMsS0FBSyxhQUFhO1lBQU9BLFFBQVE7WUFBTSxPQUFPQTtRQUM5QyxLQUFLLGFBQWE7WUFBT0EsUUFBUTtZQUFNLE9BQU9BO1FBQzlDLEtBQUssVUFBVTtZQUFPQSxRQUFRO1lBQU0sT0FBT0E7SUFDL0M7QUFDSixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9mdW5jdGlvbnMvc3dpdGNoTmFtZS50c3g/YzE4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXNwYXRjaCwgU2V0U3RhdGVBY3Rpb24gfSBmcm9tIFwicmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IHN3dGljaE5hbWUgPSAobmFtZTpzdHJpbmcpID0+IHtcbiAgICBsZXQgYWZ0ZXI6c3RyaW5nO1xuICAgIHN3aXRjaChuYW1lKSB7XG4gICAgICAgIGNhc2UgJ2d5ZW9uZ2dpJyB8fCAnZ2cnIDogYWZ0ZXIgPSAn6rK96riwJzsgcmV0dXJuIGFmdGVyO1xuICAgICAgICBjYXNlICdpbmNoZW9uJyB8fCAnaWMnIDogYWZ0ZXIgPSAn7J247LKcJzsgcmV0dXJuIGFmdGVyO1xuICAgICAgICBjYXNlICdzZW91bCcgfHwgJ3N1JyA6IGFmdGVyID0gJ+yEnOyauCc7IHJldHVybiBhZnRlcjtcbiAgICAgICAgY2FzZSAna3l1bmduYW0nIHx8ICdrbicgOiBhZnRlciA9ICfqsr3sg4Hrgqjrj4QnOyByZXR1cm4gYWZ0ZXI7XG4gICAgICAgIGNhc2UgJ2t5dW5nYnVrJyB8fCAna2InIDogYWZ0ZXIgPSAn6rK97IOB67aB64+EJzsgcmV0dXJuIGFmdGVyO1xuICAgICAgICBjYXNlICdqZW9ubmFtJyB8fCAnam4nIDogYWZ0ZXIgPSAn7KCE652864Ko64+EJzsgcmV0dXJuIGFmdGVyO1xuICAgICAgICBjYXNlICdqZW9uYnVrJyB8fCAnamInIDogYWZ0ZXIgPSAn7KCE652867aB64+EJzsgcmV0dXJuIGFmdGVyO1xuICAgICAgICBjYXNlICdidXNhbicgfHwgJ2JzJyA6IGFmdGVyID0gJ+u2gOyCsCc7IHJldHVybiBhZnRlcjtcbiAgICAgICAgY2FzZSAndWxzYW4nIHx8ICd1cycgOiBhZnRlciA9ICfsmrjsgrAnOyByZXR1cm4gYWZ0ZXI7XG4gICAgICAgIGNhc2UgJ2RhZWd1JyB8fCAnZGcnIDogYWZ0ZXIgPSAn64yA6rWsJzsgcmV0dXJuIGFmdGVyO1xuICAgICAgICBjYXNlICdjaHVuZ2J1aycgfHwgJ2NiJyA6IGFmdGVyID0gJ+y2qeyyreu2geuPhCc7IHJldHVybiBhZnRlcjtcbiAgICAgICAgY2FzZSAnY2h1bmduYW0nIHx8ICdjbicgOiBhZnRlciA9ICfstqnssq3rgqjrj4QnOyByZXR1cm4gYWZ0ZXI7XG4gICAgICAgIGNhc2UgJ2dhbmd3b24nIHx8ICdndycgOiBhZnRlciA9ICfqsJXsm5AnOyByZXR1cm4gYWZ0ZXI7XG4gICAgICAgIGNhc2UgJ2d3YW5nanUnIHx8ICdnaicgOiBhZnRlciA9ICfqtJHso7wnOyByZXR1cm4gYWZ0ZXI7XG4gICAgICAgIGNhc2UgJ2RhZWplb24nIHx8ICdkaicgOiBhZnRlciA9ICfrjIDsoIQnOyByZXR1cm4gYWZ0ZXI7XG4gICAgICAgIGNhc2UgJ2planUnIHx8ICdqaicgOiBhZnRlciA9ICfsoJzso7wnOyByZXR1cm4gYWZ0ZXI7XG4gICAgfVxufSJdLCJuYW1lcyI6WyJzd3RpY2hOYW1lIiwibmFtZSIsImFmdGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/functions/switchName.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/recoilContextProvider.tsx":
/*!***************************************!*\
  !*** ./app/recoilContextProvider.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   curComments: function() { return /* binding */ curComments; },\n/* harmony export */   curPostStore: function() { return /* binding */ curPostStore; },\n/* harmony export */   \"default\": function() { return /* binding */ RecoilContextProvider; },\n/* harmony export */   idTokenStore: function() { return /* binding */ idTokenStore; },\n/* harmony export */   isLoginStore: function() { return /* binding */ isLoginStore; },\n/* harmony export */   isPostViewOpenStore: function() { return /* binding */ isPostViewOpenStore; },\n/* harmony export */   postCreatedStore: function() { return /* binding */ postCreatedStore; },\n/* harmony export */   profileStore: function() { return /* binding */ profileStore; },\n/* harmony export */   selectedPointStore: function() { return /* binding */ selectedPointStore; },\n/* harmony export */   userDataStore: function() { return /* binding */ userDataStore; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var recoil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! recoil */ \"(app-pages-browser)/./node_modules/recoil/es/index.js\");\n/* __next_internal_client_entry_do_not_use__ postCreatedStore,profileStore,isLoginStore,curComments,idTokenStore,userDataStore,selectedPointStore,curPostStore,isPostViewOpenStore,default auto */ \n\n\nconst postCreatedStore = (0,recoil__WEBPACK_IMPORTED_MODULE_2__.atom)({\n    key: \"postCreated\",\n    default: false\n});\nconst profileStore = (0,recoil__WEBPACK_IMPORTED_MODULE_2__.atom)({\n    key: \"profile\",\n    default: {}\n});\nconst isLoginStore = (0,recoil__WEBPACK_IMPORTED_MODULE_2__.atom)({\n    key: \"isLogin\",\n    default: false\n});\nconst curComments = (0,recoil__WEBPACK_IMPORTED_MODULE_2__.atom)({\n    key: \"curComments\",\n    default: \"\"\n});\nconst idTokenStore = (0,recoil__WEBPACK_IMPORTED_MODULE_2__.atom)({\n    key: \"idTokenStore\",\n    default: \"\"\n});\nconst userDataStore = (0,recoil__WEBPACK_IMPORTED_MODULE_2__.atom)({\n    key: \"userDataStore\",\n    default: null\n});\nconst selectedPointStore = (0,recoil__WEBPACK_IMPORTED_MODULE_2__.atom)({\n    key: \"selectedPointStore\",\n    default: \"\"\n});\nconst curPostStore = (0,recoil__WEBPACK_IMPORTED_MODULE_2__.atom)({\n    key: \"curPostStore\",\n    default: null\n});\nconst isPostViewOpenStore = (0,recoil__WEBPACK_IMPORTED_MODULE_2__.atom)({\n    key: \"isPostViewOpen\",\n    default: false\n});\nfunction RecoilContextProvider(param) {\n    let { children } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(recoil__WEBPACK_IMPORTED_MODULE_2__.RecoilRoot, {\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/hongseungjae/Desktop/learning.js/daedongyourmap/app/recoilContextProvider.tsx\",\n        lineNumber: 80,\n        columnNumber: 12\n    }, this);\n}\n_c = RecoilContextProvider;\nvar _c;\n$RefreshReg$(_c, \"RecoilContextProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9yZWNvaWxDb250ZXh0UHJvdmlkZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUUwQjtBQUNnQjtBQThCbkMsTUFBTUcsbUJBQW1CRCw0Q0FBSUEsQ0FBVTtJQUMxQ0UsS0FBSTtJQUNKQyxTQUFTO0FBQ2IsR0FBRTtBQUVLLE1BQU1DLGVBQWVKLDRDQUFJQSxDQUFNO0lBQ2xDRSxLQUFJO0lBQ0pDLFNBQVMsQ0FBQztBQUNkLEdBQUU7QUFFSyxNQUFNRSxlQUFlTCw0Q0FBSUEsQ0FBVTtJQUN0Q0UsS0FBSTtJQUNKQyxTQUFTO0FBQ2IsR0FBRTtBQUVLLE1BQU1HLGNBQWNOLDRDQUFJQSxDQUFNO0lBQ2pDRSxLQUFJO0lBQ0pDLFNBQVM7QUFDYixHQUFFO0FBRUssTUFBTUksZUFBZVAsNENBQUlBLENBQVM7SUFDckNFLEtBQUk7SUFDSkMsU0FBUztBQUNiLEdBQUU7QUFFSyxNQUFNSyxnQkFBZ0JSLDRDQUFJQSxDQUFzQjtJQUNuREUsS0FBSTtJQUNKQyxTQUFTO0FBQ2IsR0FBRTtBQUVLLE1BQU1NLHFCQUFxQlQsNENBQUlBLENBQVM7SUFDM0NFLEtBQUk7SUFDSkMsU0FBUztBQUNiLEdBQUU7QUFFSyxNQUFNTyxlQUFlViw0Q0FBSUEsQ0FBa0I7SUFDOUNFLEtBQUk7SUFDSkMsU0FBUztBQUNiLEdBQUU7QUFFSyxNQUFNUSxzQkFBc0JYLDRDQUFJQSxDQUFVO0lBQzdDRSxLQUFJO0lBQ0pDLFNBQVE7QUFDWixHQUFFO0FBRWEsU0FBU1Msc0JBQXNCLEtBQXNDO1FBQXRDLEVBQUNDLFFBQVEsRUFBNkIsR0FBdEM7SUFDMUMscUJBQU8sOERBQUNkLDhDQUFVQTtrQkFBR2M7Ozs7OztBQUN6QjtLQUZ3QkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL3JlY29pbENvbnRleHRQcm92aWRlci50c3g/MTcwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgUmVjb2lsUm9vdCwgYXRvbSB9IGZyb20gXCJyZWNvaWxcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VyRGF0YVR5cGV7XG4gICAgZW1haWw6c3RyaW5nIHwgbnVsbCxcbiAgICB1aWQ6c3RyaW5nLFxuICAgIHBob3RvVVJMOnN0cmluZyB8IG51bGwsXG4gICAgaWRUb2tlbjogc3RyaW5nLFxuICAgIHJlZnJlc2hUb2tlbjogc3RyaW5nLFxuICAgIGRpc3BsYXlOYW1lOiBzdHJpbmcgfCBudWxsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUG9zdFR5cGUge1xuICAgIGNyZWF0ZVRpbWU6c3RyaW5nXG4gICAgY29udGVudDpzdHJpbmcsXG4gICAgdGl0bGU6c3RyaW5nLFxuICAgIHBvaW50OnN0cmluZyxcbiAgICBwaG90bzpBcnJheTxhbnk+LFxuICAgIHVzZXI6c3RyaW5nLFxuICAgIGNvbW1lbnRzOkFycmF5PGFueT4sXG4gICAgbmFtZTpzdHJpbmcsXG4gICAgbGlrZXM6QXJyYXk8YW55Pixcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9maWxlVHlwZSB7XG4gICAgZGlzcGxheU5hbWU6IHN0cmluZyB8IG51bGwsXG4gICAgZW1haWw6IHN0cmluZyxcbiAgICBwaG90b1VSTDogc3RyaW5nIHwgbnVsbCxcbiAgICBlbWFpbFZlcmlmaWVkOiBib29sZWFuXG59XG5cbmV4cG9ydCBjb25zdCBwb3N0Q3JlYXRlZFN0b3JlID0gYXRvbTxib29sZWFuPih7XG4gICAga2V5Oidwb3N0Q3JlYXRlZCcsXG4gICAgZGVmYXVsdDogZmFsc2Vcbn0pXG5cbmV4cG9ydCBjb25zdCBwcm9maWxlU3RvcmUgPSBhdG9tPGFueT4oe1xuICAgIGtleToncHJvZmlsZScsXG4gICAgZGVmYXVsdDoge31cbn0pXG5cbmV4cG9ydCBjb25zdCBpc0xvZ2luU3RvcmUgPSBhdG9tPGJvb2xlYW4+KHtcbiAgICBrZXk6J2lzTG9naW4nLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxufSlcblxuZXhwb3J0IGNvbnN0IGN1ckNvbW1lbnRzID0gYXRvbTxhbnk+KHtcbiAgICBrZXk6J2N1ckNvbW1lbnRzJyxcbiAgICBkZWZhdWx0OiBcIlwiLFxufSlcblxuZXhwb3J0IGNvbnN0IGlkVG9rZW5TdG9yZSA9IGF0b208c3RyaW5nPih7XG4gICAga2V5OidpZFRva2VuU3RvcmUnLFxuICAgIGRlZmF1bHQ6IFwiXCJcbn0pXG5cbmV4cG9ydCBjb25zdCB1c2VyRGF0YVN0b3JlID0gYXRvbTxVc2VyRGF0YVR5cGUgfCBudWxsPih7XG4gICAga2V5Oid1c2VyRGF0YVN0b3JlJyxcbiAgICBkZWZhdWx0OiBudWxsXG59KVxuXG5leHBvcnQgY29uc3Qgc2VsZWN0ZWRQb2ludFN0b3JlID0gYXRvbTxzdHJpbmc+KHtcbiAgICBrZXk6J3NlbGVjdGVkUG9pbnRTdG9yZScsXG4gICAgZGVmYXVsdDogXCJcIixcbn0pXG5cbmV4cG9ydCBjb25zdCBjdXJQb3N0U3RvcmUgPSBhdG9tPFBvc3RUeXBlIHwgbnVsbD4oe1xuICAgIGtleTonY3VyUG9zdFN0b3JlJyxcbiAgICBkZWZhdWx0OiBudWxsXG59KVxuXG5leHBvcnQgY29uc3QgaXNQb3N0Vmlld09wZW5TdG9yZSA9IGF0b208Ym9vbGVhbj4oe1xuICAgIGtleTonaXNQb3N0Vmlld09wZW4nLFxuICAgIGRlZmF1bHQ6ZmFsc2Vcbn0pXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJlY29pbENvbnRleHRQcm92aWRlcih7Y2hpbGRyZW59OiB7Y2hpbGRyZW46UmVhY3QuUmVhY3ROb2RlfSkge1xuICAgIHJldHVybiA8UmVjb2lsUm9vdD57IGNoaWxkcmVuIH08L1JlY29pbFJvb3Q+XG59Il0sIm5hbWVzIjpbIlJlYWN0IiwiUmVjb2lsUm9vdCIsImF0b20iLCJwb3N0Q3JlYXRlZFN0b3JlIiwia2V5IiwiZGVmYXVsdCIsInByb2ZpbGVTdG9yZSIsImlzTG9naW5TdG9yZSIsImN1ckNvbW1lbnRzIiwiaWRUb2tlblN0b3JlIiwidXNlckRhdGFTdG9yZSIsInNlbGVjdGVkUG9pbnRTdG9yZSIsImN1clBvc3RTdG9yZSIsImlzUG9zdFZpZXdPcGVuU3RvcmUiLCJSZWNvaWxDb250ZXh0UHJvdmlkZXIiLCJjaGlsZHJlbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/recoilContextProvider.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/image-component.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/client/image-component.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Image\", ({\n    enumerable: true,\n    get: function() {\n        return Image;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nconst _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/head */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\"));\nconst _getimgprops = __webpack_require__(/*! ../shared/lib/get-img-props */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imageconfig = __webpack_require__(/*! ../shared/lib/image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nconst _warnonce = __webpack_require__(/*! ../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\"));\n// This is replaced by webpack define plugin\nconst configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[\"firebasestorage.googleapis.com\"],\"remotePatterns\":[]};\nif (false) {}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized) {\n    const src = img == null ? void 0 : img.src;\n    if (!img || img[\"data-loaded-src\"] === src) {\n        return;\n    }\n    img[\"data-loaded-src\"] = src;\n    const p = \"decode\" in img ? img.decode() : Promise.resolve();\n    p.catch(()=>{}).then(()=>{\n        if (!img.parentElement || !img.isConnected) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        if (placeholder !== \"empty\") {\n            setBlurComplete(true);\n        }\n        if (onLoadRef == null ? void 0 : onLoadRef.current) {\n            // Since we don't have the SyntheticEvent here,\n            // we must create one with the same shape.\n            // See https://reactjs.org/docs/events.html\n            const event = new Event(\"load\");\n            Object.defineProperty(event, \"target\", {\n                writable: false,\n                value: img\n            });\n            let prevented = false;\n            let stopped = false;\n            onLoadRef.current({\n                ...event,\n                nativeEvent: event,\n                currentTarget: img,\n                target: img,\n                isDefaultPrevented: ()=>prevented,\n                isPropagationStopped: ()=>stopped,\n                persist: ()=>{},\n                preventDefault: ()=>{\n                    prevented = true;\n                    event.preventDefault();\n                },\n                stopPropagation: ()=>{\n                    stopped = true;\n                    event.stopPropagation();\n                }\n            });\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            onLoadingCompleteRef.current(img);\n        }\n        if (true) {\n            const origSrc = new URL(src, \"http://n\").searchParams.get(\"url\") || src;\n            if (img.getAttribute(\"data-nimg\") === \"fill\") {\n                if (!unoptimized && (!img.getAttribute(\"sizes\") || img.getAttribute(\"sizes\") === \"100vw\")) {\n                    let widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;\n                    if (widthViewportRatio < 0.6) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                    }\n                }\n                if (img.parentElement) {\n                    const { position } = window.getComputedStyle(img.parentElement);\n                    const valid = [\n                        \"absolute\",\n                        \"fixed\",\n                        \"relative\"\n                    ];\n                    if (!valid.includes(position)) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and parent element with invalid \"position\". Provided \"' + position + '\" should be one of ' + valid.map(String).join(\",\") + \".\");\n                    }\n                }\n                if (img.height === 0) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.');\n                }\n            }\n            const heightModified = img.height.toString() !== img.getAttribute(\"height\");\n            const widthModified = img.width.toString() !== img.getAttribute(\"width\");\n            if (heightModified && !widthModified || !heightModified && widthModified) {\n                (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \\'width: \"auto\"\\' or \\'height: \"auto\"\\' to maintain the aspect ratio.');\n            }\n        }\n    });\n}\nfunction getDynamicProps(fetchPriority) {\n    const [majorStr, minorStr] = _react.version.split(\".\", 2);\n    const major = parseInt(majorStr, 10);\n    const minor = parseInt(minorStr, 10);\n    if (major > 18 || major === 18 && minor >= 3) {\n        // In React 18.3.0 or newer, we must use camelCase\n        // prop to avoid \"Warning: Invalid DOM property\".\n        // See https://github.com/facebook/react/pull/25927\n        return {\n            fetchPriority\n        };\n    }\n    // In React 18.2.0 or older, we must use lowercase prop\n    // to avoid \"Warning: Invalid DOM property\".\n    return {\n        fetchpriority: fetchPriority\n    };\n}\nconst ImageElement = /*#__PURE__*/ (0, _react.forwardRef)((param, forwardedRef)=>{\n    let { src, srcSet, sizes, height, width, decoding, className, style, fetchPriority, placeholder, loading, unoptimized, fill, onLoadRef, onLoadingCompleteRef, setBlurComplete, setShowAltText, onLoad, onError, ...rest } = param;\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"img\", {\n        ...rest,\n        ...getDynamicProps(fetchPriority),\n        // It's intended to keep `loading` before `src` because React updates\n        // props in order which causes Safari/Firefox to not lazy load properly.\n        // See https://github.com/facebook/react/issues/25883\n        loading: loading,\n        width: width,\n        height: height,\n        decoding: decoding,\n        \"data-nimg\": fill ? \"fill\" : \"1\",\n        className: className,\n        style: style,\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        sizes: sizes,\n        srcSet: srcSet,\n        src: src,\n        ref: (0, _react.useCallback)((img)=>{\n            if (forwardedRef) {\n                if (typeof forwardedRef === \"function\") forwardedRef(img);\n                else if (typeof forwardedRef === \"object\") {\n                    // @ts-ignore - .current is read only it's usually assigned by react internally\n                    forwardedRef.current = img;\n                }\n            }\n            if (!img) {\n                return;\n            }\n            if (onError) {\n                // If the image has an error before react hydrates, then the error is lost.\n                // The workaround is to wait until the image is mounted which is after hydration,\n                // then we set the src again to trigger the error handler (if there was an error).\n                // eslint-disable-next-line no-self-assign\n                img.src = img.src;\n            }\n            if (true) {\n                if (!src) {\n                    console.error('Image is missing required \"src\" property:', img);\n                }\n                if (img.getAttribute(\"alt\") === null) {\n                    console.error('Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.');\n                }\n            }\n            if (img.complete) {\n                handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized);\n            }\n        }, [\n            src,\n            placeholder,\n            onLoadRef,\n            onLoadingCompleteRef,\n            setBlurComplete,\n            onError,\n            unoptimized,\n            forwardedRef\n        ]),\n        onLoad: (event)=>{\n            const img = event.currentTarget;\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized);\n        },\n        onError: (event)=>{\n            // if the real image fails to load, this will ensure \"alt\" is visible\n            setShowAltText(true);\n            if (placeholder !== \"empty\") {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    });\n});\nfunction ImagePreload(param) {\n    let { isAppRouter, imgAttributes } = param;\n    const opts = {\n        as: \"image\",\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: imgAttributes.crossOrigin,\n        referrerPolicy: imgAttributes.referrerPolicy,\n        ...getDynamicProps(imgAttributes.fetchPriority)\n    };\n    if (isAppRouter && _reactdom.default.preload) {\n        // See https://github.com/facebook/react/pull/26940\n        _reactdom.default.preload(imgAttributes.src, opts);\n        return null;\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head.default, {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n            rel: \"preload\",\n            // Note how we omit the `href` attribute, as it would only be relevant\n            // for browsers that do not support `imagesrcset`, and in those cases\n            // it would cause the incorrect image to be preloaded.\n            //\n            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n            href: imgAttributes.srcSet ? undefined : imgAttributes.src,\n            ...opts\n        }, \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)\n    });\n}\n_c = ImagePreload;\nconst Image = /*#__PURE__*/ (0, _react.forwardRef)((props, forwardedRef)=>{\n    const pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);\n    const config = (0, _react.useMemo)(()=>{\n        const c = configEnv || configContext || _imageconfig.imageConfigDefault;\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        return {\n            ...c,\n            allSizes,\n            deviceSizes\n        };\n    }, [\n        configContext\n    ]);\n    const { onLoad, onLoadingComplete } = props;\n    const onLoadRef = (0, _react.useRef)(onLoad);\n    (0, _react.useEffect)(()=>{\n        onLoadRef.current = onLoad;\n    }, [\n        onLoad\n    ]);\n    const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);\n    (0, _react.useEffect)(()=>{\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    const [blurComplete, setBlurComplete] = (0, _react.useState)(false);\n    const [showAltText, setShowAltText] = (0, _react.useState)(false);\n    const { props: imgAttributes, meta: imgMeta } = (0, _getimgprops.getImgProps)(props, {\n        defaultLoader: _imageloader.default,\n        imgConf: config,\n        blurComplete,\n        showAltText\n    });\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, {\n                ...imgAttributes,\n                unoptimized: imgMeta.unoptimized,\n                placeholder: imgMeta.placeholder,\n                fill: imgMeta.fill,\n                onLoadRef: onLoadRef,\n                onLoadingCompleteRef: onLoadingCompleteRef,\n                setBlurComplete: setBlurComplete,\n                setShowAltText: setShowAltText,\n                ref: forwardedRef\n            }),\n            imgMeta.priority ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {\n                isAppRouter: isAppRouter,\n                imgAttributes: imgAttributes\n            }) : null\n        ]\n    });\n});\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=image-component.js.map\nvar _c;\n$RefreshReg$(_c, \"ImagePreload\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLWNvbXBvbmVudC5qcyIsIm1hcHBpbmdzIjoicURBRWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILHlDQUF3QztJQUNwQ0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLDJCQUEyQkMsbUJBQU9BLENBQUMsZ0lBQXlDO0FBQ2xGLE1BQU1DLDRCQUE0QkQsbUJBQU9BLENBQUMsa0lBQTBDO0FBQ3BGLE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLHFHQUFtQjtBQUMvQyxNQUFNRyxTQUFTLFdBQVcsR0FBR0YsMEJBQTBCRyxDQUFDLENBQUNKLG1CQUFPQSxDQUFDLG1GQUFPO0FBQ3hFLE1BQU1LLFlBQVksV0FBVyxHQUFHTix5QkFBeUJLLENBQUMsQ0FBQ0osbUJBQU9BLENBQUMsMkZBQVc7QUFDOUUsTUFBTU0sUUFBUSxXQUFXLEdBQUdQLHlCQUF5QkssQ0FBQyxDQUFDSixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDbkYsTUFBTU8sZUFBZVAsbUJBQU9BLENBQUMsNkdBQTZCO0FBQzFELE1BQU1RLGVBQWVSLG1CQUFPQSxDQUFDLDJHQUE0QjtBQUN6RCxNQUFNUyxtQ0FBbUNULG1CQUFPQSxDQUFDLHlKQUFtRDtBQUNwRyxNQUFNVSxZQUFZVixtQkFBT0EsQ0FBQyxpSEFBK0I7QUFDekQsTUFBTVcsOEJBQThCWCxtQkFBT0EsQ0FBQyw2SUFBNkM7QUFDekYsTUFBTVksZUFBZSxXQUFXLEdBQUdiLHlCQUF5QkssQ0FBQyxDQUFDSixtQkFBT0EsQ0FBQyxrSEFBbUM7QUFDekcsNENBQTRDO0FBQzVDLE1BQU1hLFlBQVlDLDBQQUE2QjtBQUMvQyxJQUFJLEtBQTZCLEVBQUUsRUFFbEM7QUFDRCwwRUFBMEU7QUFDMUUsaURBQWlEO0FBQ2pELFNBQVNLLGNBQWNDLEdBQUcsRUFB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LE9BQU9wSCxRQUFRb0gsT0FBTyxDQUFDbUMsVUFBVSxLQUFLLGFBQWE7SUFDckt6SixPQUFPQyxjQUFjLENBQUNDLFFBQVFvSCxPQUFPLEVBQUUsY0FBYztRQUFFbkgsT0FBTztJQUFLO0lBQ25FSCxPQUFPMEosTUFBTSxDQUFDeEosUUFBUW9ILE9BQU8sRUFBRXBIO0lBQy9CeUosT0FBT3pKLE9BQU8sR0FBR0EsUUFBUW9ILE9BQU87QUFDbEMsRUFFQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaW1hZ2UtY29tcG9uZW50LmpzP2FjNDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW1hZ2VcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEltYWdlO1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZFwiKTtcbmNvbnN0IF9qc3hydW50aW1lID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IF9yZWFjdGRvbSA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcInJlYWN0LWRvbVwiKSk7XG5jb25zdCBfaGVhZCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaGVhZFwiKSk7XG5jb25zdCBfZ2V0aW1ncHJvcHMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzXCIpO1xuY29uc3QgX2ltYWdlY29uZmlnID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnXCIpO1xuY29uc3QgX2ltYWdlY29uZmlnY29udGV4dHNoYXJlZHJ1bnRpbWUgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZVwiKTtcbmNvbnN0IF93YXJub25jZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3V0aWxzL3dhcm4tb25jZVwiKTtcbmNvbnN0IF9yb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lXCIpO1xuY29uc3QgX2ltYWdlbG9hZGVyID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwibmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtbG9hZGVyXCIpKTtcbi8vIFRoaXMgaXMgcmVwbGFjZWQgYnkgd2VicGFjayBkZWZpbmUgcGx1Z2luXG5jb25zdCBjb25maWdFbnYgPSBwcm9jZXNzLmVudi5fX05FWFRfSU1BR0VfT1BUUztcbmlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZ2xvYmFsVGhpcy5fX05FWFRfSU1BR0VfSU1QT1JURUQgPSB0cnVlO1xufVxuLy8gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8zOTc3NzgzMy8yNjY1MzUgZm9yIHdoeSB3ZSB1c2UgdGhpcyByZWZcbi8vIGhhbmRsZXIgaW5zdGVhZCBvZiB0aGUgaW1nJ3Mgb25Mb2FkIGF0dHJpYnV0ZS5cbmZ1bmN0aW9uIGhhbmRsZUxvYWRpbmcoaW1nLCBwbGFjZWhvbGRlciwgb25Mb2FkUmVmLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgc2V0Qmx1ckNvbXBsZXRlLCB1bm9wdGltaXplZCkge1xuICAgIGNvbnN0IHNyYyA9IGltZyA9PSBudWxsID8gdm9pZCAwIDogaW1nLnNyYztcbiAgICBpZiAoIWltZyB8fCBpbWdbXCJkYXRhLWxvYWRlZC1zcmNcIl0gPT09IHNyYykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGltZ1tcImRhdGEtbG9hZGVkLXNyY1wiXSA9IHNyYztcbiAgICBjb25zdCBwID0gXCJkZWNvZGVcIiBpbiBpbWcgPyBpbWcuZGVjb2RlKCkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBwLmNhdGNoKCgpPT57fSkudGhlbigoKT0+e1xuICAgICAgICBpZiAoIWltZy5wYXJlbnRFbGVtZW50IHx8ICFpbWcuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vIEV4aXQgZWFybHkgaW4gY2FzZSBvZiByYWNlIGNvbmRpdGlvbjpcbiAgICAgICAgICAgIC8vIC0gb25sb2FkKCkgaXMgY2FsbGVkXG4gICAgICAgICAgICAvLyAtIGRlY29kZSgpIGlzIGNhbGxlZCBidXQgaW5jb21wbGV0ZVxuICAgICAgICAgICAgLy8gLSB1bm1vdW50IGlzIGNhbGxlZFxuICAgICAgICAgICAgLy8gLSBkZWNvZGUoKSBjb21wbGV0ZXNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2Vob2xkZXIgIT09IFwiZW1wdHlcIikge1xuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkxvYWRSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IG9uTG9hZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBoYXZlIHRoZSBTeW50aGV0aWNFdmVudCBoZXJlLFxuICAgICAgICAgICAgLy8gd2UgbXVzdCBjcmVhdGUgb25lIHdpdGggdGhlIHNhbWUgc2hhcGUuXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2V2ZW50cy5odG1sXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudChcImxvYWRcIik7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnQsIFwidGFyZ2V0XCIsIHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGltZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgcHJldmVudGVkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgb25Mb2FkUmVmLmN1cnJlbnQoe1xuICAgICAgICAgICAgICAgIC4uLmV2ZW50LFxuICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiBpbWcsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBpbWcsXG4gICAgICAgICAgICAgICAgaXNEZWZhdWx0UHJldmVudGVkOiAoKT0+cHJldmVudGVkLFxuICAgICAgICAgICAgICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkOiAoKT0+c3RvcHBlZCxcbiAgICAgICAgICAgICAgICBwZXJzaXN0OiAoKT0+e30sXG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6ICgpPT57XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246ICgpPT57XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Mb2FkaW5nQ29tcGxldGVSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQoaW1nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnU3JjID0gbmV3IFVSTChzcmMsIFwiaHR0cDovL25cIikuc2VhcmNoUGFyYW1zLmdldChcInVybFwiKSB8fCBzcmM7XG4gICAgICAgICAgICBpZiAoaW1nLmdldEF0dHJpYnV0ZShcImRhdGEtbmltZ1wiKSA9PT0gXCJmaWxsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVub3B0aW1pemVkICYmICghaW1nLmdldEF0dHJpYnV0ZShcInNpemVzXCIpIHx8IGltZy5nZXRBdHRyaWJ1dGUoXCJzaXplc1wiKSA9PT0gXCIxMDB2d1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgd2lkdGhWaWV3cG9ydFJhdGlvID0gaW1nLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC8gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aFZpZXdwb3J0UmF0aW8gPCAwLjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBvcmlnU3JjICsgJ1wiIGhhcyBcImZpbGxcIiBidXQgaXMgbWlzc2luZyBcInNpemVzXCIgcHJvcC4gUGxlYXNlIGFkZCBpdCB0byBpbXByb3ZlIHBhZ2UgcGVyZm9ybWFuY2UuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI3NpemVzJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGltZy5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9zaXRpb24gfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGltZy5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFic29sdXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImZpeGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJlbGF0aXZlXCJcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWxpZC5pbmNsdWRlcyhwb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBvcmlnU3JjICsgJ1wiIGhhcyBcImZpbGxcIiBhbmQgcGFyZW50IGVsZW1lbnQgd2l0aCBpbnZhbGlkIFwicG9zaXRpb25cIi4gUHJvdmlkZWQgXCInICsgcG9zaXRpb24gKyAnXCIgc2hvdWxkIGJlIG9uZSBvZiAnICsgdmFsaWQubWFwKFN0cmluZykuam9pbihcIixcIikgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGltZy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIG9yaWdTcmMgKyAnXCIgaGFzIFwiZmlsbFwiIGFuZCBhIGhlaWdodCB2YWx1ZSBvZiAwLiBUaGlzIGlzIGxpa2VseSBiZWNhdXNlIHRoZSBwYXJlbnQgZWxlbWVudCBvZiB0aGUgaW1hZ2UgaGFzIG5vdCBiZWVuIHN0eWxlZCB0byBoYXZlIGEgc2V0IGhlaWdodC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWlnaHRNb2RpZmllZCA9IGltZy5oZWlnaHQudG9TdHJpbmcoKSAhPT0gaW1nLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoTW9kaWZpZWQgPSBpbWcud2lkdGgudG9TdHJpbmcoKSAhPT0gaW1nLmdldEF0dHJpYnV0ZShcIndpZHRoXCIpO1xuICAgICAgICAgICAgaWYgKGhlaWdodE1vZGlmaWVkICYmICF3aWR0aE1vZGlmaWVkIHx8ICFoZWlnaHRNb2RpZmllZCAmJiB3aWR0aE1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIG9yaWdTcmMgKyAnXCIgaGFzIGVpdGhlciB3aWR0aCBvciBoZWlnaHQgbW9kaWZpZWQsIGJ1dCBub3QgdGhlIG90aGVyLiBJZiB5b3UgdXNlIENTUyB0byBjaGFuZ2UgdGhlIHNpemUgb2YgeW91ciBpbWFnZSwgYWxzbyBpbmNsdWRlIHRoZSBzdHlsZXMgXFwnd2lkdGg6IFwiYXV0b1wiXFwnIG9yIFxcJ2hlaWdodDogXCJhdXRvXCJcXCcgdG8gbWFpbnRhaW4gdGhlIGFzcGVjdCByYXRpby4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0RHluYW1pY1Byb3BzKGZldGNoUHJpb3JpdHkpIHtcbiAgICBjb25zdCBbbWFqb3JTdHIsIG1pbm9yU3RyXSA9IF9yZWFjdC52ZXJzaW9uLnNwbGl0KFwiLlwiLCAyKTtcbiAgICBjb25zdCBtYWpvciA9IHBhcnNlSW50KG1ham9yU3RyLCAxMCk7XG4gICAgY29uc3QgbWlub3IgPSBwYXJzZUludChtaW5vclN0ciwgMTApO1xuICAgIGlmIChtYWpvciA+IDE4IHx8IG1ham9yID09PSAxOCAmJiBtaW5vciA+PSAzKSB7XG4gICAgICAgIC8vIEluIFJlYWN0IDE4LjMuMCBvciBuZXdlciwgd2UgbXVzdCB1c2UgY2FtZWxDYXNlXG4gICAgICAgIC8vIHByb3AgdG8gYXZvaWQgXCJXYXJuaW5nOiBJbnZhbGlkIERPTSBwcm9wZXJ0eVwiLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjU5MjdcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZldGNoUHJpb3JpdHlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gSW4gUmVhY3QgMTguMi4wIG9yIG9sZGVyLCB3ZSBtdXN0IHVzZSBsb3dlcmNhc2UgcHJvcFxuICAgIC8vIHRvIGF2b2lkIFwiV2FybmluZzogSW52YWxpZCBET00gcHJvcGVydHlcIi5cbiAgICByZXR1cm4ge1xuICAgICAgICBmZXRjaHByaW9yaXR5OiBmZXRjaFByaW9yaXR5XG4gICAgfTtcbn1cbmNvbnN0IEltYWdlRWxlbWVudCA9IC8qI19fUFVSRV9fKi8gKDAsIF9yZWFjdC5mb3J3YXJkUmVmKSgocGFyYW0sIGZvcndhcmRlZFJlZik9PntcbiAgICBsZXQgeyBzcmMsIHNyY1NldCwgc2l6ZXMsIGhlaWdodCwgd2lkdGgsIGRlY29kaW5nLCBjbGFzc05hbWUsIHN0eWxlLCBmZXRjaFByaW9yaXR5LCBwbGFjZWhvbGRlciwgbG9hZGluZywgdW5vcHRpbWl6ZWQsIGZpbGwsIG9uTG9hZFJlZiwgb25Mb2FkaW5nQ29tcGxldGVSZWYsIHNldEJsdXJDb21wbGV0ZSwgc2V0U2hvd0FsdFRleHQsIG9uTG9hZCwgb25FcnJvciwgLi4ucmVzdCB9ID0gcGFyYW07XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoXCJpbWdcIiwge1xuICAgICAgICAuLi5yZXN0LFxuICAgICAgICAuLi5nZXREeW5hbWljUHJvcHMoZmV0Y2hQcmlvcml0eSksXG4gICAgICAgIC8vIEl0J3MgaW50ZW5kZWQgdG8ga2VlcCBgbG9hZGluZ2AgYmVmb3JlIGBzcmNgIGJlY2F1c2UgUmVhY3QgdXBkYXRlc1xuICAgICAgICAvLyBwcm9wcyBpbiBvcmRlciB3aGljaCBjYXVzZXMgU2FmYXJpL0ZpcmVmb3ggdG8gbm90IGxhenkgbG9hZCBwcm9wZXJseS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjU4ODNcbiAgICAgICAgbG9hZGluZzogbG9hZGluZyxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgZGVjb2Rpbmc6IGRlY29kaW5nLFxuICAgICAgICBcImRhdGEtbmltZ1wiOiBmaWxsID8gXCJmaWxsXCIgOiBcIjFcIixcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgLy8gSXQncyBpbnRlbmRlZCB0byBrZWVwIGBzcmNgIHRoZSBsYXN0IGF0dHJpYnV0ZSBiZWNhdXNlIFJlYWN0IHVwZGF0ZXNcbiAgICAgICAgLy8gYXR0cmlidXRlcyBpbiBvcmRlci4gSWYgd2Uga2VlcCBgc3JjYCB0aGUgZmlyc3Qgb25lLCBTYWZhcmkgd2lsbFxuICAgICAgICAvLyBpbW1lZGlhdGVseSBzdGFydCB0byBmZXRjaCBgc3JjYCwgYmVmb3JlIGBzaXplc2AgYW5kIGBzcmNTZXRgIGFyZSBldmVuXG4gICAgICAgIC8vIHVwZGF0ZWQgYnkgUmVhY3QuIFRoYXQgY2F1c2VzIG11bHRpcGxlIHVubmVjZXNzYXJ5IHJlcXVlc3RzIGlmIGBzcmNTZXRgXG4gICAgICAgIC8vIGFuZCBgc2l6ZXNgIGFyZSBkZWZpbmVkLlxuICAgICAgICAvLyBUaGlzIGJ1ZyBjYW5ub3QgYmUgcmVwcm9kdWNlZCBpbiBDaHJvbWUgb3IgRmlyZWZveC5cbiAgICAgICAgc2l6ZXM6IHNpemVzLFxuICAgICAgICBzcmNTZXQ6IHNyY1NldCxcbiAgICAgICAgc3JjOiBzcmMsXG4gICAgICAgIHJlZjogKDAsIF9yZWFjdC51c2VDYWxsYmFjaykoKGltZyk9PntcbiAgICAgICAgICAgIGlmIChmb3J3YXJkZWRSZWYpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcndhcmRlZFJlZiA9PT0gXCJmdW5jdGlvblwiKSBmb3J3YXJkZWRSZWYoaW1nKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZm9yd2FyZGVkUmVmID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSAuY3VycmVudCBpcyByZWFkIG9ubHkgaXQncyB1c3VhbGx5IGFzc2lnbmVkIGJ5IHJlYWN0IGludGVybmFsbHlcbiAgICAgICAgICAgICAgICAgICAgZm9yd2FyZGVkUmVmLmN1cnJlbnQgPSBpbWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpbWFnZSBoYXMgYW4gZXJyb3IgYmVmb3JlIHJlYWN0IGh5ZHJhdGVzLCB0aGVuIHRoZSBlcnJvciBpcyBsb3N0LlxuICAgICAgICAgICAgICAgIC8vIFRoZSB3b3JrYXJvdW5kIGlzIHRvIHdhaXQgdW50aWwgdGhlIGltYWdlIGlzIG1vdW50ZWQgd2hpY2ggaXMgYWZ0ZXIgaHlkcmF0aW9uLFxuICAgICAgICAgICAgICAgIC8vIHRoZW4gd2Ugc2V0IHRoZSBzcmMgYWdhaW4gdG8gdHJpZ2dlciB0aGUgZXJyb3IgaGFuZGxlciAoaWYgdGhlcmUgd2FzIGFuIGVycm9yKS5cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICAgICAgICAgICAgICBpbWcuc3JjID0gaW1nLnNyYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbWFnZSBpcyBtaXNzaW5nIHJlcXVpcmVkIFwic3JjXCIgcHJvcGVydHk6JywgaW1nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGltZy5nZXRBdHRyaWJ1dGUoXCJhbHRcIikgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW1hZ2UgaXMgbWlzc2luZyByZXF1aXJlZCBcImFsdFwiIHByb3BlcnR5LiBQbGVhc2UgYWRkIEFsdGVybmF0aXZlIFRleHQgdG8gZGVzY3JpYmUgdGhlIGltYWdlIGZvciBzY3JlZW4gcmVhZGVycyBhbmQgc2VhcmNoIGVuZ2luZXMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltZy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUxvYWRpbmcoaW1nLCBwbGFjZWhvbGRlciwgb25Mb2FkUmVmLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgc2V0Qmx1ckNvbXBsZXRlLCB1bm9wdGltaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtcbiAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgb25Mb2FkUmVmLFxuICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICAgICAgICBmb3J3YXJkZWRSZWZcbiAgICAgICAgXSksXG4gICAgICAgIG9uTG9hZDogKGV2ZW50KT0+e1xuICAgICAgICAgICAgY29uc3QgaW1nID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgIGhhbmRsZUxvYWRpbmcoaW1nLCBwbGFjZWhvbGRlciwgb25Mb2FkUmVmLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgc2V0Qmx1ckNvbXBsZXRlLCB1bm9wdGltaXplZCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChldmVudCk9PntcbiAgICAgICAgICAgIC8vIGlmIHRoZSByZWFsIGltYWdlIGZhaWxzIHRvIGxvYWQsIHRoaXMgd2lsbCBlbnN1cmUgXCJhbHRcIiBpcyB2aXNpYmxlXG4gICAgICAgICAgICBzZXRTaG93QWx0VGV4dCh0cnVlKTtcbiAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlciAhPT0gXCJlbXB0eVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlYWwgaW1hZ2UgZmFpbHMgdG8gbG9hZCwgdGhpcyB3aWxsIHN0aWxsIHJlbW92ZSB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5mdW5jdGlvbiBJbWFnZVByZWxvYWQocGFyYW0pIHtcbiAgICBsZXQgeyBpc0FwcFJvdXRlciwgaW1nQXR0cmlidXRlcyB9ID0gcGFyYW07XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgYXM6IFwiaW1hZ2VcIixcbiAgICAgICAgaW1hZ2VTcmNTZXQ6IGltZ0F0dHJpYnV0ZXMuc3JjU2V0LFxuICAgICAgICBpbWFnZVNpemVzOiBpbWdBdHRyaWJ1dGVzLnNpemVzLFxuICAgICAgICBjcm9zc09yaWdpbjogaW1nQXR0cmlidXRlcy5jcm9zc09yaWdpbixcbiAgICAgICAgcmVmZXJyZXJQb2xpY3k6IGltZ0F0dHJpYnV0ZXMucmVmZXJyZXJQb2xpY3ksXG4gICAgICAgIC4uLmdldER5bmFtaWNQcm9wcyhpbWdBdHRyaWJ1dGVzLmZldGNoUHJpb3JpdHkpXG4gICAgfTtcbiAgICBpZiAoaXNBcHBSb3V0ZXIgJiYgX3JlYWN0ZG9tLmRlZmF1bHQucHJlbG9hZCkge1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjY5NDBcbiAgICAgICAgX3JlYWN0ZG9tLmRlZmF1bHQucHJlbG9hZChpbWdBdHRyaWJ1dGVzLnNyYywgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiB1cGdyYWRlIHRvIGBAdHlwZXMvcmVhY3QtZG9tQDE4LjMueGBcbiAgICAgICAgb3B0cyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShfaGVhZC5kZWZhdWx0LCB7XG4gICAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKFwibGlua1wiLCB7XG4gICAgICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICAgICAgLy8gTm90ZSBob3cgd2Ugb21pdCB0aGUgYGhyZWZgIGF0dHJpYnV0ZSwgYXMgaXQgd291bGQgb25seSBiZSByZWxldmFudFxuICAgICAgICAgICAgLy8gZm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgYGltYWdlc3Jjc2V0YCwgYW5kIGluIHRob3NlIGNhc2VzXG4gICAgICAgICAgICAvLyBpdCB3b3VsZCBjYXVzZSB0aGUgaW5jb3JyZWN0IGltYWdlIHRvIGJlIHByZWxvYWRlZC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCNhdHRyLWxpbmstaW1hZ2VzcmNzZXRcbiAgICAgICAgICAgIGhyZWY6IGltZ0F0dHJpYnV0ZXMuc3JjU2V0ID8gdW5kZWZpbmVkIDogaW1nQXR0cmlidXRlcy5zcmMsXG4gICAgICAgICAgICAuLi5vcHRzXG4gICAgICAgIH0sIFwiX19uaW1nLVwiICsgaW1nQXR0cmlidXRlcy5zcmMgKyBpbWdBdHRyaWJ1dGVzLnNyY1NldCArIGltZ0F0dHJpYnV0ZXMuc2l6ZXMpXG4gICAgfSk7XG59XG5jb25zdCBJbWFnZSA9IC8qI19fUFVSRV9fKi8gKDAsIF9yZWFjdC5mb3J3YXJkUmVmKSgocHJvcHMsIGZvcndhcmRlZFJlZik9PntcbiAgICBjb25zdCBwYWdlc1JvdXRlciA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lLlJvdXRlckNvbnRleHQpO1xuICAgIC8vIFdlJ3JlIGluIHRoZSBhcHAgZGlyZWN0b3J5IGlmIHRoZXJlIGlzIG5vIHBhZ2VzIHJvdXRlci5cbiAgICBjb25zdCBpc0FwcFJvdXRlciA9ICFwYWdlc1JvdXRlcjtcbiAgICBjb25zdCBjb25maWdDb250ZXh0ID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShfaW1hZ2Vjb25maWdjb250ZXh0c2hhcmVkcnVudGltZS5JbWFnZUNvbmZpZ0NvbnRleHQpO1xuICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBfcmVhY3QudXNlTWVtbykoKCk9PntcbiAgICAgICAgY29uc3QgYyA9IGNvbmZpZ0VudiB8fCBjb25maWdDb250ZXh0IHx8IF9pbWFnZWNvbmZpZy5pbWFnZUNvbmZpZ0RlZmF1bHQ7XG4gICAgICAgIGNvbnN0IGFsbFNpemVzID0gW1xuICAgICAgICAgICAgLi4uYy5kZXZpY2VTaXplcyxcbiAgICAgICAgICAgIC4uLmMuaW1hZ2VTaXplc1xuICAgICAgICBdLnNvcnQoKGEsIGIpPT5hIC0gYik7XG4gICAgICAgIGNvbnN0IGRldmljZVNpemVzID0gYy5kZXZpY2VTaXplcy5zb3J0KChhLCBiKT0+YSAtIGIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uYyxcbiAgICAgICAgICAgIGFsbFNpemVzLFxuICAgICAgICAgICAgZGV2aWNlU2l6ZXNcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGNvbmZpZ0NvbnRleHRcbiAgICBdKTtcbiAgICBjb25zdCB7IG9uTG9hZCwgb25Mb2FkaW5nQ29tcGxldGUgfSA9IHByb3BzO1xuICAgIGNvbnN0IG9uTG9hZFJlZiA9ICgwLCBfcmVhY3QudXNlUmVmKShvbkxvYWQpO1xuICAgICgwLCBfcmVhY3QudXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBvbkxvYWRSZWYuY3VycmVudCA9IG9uTG9hZDtcbiAgICB9LCBbXG4gICAgICAgIG9uTG9hZFxuICAgIF0pO1xuICAgIGNvbnN0IG9uTG9hZGluZ0NvbXBsZXRlUmVmID0gKDAsIF9yZWFjdC51c2VSZWYpKG9uTG9hZGluZ0NvbXBsZXRlKTtcbiAgICAoMCwgX3JlYWN0LnVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYuY3VycmVudCA9IG9uTG9hZGluZ0NvbXBsZXRlO1xuICAgIH0sIFtcbiAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVcbiAgICBdKTtcbiAgICBjb25zdCBbYmx1ckNvbXBsZXRlLCBzZXRCbHVyQ29tcGxldGVdID0gKDAsIF9yZWFjdC51c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGNvbnN0IFtzaG93QWx0VGV4dCwgc2V0U2hvd0FsdFRleHRdID0gKDAsIF9yZWFjdC51c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGNvbnN0IHsgcHJvcHM6IGltZ0F0dHJpYnV0ZXMsIG1ldGE6IGltZ01ldGEgfSA9ICgwLCBfZ2V0aW1ncHJvcHMuZ2V0SW1nUHJvcHMpKHByb3BzLCB7XG4gICAgICAgIGRlZmF1bHRMb2FkZXI6IF9pbWFnZWxvYWRlci5kZWZhdWx0LFxuICAgICAgICBpbWdDb25mOiBjb25maWcsXG4gICAgICAgIGJsdXJDb21wbGV0ZSxcbiAgICAgICAgc2hvd0FsdFRleHRcbiAgICB9KTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4cykoX2pzeHJ1bnRpbWUuRnJhZ21lbnQsIHtcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoSW1hZ2VFbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgLi4uaW1nQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICB1bm9wdGltaXplZDogaW1nTWV0YS51bm9wdGltaXplZCxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogaW1nTWV0YS5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICBmaWxsOiBpbWdNZXRhLmZpbGwsXG4gICAgICAgICAgICAgICAgb25Mb2FkUmVmOiBvbkxvYWRSZWYsXG4gICAgICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWY6IG9uTG9hZGluZ0NvbXBsZXRlUmVmLFxuICAgICAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZTogc2V0Qmx1ckNvbXBsZXRlLFxuICAgICAgICAgICAgICAgIHNldFNob3dBbHRUZXh0OiBzZXRTaG93QWx0VGV4dCxcbiAgICAgICAgICAgICAgICByZWY6IGZvcndhcmRlZFJlZlxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpbWdNZXRhLnByaW9yaXR5ID8gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShJbWFnZVByZWxvYWQsIHtcbiAgICAgICAgICAgICAgICBpc0FwcFJvdXRlcjogaXNBcHBSb3V0ZXIsXG4gICAgICAgICAgICAgICAgaW1nQXR0cmlidXRlczogaW1nQXR0cmlidXRlc1xuICAgICAgICAgICAgfSkgOiBudWxsXG4gICAgICAgIF1cbiAgICB9KTtcbn0pO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS1jb21wb25lbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIkltYWdlIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfanN4cnVudGltZSIsIl9yZWFjdCIsIl8iLCJfcmVhY3Rkb20iLCJfaGVhZCIsIl9nZXRpbWdwcm9wcyIsIl9pbWFnZWNvbmZpZyIsIl9pbWFnZWNvbmZpZ2NvbnRleHRzaGFyZWRydW50aW1lIiwiX3dhcm5vbmNlIiwiX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiX2ltYWdlbG9hZGVyIiwiY29uZmlnRW52IiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JTUFHRV9PUFRTIiwiZ2xvYmFsVGhpcyIsIl9fTkVYVF9JTUFHRV9JTVBPUlRFRCIsImhhbmRsZUxvYWRpbmciLCJpbWciLCJwbGFjZWhvbGRlciIsIm9uTG9hZFJlZiIsIm9uTG9hZGluZ0NvbXBsZXRlUmVmIiwic2V0Qmx1ckNvbXBsZXRlIiwidW5vcHRpbWl6ZWQiLCJzcmMiLCJwIiwiZGVjb2RlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYXRjaCIsInRoZW4iLCJwYXJlbnRFbGVtZW50IiwiaXNDb25uZWN0ZWQiLCJjdXJyZW50IiwiZXZlbnQiLCJFdmVudCIsIndyaXRhYmxlIiwicHJldmVudGVkIiwic3RvcHBlZCIsIm5hdGl2ZUV2ZW50IiwiY3VycmVudFRhcmdldCIsInRhcmdldCIsImlzRGVmYXVsdFByZXZlbnRlZCIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwicGVyc2lzdCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwib3JpZ1NyYyIsIlVSTCIsInNlYXJjaFBhcmFtcyIsImdldEF0dHJpYnV0ZSIsIndpZHRoVmlld3BvcnRSYXRpbyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIndpZHRoIiwid2luZG93IiwiaW5uZXJXaWR0aCIsIndhcm5PbmNlIiwicG9zaXRpb24iLCJnZXRDb21wdXRlZFN0eWxlIiwidmFsaWQiLCJpbmNsdWRlcyIsIm1hcCIsIlN0cmluZyIsImpvaW4iLCJoZWlnaHQiLCJoZWlnaHRNb2RpZmllZCIsInRvU3RyaW5nIiwid2lkdGhNb2RpZmllZCIsImdldER5bmFtaWNQcm9wcyIsImZldGNoUHJpb3JpdHkiLCJtYWpvclN0ciIsIm1pbm9yU3RyIiwidmVyc2lvbiIsInNwbGl0IiwibWFqb3IiLCJwYXJzZUludCIsIm1pbm9yIiwiZmV0Y2hwcmlvcml0eSIsIkltYWdlRWxlbWVudCIsImZvcndhcmRSZWYiLCJwYXJhbSIsImZvcndhcmRlZFJlZiIsInNyY1NldCIsInNpemVzIiwiZGVjb2RpbmciLCJjbGFzc05hbWUiLCJzdHlsZSIsImxvYWRpbmciLCJmaWxsIiwic2V0U2hvd0FsdFRleHQiLCJvbkxvYWQiLCJvbkVycm9yIiwicmVzdCIsImpzeCIsInJlZiIsInVzZUNhbGxiYWNrIiwiY29uc29sZSIsImVycm9yIiwiY29tcGxldGUiLCJJbWFnZVByZWxvYWQiLCJpc0FwcFJvdXRlciIsImltZ0F0dHJpYnV0ZXMiLCJvcHRzIiwiYXMiLCJpbWFnZVNyY1NldCIsImltYWdlU2l6ZXMiLCJjcm9zc09yaWdpbiIsInJlZmVycmVyUG9saWN5IiwiZGVmYXVsdCIsInByZWxvYWQiLCJjaGlsZHJlbiIsInJlbCIsImhyZWYiLCJ1bmRlZmluZWQiLCJwcm9wcyIsInBhZ2VzUm91dGVyIiwidXNlQ29udGV4dCIsIlJvdXRlckNvbnRleHQiLCJjb25maWdDb250ZXh0IiwiSW1hZ2VDb25maWdDb250ZXh0IiwiY29uZmlnIiwidXNlTWVtbyIsImMiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJhbGxTaXplcyIsImRldmljZVNpemVzIiwic29ydCIsImEiLCJiIiwib25Mb2FkaW5nQ29tcGxldGUiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJibHVyQ29tcGxldGUiLCJ1c2VTdGF0ZSIsInNob3dBbHRUZXh0IiwibWV0YSIsImltZ01ldGEiLCJnZXRJbWdQcm9wcyIsImRlZmF1bHRMb2FkZXIiLCJpbWdDb25mIiwianN4cyIsIkZyYWdtZW50IiwicHJpb3JpdHkiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/image-component.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"AmpStateContext\", ({\n    enumerable: true,\n    get: function() {\n        return AmpStateContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst AmpStateContext = _react.default.createContext({});\nif (true) {\n    AmpStateContext.displayName = \"AmpStateContext\";\n} //# sourceMappingURL=amp-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsU0FBUyxXQUFXLEdBQUdGLHlCQUF5QkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyxtRkFBTztBQUN2RSxNQUFNRixrQkFBa0JHLE9BQU9FLE9BQU8sQ0FBQ0MsYUFBYSxDQUFDLENBQUM7QUFDdEQsSUFBSUMsSUFBcUMsRUFBRTtJQUN2Q1AsZ0JBQWdCUSxXQUFXLEdBQUc7QUFDbEMsRUFFQSxzREFBc0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2FtcC1jb250ZXh0LnNoYXJlZC1ydW50aW1lLmpzPzk4YjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbXBTdGF0ZUNvbnRleHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFtcFN0YXRlQ29udGV4dDtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBBbXBTdGF0ZUNvbnRleHQgPSBfcmVhY3QuZGVmYXVsdC5jcmVhdGVDb250ZXh0KHt9KTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBBbXBTdGF0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkFtcFN0YXRlQ29udGV4dFwiO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiQW1wU3RhdGVDb250ZXh0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9yZWFjdCIsIl8iLCJkZWZhdWx0IiwiY3JlYXRlQ29udGV4dCIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-mode.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isInAmpMode\", ({\n    enumerable: true,\n    get: function() {\n        return isInAmpMode;\n    }\n}));\nfunction isInAmpMode(param) {\n    let { ampFirst = false, hybrid = false, hasQuery = false } = param === void 0 ? {} : param;\n    return ampFirst || hybrid && hasQuery;\n} //# sourceMappingURL=amp-mode.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtbW9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsK0NBQThDO0lBQzFDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsU0FBU0EsWUFBWUMsS0FBSztJQUN0QixJQUFJLEVBQUVDLFdBQVcsS0FBSyxFQUFFQyxTQUFTLEtBQUssRUFBRUMsV0FBVyxLQUFLLEVBQUUsR0FBR0gsVUFBVSxLQUFLLElBQUksQ0FBQyxJQUFJQTtJQUNyRixPQUFPQyxZQUFZQyxVQUFVQztBQUNqQyxFQUVBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvYW1wLW1vZGUuanM/NjIzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzSW5BbXBNb2RlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpc0luQW1wTW9kZTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGlzSW5BbXBNb2RlKHBhcmFtKSB7XG4gICAgbGV0IHsgYW1wRmlyc3QgPSBmYWxzZSwgaHlicmlkID0gZmFsc2UsIGhhc1F1ZXJ5ID0gZmFsc2UgfSA9IHBhcmFtID09PSB2b2lkIDAgPyB7fSA6IHBhcmFtO1xuICAgIHJldHVybiBhbXBGaXJzdCB8fCBoeWJyaWQgJiYgaGFzUXVlcnk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFtcC1tb2RlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJpc0luQW1wTW9kZSIsInBhcmFtIiwiYW1wRmlyc3QiLCJoeWJyaWQiLCJoYXNRdWVyeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/get-img-props.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImgProps\", ({\n    enumerable: true,\n    get: function() {\n        return getImgProps;\n    }\n}));\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _imageblursvg = __webpack_require__(/*! ./image-blur-svg */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\");\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst VALID_LOADING_VALUES = [\n    \"lazy\",\n    \"eager\",\n    undefined\n];\nfunction isStaticRequire(src) {\n    return src.default !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return typeof src === \"object\" && (isStaticRequire(src) || isStaticImageData(src));\n}\nconst allImgs = new Map();\nlet perfObserver;\nfunction getInt(x) {\n    if (typeof x === \"undefined\") {\n        return x;\n    }\n    if (typeof x === \"number\") {\n        return Number.isFinite(x) ? x : NaN;\n    }\n    if (typeof x === \"string\" && /^[0-9]+$/.test(x)) {\n        return parseInt(x, 10);\n    }\n    return NaN;\n}\nfunction getWidths(param, width, sizes) {\n    let { deviceSizes, allSizes } = param;\n    if (sizes) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        const viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        const percentSizes = [];\n        for(let match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            const smallestRatio = Math.min(...percentSizes) * 0.01;\n            return {\n                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),\n                kind: \"w\"\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: \"w\"\n        };\n    }\n    if (typeof width !== \"number\") {\n        return {\n            widths: deviceSizes,\n            kind: \"w\"\n        };\n    }\n    const widths = [\n        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n        // > blue colors. Showing a 3x resolution image in the app vs a 2x\n        // > resolution image will be visually the same, though the 3x image\n        // > takes significantly more data. Even true 3x resolution screens are\n        // > wasteful as the human eye cannot see that level of detail without\n        // > something like a magnifying glass.\n        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n        [\n            width,\n            width * 2 /*, width * 3*/ \n        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))\n    ];\n    return {\n        widths,\n        kind: \"x\"\n    };\n}\nfunction generateImgAttrs(param) {\n    let { config, src, unoptimized, width, quality, sizes, loader } = param;\n    if (unoptimized) {\n        return {\n            src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    const { widths, kind } = getWidths(config, width, sizes);\n    const last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === \"w\" ? \"100vw\" : sizes,\n        srcSet: widths.map((w, i)=>loader({\n                config,\n                src,\n                quality,\n                width: w\n            }) + \" \" + (kind === \"w\" ? w : i + 1) + kind).join(\", \"),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config,\n            src,\n            quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getImgProps(param, _state) {\n    let { src, sizes, unoptimized = false, priority = false, loading, className, quality, width, height, fill = false, style, onLoad, onLoadingComplete, placeholder = \"empty\", blurDataURL, fetchPriority, layout, objectFit, objectPosition, lazyBoundary, lazyRoot, ...rest } = param;\n    const { imgConf, showAltText, blurComplete, defaultLoader } = _state;\n    let config;\n    let c = imgConf || _imageconfig.imageConfigDefault;\n    if (\"allSizes\" in c) {\n        config = c;\n    } else {\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        config = {\n            ...c,\n            allSizes,\n            deviceSizes\n        };\n    }\n    let loader = rest.loader || defaultLoader;\n    // Remove property so it's not spread on <img> element\n    delete rest.loader;\n    delete rest.srcSet;\n    // This special value indicates that the user\n    // didn't define a \"loader\" prop or \"loader\" config.\n    const isDefaultLoader = \"__next_img_default\" in loader;\n    if (isDefaultLoader) {\n        if (config.loader === \"custom\") {\n            throw new Error('Image with src \"' + src + '\" is missing \"loader\" prop.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n        }\n    } else {\n        // The user defined a \"loader\" prop or config.\n        // Since the config object is internal only, we\n        // must not pass it to the user-defined \"loader\".\n        const customImageLoader = loader;\n        loader = (obj)=>{\n            const { config: _, ...opts } = obj;\n            return customImageLoader(opts);\n        };\n    }\n    if (layout) {\n        if (layout === \"fill\") {\n            fill = true;\n        }\n        const layoutToStyle = {\n            intrinsic: {\n                maxWidth: \"100%\",\n                height: \"auto\"\n            },\n            responsive: {\n                width: \"100%\",\n                height: \"auto\"\n            }\n        };\n        const layoutToSizes = {\n            responsive: \"100vw\",\n            fill: \"100vw\"\n        };\n        const layoutStyle = layoutToStyle[layout];\n        if (layoutStyle) {\n            style = {\n                ...style,\n                ...layoutStyle\n            };\n        }\n        const layoutSizes = layoutToSizes[layout];\n        if (layoutSizes && !sizes) {\n            sizes = layoutSizes;\n        }\n    }\n    let staticSrc = \"\";\n    let widthInt = getInt(width);\n    let heightInt = getInt(height);\n    let blurWidth;\n    let blurHeight;\n    if (isStaticImport(src)) {\n        const staticImageData = isStaticRequire(src) ? src.default : src;\n        if (!staticImageData.src) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \" + JSON.stringify(staticImageData));\n        }\n        if (!staticImageData.height || !staticImageData.width) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \" + JSON.stringify(staticImageData));\n        }\n        blurWidth = staticImageData.blurWidth;\n        blurHeight = staticImageData.blurHeight;\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!fill) {\n            if (!widthInt && !heightInt) {\n                widthInt = staticImageData.width;\n                heightInt = staticImageData.height;\n            } else if (widthInt && !heightInt) {\n                const ratio = widthInt / staticImageData.width;\n                heightInt = Math.round(staticImageData.height * ratio);\n            } else if (!widthInt && heightInt) {\n                const ratio = heightInt / staticImageData.height;\n                widthInt = Math.round(staticImageData.width * ratio);\n            }\n        }\n    }\n    src = typeof src === \"string\" ? src : staticSrc;\n    let isLazy = !priority && (loading === \"lazy\" || typeof loading === \"undefined\");\n    if (!src || src.startsWith(\"data:\") || src.startsWith(\"blob:\")) {\n        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if (config.unoptimized) {\n        unoptimized = true;\n    }\n    if (isDefaultLoader && src.endsWith(\".svg\") && !config.dangerouslyAllowSVG) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        unoptimized = true;\n    }\n    if (priority) {\n        fetchPriority = \"high\";\n    }\n    const qualityInt = getInt(quality);\n    if (true) {\n        if (config.output === \"export\" && isDefaultLoader && !unoptimized) {\n            throw new Error(\"Image Optimization using the default loader is not compatible with `{ output: 'export' }`.\\n  Possible solutions:\\n    - Remove `{ output: 'export' }` and run \\\"next start\\\" to run server mode including the Image Optimization API.\\n    - Configure `{ images: { unoptimized: true } }` in `next.config.js` to disable the Image Optimization API.\\n  Read more: https://nextjs.org/docs/messages/export-image-api\");\n        }\n        if (!src) {\n            // React doesn't show the stack trace and there's\n            // no `src` to help identify which image, so we\n            // instead console.error(ref) during mount.\n            unoptimized = true;\n        } else {\n            if (fill) {\n                if (width) {\n                    throw new Error('Image with src \"' + src + '\" has both \"width\" and \"fill\" properties. Only one should be used.');\n                }\n                if (height) {\n                    throw new Error('Image with src \"' + src + '\" has both \"height\" and \"fill\" properties. Only one should be used.');\n                }\n                if ((style == null ? void 0 : style.position) && style.position !== \"absolute\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.position\" properties. Images with \"fill\" always use position absolute - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.width) && style.width !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.width\" properties. Images with \"fill\" always use width 100% - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.height) && style.height !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.height\" properties. Images with \"fill\" always use height 100% - it cannot be modified.');\n                }\n            } else {\n                if (typeof widthInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"width\" property.');\n                } else if (isNaN(widthInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"width\" property. Expected a numeric value in pixels but received \"' + width + '\".');\n                }\n                if (typeof heightInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"height\" property.');\n                } else if (isNaN(heightInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"height\" property. Expected a numeric value in pixels but received \"' + height + '\".');\n                }\n            }\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"loading\" property. Provided \"' + loading + '\" should be one of ' + VALID_LOADING_VALUES.map(String).join(\",\") + \".\");\n        }\n        if (priority && loading === \"lazy\") {\n            throw new Error('Image with src \"' + src + '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.');\n        }\n        if (placeholder !== \"empty\" && placeholder !== \"blur\" && !placeholder.startsWith(\"data:image/\")) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"placeholder\" property \"' + placeholder + '\".');\n        }\n        if (placeholder !== \"empty\") {\n            if (widthInt && heightInt && widthInt * heightInt < 1600) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is smaller than 40x40. Consider removing the \"placeholder\" property to improve performance.');\n            }\n        }\n        if (placeholder === \"blur\" && !blurDataURL) {\n            const VALID_BLUR_EXT = [\n                \"jpeg\",\n                \"png\",\n                \"webp\",\n                \"avif\"\n            ] // should match next-image-loader\n            ;\n            throw new Error('Image with src \"' + src + '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n        Possible solutions:\\n          - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n          - Change the \"src\" property to a static import with one of the supported file types: ' + VALID_BLUR_EXT.join(\",\") + ' (animated images not supported)\\n          - Remove the \"placeholder\" property, effectively no blur effect\\n        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url');\n        }\n        if (\"ref\" in rest) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using unsupported \"ref\" property. Consider using the \"onLoad\" property instead.');\n        }\n        if (!unoptimized && !isDefaultLoader) {\n            const urlStr = loader({\n                config,\n                src,\n                width: widthInt || 400,\n                quality: qualityInt || 75\n            });\n            let url;\n            try {\n                url = new URL(urlStr);\n            } catch (err) {}\n            if (urlStr === src || url && url.pathname === src && !url.search) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n            }\n        }\n        if (onLoadingComplete) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using deprecated \"onLoadingComplete\" property. Please use the \"onLoad\" property instead.');\n        }\n        for (const [legacyKey, legacyValue] of Object.entries({\n            layout,\n            objectFit,\n            objectPosition,\n            lazyBoundary,\n            lazyRoot\n        })){\n            if (legacyValue) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has legacy prop \"' + legacyKey + '\". Did you forget to run the codemod?' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13\");\n            }\n        }\n        if ( true && !perfObserver && window.PerformanceObserver) {\n            perfObserver = new PerformanceObserver((entryList)=>{\n                for (const entry of entryList.getEntries()){\n                    var _entry_element;\n                    // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                    const imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || \"\";\n                    const lcpImage = allImgs.get(imgSrc);\n                    if (lcpImage && !lcpImage.priority && lcpImage.placeholder === \"empty\" && !lcpImage.src.startsWith(\"data:\") && !lcpImage.src.startsWith(\"blob:\")) {\n                        // https://web.dev/lcp/#measure-lcp-in-javascript\n                        (0, _warnonce.warnOnce)('Image with src \"' + lcpImage.src + '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.' + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n                    }\n                }\n            });\n            try {\n                perfObserver.observe({\n                    type: \"largest-contentful-paint\",\n                    buffered: true\n                });\n            } catch (err) {\n                // Log error but don't crash the app\n                console.error(err);\n            }\n        }\n    }\n    const imgStyle = Object.assign(fill ? {\n        position: \"absolute\",\n        height: \"100%\",\n        width: \"100%\",\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        objectFit,\n        objectPosition\n    } : {}, showAltText ? {} : {\n        color: \"transparent\"\n    }, style);\n    const backgroundImage = !blurComplete && placeholder !== \"empty\" ? placeholder === \"blur\" ? 'url(\"data:image/svg+xml;charset=utf-8,' + (0, _imageblursvg.getImageBlurSvg)({\n        widthInt,\n        heightInt,\n        blurWidth,\n        blurHeight,\n        blurDataURL: blurDataURL || \"\",\n        objectFit: imgStyle.objectFit\n    }) + '\")' : 'url(\"' + placeholder + '\")' // assume `data:image/`\n     : null;\n    let placeholderStyle = backgroundImage ? {\n        backgroundSize: imgStyle.objectFit || \"cover\",\n        backgroundPosition: imgStyle.objectPosition || \"50% 50%\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundImage\n    } : {};\n    if (true) {\n        if (placeholderStyle.backgroundImage && placeholder === \"blur\" && (blurDataURL == null ? void 0 : blurDataURL.startsWith(\"/\"))) {\n            // During `next dev`, we don't want to generate blur placeholders with webpack\n            // because it can delay starting the dev server. Instead, `next-image-loader.js`\n            // will inline a special url to lazily generate the blur placeholder at request time.\n            placeholderStyle.backgroundImage = 'url(\"' + blurDataURL + '\")';\n        }\n    }\n    const imgAttributes = generateImgAttrs({\n        config,\n        src,\n        unoptimized,\n        width: widthInt,\n        quality: qualityInt,\n        sizes,\n        loader\n    });\n    if (true) {\n        if (true) {\n            let fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src,\n                priority,\n                placeholder\n            });\n        }\n    }\n    const props = {\n        ...rest,\n        loading: isLazy ? \"lazy\" : loading,\n        fetchPriority,\n        width: widthInt,\n        height: heightInt,\n        decoding: \"async\",\n        className,\n        style: {\n            ...imgStyle,\n            ...placeholderStyle\n        },\n        sizes: imgAttributes.sizes,\n        srcSet: imgAttributes.srcSet,\n        src: imgAttributes.src\n    };\n    const meta = {\n        unoptimized,\n        priority,\n        placeholder,\n        fill\n    };\n    return {\n        props,\n        meta\n    };\n} //# sourceMappingURL=get-img-props.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCwrQ0FBOEM7SUFDMUNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxZQUFZQyxtQkFBT0EsQ0FBQyxxR0FBbUI7QUFDN0MsTUFBTUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQyxtR0FBa0I7QUFDaEQsTUFBTUUsZUFBZUYsbUJBQU9BLENBQUMsK0ZBQWdCO0FBQzdDLE1BQU1HLHVCQUF1QjtJQUN6QjtJQUNBO0lBQ0FDO0NBQ0g7QUFDRCxTQUFTQyxnQkFBZ0JDLEdBQUc7SUFDeEIsT0FBT0EsSUFBSUMsT0FBTyxLQUFLSDtBQUMzQjtBQUNBLFNBQVNJLGtCQUFrQkYsR0FBRztJQUMxQixPQUFPQSxJQUFJQSxHQUFHLEtBQUtGO0FBQ3ZCO0FBQ0EsU0FBU0ssZUFBZUgsR0FBRztJQUN2QixPQUFPLE9BQU9BLFFBQVEsWUFBYUQsQ0FBQUEsZ0JBQWdCQyxRQUFRRSxrQkFBa0JGLElBQUc7QUFDcEY7QUFDQSxNQUFNSSxVQUFVLElBQUlDO0FBQ3BCLElBQUlDO0FBQ0osU0FBU0MsT0FBT0MsQ0FBQztJQUNiLElBQUksT0FBT0EsTUFBTSxhQUFhO1FBQzFCLE9BQU9BO0lBQ1g7SUFDQSxJQUFJLE9BQU9BLE1BQU0sVUFBVTtRQUN2QixPQUFPQyxPQUFPQyxRQUFRLENBQUNGLEtBQUtBLElBQUlHO0lBQ3BDO0lBQ0EsSUFBSSxPQUFPSCxNQUFNLFlBQVksV0FBV0ksSUFBSSxDQUFDSixJQUFJO1FBQzdDLE9BQU9LLFNBQVNMLEdBQUc7SUFDdkI7SUFDQSxPQUFPRztBQUNYO0FBQ0EsU0FBU0csVUFBVUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLEtBQUs7SUFDbEMsSUFBSSxF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VXBGLGNBQWM7UUFDL0Q7SUFDSjtJQUNBLE1BQU0wRixnQkFBZ0I3RyxpQkFBaUI7UUFDbkNDO1FBQ0F2QztRQUNBd0M7UUFDQXhCLE9BQU95RTtRQUNQaEQsU0FBUzZEO1FBQ1RyRjtRQUNBeUI7SUFDSjtJQUNBLElBQUk2RCxJQUFxQyxFQUFFO1FBQ3ZDLElBQUksSUFBNkIsRUFBRTtZQUMvQixJQUFJNkM7WUFDSixJQUFJO2dCQUNBQSxVQUFVLElBQUluQyxJQUFJa0MsY0FBY25KLEdBQUc7WUFDdkMsRUFBRSxPQUFPcUosR0FBRztnQkFDUkQsVUFBVSxJQUFJbkMsSUFBSWtDLGNBQWNuSixHQUFHLEVBQUV3SCxPQUFPOEIsUUFBUSxDQUFDQyxJQUFJO1lBQzdEO1lBQ0FuSixRQUFRb0osR0FBRyxDQUFDSixRQUFRRyxJQUFJLEVBQUU7Z0JBQ3RCdko7Z0JBQ0FnRDtnQkFDQVE7WUFDSjtRQUNKO0lBQ0o7SUFDQSxNQUFNaUcsUUFBUTtRQUNWLEdBQUd6RixJQUFJO1FBQ1BmLFNBQVNpRCxTQUFTLFNBQVNqRDtRQUMzQlM7UUFDQTFDLE9BQU95RTtRQUNQdEMsUUFBUXVDO1FBQ1JnRSxVQUFVO1FBQ1Z4RztRQUNBRyxPQUFPO1lBQ0gsR0FBR2lGLFFBQVE7WUFDWCxHQUFHUyxnQkFBZ0I7UUFDdkI7UUFDQTlILE9BQU9rSSxjQUFjbEksS0FBSztRQUMxQjBCLFFBQVF3RyxjQUFjeEcsTUFBTTtRQUM1QjNDLEtBQUttSixjQUFjbkosR0FBRztJQUMxQjtJQUNBLE1BQU0ySixPQUFPO1FBQ1RuSDtRQUNBUTtRQUNBUTtRQUNBSjtJQUNKO0lBQ0EsT0FBTztRQUNIcUc7UUFDQUU7SUFDSjtBQUNKLEVBRUEseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLmpzP2JiYWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRJbWdQcm9wc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW1nUHJvcHM7XG4gICAgfVxufSk7XG5jb25zdCBfd2Fybm9uY2UgPSByZXF1aXJlKFwiLi91dGlscy93YXJuLW9uY2VcIik7XG5jb25zdCBfaW1hZ2VibHVyc3ZnID0gcmVxdWlyZShcIi4vaW1hZ2UtYmx1ci1zdmdcIik7XG5jb25zdCBfaW1hZ2Vjb25maWcgPSByZXF1aXJlKFwiLi9pbWFnZS1jb25maWdcIik7XG5jb25zdCBWQUxJRF9MT0FESU5HX1ZBTFVFUyA9IFtcbiAgICBcImxhenlcIixcbiAgICBcImVhZ2VyXCIsXG4gICAgdW5kZWZpbmVkXG5dO1xuZnVuY3Rpb24gaXNTdGF0aWNSZXF1aXJlKHNyYykge1xuICAgIHJldHVybiBzcmMuZGVmYXVsdCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNTdGF0aWNJbWFnZURhdGEoc3JjKSB7XG4gICAgcmV0dXJuIHNyYy5zcmMgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzU3RhdGljSW1wb3J0KHNyYykge1xuICAgIHJldHVybiB0eXBlb2Ygc3JjID09PSBcIm9iamVjdFwiICYmIChpc1N0YXRpY1JlcXVpcmUoc3JjKSB8fCBpc1N0YXRpY0ltYWdlRGF0YShzcmMpKTtcbn1cbmNvbnN0IGFsbEltZ3MgPSBuZXcgTWFwKCk7XG5sZXQgcGVyZk9ic2VydmVyO1xuZnVuY3Rpb24gZ2V0SW50KHgpIHtcbiAgICBpZiAodHlwZW9mIHggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHgpID8geCA6IE5hTjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB4ID09PSBcInN0cmluZ1wiICYmIC9eWzAtOV0rJC8udGVzdCh4KSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoeCwgMTApO1xuICAgIH1cbiAgICByZXR1cm4gTmFOO1xufVxuZnVuY3Rpb24gZ2V0V2lkdGhzKHBhcmFtLCB3aWR0aCwgc2l6ZXMpIHtcbiAgICBsZXQgeyBkZXZpY2VTaXplcywgYWxsU2l6ZXMgfSA9IHBhcmFtO1xuICAgIGlmIChzaXplcykge1xuICAgICAgICAvLyBGaW5kIGFsbCB0aGUgXCJ2d1wiIHBlcmNlbnQgc2l6ZXMgdXNlZCBpbiB0aGUgc2l6ZXMgcHJvcFxuICAgICAgICBjb25zdCB2aWV3cG9ydFdpZHRoUmUgPSAvKF58XFxzKSgxP1xcZD9cXGQpdncvZztcbiAgICAgICAgY29uc3QgcGVyY2VudFNpemVzID0gW107XG4gICAgICAgIGZvcihsZXQgbWF0Y2g7IG1hdGNoID0gdmlld3BvcnRXaWR0aFJlLmV4ZWMoc2l6ZXMpOyBtYXRjaCl7XG4gICAgICAgICAgICBwZXJjZW50U2l6ZXMucHVzaChwYXJzZUludChtYXRjaFsyXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZXJjZW50U2l6ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBzbWFsbGVzdFJhdGlvID0gTWF0aC5taW4oLi4ucGVyY2VudFNpemVzKSAqIDAuMDE7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoczogYWxsU2l6ZXMuZmlsdGVyKChzKT0+cyA+PSBkZXZpY2VTaXplc1swXSAqIHNtYWxsZXN0UmF0aW8pLFxuICAgICAgICAgICAgICAgIGtpbmQ6IFwid1wiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aHM6IGFsbFNpemVzLFxuICAgICAgICAgICAga2luZDogXCJ3XCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGhzOiBkZXZpY2VTaXplcyxcbiAgICAgICAgICAgIGtpbmQ6IFwid1wiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHdpZHRocyA9IFtcbiAgICAgICAgLi4ubmV3IFNldCgvLyA+IFRoaXMgbWVhbnMgdGhhdCBtb3N0IE9MRUQgc2NyZWVucyB0aGF0IHNheSB0aGV5IGFyZSAzeCByZXNvbHV0aW9uLFxuICAgICAgICAvLyA+IGFyZSBhY3R1YWxseSAzeCBpbiB0aGUgZ3JlZW4gY29sb3IsIGJ1dCBvbmx5IDEuNXggaW4gdGhlIHJlZCBhbmRcbiAgICAgICAgLy8gPiBibHVlIGNvbG9ycy4gU2hvd2luZyBhIDN4IHJlc29sdXRpb24gaW1hZ2UgaW4gdGhlIGFwcCB2cyBhIDJ4XG4gICAgICAgIC8vID4gcmVzb2x1dGlvbiBpbWFnZSB3aWxsIGJlIHZpc3VhbGx5IHRoZSBzYW1lLCB0aG91Z2ggdGhlIDN4IGltYWdlXG4gICAgICAgIC8vID4gdGFrZXMgc2lnbmlmaWNhbnRseSBtb3JlIGRhdGEuIEV2ZW4gdHJ1ZSAzeCByZXNvbHV0aW9uIHNjcmVlbnMgYXJlXG4gICAgICAgIC8vID4gd2FzdGVmdWwgYXMgdGhlIGh1bWFuIGV5ZSBjYW5ub3Qgc2VlIHRoYXQgbGV2ZWwgb2YgZGV0YWlsIHdpdGhvdXRcbiAgICAgICAgLy8gPiBzb21ldGhpbmcgbGlrZSBhIG1hZ25pZnlpbmcgZ2xhc3MuXG4gICAgICAgIC8vIGh0dHBzOi8vYmxvZy50d2l0dGVyLmNvbS9lbmdpbmVlcmluZy9lbl91cy90b3BpY3MvaW5mcmFzdHJ1Y3R1cmUvMjAxOS9jYXBwaW5nLWltYWdlLWZpZGVsaXR5LW9uLXVsdHJhLWhpZ2gtcmVzb2x1dGlvbi1kZXZpY2VzLmh0bWxcbiAgICAgICAgW1xuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICB3aWR0aCAqIDIgLyosIHdpZHRoICogMyovIFxuICAgICAgICBdLm1hcCgodyk9PmFsbFNpemVzLmZpbmQoKHApPT5wID49IHcpIHx8IGFsbFNpemVzW2FsbFNpemVzLmxlbmd0aCAtIDFdKSlcbiAgICBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRocyxcbiAgICAgICAga2luZDogXCJ4XCJcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWdBdHRycyhwYXJhbSkge1xuICAgIGxldCB7IGNvbmZpZywgc3JjLCB1bm9wdGltaXplZCwgd2lkdGgsIHF1YWxpdHksIHNpemVzLCBsb2FkZXIgfSA9IHBhcmFtO1xuICAgIGlmICh1bm9wdGltaXplZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgc3JjU2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzaXplczogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHsgd2lkdGhzLCBraW5kIH0gPSBnZXRXaWR0aHMoY29uZmlnLCB3aWR0aCwgc2l6ZXMpO1xuICAgIGNvbnN0IGxhc3QgPSB3aWR0aHMubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaXplczogIXNpemVzICYmIGtpbmQgPT09IFwid1wiID8gXCIxMDB2d1wiIDogc2l6ZXMsXG4gICAgICAgIHNyY1NldDogd2lkdGhzLm1hcCgodywgaSk9PmxvYWRlcih7XG4gICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICBxdWFsaXR5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3XG4gICAgICAgICAgICB9KSArIFwiIFwiICsgKGtpbmQgPT09IFwid1wiID8gdyA6IGkgKyAxKSArIGtpbmQpLmpvaW4oXCIsIFwiKSxcbiAgICAgICAgLy8gSXQncyBpbnRlbmRlZCB0byBrZWVwIGBzcmNgIHRoZSBsYXN0IGF0dHJpYnV0ZSBiZWNhdXNlIFJlYWN0IHVwZGF0ZXNcbiAgICAgICAgLy8gYXR0cmlidXRlcyBpbiBvcmRlci4gSWYgd2Uga2VlcCBgc3JjYCB0aGUgZmlyc3Qgb25lLCBTYWZhcmkgd2lsbFxuICAgICAgICAvLyBpbW1lZGlhdGVseSBzdGFydCB0byBmZXRjaCBgc3JjYCwgYmVmb3JlIGBzaXplc2AgYW5kIGBzcmNTZXRgIGFyZSBldmVuXG4gICAgICAgIC8vIHVwZGF0ZWQgYnkgUmVhY3QuIFRoYXQgY2F1c2VzIG11bHRpcGxlIHVubmVjZXNzYXJ5IHJlcXVlc3RzIGlmIGBzcmNTZXRgXG4gICAgICAgIC8vIGFuZCBgc2l6ZXNgIGFyZSBkZWZpbmVkLlxuICAgICAgICAvLyBUaGlzIGJ1ZyBjYW5ub3QgYmUgcmVwcm9kdWNlZCBpbiBDaHJvbWUgb3IgRmlyZWZveC5cbiAgICAgICAgc3JjOiBsb2FkZXIoe1xuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgcXVhbGl0eSxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aHNbbGFzdF1cbiAgICAgICAgfSlcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0SW1nUHJvcHMocGFyYW0sIF9zdGF0ZSkge1xuICAgIGxldCB7IHNyYywgc2l6ZXMsIHVub3B0aW1pemVkID0gZmFsc2UsIHByaW9yaXR5ID0gZmFsc2UsIGxvYWRpbmcsIGNsYXNzTmFtZSwgcXVhbGl0eSwgd2lkdGgsIGhlaWdodCwgZmlsbCA9IGZhbHNlLCBzdHlsZSwgb25Mb2FkLCBvbkxvYWRpbmdDb21wbGV0ZSwgcGxhY2Vob2xkZXIgPSBcImVtcHR5XCIsIGJsdXJEYXRhVVJMLCBmZXRjaFByaW9yaXR5LCBsYXlvdXQsIG9iamVjdEZpdCwgb2JqZWN0UG9zaXRpb24sIGxhenlCb3VuZGFyeSwgbGF6eVJvb3QsIC4uLnJlc3QgfSA9IHBhcmFtO1xuICAgIGNvbnN0IHsgaW1nQ29uZiwgc2hvd0FsdFRleHQsIGJsdXJDb21wbGV0ZSwgZGVmYXVsdExvYWRlciB9ID0gX3N0YXRlO1xuICAgIGxldCBjb25maWc7XG4gICAgbGV0IGMgPSBpbWdDb25mIHx8IF9pbWFnZWNvbmZpZy5pbWFnZUNvbmZpZ0RlZmF1bHQ7XG4gICAgaWYgKFwiYWxsU2l6ZXNcIiBpbiBjKSB7XG4gICAgICAgIGNvbmZpZyA9IGM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYWxsU2l6ZXMgPSBbXG4gICAgICAgICAgICAuLi5jLmRldmljZVNpemVzLFxuICAgICAgICAgICAgLi4uYy5pbWFnZVNpemVzXG4gICAgICAgIF0uc29ydCgoYSwgYik9PmEgLSBiKTtcbiAgICAgICAgY29uc3QgZGV2aWNlU2l6ZXMgPSBjLmRldmljZVNpemVzLnNvcnQoKGEsIGIpPT5hIC0gYik7XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICBhbGxTaXplcyxcbiAgICAgICAgICAgIGRldmljZVNpemVzXG4gICAgICAgIH07XG4gICAgfVxuICAgIGxldCBsb2FkZXIgPSByZXN0LmxvYWRlciB8fCBkZWZhdWx0TG9hZGVyO1xuICAgIC8vIFJlbW92ZSBwcm9wZXJ0eSBzbyBpdCdzIG5vdCBzcHJlYWQgb24gPGltZz4gZWxlbWVudFxuICAgIGRlbGV0ZSByZXN0LmxvYWRlcjtcbiAgICBkZWxldGUgcmVzdC5zcmNTZXQ7XG4gICAgLy8gVGhpcyBzcGVjaWFsIHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZSB1c2VyXG4gICAgLy8gZGlkbid0IGRlZmluZSBhIFwibG9hZGVyXCIgcHJvcCBvciBcImxvYWRlclwiIGNvbmZpZy5cbiAgICBjb25zdCBpc0RlZmF1bHRMb2FkZXIgPSBcIl9fbmV4dF9pbWdfZGVmYXVsdFwiIGluIGxvYWRlcjtcbiAgICBpZiAoaXNEZWZhdWx0TG9hZGVyKSB7XG4gICAgICAgIGlmIChjb25maWcubG9hZGVyID09PSBcImN1c3RvbVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBpcyBtaXNzaW5nIFwibG9hZGVyXCIgcHJvcC4nICsgXCJcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtbWlzc2luZy1sb2FkZXJcIik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgdXNlciBkZWZpbmVkIGEgXCJsb2FkZXJcIiBwcm9wIG9yIGNvbmZpZy5cbiAgICAgICAgLy8gU2luY2UgdGhlIGNvbmZpZyBvYmplY3QgaXMgaW50ZXJuYWwgb25seSwgd2VcbiAgICAgICAgLy8gbXVzdCBub3QgcGFzcyBpdCB0byB0aGUgdXNlci1kZWZpbmVkIFwibG9hZGVyXCIuXG4gICAgICAgIGNvbnN0IGN1c3RvbUltYWdlTG9hZGVyID0gbG9hZGVyO1xuICAgICAgICBsb2FkZXIgPSAob2JqKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBjb25maWc6IF8sIC4uLm9wdHMgfSA9IG9iajtcbiAgICAgICAgICAgIHJldHVybiBjdXN0b21JbWFnZUxvYWRlcihvcHRzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGxheW91dCkge1xuICAgICAgICBpZiAobGF5b3V0ID09PSBcImZpbGxcIikge1xuICAgICAgICAgICAgZmlsbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF5b3V0VG9TdHlsZSA9IHtcbiAgICAgICAgICAgIGludHJpbnNpYzoge1xuICAgICAgICAgICAgICAgIG1heFdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzcG9uc2l2ZToge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxheW91dFRvU2l6ZXMgPSB7XG4gICAgICAgICAgICByZXNwb25zaXZlOiBcIjEwMHZ3XCIsXG4gICAgICAgICAgICBmaWxsOiBcIjEwMHZ3XCJcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbGF5b3V0U3R5bGUgPSBsYXlvdXRUb1N0eWxlW2xheW91dF07XG4gICAgICAgIGlmIChsYXlvdXRTdHlsZSkge1xuICAgICAgICAgICAgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICAgICAgICAgLi4ubGF5b3V0U3R5bGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF5b3V0U2l6ZXMgPSBsYXlvdXRUb1NpemVzW2xheW91dF07XG4gICAgICAgIGlmIChsYXlvdXRTaXplcyAmJiAhc2l6ZXMpIHtcbiAgICAgICAgICAgIHNpemVzID0gbGF5b3V0U2l6ZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0YXRpY1NyYyA9IFwiXCI7XG4gICAgbGV0IHdpZHRoSW50ID0gZ2V0SW50KHdpZHRoKTtcbiAgICBsZXQgaGVpZ2h0SW50ID0gZ2V0SW50KGhlaWdodCk7XG4gICAgbGV0IGJsdXJXaWR0aDtcbiAgICBsZXQgYmx1ckhlaWdodDtcbiAgICBpZiAoaXNTdGF0aWNJbXBvcnQoc3JjKSkge1xuICAgICAgICBjb25zdCBzdGF0aWNJbWFnZURhdGEgPSBpc1N0YXRpY1JlcXVpcmUoc3JjKSA/IHNyYy5kZWZhdWx0IDogc3JjO1xuICAgICAgICBpZiAoIXN0YXRpY0ltYWdlRGF0YS5zcmMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuIG9iamVjdCBzaG91bGQgb25seSBiZSBwYXNzZWQgdG8gdGhlIGltYWdlIGNvbXBvbmVudCBzcmMgcGFyYW1ldGVyIGlmIGl0IGNvbWVzIGZyb20gYSBzdGF0aWMgaW1hZ2UgaW1wb3J0LiBJdCBtdXN0IGluY2x1ZGUgc3JjLiBSZWNlaXZlZCBcIiArIEpTT04uc3RyaW5naWZ5KHN0YXRpY0ltYWdlRGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhdGljSW1hZ2VEYXRhLmhlaWdodCB8fCAhc3RhdGljSW1hZ2VEYXRhLndpZHRoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbiBvYmplY3Qgc2hvdWxkIG9ubHkgYmUgcGFzc2VkIHRvIHRoZSBpbWFnZSBjb21wb25lbnQgc3JjIHBhcmFtZXRlciBpZiBpdCBjb21lcyBmcm9tIGEgc3RhdGljIGltYWdlIGltcG9ydC4gSXQgbXVzdCBpbmNsdWRlIGhlaWdodCBhbmQgd2lkdGguIFJlY2VpdmVkIFwiICsgSlNPTi5zdHJpbmdpZnkoc3RhdGljSW1hZ2VEYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgYmx1cldpZHRoID0gc3RhdGljSW1hZ2VEYXRhLmJsdXJXaWR0aDtcbiAgICAgICAgYmx1ckhlaWdodCA9IHN0YXRpY0ltYWdlRGF0YS5ibHVySGVpZ2h0O1xuICAgICAgICBibHVyRGF0YVVSTCA9IGJsdXJEYXRhVVJMIHx8IHN0YXRpY0ltYWdlRGF0YS5ibHVyRGF0YVVSTDtcbiAgICAgICAgc3RhdGljU3JjID0gc3RhdGljSW1hZ2VEYXRhLnNyYztcbiAgICAgICAgaWYgKCFmaWxsKSB7XG4gICAgICAgICAgICBpZiAoIXdpZHRoSW50ICYmICFoZWlnaHRJbnQpIHtcbiAgICAgICAgICAgICAgICB3aWR0aEludCA9IHN0YXRpY0ltYWdlRGF0YS53aWR0aDtcbiAgICAgICAgICAgICAgICBoZWlnaHRJbnQgPSBzdGF0aWNJbWFnZURhdGEuaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3aWR0aEludCAmJiAhaGVpZ2h0SW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF0aW8gPSB3aWR0aEludCAvIHN0YXRpY0ltYWdlRGF0YS53aWR0aDtcbiAgICAgICAgICAgICAgICBoZWlnaHRJbnQgPSBNYXRoLnJvdW5kKHN0YXRpY0ltYWdlRGF0YS5oZWlnaHQgKiByYXRpbyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF3aWR0aEludCAmJiBoZWlnaHRJbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYXRpbyA9IGhlaWdodEludCAvIHN0YXRpY0ltYWdlRGF0YS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgd2lkdGhJbnQgPSBNYXRoLnJvdW5kKHN0YXRpY0ltYWdlRGF0YS53aWR0aCAqIHJhdGlvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzcmMgPSB0eXBlb2Ygc3JjID09PSBcInN0cmluZ1wiID8gc3JjIDogc3RhdGljU3JjO1xuICAgIGxldCBpc0xhenkgPSAhcHJpb3JpdHkgJiYgKGxvYWRpbmcgPT09IFwibGF6eVwiIHx8IHR5cGVvZiBsb2FkaW5nID09PSBcInVuZGVmaW5lZFwiKTtcbiAgICBpZiAoIXNyYyB8fCBzcmMuc3RhcnRzV2l0aChcImRhdGE6XCIpIHx8IHNyYy5zdGFydHNXaXRoKFwiYmxvYjpcIikpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRUUC9CYXNpY3Nfb2ZfSFRUUC9EYXRhX1VSSXNcbiAgICAgICAgdW5vcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICBpc0xhenkgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy51bm9wdGltaXplZCkge1xuICAgICAgICB1bm9wdGltaXplZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpc0RlZmF1bHRMb2FkZXIgJiYgc3JjLmVuZHNXaXRoKFwiLnN2Z1wiKSAmJiAhY29uZmlnLmRhbmdlcm91c2x5QWxsb3dTVkcpIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHRvIG1ha2Ugc3ZnIHNlcnZlIGFzLWlzIHRvIGF2b2lkIHByb3h5aW5nXG4gICAgICAgIC8vIHRocm91Z2ggdGhlIGJ1aWx0LWluIEltYWdlIE9wdGltaXphdGlvbiBBUEkuXG4gICAgICAgIHVub3B0aW1pemVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByaW9yaXR5KSB7XG4gICAgICAgIGZldGNoUHJpb3JpdHkgPSBcImhpZ2hcIjtcbiAgICB9XG4gICAgY29uc3QgcXVhbGl0eUludCA9IGdldEludChxdWFsaXR5KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChjb25maWcub3V0cHV0ID09PSBcImV4cG9ydFwiICYmIGlzRGVmYXVsdExvYWRlciAmJiAhdW5vcHRpbWl6ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkltYWdlIE9wdGltaXphdGlvbiB1c2luZyB0aGUgZGVmYXVsdCBsb2FkZXIgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBgeyBvdXRwdXQ6ICdleHBvcnQnIH1gLlxcbiAgUG9zc2libGUgc29sdXRpb25zOlxcbiAgICAtIFJlbW92ZSBgeyBvdXRwdXQ6ICdleHBvcnQnIH1gIGFuZCBydW4gXFxcIm5leHQgc3RhcnRcXFwiIHRvIHJ1biBzZXJ2ZXIgbW9kZSBpbmNsdWRpbmcgdGhlIEltYWdlIE9wdGltaXphdGlvbiBBUEkuXFxuICAgIC0gQ29uZmlndXJlIGB7IGltYWdlczogeyB1bm9wdGltaXplZDogdHJ1ZSB9IH1gIGluIGBuZXh0LmNvbmZpZy5qc2AgdG8gZGlzYWJsZSB0aGUgSW1hZ2UgT3B0aW1pemF0aW9uIEFQSS5cXG4gIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZXhwb3J0LWltYWdlLWFwaVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgLy8gUmVhY3QgZG9lc24ndCBzaG93IHRoZSBzdGFjayB0cmFjZSBhbmQgdGhlcmUnc1xuICAgICAgICAgICAgLy8gbm8gYHNyY2AgdG8gaGVscCBpZGVudGlmeSB3aGljaCBpbWFnZSwgc28gd2VcbiAgICAgICAgICAgIC8vIGluc3RlYWQgY29uc29sZS5lcnJvcihyZWYpIGR1cmluZyBtb3VudC5cbiAgICAgICAgICAgIHVub3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBib3RoIFwid2lkdGhcIiBhbmQgXCJmaWxsXCIgcHJvcGVydGllcy4gT25seSBvbmUgc2hvdWxkIGJlIHVzZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIGJvdGggXCJoZWlnaHRcIiBhbmQgXCJmaWxsXCIgcHJvcGVydGllcy4gT25seSBvbmUgc2hvdWxkIGJlIHVzZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoc3R5bGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0eWxlLnBvc2l0aW9uKSAmJiBzdHlsZS5wb3NpdGlvbiAhPT0gXCJhYnNvbHV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBib3RoIFwiZmlsbFwiIGFuZCBcInN0eWxlLnBvc2l0aW9uXCIgcHJvcGVydGllcy4gSW1hZ2VzIHdpdGggXCJmaWxsXCIgYWx3YXlzIHVzZSBwb3NpdGlvbiBhYnNvbHV0ZSAtIGl0IGNhbm5vdCBiZSBtb2RpZmllZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChzdHlsZSA9PSBudWxsID8gdm9pZCAwIDogc3R5bGUud2lkdGgpICYmIHN0eWxlLndpZHRoICE9PSBcIjEwMCVcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgYm90aCBcImZpbGxcIiBhbmQgXCJzdHlsZS53aWR0aFwiIHByb3BlcnRpZXMuIEltYWdlcyB3aXRoIFwiZmlsbFwiIGFsd2F5cyB1c2Ugd2lkdGggMTAwJSAtIGl0IGNhbm5vdCBiZSBtb2RpZmllZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChzdHlsZSA9PSBudWxsID8gdm9pZCAwIDogc3R5bGUuaGVpZ2h0KSAmJiBzdHlsZS5oZWlnaHQgIT09IFwiMTAwJVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBib3RoIFwiZmlsbFwiIGFuZCBcInN0eWxlLmhlaWdodFwiIHByb3BlcnRpZXMuIEltYWdlcyB3aXRoIFwiZmlsbFwiIGFsd2F5cyB1c2UgaGVpZ2h0IDEwMCUgLSBpdCBjYW5ub3QgYmUgbW9kaWZpZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpZHRoSW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJ3aWR0aFwiIHByb3BlcnR5LicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOYU4od2lkdGhJbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBpbnZhbGlkIFwid2lkdGhcIiBwcm9wZXJ0eS4gRXhwZWN0ZWQgYSBudW1lcmljIHZhbHVlIGluIHBpeGVscyBidXQgcmVjZWl2ZWQgXCInICsgd2lkdGggKyAnXCIuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0SW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJoZWlnaHRcIiBwcm9wZXJ0eS4nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKGhlaWdodEludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIGludmFsaWQgXCJoZWlnaHRcIiBwcm9wZXJ0eS4gRXhwZWN0ZWQgYSBudW1lcmljIHZhbHVlIGluIHBpeGVscyBidXQgcmVjZWl2ZWQgXCInICsgaGVpZ2h0ICsgJ1wiLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIVZBTElEX0xPQURJTkdfVkFMVUVTLmluY2x1ZGVzKGxvYWRpbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgaW52YWxpZCBcImxvYWRpbmdcIiBwcm9wZXJ0eS4gUHJvdmlkZWQgXCInICsgbG9hZGluZyArICdcIiBzaG91bGQgYmUgb25lIG9mICcgKyBWQUxJRF9MT0FESU5HX1ZBTFVFUy5tYXAoU3RyaW5nKS5qb2luKFwiLFwiKSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJpb3JpdHkgJiYgbG9hZGluZyA9PT0gXCJsYXp5XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBib3RoIFwicHJpb3JpdHlcIiBhbmQgXCJsb2FkaW5nPVxcJ2xhenlcXCdcIiBwcm9wZXJ0aWVzLiBPbmx5IG9uZSBzaG91bGQgYmUgdXNlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2Vob2xkZXIgIT09IFwiZW1wdHlcIiAmJiBwbGFjZWhvbGRlciAhPT0gXCJibHVyXCIgJiYgIXBsYWNlaG9sZGVyLnN0YXJ0c1dpdGgoXCJkYXRhOmltYWdlL1wiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIGludmFsaWQgXCJwbGFjZWhvbGRlclwiIHByb3BlcnR5IFwiJyArIHBsYWNlaG9sZGVyICsgJ1wiLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwbGFjZWhvbGRlciAhPT0gXCJlbXB0eVwiKSB7XG4gICAgICAgICAgICBpZiAod2lkdGhJbnQgJiYgaGVpZ2h0SW50ICYmIHdpZHRoSW50ICogaGVpZ2h0SW50IDwgMTYwMCkge1xuICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaXMgc21hbGxlciB0aGFuIDQweDQwLiBDb25zaWRlciByZW1vdmluZyB0aGUgXCJwbGFjZWhvbGRlclwiIHByb3BlcnR5IHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyID09PSBcImJsdXJcIiAmJiAhYmx1ckRhdGFVUkwpIHtcbiAgICAgICAgICAgIGNvbnN0IFZBTElEX0JMVVJfRVhUID0gW1xuICAgICAgICAgICAgICAgIFwianBlZ1wiLFxuICAgICAgICAgICAgICAgIFwicG5nXCIsXG4gICAgICAgICAgICAgICAgXCJ3ZWJwXCIsXG4gICAgICAgICAgICAgICAgXCJhdmlmXCJcbiAgICAgICAgICAgIF0gLy8gc2hvdWxkIG1hdGNoIG5leHQtaW1hZ2UtbG9hZGVyXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgXCJwbGFjZWhvbGRlcj1cXCdibHVyXFwnXCIgcHJvcGVydHkgYnV0IGlzIG1pc3NpbmcgdGhlIFwiYmx1ckRhdGFVUkxcIiBwcm9wZXJ0eS5cXG4gICAgICAgIFBvc3NpYmxlIHNvbHV0aW9uczpcXG4gICAgICAgICAgLSBBZGQgYSBcImJsdXJEYXRhVVJMXCIgcHJvcGVydHksIHRoZSBjb250ZW50cyBzaG91bGQgYmUgYSBzbWFsbCBEYXRhIFVSTCB0byByZXByZXNlbnQgdGhlIGltYWdlXFxuICAgICAgICAgIC0gQ2hhbmdlIHRoZSBcInNyY1wiIHByb3BlcnR5IHRvIGEgc3RhdGljIGltcG9ydCB3aXRoIG9uZSBvZiB0aGUgc3VwcG9ydGVkIGZpbGUgdHlwZXM6ICcgKyBWQUxJRF9CTFVSX0VYVC5qb2luKFwiLFwiKSArICcgKGFuaW1hdGVkIGltYWdlcyBub3Qgc3VwcG9ydGVkKVxcbiAgICAgICAgICAtIFJlbW92ZSB0aGUgXCJwbGFjZWhvbGRlclwiIHByb3BlcnR5LCBlZmZlY3RpdmVseSBubyBibHVyIGVmZmVjdFxcbiAgICAgICAgUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9wbGFjZWhvbGRlci1ibHVyLWRhdGEtdXJsJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwicmVmXCIgaW4gcmVzdCkge1xuICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBpcyB1c2luZyB1bnN1cHBvcnRlZCBcInJlZlwiIHByb3BlcnR5LiBDb25zaWRlciB1c2luZyB0aGUgXCJvbkxvYWRcIiBwcm9wZXJ0eSBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdW5vcHRpbWl6ZWQgJiYgIWlzRGVmYXVsdExvYWRlcikge1xuICAgICAgICAgICAgY29uc3QgdXJsU3RyID0gbG9hZGVyKHtcbiAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aEludCB8fCA0MDAsXG4gICAgICAgICAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCB8fCA3NVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgdXJsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB1cmwgPSBuZXcgVVJMKHVybFN0cik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICBpZiAodXJsU3RyID09PSBzcmMgfHwgdXJsICYmIHVybC5wYXRobmFtZSA9PT0gc3JjICYmICF1cmwuc2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgYSBcImxvYWRlclwiIHByb3BlcnR5IHRoYXQgZG9lcyBub3QgaW1wbGVtZW50IHdpZHRoLiBQbGVhc2UgaW1wbGVtZW50IGl0IG9yIHVzZSB0aGUgXCJ1bm9wdGltaXplZFwiIHByb3BlcnR5IGluc3RlYWQuJyArIFwiXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLW1pc3NpbmctbG9hZGVyLXdpZHRoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbkxvYWRpbmdDb21wbGV0ZSkge1xuICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBpcyB1c2luZyBkZXByZWNhdGVkIFwib25Mb2FkaW5nQ29tcGxldGVcIiBwcm9wZXJ0eS4gUGxlYXNlIHVzZSB0aGUgXCJvbkxvYWRcIiBwcm9wZXJ0eSBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2xlZ2FjeUtleSwgbGVnYWN5VmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHtcbiAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgIG9iamVjdEZpdCxcbiAgICAgICAgICAgIG9iamVjdFBvc2l0aW9uLFxuICAgICAgICAgICAgbGF6eUJvdW5kYXJ5LFxuICAgICAgICAgICAgbGF6eVJvb3RcbiAgICAgICAgfSkpe1xuICAgICAgICAgICAgaWYgKGxlZ2FjeVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgbGVnYWN5IHByb3AgXCInICsgbGVnYWN5S2V5ICsgJ1wiLiBEaWQgeW91IGZvcmdldCB0byBydW4gdGhlIGNvZGVtb2Q/JyArIFwiXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVwZ3JhZGUtdG8tMTNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgIXBlcmZPYnNlcnZlciAmJiB3aW5kb3cuUGVyZm9ybWFuY2VPYnNlcnZlcikge1xuICAgICAgICAgICAgcGVyZk9ic2VydmVyID0gbmV3IFBlcmZvcm1hbmNlT2JzZXJ2ZXIoKGVudHJ5TGlzdCk9PntcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJ5TGlzdC5nZXRFbnRyaWVzKCkpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2VudHJ5X2VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSBtaXNzaW5nIFwiTGFyZ2VzdENvbnRlbnRmdWxQYWludFwiIGNsYXNzIHdpdGggXCJlbGVtZW50XCIgcHJvcFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWdTcmMgPSAoZW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IChfZW50cnlfZWxlbWVudCA9IGVudHJ5LmVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZW50cnlfZWxlbWVudC5zcmMpIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxjcEltYWdlID0gYWxsSW1ncy5nZXQoaW1nU3JjKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxjcEltYWdlICYmICFsY3BJbWFnZS5wcmlvcml0eSAmJiBsY3BJbWFnZS5wbGFjZWhvbGRlciA9PT0gXCJlbXB0eVwiICYmICFsY3BJbWFnZS5zcmMuc3RhcnRzV2l0aChcImRhdGE6XCIpICYmICFsY3BJbWFnZS5zcmMuc3RhcnRzV2l0aChcImJsb2I6XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3dlYi5kZXYvbGNwLyNtZWFzdXJlLWxjcC1pbi1qYXZhc2NyaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3dhcm5vbmNlLndhcm5PbmNlKSgnSW1hZ2Ugd2l0aCBzcmMgXCInICsgbGNwSW1hZ2Uuc3JjICsgJ1wiIHdhcyBkZXRlY3RlZCBhcyB0aGUgTGFyZ2VzdCBDb250ZW50ZnVsIFBhaW50IChMQ1ApLiBQbGVhc2UgYWRkIHRoZSBcInByaW9yaXR5XCIgcHJvcGVydHkgaWYgdGhpcyBpbWFnZSBpcyBhYm92ZSB0aGUgZm9sZC4nICsgXCJcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNwcmlvcml0eVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwZXJmT2JzZXJ2ZXIub2JzZXJ2ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibGFyZ2VzdC1jb250ZW50ZnVsLXBhaW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcmVkOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBMb2cgZXJyb3IgYnV0IGRvbid0IGNyYXNoIHRoZSBhcHBcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW1nU3R5bGUgPSBPYmplY3QuYXNzaWduKGZpbGwgPyB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICBvYmplY3RGaXQsXG4gICAgICAgIG9iamVjdFBvc2l0aW9uXG4gICAgfSA6IHt9LCBzaG93QWx0VGV4dCA/IHt9IDoge1xuICAgICAgICBjb2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgfSwgc3R5bGUpO1xuICAgIGNvbnN0IGJhY2tncm91bmRJbWFnZSA9ICFibHVyQ29tcGxldGUgJiYgcGxhY2Vob2xkZXIgIT09IFwiZW1wdHlcIiA/IHBsYWNlaG9sZGVyID09PSBcImJsdXJcIiA/ICd1cmwoXCJkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCwnICsgKDAsIF9pbWFnZWJsdXJzdmcuZ2V0SW1hZ2VCbHVyU3ZnKSh7XG4gICAgICAgIHdpZHRoSW50LFxuICAgICAgICBoZWlnaHRJbnQsXG4gICAgICAgIGJsdXJXaWR0aCxcbiAgICAgICAgYmx1ckhlaWdodCxcbiAgICAgICAgYmx1ckRhdGFVUkw6IGJsdXJEYXRhVVJMIHx8IFwiXCIsXG4gICAgICAgIG9iamVjdEZpdDogaW1nU3R5bGUub2JqZWN0Rml0XG4gICAgfSkgKyAnXCIpJyA6ICd1cmwoXCInICsgcGxhY2Vob2xkZXIgKyAnXCIpJyAvLyBhc3N1bWUgYGRhdGE6aW1hZ2UvYFxuICAgICA6IG51bGw7XG4gICAgbGV0IHBsYWNlaG9sZGVyU3R5bGUgPSBiYWNrZ3JvdW5kSW1hZ2UgPyB7XG4gICAgICAgIGJhY2tncm91bmRTaXplOiBpbWdTdHlsZS5vYmplY3RGaXQgfHwgXCJjb3ZlclwiLFxuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IGltZ1N0eWxlLm9iamVjdFBvc2l0aW9uIHx8IFwiNTAlIDUwJVwiLFxuICAgICAgICBiYWNrZ3JvdW5kUmVwZWF0OiBcIm5vLXJlcGVhdFwiLFxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2VcbiAgICB9IDoge307XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyU3R5bGUuYmFja2dyb3VuZEltYWdlICYmIHBsYWNlaG9sZGVyID09PSBcImJsdXJcIiAmJiAoYmx1ckRhdGFVUkwgPT0gbnVsbCA/IHZvaWQgMCA6IGJsdXJEYXRhVVJMLnN0YXJ0c1dpdGgoXCIvXCIpKSkge1xuICAgICAgICAgICAgLy8gRHVyaW5nIGBuZXh0IGRldmAsIHdlIGRvbid0IHdhbnQgdG8gZ2VuZXJhdGUgYmx1ciBwbGFjZWhvbGRlcnMgd2l0aCB3ZWJwYWNrXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0IGNhbiBkZWxheSBzdGFydGluZyB0aGUgZGV2IHNlcnZlci4gSW5zdGVhZCwgYG5leHQtaW1hZ2UtbG9hZGVyLmpzYFxuICAgICAgICAgICAgLy8gd2lsbCBpbmxpbmUgYSBzcGVjaWFsIHVybCB0byBsYXppbHkgZ2VuZXJhdGUgdGhlIGJsdXIgcGxhY2Vob2xkZXIgYXQgcmVxdWVzdCB0aW1lLlxuICAgICAgICAgICAgcGxhY2Vob2xkZXJTdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAndXJsKFwiJyArIGJsdXJEYXRhVVJMICsgJ1wiKSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW1nQXR0cmlidXRlcyA9IGdlbmVyYXRlSW1nQXR0cnMoe1xuICAgICAgICBjb25maWcsXG4gICAgICAgIHNyYyxcbiAgICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICAgIHdpZHRoOiB3aWR0aEludCxcbiAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCxcbiAgICAgICAgc2l6ZXMsXG4gICAgICAgIGxvYWRlclxuICAgIH0pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxldCBmdWxsVXJsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmdWxsVXJsID0gbmV3IFVSTChpbWdBdHRyaWJ1dGVzLnNyYyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZnVsbFVybCA9IG5ldyBVUkwoaW1nQXR0cmlidXRlcy5zcmMsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFsbEltZ3Muc2V0KGZ1bGxVcmwuaHJlZiwge1xuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIGxvYWRpbmc6IGlzTGF6eSA/IFwibGF6eVwiIDogbG9hZGluZyxcbiAgICAgICAgZmV0Y2hQcmlvcml0eSxcbiAgICAgICAgd2lkdGg6IHdpZHRoSW50LFxuICAgICAgICBoZWlnaHQ6IGhlaWdodEludCxcbiAgICAgICAgZGVjb2Rpbmc6IFwiYXN5bmNcIixcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgLi4uaW1nU3R5bGUsXG4gICAgICAgICAgICAuLi5wbGFjZWhvbGRlclN0eWxlXG4gICAgICAgIH0sXG4gICAgICAgIHNpemVzOiBpbWdBdHRyaWJ1dGVzLnNpemVzLFxuICAgICAgICBzcmNTZXQ6IGltZ0F0dHJpYnV0ZXMuc3JjU2V0LFxuICAgICAgICBzcmM6IGltZ0F0dHJpYnV0ZXMuc3JjXG4gICAgfTtcbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgcHJpb3JpdHksXG4gICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICBmaWxsXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9wcyxcbiAgICAgICAgbWV0YVxuICAgIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1pbWctcHJvcHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImdldEltZ1Byb3BzIiwiX3dhcm5vbmNlIiwicmVxdWlyZSIsIl9pbWFnZWJsdXJzdmciLCJfaW1hZ2Vjb25maWciLCJWQUxJRF9MT0FESU5HX1ZBTFVFUyIsInVuZGVmaW5lZCIsImlzU3RhdGljUmVxdWlyZSIsInNyYyIsImRlZmF1bHQiLCJpc1N0YXRpY0ltYWdlRGF0YSIsImlzU3RhdGljSW1wb3J0IiwiYWxsSW1ncyIsIk1hcCIsInBlcmZPYnNlcnZlciIsImdldEludCIsIngiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIk5hTiIsInRlc3QiLCJwYXJzZUludCIsImdldFdpZHRocyIsInBhcmFtIiwid2lkdGgiLCJzaXplcyIsImRldmljZVNpemVzIiwiYWxsU2l6ZXMiLCJ2aWV3cG9ydFdpZHRoUmUiLCJwZXJjZW50U2l6ZXMiLCJtYXRjaCIsImV4ZWMiLCJwdXNoIiwibGVuZ3RoIiwic21hbGxlc3RSYXRpbyIsIk1hdGgiLCJtaW4iLCJ3aWR0aHMiLCJmaWx0ZXIiLCJzIiwia2luZCIsIlNldCIsIm1hcCIsInciLCJmaW5kIiwicCIsImdlbmVyYXRlSW1nQXR0cnMiLCJjb25maWciLCJ1bm9wdGltaXplZCIsInF1YWxpdHkiLCJsb2FkZXIiLCJzcmNTZXQiLCJsYXN0IiwiaSIsImpvaW4iLCJfc3RhdGUiLCJwcmlvcml0eSIsImxvYWRpbmciLCJjbGFzc05hbWUiLCJoZWlnaHQiLCJmaWxsIiwic3R5bGUiLCJvbkxvYWQiLCJvbkxvYWRpbmdDb21wbGV0ZSIsInBsYWNlaG9sZGVyIiwiYmx1ckRhdGFVUkwiLCJmZXRjaFByaW9yaXR5IiwibGF5b3V0Iiwib2JqZWN0Rml0Iiwib2JqZWN0UG9zaXRpb24iLCJsYXp5Qm91bmRhcnkiLCJsYXp5Um9vdCIsInJlc3QiLCJpbWdDb25mIiwic2hvd0FsdFRleHQiLCJibHVyQ29tcGxldGUiLCJkZWZhdWx0TG9hZGVyIiwiYyIsImltYWdlQ29uZmlnRGVmYXVsdCIsImltYWdlU2l6ZXMiLCJzb3J0IiwiYSIsImIiLCJpc0RlZmF1bHRMb2FkZXIiLCJFcnJvciIsImN1c3RvbUltYWdlTG9hZGVyIiwib2JqIiwiXyIsIm9wdHMiLCJsYXlvdXRUb1N0eWxlIiwiaW50cmluc2ljIiwibWF4V2lkdGgiLCJyZXNwb25zaXZlIiwibGF5b3V0VG9TaXplcyIsImxheW91dFN0eWxlIiwibGF5b3V0U2l6ZXMiLCJzdGF0aWNTcmMiLCJ3aWR0aEludCIsImhlaWdodEludCIsImJsdXJXaWR0aCIsImJsdXJIZWlnaHQiLCJzdGF0aWNJbWFnZURhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwicmF0aW8iLCJyb3VuZCIsImlzTGF6eSIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsImRhbmdlcm91c2x5QWxsb3dTVkciLCJxdWFsaXR5SW50IiwicHJvY2VzcyIsIm91dHB1dCIsInBvc2l0aW9uIiwiaXNOYU4iLCJpbmNsdWRlcyIsIlN0cmluZyIsIndhcm5PbmNlIiwiVkFMSURfQkxVUl9FWFQiLCJ1cmxTdHIiLCJ1cmwiLCJVUkwiLCJlcnIiLCJwYXRobmFtZSIsInNlYXJjaCIsImxlZ2FjeUtleSIsImxlZ2FjeVZhbHVlIiwiZW50cmllcyIsIndpbmRvdyIsIlBlcmZvcm1hbmNlT2JzZXJ2ZXIiLCJlbnRyeUxpc3QiLCJlbnRyeSIsImdldEVudHJpZXMiLCJfZW50cnlfZWxlbWVudCIsImltZ1NyYyIsImVsZW1lbnQiLCJsY3BJbWFnZSIsIm9ic2VydmUiLCJ0eXBlIiwiYnVmZmVyZWQiLCJjb25zb2xlIiwiZXJyb3IiLCJpbWdTdHlsZSIsImFzc2lnbiIsImxlZnQiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImNvbG9yIiwiYmFja2dyb3VuZEltYWdlIiwiZ2V0SW1hZ2VCbHVyU3ZnIiwicGxhY2Vob2xkZXJTdHlsZSIsImJhY2tncm91bmRTaXplIiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYmFja2dyb3VuZFJlcGVhdCIsImltZ0F0dHJpYnV0ZXMiLCJmdWxsVXJsIiwiZSIsImxvY2F0aW9uIiwiaHJlZiIsInNldCIsInByb3BzIiwiZGVjb2RpbmciLCJtZXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/head.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    defaultHead: function() {\n        return defaultHead;\n    },\n    default: function() {\n        return _default;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _sideeffect = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./side-effect */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\"));\nconst _ampcontextsharedruntime = __webpack_require__(/*! ./amp-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\");\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ./head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _ampmode = __webpack_require__(/*! ./amp-mode */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\");\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nfunction defaultHead(inAmpMode) {\n    if (inAmpMode === void 0) inAmpMode = false;\n    const head = [\n        /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            charSet: \"utf-8\"\n        })\n    ];\n    if (!inAmpMode) {\n        head.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            name: \"viewport\",\n            content: \"width=device-width\"\n        }));\n    }\n    return head;\n}\nfunction onlyReactElement(list, child) {\n    // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n    if (typeof child === \"string\" || typeof child === \"number\") {\n        return list;\n    }\n    // Adds support for React.Fragment\n    if (child.type === _react.default.Fragment) {\n        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{\n            if (typeof fragmentChild === \"string\" || typeof fragmentChild === \"number\") {\n                return fragmentList;\n            }\n            return fragmentList.concat(fragmentChild);\n        }, []));\n    }\n    return list.concat(child);\n}\nconst METATYPES = [\n    \"name\",\n    \"httpEquiv\",\n    \"charSet\",\n    \"itemProp\"\n];\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/ function unique() {\n    const keys = new Set();\n    const tags = new Set();\n    const metaTypes = new Set();\n    const metaCategories = {};\n    return (h)=>{\n        let isUnique = true;\n        let hasKey = false;\n        if (h.key && typeof h.key !== \"number\" && h.key.indexOf(\"$\") > 0) {\n            hasKey = true;\n            const key = h.key.slice(h.key.indexOf(\"$\") + 1);\n            if (keys.has(key)) {\n                isUnique = false;\n            } else {\n                keys.add(key);\n            }\n        }\n        // eslint-disable-next-line default-case\n        switch(h.type){\n            case \"title\":\n            case \"base\":\n                if (tags.has(h.type)) {\n                    isUnique = false;\n                } else {\n                    tags.add(h.type);\n                }\n                break;\n            case \"meta\":\n                for(let i = 0, len = METATYPES.length; i < len; i++){\n                    const metatype = METATYPES[i];\n                    if (!h.props.hasOwnProperty(metatype)) continue;\n                    if (metatype === \"charSet\") {\n                        if (metaTypes.has(metatype)) {\n                            isUnique = false;\n                        } else {\n                            metaTypes.add(metatype);\n                        }\n                    } else {\n                        const category = h.props[metatype];\n                        const categories = metaCategories[metatype] || new Set();\n                        if ((metatype !== \"name\" || !hasKey) && categories.has(category)) {\n                            isUnique = false;\n                        } else {\n                            categories.add(category);\n                            metaCategories[metatype] = categories;\n                        }\n                    }\n                }\n                break;\n        }\n        return isUnique;\n    };\n}\n/**\n *\n * @param headChildrenElements List of children of <Head>\n */ function reduceComponents(headChildrenElements, props) {\n    const { inAmpMode } = props;\n    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map((c, i)=>{\n        const key = c.key || i;\n        if (false) {}\n        if (true) {\n            // omit JSON-LD structured data snippets from the warning\n            if (c.type === \"script\" && c.props[\"type\"] !== \"application/ld+json\") {\n                const srcMessage = c.props[\"src\"] ? '<script> tag with src=\"' + c.props[\"src\"] + '\"' : \"inline <script>\";\n                (0, _warnonce.warnOnce)(\"Do not add <script> tags using next/head (see \" + srcMessage + \"). Use next/script instead. \\nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component\");\n            } else if (c.type === \"link\" && c.props[\"rel\"] === \"stylesheet\") {\n                (0, _warnonce.warnOnce)('Do not add stylesheets using next/head (see <link rel=\"stylesheet\"> tag with href=\"' + c.props[\"href\"] + '\"). Use Document instead. \\nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component');\n            }\n        }\n        return /*#__PURE__*/ _react.default.cloneElement(c, {\n            key\n        });\n    });\n}\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */ function Head(param) {\n    let { children } = param;\n    const ampState = (0, _react.useContext)(_ampcontextsharedruntime.AmpStateContext);\n    const headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect.default, {\n        reduceComponentsToState: reduceComponents,\n        headManager: headManager,\n        inAmpMode: (0, _ampmode.isInAmpMode)(ampState),\n        children: children\n    });\n}\n_c = Head;\nconst _default = Head;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=head.js.map\nvar _c;\n$RefreshReg$(_c, \"Head\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9oZWFkLmpzIiwibWFwcGluZ3MiOiJxREFFYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsYUFBYTtRQUNULE9BQU9BO0lBQ1g7SUFDQUMsU0FBUztRQUNMLE9BQU9PO0lBQ1g7QUFDSjtBQUNBLE1BQU1DLDJCQUEyQkMsbUJBQU9BLENBQUMsZ0lBQXlDO0FBQ2xGLE1BQU1DLDRCQUE0QkQsbUJBQU9BLENBQUMsa0lBQTBDO0FBQ3BGLE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLHFHQUFtQjtBQUMvQyxNQUFNRyxTQUFTLFdBQVcsR0FBR0YsMEJBQTBCRyxDQUFDLENBQUNKLG1CQUFPQSxDQUFDLG1GQUFPO0FBQ3hFLE1BQU1LLGNBQWMsV0FBVyxHQUFHTix5QkFBeUJLLENBQUMsQ0FBQ0osbUJBQU9BLENBQUMsNkZBQWU7QUFDcEYsTUFBTU0sMkJBQTJCTixtQkFBT0EsQ0FBQywySEFBOEI7QUFDdkUsTUFBTU8sbUNBQW1DUCxtQkFBT0EsQ0FBQyw2SUFBdUM7QUFDeEYsTUFBTVEsV0FBV1IsbUJBQU9BLENBQUMsdUZBQVk7QUFDckMsTUFBTVMsWUFBWVQsbUJBQU9BLENBQUMscUdBQW1CO0FBQzdDLFNBQVNWLFlBQVlvQixTQUFTO0lBQzFCLElBQUlBLGNBQWMsS0FBSyxHQUFHQSxZQUFZO0lBQ3RDLE1BQU1DLE9BQU87UUFDVCxXQUFXLEdBQUksSUFBR1QsWUFBWVUsR0FBRyxFQUFFLFFBQVE7WUFDdkND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VSxFQUFFakUseUJBQXlCa0UsZUFBZTtJQUNoRixNQUFNQyxjQUFjLENBQUMsR0FBR3RFLE9BQU9vRSxVQUFVLEVBQUVoRSxpQ0FBaUNtRSxrQkFBa0I7SUFDOUYsT0FBcUIsV0FBSCxHQUFJLElBQUd4RSxZQUFZVSxHQUFHLEVBQUVQLFlBQVlkLE9BQU8sRUFBRTtRQUMzRG9GLHlCQUF5QnhCO1FBQ3pCc0IsYUFBYUE7UUFDYi9ELFdBQVcsQ0FBQyxHQUFHRixTQUFTb0UsV0FBVyxFQUFFTjtRQUNyQzdDLFVBQVVBO0lBQ2Q7QUFDSjtLQVZhMkM7QUFXYixNQUFNdEUsV0FBV3NFO0FBRWpCLElBQUksQ0FBQyxPQUFPakYsUUFBUUksT0FBTyxLQUFLLGNBQWUsT0FBT0osUUFBUUksT0FBTyxLQUFLLFlBQVlKLFFBQVFJLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0osUUFBUUksT0FBTyxDQUFDc0YsVUFBVSxLQUFLLGFBQWE7SUFDcks1RixPQUFPQyxjQUFjLENBQUNDLFFBQVFJLE9BQU8sRUFBRSxjQUFjO1FBQUVILE9BQU87SUFBSztJQUNuRUgsT0FBTzZGLE1BQU0sQ0FBQzNGLFFBQVFJLE9BQU8sRUFBRUo7SUFDL0JFLE9BQU9GLE9BQU8sR0FBR0EsUUFBUUksT0FBTztBQUNsQyxFQUVBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaGVhZC5qcz9mYjVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGRlZmF1bHRIZWFkOiBudWxsLFxuICAgIGRlZmF1bHQ6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZGVmYXVsdEhlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdEhlYWQ7XG4gICAgfSxcbiAgICBkZWZhdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0O1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZFwiKTtcbmNvbnN0IF9qc3hydW50aW1lID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IF9zaWRlZWZmZWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi9zaWRlLWVmZmVjdFwiKSk7XG5jb25zdCBfYW1wY29udGV4dHNoYXJlZHJ1bnRpbWUgPSByZXF1aXJlKFwiLi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZVwiKTtcbmNvbnN0IF9oZWFkbWFuYWdlcmNvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZShcIi4vaGVhZC1tYW5hZ2VyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWVcIik7XG5jb25zdCBfYW1wbW9kZSA9IHJlcXVpcmUoXCIuL2FtcC1tb2RlXCIpO1xuY29uc3QgX3dhcm5vbmNlID0gcmVxdWlyZShcIi4vdXRpbHMvd2Fybi1vbmNlXCIpO1xuZnVuY3Rpb24gZGVmYXVsdEhlYWQoaW5BbXBNb2RlKSB7XG4gICAgaWYgKGluQW1wTW9kZSA9PT0gdm9pZCAwKSBpbkFtcE1vZGUgPSBmYWxzZTtcbiAgICBjb25zdCBoZWFkID0gW1xuICAgICAgICAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKFwibWV0YVwiLCB7XG4gICAgICAgICAgICBjaGFyU2V0OiBcInV0Zi04XCJcbiAgICAgICAgfSlcbiAgICBdO1xuICAgIGlmICghaW5BbXBNb2RlKSB7XG4gICAgICAgIGhlYWQucHVzaCgvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKFwibWV0YVwiLCB7XG4gICAgICAgICAgICBuYW1lOiBcInZpZXdwb3J0XCIsXG4gICAgICAgICAgICBjb250ZW50OiBcIndpZHRoPWRldmljZS13aWR0aFwiXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWQ7XG59XG5mdW5jdGlvbiBvbmx5UmVhY3RFbGVtZW50KGxpc3QsIGNoaWxkKSB7XG4gICAgLy8gUmVhY3QgY2hpbGRyZW4gY2FuIGJlIFwic3RyaW5nXCIgb3IgXCJudW1iZXJcIiBpbiB0aGlzIGNhc2Ugd2UgaWdub3JlIHRoZW0gZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBjaGlsZCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgLy8gQWRkcyBzdXBwb3J0IGZvciBSZWFjdC5GcmFnbWVudFxuICAgIGlmIChjaGlsZC50eXBlID09PSBfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCkge1xuICAgICAgICByZXR1cm4gbGlzdC5jb25jYXQoLy8gQHRzLWV4cGVjdC1lcnJvciBAdHlwZXMvcmVhY3QgZG9lcyBub3QgcmVtb3ZlIGZyYWdtZW50cyBidXQgdGhpcyBjb3VsZCBhbHNvIHJldHVybiBSZWFjdFBvcnRhbFtdXG4gICAgICAgIF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGQucHJvcHMuY2hpbGRyZW4pLnJlZHVjZSgvLyBAdHMtZXhwZWN0LWVycm9yIEB0eXBlcy9yZWFjdCBkb2VzIG5vdCByZW1vdmUgZnJhZ21lbnRzIGJ1dCB0aGlzIGNvdWxkIGFsc28gcmV0dXJuIFJlYWN0UG9ydGFsW11cbiAgICAgICAgKGZyYWdtZW50TGlzdCwgZnJhZ21lbnRDaGlsZCk9PntcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnJhZ21lbnRDaGlsZCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgZnJhZ21lbnRDaGlsZCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudExpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRMaXN0LmNvbmNhdChmcmFnbWVudENoaWxkKTtcbiAgICAgICAgfSwgW10pKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3QuY29uY2F0KGNoaWxkKTtcbn1cbmNvbnN0IE1FVEFUWVBFUyA9IFtcbiAgICBcIm5hbWVcIixcbiAgICBcImh0dHBFcXVpdlwiLFxuICAgIFwiY2hhclNldFwiLFxuICAgIFwiaXRlbVByb3BcIlxuXTtcbi8qXG4gcmV0dXJucyBhIGZ1bmN0aW9uIGZvciBmaWx0ZXJpbmcgaGVhZCBjaGlsZCBlbGVtZW50c1xuIHdoaWNoIHNob3VsZG4ndCBiZSBkdXBsaWNhdGVkLCBsaWtlIDx0aXRsZS8+XG4gQWxzbyBhZGRzIHN1cHBvcnQgZm9yIGRlZHVwbGljYXRlZCBga2V5YCBwcm9wZXJ0aWVzXG4qLyBmdW5jdGlvbiB1bmlxdWUoKSB7XG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB0YWdzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IG1ldGFUeXBlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBtZXRhQ2F0ZWdvcmllcyA9IHt9O1xuICAgIHJldHVybiAoaCk9PntcbiAgICAgICAgbGV0IGlzVW5pcXVlID0gdHJ1ZTtcbiAgICAgICAgbGV0IGhhc0tleSA9IGZhbHNlO1xuICAgICAgICBpZiAoaC5rZXkgJiYgdHlwZW9mIGgua2V5ICE9PSBcIm51bWJlclwiICYmIGgua2V5LmluZGV4T2YoXCIkXCIpID4gMCkge1xuICAgICAgICAgICAgaGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGgua2V5LnNsaWNlKGgua2V5LmluZGV4T2YoXCIkXCIpICsgMSk7XG4gICAgICAgICAgICBpZiAoa2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlZmF1bHQtY2FzZVxuICAgICAgICBzd2l0Y2goaC50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgXCJ0aXRsZVwiOlxuICAgICAgICAgICAgY2FzZSBcImJhc2VcIjpcbiAgICAgICAgICAgICAgICBpZiAodGFncy5oYXMoaC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ3MuYWRkKGgudHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1ldGFcIjpcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwLCBsZW4gPSBNRVRBVFlQRVMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhdHlwZSA9IE1FVEFUWVBFU1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoLnByb3BzLmhhc093blByb3BlcnR5KG1ldGF0eXBlKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhdHlwZSA9PT0gXCJjaGFyU2V0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhVHlwZXMuaGFzKG1ldGF0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFUeXBlcy5hZGQobWV0YXR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSBoLnByb3BzW21ldGF0eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBtZXRhQ2F0ZWdvcmllc1ttZXRhdHlwZV0gfHwgbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtZXRhdHlwZSAhPT0gXCJuYW1lXCIgfHwgIWhhc0tleSkgJiYgY2F0ZWdvcmllcy5oYXMoY2F0ZWdvcnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNVbmlxdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllcy5hZGQoY2F0ZWdvcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFDYXRlZ29yaWVzW21ldGF0eXBlXSA9IGNhdGVnb3JpZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVW5pcXVlO1xuICAgIH07XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gaGVhZENoaWxkcmVuRWxlbWVudHMgTGlzdCBvZiBjaGlsZHJlbiBvZiA8SGVhZD5cbiAqLyBmdW5jdGlvbiByZWR1Y2VDb21wb25lbnRzKGhlYWRDaGlsZHJlbkVsZW1lbnRzLCBwcm9wcykge1xuICAgIGNvbnN0IHsgaW5BbXBNb2RlIH0gPSBwcm9wcztcbiAgICByZXR1cm4gaGVhZENoaWxkcmVuRWxlbWVudHMucmVkdWNlKG9ubHlSZWFjdEVsZW1lbnQsIFtdKS5yZXZlcnNlKCkuY29uY2F0KGRlZmF1bHRIZWFkKGluQW1wTW9kZSkucmV2ZXJzZSgpKS5maWx0ZXIodW5pcXVlKCkpLnJldmVyc2UoKS5tYXAoKGMsIGkpPT57XG4gICAgICAgIGNvbnN0IGtleSA9IGMua2V5IHx8IGk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJkZXZlbG9wbWVudFwiICYmIHByb2Nlc3MuZW52Ll9fTkVYVF9PUFRJTUlaRV9GT05UUyAmJiAhaW5BbXBNb2RlKSB7XG4gICAgICAgICAgICBpZiAoYy50eXBlID09PSBcImxpbmtcIiAmJiBjLnByb3BzW1wiaHJlZlwiXSAmJiAvLyBUT0RPKHByYXRlZWtiaEApOiBSZXBsYWNlIHRoaXMgd2l0aCBjb25zdCBmcm9tIGBjb25zdGFudHNgIHdoZW4gdGhlIHRyZWUgc2hha2luZyB3b3Jrcy5cbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzXCIsXG4gICAgICAgICAgICAgICAgXCJodHRwczovL3VzZS50eXBla2l0Lm5ldC9cIlxuICAgICAgICAgICAgXS5zb21lKCh1cmwpPT5jLnByb3BzW1wiaHJlZlwiXS5zdGFydHNXaXRoKHVybCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmMucHJvcHMgfHwge31cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG5ld1Byb3BzW1wiZGF0YS1ocmVmXCJdID0gbmV3UHJvcHNbXCJocmVmXCJdO1xuICAgICAgICAgICAgICAgIG5ld1Byb3BzW1wiaHJlZlwiXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBhdHRyaWJ1dGUgdG8gbWFrZSBpdCBlYXN5IHRvIGlkZW50aWZ5IG9wdGltaXplZCB0YWdzXG4gICAgICAgICAgICAgICAgbmV3UHJvcHNbXCJkYXRhLW9wdGltaXplZC1mb250c1wiXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGMsIG5ld1Byb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgICAgLy8gb21pdCBKU09OLUxEIHN0cnVjdHVyZWQgZGF0YSBzbmlwcGV0cyBmcm9tIHRoZSB3YXJuaW5nXG4gICAgICAgICAgICBpZiAoYy50eXBlID09PSBcInNjcmlwdFwiICYmIGMucHJvcHNbXCJ0eXBlXCJdICE9PSBcImFwcGxpY2F0aW9uL2xkK2pzb25cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNyY01lc3NhZ2UgPSBjLnByb3BzW1wic3JjXCJdID8gJzxzY3JpcHQ+IHRhZyB3aXRoIHNyYz1cIicgKyBjLnByb3BzW1wic3JjXCJdICsgJ1wiJyA6IFwiaW5saW5lIDxzY3JpcHQ+XCI7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoXCJEbyBub3QgYWRkIDxzY3JpcHQ+IHRhZ3MgdXNpbmcgbmV4dC9oZWFkIChzZWUgXCIgKyBzcmNNZXNzYWdlICsgXCIpLiBVc2UgbmV4dC9zY3JpcHQgaW5zdGVhZC4gXFxuU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uby1zY3JpcHQtdGFncy1pbi1oZWFkLWNvbXBvbmVudFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYy50eXBlID09PSBcImxpbmtcIiAmJiBjLnByb3BzW1wicmVsXCJdID09PSBcInN0eWxlc2hlZXRcIikge1xuICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdEbyBub3QgYWRkIHN0eWxlc2hlZXRzIHVzaW5nIG5leHQvaGVhZCAoc2VlIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIj4gdGFnIHdpdGggaHJlZj1cIicgKyBjLnByb3BzW1wiaHJlZlwiXSArICdcIikuIFVzZSBEb2N1bWVudCBpbnN0ZWFkLiBcXG5TZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25vLXN0eWxlc2hlZXRzLWluLWhlYWQtY29tcG9uZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGMsIHtcbiAgICAgICAgICAgIGtleVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogVGhpcyBjb21wb25lbnQgaW5qZWN0cyBlbGVtZW50cyB0byBgPGhlYWQ+YCBvZiB5b3VyIHBhZ2UuXG4gKiBUbyBhdm9pZCBkdXBsaWNhdGVkIGB0YWdzYCBpbiBgPGhlYWQ+YCB5b3UgY2FuIHVzZSB0aGUgYGtleWAgcHJvcGVydHksIHdoaWNoIHdpbGwgbWFrZSBzdXJlIGV2ZXJ5IHRhZyBpcyBvbmx5IHJlbmRlcmVkIG9uY2UuXG4gKi8gZnVuY3Rpb24gSGVhZChwYXJhbSkge1xuICAgIGxldCB7IGNoaWxkcmVuIH0gPSBwYXJhbTtcbiAgICBjb25zdCBhbXBTdGF0ZSA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoX2FtcGNvbnRleHRzaGFyZWRydW50aW1lLkFtcFN0YXRlQ29udGV4dCk7XG4gICAgY29uc3QgaGVhZE1hbmFnZXIgPSAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKF9oZWFkbWFuYWdlcmNvbnRleHRzaGFyZWRydW50aW1lLkhlYWRNYW5hZ2VyQ29udGV4dCk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX3NpZGVlZmZlY3QuZGVmYXVsdCwge1xuICAgICAgICByZWR1Y2VDb21wb25lbnRzVG9TdGF0ZTogcmVkdWNlQ29tcG9uZW50cyxcbiAgICAgICAgaGVhZE1hbmFnZXI6IGhlYWRNYW5hZ2VyLFxuICAgICAgICBpbkFtcE1vZGU6ICgwLCBfYW1wbW9kZS5pc0luQW1wTW9kZSkoYW1wU3RhdGUpLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICB9KTtcbn1cbmNvbnN0IF9kZWZhdWx0ID0gSGVhZDtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJkZWZhdWx0SGVhZCIsImRlZmF1bHQiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX2pzeHJ1bnRpbWUiLCJfcmVhY3QiLCJfIiwiX3NpZGVlZmZlY3QiLCJfYW1wY29udGV4dHNoYXJlZHJ1bnRpbWUiLCJfaGVhZG1hbmFnZXJjb250ZXh0c2hhcmVkcnVudGltZSIsIl9hbXBtb2RlIiwiX3dhcm5vbmNlIiwiaW5BbXBNb2RlIiwiaGVhZCIsImpzeCIsImNoYXJTZXQiLCJwdXNoIiwiY29udGVudCIsIm9ubHlSZWFjdEVsZW1lbnQiLCJsaXN0IiwiY2hpbGQiLCJ0eXBlIiwiRnJhZ21lbnQiLCJjb25jYXQiLCJDaGlsZHJlbiIsInRvQXJyYXkiLCJwcm9wcyIsImNoaWxkcmVuIiwicmVkdWNlIiwiZnJhZ21lbnRMaXN0IiwiZnJhZ21lbnRDaGlsZCIsIk1FVEFUWVBFUyIsInVuaXF1ZSIsImtleXMiLCJTZXQiLCJ0YWdzIiwibWV0YVR5cGVzIiwibWV0YUNhdGVnb3JpZXMiLCJoIiwiaXNVbmlxdWUiLCJoYXNLZXkiLCJrZXkiLCJpbmRleE9mIiwic2xpY2UiLCJoYXMiLCJhZGQiLCJpIiwibGVuIiwibGVuZ3RoIiwibWV0YXR5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhdGVnb3J5IiwiY2F0ZWdvcmllcyIsInJlZHVjZUNvbXBvbmVudHMiLCJoZWFkQ2hpbGRyZW5FbGVtZW50cyIsInJldmVyc2UiLCJmaWx0ZXIiLCJtYXAiLCJjIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9PUFRJTUlaRV9GT05UUyIsInNvbWUiLCJ1cmwiLCJzdGFydHNXaXRoIiwibmV3UHJvcHMiLCJ1bmRlZmluZWQiLCJjbG9uZUVsZW1lbnQiLCJzcmNNZXNzYWdlIiwid2Fybk9uY2UiLCJIZWFkIiwicGFyYW0iLCJhbXBTdGF0ZSIsInVzZUNvbnRleHQiLCJBbXBTdGF0ZUNvbnRleHQiLCJoZWFkTWFuYWdlciIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsInJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIiwiaXNJbkFtcE1vZGUiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-blur-svg.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * A shared function, used on both client and server, to generate a SVG blur placeholder.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImageBlurSvg\", ({\n    enumerable: true,\n    get: function() {\n        return getImageBlurSvg;\n    }\n}));\nfunction getImageBlurSvg(param) {\n    let { widthInt, heightInt, blurWidth, blurHeight, blurDataURL, objectFit } = param;\n    const std = 20;\n    const svgWidth = blurWidth ? blurWidth * 40 : widthInt;\n    const svgHeight = blurHeight ? blurHeight * 40 : heightInt;\n    const viewBox = svgWidth && svgHeight ? \"viewBox='0 0 \" + svgWidth + \" \" + svgHeight + \"'\" : \"\";\n    const preserveAspectRatio = viewBox ? \"none\" : objectFit === \"contain\" ? \"xMidYMid\" : objectFit === \"cover\" ? \"xMidYMid slice\" : \"none\";\n    return \"%3Csvg xmlns='http://www.w3.org/2000/svg' \" + viewBox + \"%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='\" + preserveAspectRatio + \"' style='filter: url(%23b);' href='\" + blurDataURL + \"'/%3E%3C/svg%3E\";\n} //# sourceMappingURL=image-blur-svg.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Zy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUFnQjtBQUNqQkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILG1EQUFrRDtJQUM5Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLFNBQVNBLGdCQUFnQkMsS0FBSztJQUMxQixJQUFJLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUVDLFVBQVUsRUFBRUMsV0FBVyxFQUFFQyxTQUFTLEVBQUUsR0FBR047SUFDN0UsTUFBTU8sTUFBTTtJQUNaLE1BQU1DLFdBQVdMLFlBQVlBLFlBQVksS0FBS0Y7SUFDOUMsTUFBTVEsWUFBWUwsYUFBYUEsYUFBYSxLQUFLRjtJQUNqRCxNQUFNUSxVQUFVRixZQUFZQyxZQUFZLGtCQUFrQkQsV0FBVyxNQUFNQyxZQUFZLE1BQU07SUFDN0YsTUFBTUUsc0JBQXNCRCxVQUFVLFNBQVNKLGNBQWMsWUFBWSxhQUFhQSxjQUFjLFVBQVUsbUJBQW1CO0lBQ2pJLE9BQU8sK0NBQStDSSxVQUFVLDhGQUE4RkgsTUFBTSxvUUFBb1FBLE1BQU0sZ0dBQWdHSSxzQkFBc0Isd0NBQXdDTixjQUFjO0FBQzlsQixFQUVBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtYmx1ci1zdmcuanM/OTU3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgc2hhcmVkIGZ1bmN0aW9uLCB1c2VkIG9uIGJvdGggY2xpZW50IGFuZCBzZXJ2ZXIsIHRvIGdlbmVyYXRlIGEgU1ZHIGJsdXIgcGxhY2Vob2xkZXIuXG4gKi8gXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRJbWFnZUJsdXJTdmdcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldEltYWdlQmx1clN2ZztcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGdldEltYWdlQmx1clN2ZyhwYXJhbSkge1xuICAgIGxldCB7IHdpZHRoSW50LCBoZWlnaHRJbnQsIGJsdXJXaWR0aCwgYmx1ckhlaWdodCwgYmx1ckRhdGFVUkwsIG9iamVjdEZpdCB9ID0gcGFyYW07XG4gICAgY29uc3Qgc3RkID0gMjA7XG4gICAgY29uc3Qgc3ZnV2lkdGggPSBibHVyV2lkdGggPyBibHVyV2lkdGggKiA0MCA6IHdpZHRoSW50O1xuICAgIGNvbnN0IHN2Z0hlaWdodCA9IGJsdXJIZWlnaHQgPyBibHVySGVpZ2h0ICogNDAgOiBoZWlnaHRJbnQ7XG4gICAgY29uc3Qgdmlld0JveCA9IHN2Z1dpZHRoICYmIHN2Z0hlaWdodCA/IFwidmlld0JveD0nMCAwIFwiICsgc3ZnV2lkdGggKyBcIiBcIiArIHN2Z0hlaWdodCArIFwiJ1wiIDogXCJcIjtcbiAgICBjb25zdCBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gdmlld0JveCA/IFwibm9uZVwiIDogb2JqZWN0Rml0ID09PSBcImNvbnRhaW5cIiA/IFwieE1pZFlNaWRcIiA6IG9iamVjdEZpdCA9PT0gXCJjb3ZlclwiID8gXCJ4TWlkWU1pZCBzbGljZVwiIDogXCJub25lXCI7XG4gICAgcmV0dXJuIFwiJTNDc3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgXCIgKyB2aWV3Qm94ICsgXCIlM0UlM0NmaWx0ZXIgaWQ9J2InIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0nc1JHQiclM0UlM0NmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249J1wiICsgc3RkICsgXCInLyUzRSUzQ2ZlQ29sb3JNYXRyaXggdmFsdWVzPScxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxMDAgLTEnIHJlc3VsdD0ncycvJTNFJTNDZmVGbG9vZCB4PScwJyB5PScwJyB3aWR0aD0nMTAwJTI1JyBoZWlnaHQ9JzEwMCUyNScvJTNFJTNDZmVDb21wb3NpdGUgb3BlcmF0b3I9J291dCcgaW49J3MnLyUzRSUzQ2ZlQ29tcG9zaXRlIGluMj0nU291cmNlR3JhcGhpYycvJTNFJTNDZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSdcIiArIHN0ZCArIFwiJy8lM0UlM0MvZmlsdGVyJTNFJTNDaW1hZ2Ugd2lkdGg9JzEwMCUyNScgaGVpZ2h0PScxMDAlMjUnIHg9JzAnIHk9JzAnIHByZXNlcnZlQXNwZWN0UmF0aW89J1wiICsgcHJlc2VydmVBc3BlY3RSYXRpbyArIFwiJyBzdHlsZT0nZmlsdGVyOiB1cmwoJTIzYik7JyBocmVmPSdcIiArIGJsdXJEYXRhVVJMICsgXCInLyUzRSUzQy9zdmclM0VcIjtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtYmx1ci1zdmcuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImdldEltYWdlQmx1clN2ZyIsInBhcmFtIiwid2lkdGhJbnQiLCJoZWlnaHRJbnQiLCJibHVyV2lkdGgiLCJibHVySGVpZ2h0IiwiYmx1ckRhdGFVUkwiLCJvYmplY3RGaXQiLCJzdGQiLCJzdmdXaWR0aCIsInN2Z0hlaWdodCIsInZpZXdCb3giLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js ***!
  \**********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ImageConfigContext\", ({\n    enumerable: true,\n    get: function() {\n        return ImageConfigContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst ImageConfigContext = _react.default.createContext(_imageconfig.imageConfigDefault);\nif (true) {\n    ImageConfigContext.displayName = \"ImageConfigContext\";\n} //# sourceMappingURL=image-config-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsc0RBQXFEO0lBQ2pESSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsU0FBUyxXQUFXLEdBQUdGLHlCQUF5QkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyxtRkFBTztBQUN2RSxNQUFNRyxlQUFlSCxtQkFBT0EsQ0FBQywrRkFBZ0I7QUFDN0MsTUFBTUYscUJBQXFCRyxPQUFPRyxPQUFPLENBQUNDLGFBQWEsQ0FBQ0YsYUFBYUcsa0JBQWtCO0FBQ3ZGLElBQUlDLElBQXFDLEVBQUU7SUFDdkNULG1CQUFtQlUsV0FBVyxHQUFHO0FBQ3JDLEVBRUEsK0RBQStEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcz8yNzhiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW1hZ2VDb25maWdDb250ZXh0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBJbWFnZUNvbmZpZ0NvbnRleHQ7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX2ltYWdlY29uZmlnID0gcmVxdWlyZShcIi4vaW1hZ2UtY29uZmlnXCIpO1xuY29uc3QgSW1hZ2VDb25maWdDb250ZXh0ID0gX3JlYWN0LmRlZmF1bHQuY3JlYXRlQ29udGV4dChfaW1hZ2Vjb25maWcuaW1hZ2VDb25maWdEZWZhdWx0KTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBJbWFnZUNvbmZpZ0NvbnRleHQuZGlzcGxheU5hbWUgPSBcIkltYWdlQ29uZmlnQ29udGV4dFwiO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiSW1hZ2VDb25maWdDb250ZXh0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9yZWFjdCIsIl8iLCJfaW1hZ2Vjb25maWciLCJkZWZhdWx0IiwiY3JlYXRlQ29udGV4dCIsImltYWdlQ29uZmlnRGVmYXVsdCIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    VALID_LOADERS: function() {\n        return VALID_LOADERS;\n    },\n    imageConfigDefault: function() {\n        return imageConfigDefault;\n    }\n});\nconst VALID_LOADERS = [\n    \"default\",\n    \"imgix\",\n    \"cloudinary\",\n    \"akamai\",\n    \"custom\"\n];\nconst imageConfigDefault = {\n    deviceSizes: [\n        640,\n        750,\n        828,\n        1080,\n        1200,\n        1920,\n        2048,\n        3840\n    ],\n    imageSizes: [\n        16,\n        32,\n        48,\n        64,\n        96,\n        128,\n        256,\n        384\n    ],\n    path: \"/_next/image\",\n    loader: \"default\",\n    loaderFile: \"\",\n    domains: [],\n    disableStaticImages: false,\n    minimumCacheTTL: 60,\n    formats: [\n        \"image/webp\"\n    ],\n    dangerouslyAllowSVG: false,\n    contentSecurityPolicy: \"script-src 'none'; frame-src 'none'; sandbox;\",\n    contentDispositionType: \"inline\",\n    remotePatterns: [],\n    unoptimized: false\n}; //# sourceMappingURL=image-config.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FHTjtBQUNBLFNBQVNHLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlULE9BQU9DLGNBQWMsQ0FBQ08sUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTCxTQUFTO0lBQ2JHLGVBQWU7UUFDWCxPQUFPQTtJQUNYO0lBQ0FDLG9CQUFvQjtRQUNoQixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxNQUFNRCxnQkFBZ0I7SUFDbEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ0QsTUFBTUMscUJBQXFCO0lBQ3ZCTyxhQUFhO1FBQ1Q7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0RDLFlBQVk7UUFDUjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDREMsTUFBTTtJQUNOQyxRQUFRO0lBQ1JDLFlBQVk7SUFDWkMsU0FBUyxFQUFFO0lBQ1hDLHFCQUFxQjtJQUNyQkMsaUJBQWlCO0lBQ2pCQyxTQUFTO1FBQ0w7S0FDSDtJQUNEQyxxQkFBcUI7SUFDckJDLHVCQUF1QjtJQUN2QkMsd0JBQXdCO0lBQ3hCQyxnQkFBZ0IsRUFBRTtJQUNsQkMsYUFBYTtBQUNqQixHQUVBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnLmpzPzMxMjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBWQUxJRF9MT0FERVJTOiBudWxsLFxuICAgIGltYWdlQ29uZmlnRGVmYXVsdDogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBWQUxJRF9MT0FERVJTOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFZBTElEX0xPQURFUlM7XG4gICAgfSxcbiAgICBpbWFnZUNvbmZpZ0RlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaW1hZ2VDb25maWdEZWZhdWx0O1xuICAgIH1cbn0pO1xuY29uc3QgVkFMSURfTE9BREVSUyA9IFtcbiAgICBcImRlZmF1bHRcIixcbiAgICBcImltZ2l4XCIsXG4gICAgXCJjbG91ZGluYXJ5XCIsXG4gICAgXCJha2FtYWlcIixcbiAgICBcImN1c3RvbVwiXG5dO1xuY29uc3QgaW1hZ2VDb25maWdEZWZhdWx0ID0ge1xuICAgIGRldmljZVNpemVzOiBbXG4gICAgICAgIDY0MCxcbiAgICAgICAgNzUwLFxuICAgICAgICA4MjgsXG4gICAgICAgIDEwODAsXG4gICAgICAgIDEyMDAsXG4gICAgICAgIDE5MjAsXG4gICAgICAgIDIwNDgsXG4gICAgICAgIDM4NDBcbiAgICBdLFxuICAgIGltYWdlU2l6ZXM6IFtcbiAgICAgICAgMTYsXG4gICAgICAgIDMyLFxuICAgICAgICA0OCxcbiAgICAgICAgNjQsXG4gICAgICAgIDk2LFxuICAgICAgICAxMjgsXG4gICAgICAgIDI1NixcbiAgICAgICAgMzg0XG4gICAgXSxcbiAgICBwYXRoOiBcIi9fbmV4dC9pbWFnZVwiLFxuICAgIGxvYWRlcjogXCJkZWZhdWx0XCIsXG4gICAgbG9hZGVyRmlsZTogXCJcIixcbiAgICBkb21haW5zOiBbXSxcbiAgICBkaXNhYmxlU3RhdGljSW1hZ2VzOiBmYWxzZSxcbiAgICBtaW5pbXVtQ2FjaGVUVEw6IDYwLFxuICAgIGZvcm1hdHM6IFtcbiAgICAgICAgXCJpbWFnZS93ZWJwXCJcbiAgICBdLFxuICAgIGRhbmdlcm91c2x5QWxsb3dTVkc6IGZhbHNlLFxuICAgIGNvbnRlbnRTZWN1cml0eVBvbGljeTogXCJzY3JpcHQtc3JjICdub25lJzsgZnJhbWUtc3JjICdub25lJzsgc2FuZGJveDtcIixcbiAgICBjb250ZW50RGlzcG9zaXRpb25UeXBlOiBcImlubGluZVwiLFxuICAgIHJlbW90ZVBhdHRlcm5zOiBbXSxcbiAgICB1bm9wdGltaXplZDogZmFsc2Vcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLWNvbmZpZy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJWQUxJRF9MT0FERVJTIiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGV2aWNlU2l6ZXMiLCJpbWFnZVNpemVzIiwicGF0aCIsImxvYWRlciIsImxvYWRlckZpbGUiLCJkb21haW5zIiwiZGlzYWJsZVN0YXRpY0ltYWdlcyIsIm1pbmltdW1DYWNoZVRUTCIsImZvcm1hdHMiLCJkYW5nZXJvdXNseUFsbG93U1ZHIiwiY29udGVudFNlY3VyaXR5UG9saWN5IiwiY29udGVudERpc3Bvc2l0aW9uVHlwZSIsInJlbW90ZVBhdHRlcm5zIiwidW5vcHRpbWl6ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-external.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getImageProps: function() {\n        return getImageProps;\n    },\n    default: function() {\n        return _default;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _getimgprops = __webpack_require__(/*! ./get-img-props */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imagecomponent = __webpack_require__(/*! ../../client/image-component */ \"(app-pages-browser)/./node_modules/next/dist/client/image-component.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\"));\nconst getImageProps = (imgProps)=>{\n    const { props } = (0, _getimgprops.getImgProps)(imgProps, {\n        defaultLoader: _imageloader.default,\n        // This is replaced by webpack define plugin\n        imgConf: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[\"firebasestorage.googleapis.com\"],\"remotePatterns\":[]}\n    });\n    // Normally we don't care about undefined props because we pass to JSX,\n    // but this exported function could be used by the end user for anything\n    // so we delete undefined props to clean it up a little.\n    for (const [key, value] of Object.entries(props)){\n        if (value === undefined) {\n            delete props[key];\n        }\n    }\n    return {\n        props\n    };\n};\nconst _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsZUFBZTtRQUNYLE9BQU9BO0lBQ1g7SUFDQUMsU0FBUztRQUNMLE9BQU9PO0lBQ1g7QUFDSjtBQUNBLE1BQU1DLDJCQUEyQkMsbUJBQU9BLENBQUMsZ0lBQXlDO0FBQ2xGLE1BQU1DLGVBQWVELG1CQUFPQSxDQUFDLGlHQUFpQjtBQUM5QyxNQUFNRSxrQkFBa0JGLG1CQUFPQSxDQUFDLDRHQUE4QjtBQUM5RCxNQUFNRyxlQUFlLFdBQVcsR0FBR0oseUJBQXlCSyxDQUFDLENBQUNKLG1CQUFPQSxDQUFDLGtIQUFtQztBQUN6RyxNQUFNVixnQkFBZ0IsQ0FBQ2U7SUFDbkIsTUFBTSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxDQUFDLEdBQUdMLGFBQWFNLFdBQVcsRUFBRUYsVUFBVTtRQUN0REcsZUFBZUwsYUFBYVosT0FBTztRQUNuQyw0Q0FBNEM7UUFDNUNrQixTQUFTQywwUEFBNkI7SUFDMUM7SUFDQSx1RUFBdUU7SUFDdkUsd0VBQXdFO0lBQ3hFLHdEQUF3RDtJQUN4RCxLQUFLLE1BQU0sQ0FBQ0csS0FBS3pCLE1BQU0sSUFBSUgsT0FBTzZCLE9BQU8sQ0FBQ1IsT0FBTztRQUM3QyxJQUFJbEIsVUFBVTJCLFdBQVc7WUFDckIsT0FBT1QsS0FBSyxDQUFDTyxJQUFJO1FBQ3JCO0lBQ0o7SUFDQSxPQUFPO1FBQ0hQO0lBQ0o7QUFDSjtBQUNBLE1BQU1SLFdBQVdJLGdCQUFnQmMsS0FBSyxFQUV0QywwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2ltYWdlLWV4dGVybmFsLmpzPzY4Y2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRJbWFnZVByb3BzOiBudWxsLFxuICAgIGRlZmF1bHQ6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZ2V0SW1hZ2VQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRJbWFnZVByb3BzO1xuICAgIH0sXG4gICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdDtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfZ2V0aW1ncHJvcHMgPSByZXF1aXJlKFwiLi9nZXQtaW1nLXByb3BzXCIpO1xuY29uc3QgX2ltYWdlY29tcG9uZW50ID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9pbWFnZS1jb21wb25lbnRcIik7XG5jb25zdCBfaW1hZ2Vsb2FkZXIgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXJcIikpO1xuY29uc3QgZ2V0SW1hZ2VQcm9wcyA9IChpbWdQcm9wcyk9PntcbiAgICBjb25zdCB7IHByb3BzIH0gPSAoMCwgX2dldGltZ3Byb3BzLmdldEltZ1Byb3BzKShpbWdQcm9wcywge1xuICAgICAgICBkZWZhdWx0TG9hZGVyOiBfaW1hZ2Vsb2FkZXIuZGVmYXVsdCxcbiAgICAgICAgLy8gVGhpcyBpcyByZXBsYWNlZCBieSB3ZWJwYWNrIGRlZmluZSBwbHVnaW5cbiAgICAgICAgaW1nQ29uZjogcHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFNcbiAgICB9KTtcbiAgICAvLyBOb3JtYWxseSB3ZSBkb24ndCBjYXJlIGFib3V0IHVuZGVmaW5lZCBwcm9wcyBiZWNhdXNlIHdlIHBhc3MgdG8gSlNYLFxuICAgIC8vIGJ1dCB0aGlzIGV4cG9ydGVkIGZ1bmN0aW9uIGNvdWxkIGJlIHVzZWQgYnkgdGhlIGVuZCB1c2VyIGZvciBhbnl0aGluZ1xuICAgIC8vIHNvIHdlIGRlbGV0ZSB1bmRlZmluZWQgcHJvcHMgdG8gY2xlYW4gaXQgdXAgYSBsaXR0bGUuXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKXtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzXG4gICAgfTtcbn07XG5jb25zdCBfZGVmYXVsdCA9IF9pbWFnZWNvbXBvbmVudC5JbWFnZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtZXh0ZXJuYWwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiZ2V0SW1hZ2VQcm9wcyIsImRlZmF1bHQiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfZ2V0aW1ncHJvcHMiLCJfaW1hZ2Vjb21wb25lbnQiLCJfaW1hZ2Vsb2FkZXIiLCJfIiwiaW1nUHJvcHMiLCJwcm9wcyIsImdldEltZ1Byb3BzIiwiZGVmYXVsdExvYWRlciIsImltZ0NvbmYiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0lNQUdFX09QVFMiLCJrZXkiLCJlbnRyaWVzIiwidW5kZWZpbmVkIiwiSW1hZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-loader.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nfunction defaultLoader(param) {\n    let { config, src, width, quality } = param;\n    if (true) {\n        const missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push(\"src\");\n        if (!width) missingValues.push(\"width\");\n        if (missingValues.length > 0) {\n            throw new Error(\"Next Image Optimization requires \" + missingValues.join(\", \") + \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \" + JSON.stringify({\n                src,\n                width,\n                quality\n            }));\n        }\n        if (src.startsWith(\"//\")) {\n            throw new Error('Failed to parse src \"' + src + '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)');\n        }\n        if (!src.startsWith(\"/\") && (config.domains || config.remotePatterns)) {\n            let parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw new Error('Failed to parse src \"' + src + '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)');\n            }\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasMatch } = __webpack_require__(/*! ./match-remote-pattern */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\");\n                if (!hasMatch(config.domains, config.remotePatterns, parsedSrc)) {\n                    throw new Error(\"Invalid src prop (\" + src + ') on `next/image`, hostname \"' + parsedSrc.hostname + '\" is not configured under images in your `next.config.js`\\n' + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n                }\n            }\n        }\n    }\n    return config.path + \"?url=\" + encodeURIComponent(src) + \"&w=\" + width + \"&q=\" + (quality || 75) + ( false ? 0 : \"\");\n}\n// We use this to determine if the import is the default loader\n// or a custom loader defined by the user in next.config.js\ndefaultLoader.__next_img_default = true;\nconst _default = defaultLoader; //# sourceMappingURL=image-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDJDQUEwQztJQUN0Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLFNBQVNDLGNBQWNDLEtBQUs7SUFDeEIsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsS0FBSyxFQUFFQyxPQUFPLEVBQUUsR0FBR0o7SUFDdEMsSUFBSUssSUFBcUMsRUFBRTtRQUN2QyxNQUFNQyxnQkFBZ0IsRUFBRTtRQUN4Qix5REFBeUQ7UUFDekQsSUFBSSxDQUFDSixLQUFLSSxjQUFjQyxJQUFJLENBQUM7UUFDN0IsSUFBSSxDQUFDSixPQUFPRyxjQUFjQyxJQUFJLENBQUM7UUFDL0IsSUFBSUQsY0FBY0UsTUFBTSxHQUFHLEdBQUc7WUFDMUIsTUFBTSxJQUFJQyxNQUFNLHNDQUFzQ0gsY0FBY0ksSUFBSSxDQUFDLFFBQVEsZ0dBQWdHQyxLQUFLQyxTQUFTLENBQUM7Z0JBQzVMVjtnQkFDQUM7Z0JBQ0FDO1lBQ0o7UUFDSjtRQUNBLElBQUlGLElBQUlXLFVBQVUsQ0FBQyxPQUFPO1lBQ3RCLE1BQU0sSUFBSUosTUFBTSwwQkFBMEJQLE1BQU07UUFDcEQ7UUFDQSxJQUFJLENBQUNBLElBQUlXLFVBQVUsQ0FBQyxRQUFTWixDQUFBQSxPQUFPYSxPQUFPLElBQUliLE9BQU9jLGNBQWMsR0FBRztZQUNuRSxJQUFJQztZQUNKLElBQUk7Z0JBQ0FBLFlBQVksSUFBSUMsSUFBSWY7WUFDeEIsRUFBRSxPQUFPZ0IsS0FBSztnQkFDVkMsUUFBUUMsS0FBSyxDQUFDRjtnQkFDZCxNQUFNLElBQUlULE1BQU0sMEJBQTBCUCxNQUFNO1lBQ3BEO1lBQ0EsSUFBSUcsSUFDK0IsRUFBRTtnQkFDakMsdUVBQXVFO2dCQUN2RSxNQUFNLEVBQUVrQixRQUFRLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsK0dBQXdCO2dCQUNyRCxJQUFJLENBQUNELFNBQVN0QixPQUFPYSxPQUFPLEVBQUViLE9BQU9jLGNBQWMsRUFBRUMsWUFBWTtvQkFDN0QsTUFBTSxJQUFJUCxNQUFNLHVCQUF1QlAsTUFBTSxrQ0FBa0NjLFVBQVVTLFFBQVEsR0FBRyxnRUFBZ0U7Z0JBQ3hLO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsT0FBT3hCLE9BQU95QixJQUFJLEdBQUcsVUFBVUMsbUJBQW1CekIsT0FBTyxRQUFRQyxRQUFRLFFBQVNDLENBQUFBLFdBQVcsRUFBQyxJQUFNQyxDQUFBQSxNQUE4QixHQUFHLENBQXdDLEdBQUcsRUFBQztBQUNyTDtBQUNBLCtEQUErRDtBQUMvRCwyREFBMkQ7QUFDM0ROLGNBQWM4QixrQkFBa0IsR0FBRztBQUNuQyxNQUFNL0IsV0FBV0MsZUFFakIsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIuanM/YzBhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0O1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gZGVmYXVsdExvYWRlcihwYXJhbSkge1xuICAgIGxldCB7IGNvbmZpZywgc3JjLCB3aWR0aCwgcXVhbGl0eSB9ID0gcGFyYW07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zdCBtaXNzaW5nVmFsdWVzID0gW107XG4gICAgICAgIC8vIHRoZXNlIHNob3VsZCBhbHdheXMgYmUgcHJvdmlkZWQgYnV0IG1ha2Ugc3VyZSB0aGV5IGFyZVxuICAgICAgICBpZiAoIXNyYykgbWlzc2luZ1ZhbHVlcy5wdXNoKFwic3JjXCIpO1xuICAgICAgICBpZiAoIXdpZHRoKSBtaXNzaW5nVmFsdWVzLnB1c2goXCJ3aWR0aFwiKTtcbiAgICAgICAgaWYgKG1pc3NpbmdWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmV4dCBJbWFnZSBPcHRpbWl6YXRpb24gcmVxdWlyZXMgXCIgKyBtaXNzaW5nVmFsdWVzLmpvaW4oXCIsIFwiKSArIFwiIHRvIGJlIHByb3ZpZGVkLiBNYWtlIHN1cmUgeW91IHBhc3MgdGhlbSBhcyBwcm9wcyB0byB0aGUgYG5leHQvaW1hZ2VgIGNvbXBvbmVudC4gUmVjZWl2ZWQ6IFwiICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICBxdWFsaXR5XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNyYy5zdGFydHNXaXRoKFwiLy9cIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHBhcnNlIHNyYyBcIicgKyBzcmMgKyAnXCIgb24gYG5leHQvaW1hZ2VgLCBwcm90b2NvbC1yZWxhdGl2ZSBVUkwgKC8vKSBtdXN0IGJlIGNoYW5nZWQgdG8gYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3JjLnN0YXJ0c1dpdGgoXCIvXCIpICYmIChjb25maWcuZG9tYWlucyB8fCBjb25maWcucmVtb3RlUGF0dGVybnMpKSB7XG4gICAgICAgICAgICBsZXQgcGFyc2VkU3JjO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJzZWRTcmMgPSBuZXcgVVJMKHNyYyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2Ugc3JjIFwiJyArIHNyYyArICdcIiBvbiBgbmV4dC9pbWFnZWAsIGlmIHVzaW5nIHJlbGF0aXZlIGltYWdlIGl0IG11c3Qgc3RhcnQgd2l0aCBhIGxlYWRpbmcgc2xhc2ggXCIvXCIgb3IgYmUgYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInRlc3RcIiAmJiAvLyBtaWNyb21hdGNoIGlzbid0IGNvbXBhdGlibGUgd2l0aCBlZGdlIHJ1bnRpbWVcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSAhPT0gXCJlZGdlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgZHluYW1pYyByZXF1aXJlIGJlY2F1c2UgdGhpcyBzaG91bGQgb25seSBlcnJvciBpbiBkZXZlbG9wbWVudFxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaGFzTWF0Y2ggfSA9IHJlcXVpcmUoXCIuL21hdGNoLXJlbW90ZS1wYXR0ZXJuXCIpO1xuICAgICAgICAgICAgICAgIGlmICghaGFzTWF0Y2goY29uZmlnLmRvbWFpbnMsIGNvbmZpZy5yZW1vdGVQYXR0ZXJucywgcGFyc2VkU3JjKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNyYyBwcm9wIChcIiArIHNyYyArICcpIG9uIGBuZXh0L2ltYWdlYCwgaG9zdG5hbWUgXCInICsgcGFyc2VkU3JjLmhvc3RuYW1lICsgJ1wiIGlzIG5vdCBjb25maWd1cmVkIHVuZGVyIGltYWdlcyBpbiB5b3VyIGBuZXh0LmNvbmZpZy5qc2BcXG4nICsgXCJTZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVuY29uZmlndXJlZC1ob3N0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29uZmlnLnBhdGggKyBcIj91cmw9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoc3JjKSArIFwiJnc9XCIgKyB3aWR0aCArIFwiJnE9XCIgKyAocXVhbGl0eSB8fCA3NSkgKyAocHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEID8gXCImZHBsPVwiICsgcHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEIDogXCJcIik7XG59XG4vLyBXZSB1c2UgdGhpcyB0byBkZXRlcm1pbmUgaWYgdGhlIGltcG9ydCBpcyB0aGUgZGVmYXVsdCBsb2FkZXJcbi8vIG9yIGEgY3VzdG9tIGxvYWRlciBkZWZpbmVkIGJ5IHRoZSB1c2VyIGluIG5leHQuY29uZmlnLmpzXG5kZWZhdWx0TG9hZGVyLl9fbmV4dF9pbWdfZGVmYXVsdCA9IHRydWU7XG5jb25zdCBfZGVmYXVsdCA9IGRlZmF1bHRMb2FkZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLWxvYWRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2RlZmF1bHQiLCJkZWZhdWx0TG9hZGVyIiwicGFyYW0iLCJjb25maWciLCJzcmMiLCJ3aWR0aCIsInF1YWxpdHkiLCJwcm9jZXNzIiwibWlzc2luZ1ZhbHVlcyIsInB1c2giLCJsZW5ndGgiLCJFcnJvciIsImpvaW4iLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhcnRzV2l0aCIsImRvbWFpbnMiLCJyZW1vdGVQYXR0ZXJucyIsInBhcnNlZFNyYyIsIlVSTCIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsImVudiIsIk5FWFRfUlVOVElNRSIsImhhc01hdGNoIiwicmVxdWlyZSIsImhvc3RuYW1lIiwicGF0aCIsImVuY29kZVVSSUNvbXBvbmVudCIsIk5FWFRfREVQTE9ZTUVOVF9JRCIsIl9fbmV4dF9pbWdfZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    matchRemotePattern: function() {\n        return matchRemotePattern;\n    },\n    hasMatch: function() {\n        return hasMatch;\n    }\n});\nconst _micromatch = __webpack_require__(/*! next/dist/compiled/micromatch */ \"(app-pages-browser)/./node_modules/next/dist/compiled/micromatch/index.js\");\nfunction matchRemotePattern(pattern, url) {\n    if (pattern.protocol !== undefined) {\n        const actualProto = url.protocol.slice(0, -1);\n        if (pattern.protocol !== actualProto) {\n            return false;\n        }\n    }\n    if (pattern.port !== undefined) {\n        if (pattern.port !== url.port) {\n            return false;\n        }\n    }\n    if (pattern.hostname === undefined) {\n        throw new Error(\"Pattern should define hostname but found\\n\" + JSON.stringify(pattern));\n    } else {\n        if (!(0, _micromatch.makeRe)(pattern.hostname).test(url.hostname)) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    if (!(0, _micromatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : \"**\").test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasMatch(domains, remotePatterns, url) {\n    return domains.some((domain)=>url.hostname === domain) || remotePatterns.some((p)=>matchRemotePattern(p, url));\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9tYXRjaC1yZW1vdGUtcGF0dGVybi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsb0JBQW9CO1FBQ2hCLE9BQU9BO0lBQ1g7SUFDQUMsVUFBVTtRQUNOLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1PLGNBQWNDLG1CQUFPQSxDQUFDLGdIQUErQjtBQUMzRCxTQUFTVCxtQkFBbUJVLE9BQU8sRUFBRUMsR0FBRztJQUNwQyxJQUFJRCxRQUFRRSxRQUFRLEtBQUtDLFdBQVc7UUFDaEMsTUFBTUMsY0FBY0gsSUFBSUMsUUFBUSxDQUFDRyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQzNDLElBQUlMLFFBQVFFLFFBQVEsS0FBS0UsYUFBYTtZQUNsQyxPQUFPO1FBQ1g7SUFDSjtJQUNBLElBQUlKLFFBQVFNLElBQUksS0FBS0gsV0FBVztRQUM1QixJQUFJSCxRQUFRTSxJQUFJLEtBQUtMLElBQUlLLElBQUksRUFBRTtZQUMzQixPQUFPO1FBQ1g7SUFDSjtJQUNBLElBQUlOLFFBQVFPLFFBQVEsS0FBS0osV0FBVztRQUNoQyxNQUFNLElBQUlLLE1BQU0sK0NBQStDQyxLQUFLQyxTQUFTLENBQUNWO0lBQ2xGLE9BQU87UUFDSCxJQUFJLENBQUMsQ0FBQyxHQUFHRixZQUFZYSxNQUFNLEVBQUVYLFFBQVFPLFFBQVEsRUFBRUssSUFBSSxDQUFDWCxJQUFJTSxRQUFRLEdBQUc7WUFDL0QsT0FBTztRQUNYO0lBQ0o7SUFDQSxJQUFJTTtJQUNKLElBQUksQ0FBQyxDQUFDLEdBQUdmLFlBQVlhLE1BQU0sRUFBRSxDQUFDRSxvQkFBb0JiLFFBQVFjLFFBQVEsS0FBSyxPQUFPRCxvQkFBb0IsTUFBTUQsSUFBSSxDQUFDWCxJQUFJYSxRQUFRLEdBQUc7UUFDeEgsT0FBTztJQUNYO0lBQ0EsT0FBTztBQUNYO0FBQ0EsU0FBU3ZCLFNBQVN3QixPQUFPLEVBQUVDLGNBQWMsRUFBRWYsR0FBRztJQUMxQyxPQUFPYyxRQUFRRSxJQUFJLENBQUMsQ0FBQ0MsU0FBU2pCLElBQUlNLFFBQVEsS0FBS1csV0FBV0YsZUFBZUMsSUFBSSxDQUFDLENBQUNFLElBQUk3QixtQkFBbUI2QixHQUFHbEI7QUFDN0csRUFFQSxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL21hdGNoLXJlbW90ZS1wYXR0ZXJuLmpzPzBjOWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtYXRjaFJlbW90ZVBhdHRlcm46IG51bGwsXG4gICAgaGFzTWF0Y2g6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgbWF0Y2hSZW1vdGVQYXR0ZXJuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoUmVtb3RlUGF0dGVybjtcbiAgICB9LFxuICAgIGhhc01hdGNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGhhc01hdGNoO1xuICAgIH1cbn0pO1xuY29uc3QgX21pY3JvbWF0Y2ggPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL21pY3JvbWF0Y2hcIik7XG5mdW5jdGlvbiBtYXRjaFJlbW90ZVBhdHRlcm4ocGF0dGVybiwgdXJsKSB7XG4gICAgaWYgKHBhdHRlcm4ucHJvdG9jb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBhY3R1YWxQcm90byA9IHVybC5wcm90b2NvbC5zbGljZSgwLCAtMSk7XG4gICAgICAgIGlmIChwYXR0ZXJuLnByb3RvY29sICE9PSBhY3R1YWxQcm90bykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuLnBvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocGF0dGVybi5wb3J0ICE9PSB1cmwucG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuLmhvc3RuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0dGVybiBzaG91bGQgZGVmaW5lIGhvc3RuYW1lIGJ1dCBmb3VuZFxcblwiICsgSlNPTi5zdHJpbmdpZnkocGF0dGVybikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKDAsIF9taWNyb21hdGNoLm1ha2VSZSkocGF0dGVybi5ob3N0bmFtZSkudGVzdCh1cmwuaG9zdG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9wYXR0ZXJuX3BhdGhuYW1lO1xuICAgIGlmICghKDAsIF9taWNyb21hdGNoLm1ha2VSZSkoKF9wYXR0ZXJuX3BhdGhuYW1lID0gcGF0dGVybi5wYXRobmFtZSkgIT0gbnVsbCA/IF9wYXR0ZXJuX3BhdGhuYW1lIDogXCIqKlwiKS50ZXN0KHVybC5wYXRobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGhhc01hdGNoKGRvbWFpbnMsIHJlbW90ZVBhdHRlcm5zLCB1cmwpIHtcbiAgICByZXR1cm4gZG9tYWlucy5zb21lKChkb21haW4pPT51cmwuaG9zdG5hbWUgPT09IGRvbWFpbikgfHwgcmVtb3RlUGF0dGVybnMuc29tZSgocCk9Pm1hdGNoUmVtb3RlUGF0dGVybihwLCB1cmwpKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0Y2gtcmVtb3RlLXBhdHRlcm4uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwibWF0Y2hSZW1vdGVQYXR0ZXJuIiwiaGFzTWF0Y2giLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfbWljcm9tYXRjaCIsInJlcXVpcmUiLCJwYXR0ZXJuIiwidXJsIiwicHJvdG9jb2wiLCJ1bmRlZmluZWQiLCJhY3R1YWxQcm90byIsInNsaWNlIiwicG9ydCIsImhvc3RuYW1lIiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwibWFrZVJlIiwidGVzdCIsIl9wYXR0ZXJuX3BhdGhuYW1lIiwicGF0aG5hbWUiLCJkb21haW5zIiwicmVtb3RlUGF0dGVybnMiLCJzb21lIiwiZG9tYWluIiwicCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router-context.shared-runtime.js ***!
  \****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouterContext\", ({\n    enumerable: true,\n    get: function() {\n        return RouterContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst RouterContext = _react.default.createContext(null);\nif (true) {\n    RouterContext.displayName = \"RouterContext\";\n} //# sourceMappingURL=router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsaURBQWdEO0lBQzVDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsU0FBUyxXQUFXLEdBQUdGLHlCQUF5QkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyxtRkFBTztBQUN2RSxNQUFNRixnQkFBZ0JHLE9BQU9FLE9BQU8sQ0FBQ0MsYUFBYSxDQUFDO0FBQ25ELElBQUlDLElBQXFDLEVBQUU7SUFDdkNQLGNBQWNRLFdBQVcsR0FBRztBQUNoQyxFQUVBLHlEQUF5RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUuanM/OGZhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJvdXRlckNvbnRleHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJvdXRlckNvbnRleHQ7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgUm91dGVyQ29udGV4dCA9IF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVyQ29udGV4dFwiO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiUm91dGVyQ29udGV4dCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfcmVhY3QiLCJfIiwiZGVmYXVsdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/side-effect.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return SideEffect;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst isServer = \"object\" === \"undefined\";\nconst useClientOnlyLayoutEffect = isServer ? ()=>{} : _react.useLayoutEffect;\nconst useClientOnlyEffect = isServer ? ()=>{} : _react.useEffect;\nfunction SideEffect(props) {\n    _s();\n    const { headManager, reduceComponentsToState } = props;\n    function emitChange() {\n        if (headManager && headManager.mountedInstances) {\n            const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));\n            headManager.updateHead(reduceComponentsToState(headElements, props));\n        }\n    }\n    if (isServer) {\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        emitChange();\n    }\n    useClientOnlyLayoutEffect(()=>{\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        return ()=>{\n            var _headManager_mountedInstances;\n            headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.delete(props.children);\n        };\n    });\n    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n    // being rendered, we only trigger the method from the last one.\n    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n    // singleton in the layout effect pass, and actually trigger it in the effect pass.\n    useClientOnlyLayoutEffect(()=>{\n        if (headManager) {\n            headManager._pendingUpdate = emitChange;\n        }\n        return ()=>{\n            if (headManager) {\n                headManager._pendingUpdate = emitChange;\n            }\n        };\n    });\n    useClientOnlyEffect(()=>{\n        if (headManager && headManager._pendingUpdate) {\n            headManager._pendingUpdate();\n            headManager._pendingUpdate = null;\n        }\n        return ()=>{\n            if (headManager && headManager._pendingUpdate) {\n                headManager._pendingUpdate();\n                headManager._pendingUpdate = null;\n            }\n        };\n    });\n    return null;\n} //# sourceMappingURL=side-effect.js.map\n_s(SideEffect, \"gHVkikNHNxjVdD11eJBzaqkCiPY=\", false, function() {\n    return [\n        useClientOnlyLayoutEffect,\n        useClientOnlyLayoutEffect,\n        useClientOnlyEffect\n    ];\n});\n_c = SideEffect;\nvar _c;\n$RefreshReg$(_c, \"SideEffect\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9zaWRlLWVmZmVjdC5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0FBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCwyQ0FBMEM7SUFDdENJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxTQUFTQyxtQkFBT0EsQ0FBQyxtRkFBTztBQUM5QixNQUFNQyxXQUFXLGFBQWtCO0FBQ25DLE1BQU1DLDRCQUE0QkQsV0FBVyxLQUFLLElBQUlGLE9BQU9JLGVBQWU7QUFDNUUsTUFBTUMsc0JBQXNCSCxXQUFXLEtBQUssSUFBSUYsT0FBT00sU0FBUztBQUNoRSxTQUFTUCxXQUFXUSxLQUFLOztJQUNyQixNQUFNLEVBQUVDLFdBQVcsRUFBRUMsdUJBQXVCLEVBQUUsR0FBR0Y7SUFDakQsU0FBU0c7UUFDTCxJQUFJRixlQUFlQSxZQUFZRyxnQkFBZ0IsRUFBRTtZQUM3QyxNQUFNQyxlQUFlWixPQUFPYSxRQUFRLENBQUNDLE9BQU8sQ0FBQ0MsTUFBTUMsSUFBSSxDQUFDUixZQUFZRyxnQkFBZ0IsRUFBRU0sTUFBTSxDQUFDQztZQUM3RlYsWUFBWVcsVUFBVSxDQUFDVix3QkFBd0JHLGNBQWNMO1FBQ2pFO0lBQ0o7SUFDQSxJQUFJTCxVQUFVO1FBQ1YsSUFBSWtCO1FBQ0paLGVBQWUsT0FBTyxLQUFLLElBQUksQ0FBQ1ksZ0NBQWdDWixZQUFZRyxnQkFBZ0IsS0FBSyxPQUFPLEtBQUssSUFBSVMsOEJBQThCQyxHQUFHLENBQUNkLE1BQU1lLFFBQVE7UUFDaktaO0lBQ0o7SUFDQVAsMEJBQTBCO1FBQ3RCLElBQUlpQjtRQUNKWixlQUFlLE9BQU8sS0FBSyxJQUFJLENBQUNZLGdDQUFnQ1osWUFBWUcsZ0JBQWdCLEtBQUssT0FBTyxLQUFLLElBQUlTLDhCQUE4QkMsR0FBRyxDQUFDZCxNQUFNZSxRQUFRO1FBQ2pLLE9BQU87WUFDSCxJQUFJRjtZQUNKWixlQUFlLE9BQU8sS0FBSyxJQUFJLENBQUNZLGdDQUFnQ1osWUFBWUcsZ0JBQWdCLEtBQUssT0FBTyxLQUFLLElBQUlTLDhCQUE4QkcsTUFBTSxDQUFDaEIsTUFBTWUsUUFBUTtRQUN4SztJQUNKO0lBQ0Esa0ZBQWtGO0lBQ2xGLG9GQUFvRjtJQUNwRixnRUFBZ0U7SUFDaEUscUZBQXFGO0lBQ3JGLG1GQUFtRjtJQUNuRm5CLDBCQUEwQjtRQUN0QixJQUFJSyxhQUFhO1lBQ2JBLFlBQVlnQixjQUFjLEdBQUdkO1FBQ2pDO1FBQ0EsT0FBTztZQUNILElBQUlGLGFBQWE7Z0JBQ2JBLFlBQVlnQixjQUFjLEdBQUdkO1lBQ2pDO1FBQ0o7SUFDSjtJQUNBTCxvQkFBb0I7UUFDaEIsSUFBSUcsZUFBZUEsWUFBWWdCLGNBQWMsRUFBRTtZQUMzQ2hCLFlBQVlnQixjQUFjO1lBQzFCaEIsWUFBWWdCLGNBQWMsR0FBRztRQUNqQztRQUNBLE9BQU87WUFDSCxJQUFJaEIsZUFBZUEsWUFBWWdCLGNBQWMsRUFBRTtnQkFDM0NoQixZQUFZZ0IsY0FBYztnQkFDMUJoQixZQUFZZ0IsY0FBYyxHQUFHO1lBQ2pDO1FBQ0o7SUFDSjtJQUNBLE9BQU87QUFDWCxFQUVBLHVDQUF1QztHQW5EOUJ6Qjs7UUFhTEk7UUFhQUE7UUFVQUU7OztLQXBDS04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3NpZGUtZWZmZWN0LmpzPzQwOGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTaWRlRWZmZWN0O1xuICAgIH1cbn0pO1xuY29uc3QgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuY29uc3QgaXNTZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiO1xuY29uc3QgdXNlQ2xpZW50T25seUxheW91dEVmZmVjdCA9IGlzU2VydmVyID8gKCk9Pnt9IDogX3JlYWN0LnVzZUxheW91dEVmZmVjdDtcbmNvbnN0IHVzZUNsaWVudE9ubHlFZmZlY3QgPSBpc1NlcnZlciA/ICgpPT57fSA6IF9yZWFjdC51c2VFZmZlY3Q7XG5mdW5jdGlvbiBTaWRlRWZmZWN0KHByb3BzKSB7XG4gICAgY29uc3QgeyBoZWFkTWFuYWdlciwgcmVkdWNlQ29tcG9uZW50c1RvU3RhdGUgfSA9IHByb3BzO1xuICAgIGZ1bmN0aW9uIGVtaXRDaGFuZ2UoKSB7XG4gICAgICAgIGlmIChoZWFkTWFuYWdlciAmJiBoZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkRWxlbWVudHMgPSBfcmVhY3QuQ2hpbGRyZW4udG9BcnJheShBcnJheS5mcm9tKGhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMpLmZpbHRlcihCb29sZWFuKSk7XG4gICAgICAgICAgICBoZWFkTWFuYWdlci51cGRhdGVIZWFkKHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlKGhlYWRFbGVtZW50cywgcHJvcHMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNTZXJ2ZXIpIHtcbiAgICAgICAgdmFyIF9oZWFkTWFuYWdlcl9tb3VudGVkSW5zdGFuY2VzO1xuICAgICAgICBoZWFkTWFuYWdlciA9PSBudWxsID8gdm9pZCAwIDogKF9oZWFkTWFuYWdlcl9tb3VudGVkSW5zdGFuY2VzID0gaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9oZWFkTWFuYWdlcl9tb3VudGVkSW5zdGFuY2VzLmFkZChwcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIGVtaXRDaGFuZ2UoKTtcbiAgICB9XG4gICAgdXNlQ2xpZW50T25seUxheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICB2YXIgX2hlYWRNYW5hZ2VyX21vdW50ZWRJbnN0YW5jZXM7XG4gICAgICAgIGhlYWRNYW5hZ2VyID09IG51bGwgPyB2b2lkIDAgOiAoX2hlYWRNYW5hZ2VyX21vdW50ZWRJbnN0YW5jZXMgPSBoZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzKSA9PSBudWxsID8gdm9pZCAwIDogX2hlYWRNYW5hZ2VyX21vdW50ZWRJbnN0YW5jZXMuYWRkKHByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICB2YXIgX2hlYWRNYW5hZ2VyX21vdW50ZWRJbnN0YW5jZXM7XG4gICAgICAgICAgICBoZWFkTWFuYWdlciA9PSBudWxsID8gdm9pZCAwIDogKF9oZWFkTWFuYWdlcl9tb3VudGVkSW5zdGFuY2VzID0gaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9oZWFkTWFuYWdlcl9tb3VudGVkSW5zdGFuY2VzLmRlbGV0ZShwcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgLy8gV2UgbmVlZCB0byBjYWxsIGB1cGRhdGVIZWFkYCBtZXRob2Qgd2hlbmV2ZXIgdGhlIGBTaWRlRWZmZWN0YCBpcyB0cmlnZ2VyIGluIGFsbFxuICAgIC8vIGxpZmUtY3ljbGVzOiBtb3VudCwgdXBkYXRlLCB1bm1vdW50LiBIb3dldmVyLCBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgYFNpZGVFZmZlY3Rgc1xuICAgIC8vIGJlaW5nIHJlbmRlcmVkLCB3ZSBvbmx5IHRyaWdnZXIgdGhlIG1ldGhvZCBmcm9tIHRoZSBsYXN0IG9uZS5cbiAgICAvLyBUaGlzIGlzIGVuc3VyZWQgYnkga2VlcGluZyB0aGUgbGFzdCB1bmZsdXNoZWQgYHVwZGF0ZUhlYWRgIGluIHRoZSBgX3BlbmRpbmdVcGRhdGVgXG4gICAgLy8gc2luZ2xldG9uIGluIHRoZSBsYXlvdXQgZWZmZWN0IHBhc3MsIGFuZCBhY3R1YWxseSB0cmlnZ2VyIGl0IGluIHRoZSBlZmZlY3QgcGFzcy5cbiAgICB1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChoZWFkTWFuYWdlcikge1xuICAgICAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBlbWl0Q2hhbmdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgaWYgKGhlYWRNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBlbWl0Q2hhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHVzZUNsaWVudE9ubHlFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKGhlYWRNYW5hZ2VyICYmIGhlYWRNYW5hZ2VyLl9wZW5kaW5nVXBkYXRlKSB7XG4gICAgICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSgpO1xuICAgICAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgaWYgKGhlYWRNYW5hZ2VyICYmIGhlYWRNYW5hZ2VyLl9wZW5kaW5nVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZGUtZWZmZWN0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJTaWRlRWZmZWN0IiwiX3JlYWN0IiwicmVxdWlyZSIsImlzU2VydmVyIiwidXNlQ2xpZW50T25seUxheW91dEVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUNsaWVudE9ubHlFZmZlY3QiLCJ1c2VFZmZlY3QiLCJwcm9wcyIsImhlYWRNYW5hZ2VyIiwicmVkdWNlQ29tcG9uZW50c1RvU3RhdGUiLCJlbWl0Q2hhbmdlIiwibW91bnRlZEluc3RhbmNlcyIsImhlYWRFbGVtZW50cyIsIkNoaWxkcmVuIiwidG9BcnJheSIsIkFycmF5IiwiZnJvbSIsImZpbHRlciIsIkJvb2xlYW4iLCJ1cGRhdGVIZWFkIiwiX2hlYWRNYW5hZ2VyX21vdW50ZWRJbnN0YW5jZXMiLCJhZGQiLCJjaGlsZHJlbiIsImRlbGV0ZSIsIl9wZW5kaW5nVXBkYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@swc/helpers/esm/_tagged_template_literal.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_tagged_template_literal.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _tagged_template_literal; },\n/* harmony export */   _tagged_template_literal: function() { return /* binding */ _tagged_template_literal; }\n/* harmony export */ });\nfunction _tagged_template_literal(strings, raw) {\n    if (!raw) raw = strings.slice(0);\n    return Object.freeze(Object.defineProperties(strings, {\n        raw: {\n            value: Object.freeze(raw)\n        }\n    }));\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL190YWdnZWRfdGVtcGxhdGVfbGl0ZXJhbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPLFNBQVNBLHlCQUF5QkMsT0FBTyxFQUFFQyxHQUFHO0lBQ2pELElBQUksQ0FBQ0EsS0FBS0EsTUFBTUQsUUFBUUUsS0FBSyxDQUFDO0lBRTlCLE9BQU9DLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0UsZ0JBQWdCLENBQUNMLFNBQVM7UUFBRUMsS0FBSztZQUFFSyxPQUFPSCxPQUFPQyxNQUFNLENBQUNIO1FBQUs7SUFBRTtBQUMvRjtBQUN5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2VzbS9fdGFnZ2VkX3RlbXBsYXRlX2xpdGVyYWwuanM/YmNlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gX3RhZ2dlZF90ZW1wbGF0ZV9saXRlcmFsKHN0cmluZ3MsIHJhdykge1xuICAgIGlmICghcmF3KSByYXcgPSBzdHJpbmdzLnNsaWNlKDApO1xuXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc3RyaW5ncywgeyByYXc6IHsgdmFsdWU6IE9iamVjdC5mcmVlemUocmF3KSB9IH0pKTtcbn1cbmV4cG9ydCB7IF90YWdnZWRfdGVtcGxhdGVfbGl0ZXJhbCBhcyBfIH07XG4iXSwibmFtZXMiOlsiX3RhZ2dlZF90ZW1wbGF0ZV9saXRlcmFsIiwic3RyaW5ncyIsInJhdyIsInNsaWNlIiwiT2JqZWN0IiwiZnJlZXplIiwiZGVmaW5lUHJvcGVydGllcyIsInZhbHVlIiwiXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@swc/helpers/esm/_tagged_template_literal.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/stylis/src/Enum.js":
/*!*****************************************!*\
  !*** ./node_modules/stylis/src/Enum.js ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CHARSET: function() { return /* binding */ CHARSET; },\n/* harmony export */   COMMENT: function() { return /* binding */ COMMENT; },\n/* harmony export */   COUNTER_STYLE: function() { return /* binding */ COUNTER_STYLE; },\n/* harmony export */   DECLARATION: function() { return /* binding */ DECLARATION; },\n/* harmony export */   DOCUMENT: function() { return /* binding */ DOCUMENT; },\n/* harmony export */   FONT_FACE: function() { return /* binding */ FONT_FACE; },\n/* harmony export */   FONT_FEATURE_VALUES: function() { return /* binding */ FONT_FEATURE_VALUES; },\n/* harmony export */   IMPORT: function() { return /* binding */ IMPORT; },\n/* harmony export */   KEYFRAMES: function() { return /* binding */ KEYFRAMES; },\n/* harmony export */   LAYER: function() { return /* binding */ LAYER; },\n/* harmony export */   MEDIA: function() { return /* binding */ MEDIA; },\n/* harmony export */   MOZ: function() { return /* binding */ MOZ; },\n/* harmony export */   MS: function() { return /* binding */ MS; },\n/* harmony export */   NAMESPACE: function() { return /* binding */ NAMESPACE; },\n/* harmony export */   PAGE: function() { return /* binding */ PAGE; },\n/* harmony export */   RULESET: function() { return /* binding */ RULESET; },\n/* harmony export */   SUPPORTS: function() { return /* binding */ SUPPORTS; },\n/* harmony export */   VIEWPORT: function() { return /* binding */ VIEWPORT; },\n/* harmony export */   WEBKIT: function() { return /* binding */ WEBKIT; }\n/* harmony export */ });\nvar MS = \"-ms-\";\nvar MOZ = \"-moz-\";\nvar WEBKIT = \"-webkit-\";\nvar COMMENT = \"comm\";\nvar RULESET = \"rule\";\nvar DECLARATION = \"decl\";\nvar PAGE = \"@page\";\nvar MEDIA = \"@media\";\nvar IMPORT = \"@import\";\nvar CHARSET = \"@charset\";\nvar VIEWPORT = \"@viewport\";\nvar SUPPORTS = \"@supports\";\nvar DOCUMENT = \"@document\";\nvar NAMESPACE = \"@namespace\";\nvar KEYFRAMES = \"@keyframes\";\nvar FONT_FACE = \"@font-face\";\nvar COUNTER_STYLE = \"@counter-style\";\nvar FONT_FEATURE_VALUES = \"@font-feature-values\";\nvar LAYER = \"@layer\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsaXMvc3JjL0VudW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFPLElBQUlBLEtBQUssT0FBTTtBQUNmLElBQUlDLE1BQU0sUUFBTztBQUNqQixJQUFJQyxTQUFTLFdBQVU7QUFFdkIsSUFBSUMsVUFBVSxPQUFNO0FBQ3BCLElBQUlDLFVBQVUsT0FBTTtBQUNwQixJQUFJQyxjQUFjLE9BQU07QUFFeEIsSUFBSUMsT0FBTyxRQUFPO0FBQ2xCLElBQUlDLFFBQVEsU0FBUTtBQUNwQixJQUFJQyxTQUFTLFVBQVM7QUFDdEIsSUFBSUMsVUFBVSxXQUFVO0FBQ3hCLElBQUlDLFdBQVcsWUFBVztBQUMxQixJQUFJQyxXQUFXLFlBQVc7QUFDMUIsSUFBSUMsV0FBVyxZQUFXO0FBQzFCLElBQUlDLFlBQVksYUFBWTtBQUM1QixJQUFJQyxZQUFZLGFBQVk7QUFDNUIsSUFBSUMsWUFBWSxhQUFZO0FBQzVCLElBQUlDLGdCQUFnQixpQkFBZ0I7QUFDcEMsSUFBSUMsc0JBQXNCLHVCQUFzQjtBQUNoRCxJQUFJQyxRQUFRLFNBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0eWxpcy9zcmMvRW51bS5qcz8zM2YyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgTVMgPSAnLW1zLSdcbmV4cG9ydCB2YXIgTU9aID0gJy1tb3otJ1xuZXhwb3J0IHZhciBXRUJLSVQgPSAnLXdlYmtpdC0nXG5cbmV4cG9ydCB2YXIgQ09NTUVOVCA9ICdjb21tJ1xuZXhwb3J0IHZhciBSVUxFU0VUID0gJ3J1bGUnXG5leHBvcnQgdmFyIERFQ0xBUkFUSU9OID0gJ2RlY2wnXG5cbmV4cG9ydCB2YXIgUEFHRSA9ICdAcGFnZSdcbmV4cG9ydCB2YXIgTUVESUEgPSAnQG1lZGlhJ1xuZXhwb3J0IHZhciBJTVBPUlQgPSAnQGltcG9ydCdcbmV4cG9ydCB2YXIgQ0hBUlNFVCA9ICdAY2hhcnNldCdcbmV4cG9ydCB2YXIgVklFV1BPUlQgPSAnQHZpZXdwb3J0J1xuZXhwb3J0IHZhciBTVVBQT1JUUyA9ICdAc3VwcG9ydHMnXG5leHBvcnQgdmFyIERPQ1VNRU5UID0gJ0Bkb2N1bWVudCdcbmV4cG9ydCB2YXIgTkFNRVNQQUNFID0gJ0BuYW1lc3BhY2UnXG5leHBvcnQgdmFyIEtFWUZSQU1FUyA9ICdAa2V5ZnJhbWVzJ1xuZXhwb3J0IHZhciBGT05UX0ZBQ0UgPSAnQGZvbnQtZmFjZSdcbmV4cG9ydCB2YXIgQ09VTlRFUl9TVFlMRSA9ICdAY291bnRlci1zdHlsZSdcbmV4cG9ydCB2YXIgRk9OVF9GRUFUVVJFX1ZBTFVFUyA9ICdAZm9udC1mZWF0dXJlLXZhbHVlcydcbmV4cG9ydCB2YXIgTEFZRVIgPSAnQGxheWVyJ1xuIl0sIm5hbWVzIjpbIk1TIiwiTU9aIiwiV0VCS0lUIiwiQ09NTUVOVCIsIlJVTEVTRVQiLCJERUNMQVJBVElPTiIsIlBBR0UiLCJNRURJQSIsIklNUE9SVCIsIkNIQVJTRVQiLCJWSUVXUE9SVCIsIlNVUFBPUlRTIiwiRE9DVU1FTlQiLCJOQU1FU1BBQ0UiLCJLRVlGUkFNRVMiLCJGT05UX0ZBQ0UiLCJDT1VOVEVSX1NUWUxFIiwiRk9OVF9GRUFUVVJFX1ZBTFVFUyIsIkxBWUVSIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/stylis/src/Enum.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/stylis/src/Middleware.js":
/*!***********************************************!*\
  !*** ./node_modules/stylis/src/Middleware.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   middleware: function() { return /* binding */ middleware; },\n/* harmony export */   namespace: function() { return /* binding */ namespace; },\n/* harmony export */   prefixer: function() { return /* binding */ prefixer; },\n/* harmony export */   rulesheet: function() { return /* binding */ rulesheet; }\n/* harmony export */ });\n/* harmony import */ var _Enum_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Enum.js */ \"(app-pages-browser)/./node_modules/stylis/src/Enum.js\");\n/* harmony import */ var _Utility_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utility.js */ \"(app-pages-browser)/./node_modules/stylis/src/Utility.js\");\n/* harmony import */ var _Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Tokenizer.js */ \"(app-pages-browser)/./node_modules/stylis/src/Tokenizer.js\");\n/* harmony import */ var _Serializer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Serializer.js */ \"(app-pages-browser)/./node_modules/stylis/src/Serializer.js\");\n/* harmony import */ var _Prefixer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Prefixer.js */ \"(app-pages-browser)/./node_modules/stylis/src/Prefixer.js\");\n\n\n\n\n\n/**\n * @param {function[]} collection\n * @return {function}\n */ function middleware(collection) {\n    var length = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.sizeof)(collection);\n    return function(element, index, children, callback) {\n        var output = \"\";\n        for(var i = 0; i < length; i++)output += collection[i](element, index, children, callback) || \"\";\n        return output;\n    };\n}\n/**\n * @param {function} callback\n * @return {function}\n */ function rulesheet(callback) {\n    return function(element) {\n        if (!element.root) {\n            if (element = element.return) callback(element);\n        }\n    };\n}\n/**\n * @param {object} element\n * @param {number} index\n * @param {object[]} children\n * @param {function} callback\n */ function prefixer(element, index, children, callback) {\n    if (element.length > -1) {\n        if (!element.return) switch(element.type){\n            case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.DECLARATION:\n                element.return = (0,_Prefixer_js__WEBPACK_IMPORTED_MODULE_2__.prefix)(element.value, element.length, children);\n                return;\n            case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.KEYFRAMES:\n                return (0,_Serializer_js__WEBPACK_IMPORTED_MODULE_3__.serialize)([\n                    (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.copy)(element, {\n                        value: (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(element.value, \"@\", \"@\" + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT)\n                    })\n                ], callback);\n            case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.RULESET:\n                if (element.length) return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.combine)(children = element.props, function(value) {\n                    switch((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.match)(value, callback = /(::plac\\w+|:read-\\w+)/)){\n                        // :read-(only|write)\n                        case \":read-only\":\n                        case \":read-write\":\n                            (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.lift)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.copy)(element, {\n                                props: [\n                                    (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /:(read-\\w+)/, \":\" + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MOZ + \"$1\")\n                                ]\n                            }));\n                            (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.lift)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.copy)(element, {\n                                props: [\n                                    value\n                                ]\n                            }));\n                            (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.assign)(element, {\n                                props: (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.filter)(children, callback)\n                            });\n                            break;\n                        // :placeholder\n                        case \"::placeholder\":\n                            (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.lift)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.copy)(element, {\n                                props: [\n                                    (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /:(plac\\w+)/, \":\" + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + \"input-$1\")\n                                ]\n                            }));\n                            (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.lift)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.copy)(element, {\n                                props: [\n                                    (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /:(plac\\w+)/, \":\" + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MOZ + \"$1\")\n                                ]\n                            }));\n                            (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.lift)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.copy)(element, {\n                                props: [\n                                    (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /:(plac\\w+)/, _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + \"input-$1\")\n                                ]\n                            }));\n                            (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.lift)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.copy)(element, {\n                                props: [\n                                    value\n                                ]\n                            }));\n                            (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.assign)(element, {\n                                props: (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.filter)(children, callback)\n                            });\n                            break;\n                    }\n                    return \"\";\n                });\n        }\n    }\n}\n/**\n * @param {object} element\n * @param {number} index\n * @param {object[]} children\n */ function namespace(element) {\n    switch(element.type){\n        case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.RULESET:\n            element.props = element.props.map(function(value) {\n                return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.combine)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.tokenize)(value), function(value, index, children) {\n                    switch((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, 0)){\n                        // \\f\n                        case 12:\n                            return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.substr)(value, 1, (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.strlen)(value));\n                        // \\0 ( + > ~\n                        case 0:\n                        case 40:\n                        case 43:\n                        case 62:\n                        case 126:\n                            return value;\n                        // :\n                        case 58:\n                            if (children[++index] === \"global\") children[index] = \"\", children[++index] = \"\\f\" + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.substr)(children[index], index = 1, -1);\n                        // \\s\n                        case 32:\n                            return index === 1 ? \"\" : value;\n                        default:\n                            switch(index){\n                                case 0:\n                                    element = value;\n                                    return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.sizeof)(children) > 1 ? \"\" : value;\n                                case index = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.sizeof)(children) - 1:\n                                case 2:\n                                    return index === 2 ? value + element + element : value + element;\n                                default:\n                                    return value;\n                            }\n                    }\n                });\n            });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsaXMvc3JjL01pZGRsZXdhcmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQTBFO0FBQzBCO0FBQ2pEO0FBQ1Y7QUFDTDtBQUVwQzs7O0NBR0MsR0FDTSxTQUFTb0IsV0FBWUMsVUFBVTtJQUNyQyxJQUFJQyxTQUFTWixtREFBTUEsQ0FBQ1c7SUFFcEIsT0FBTyxTQUFVRSxPQUFPLEVBQUVDLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxRQUFRO1FBQ2xELElBQUlDLFNBQVM7UUFFYixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSU4sUUFBUU0sSUFDM0JELFVBQVVOLFVBQVUsQ0FBQ08sRUFBRSxDQUFDTCxTQUFTQyxPQUFPQyxVQUFVQyxhQUFhO1FBRWhFLE9BQU9DO0lBQ1I7QUFDRDtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNFLFVBQVdILFFBQVE7SUFDbEMsT0FBTyxTQUFVSCxPQUFPO1FBQ3ZCLElBQUksQ0FBQ0EsUUFBUU8sSUFBSSxFQUNoQjtZQUFBLElBQUlQLFVBQVVBLFFBQVFRLE1BQU0sRUFDM0JMLFNBQVNIO1FBQU87SUFDbkI7QUFDRDtBQUVBOzs7OztDQUtDLEdBQ00sU0FBU1MsU0FBVVQsT0FBTyxFQUFFQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsUUFBUTtJQUMzRCxJQUFJSCxRQUFRRCxNQUFNLEdBQUcsQ0FBQyxHQUNyQjtRQUFBLElBQUksQ0FBQ0MsUUFBUVEsTUFBTSxFQUNsQixPQUFRUixRQUFRVSxJQUFJO1lBQ25CLEtBQUs1QixpREFBV0E7Z0JBQUVrQixRQUFRUSxNQUFNLEdBQUdaLG9EQUFNQSxDQUFDSSxRQUFRVyxLQUFLLEVBQUVYLFFBQVFELE1BQU0sRUFBRUc7Z0JBQ3hFO1lBQ0QsS0FBS3JCLCtDQUFTQTtnQkFDYixPQUFPYyx5REFBU0EsQ0FBQztvQkFBQ0gsbURBQUlBLENBQUNRLFNBQVM7d0JBQUNXLE9BQU92QixvREFBT0EsQ0FBQ1ksUUFBUVcsS0FB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QU9ELFVBQVUsSUFBSVUsUUFBUVgsVUFBVUEsVUFBVVcsUUFBUVg7Z0NBQzFEO29DQUNDLE9BQU9XOzRCQUNUO29CQUNGO2dCQUNEO1lBQ0Q7SUFDRjtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zdHlsaXMvc3JjL01pZGRsZXdhcmUuanM/OTlhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge01TLCBNT1osIFdFQktJVCwgUlVMRVNFVCwgS0VZRlJBTUVTLCBERUNMQVJBVElPTn0gZnJvbSAnLi9FbnVtLmpzJ1xuaW1wb3J0IHttYXRjaCwgY2hhcmF0LCBzdWJzdHIsIHN0cmxlbiwgc2l6ZW9mLCByZXBsYWNlLCBjb21iaW5lLCBmaWx0ZXIsIGFzc2lnbn0gZnJvbSAnLi9VdGlsaXR5LmpzJ1xuaW1wb3J0IHtjb3B5LCBsaWZ0LCB0b2tlbml6ZX0gZnJvbSAnLi9Ub2tlbml6ZXIuanMnXG5pbXBvcnQge3NlcmlhbGl6ZX0gZnJvbSAnLi9TZXJpYWxpemVyLmpzJ1xuaW1wb3J0IHtwcmVmaXh9IGZyb20gJy4vUHJlZml4ZXIuanMnXG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbltdfSBjb2xsZWN0aW9uXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1pZGRsZXdhcmUgKGNvbGxlY3Rpb24pIHtcblx0dmFyIGxlbmd0aCA9IHNpemVvZihjb2xsZWN0aW9uKVxuXG5cdHJldHVybiBmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgsIGNoaWxkcmVuLCBjYWxsYmFjaykge1xuXHRcdHZhciBvdXRwdXQgPSAnJ1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdG91dHB1dCArPSBjb2xsZWN0aW9uW2ldKGVsZW1lbnQsIGluZGV4LCBjaGlsZHJlbiwgY2FsbGJhY2spIHx8ICcnXG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydWxlc2hlZXQgKGNhbGxiYWNrKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoZWxlbWVudCkge1xuXHRcdGlmICghZWxlbWVudC5yb290KVxuXHRcdFx0aWYgKGVsZW1lbnQgPSBlbGVtZW50LnJldHVybilcblx0XHRcdFx0Y2FsbGJhY2soZWxlbWVudClcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7b2JqZWN0W119IGNoaWxkcmVuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJlZml4ZXIgKGVsZW1lbnQsIGluZGV4LCBjaGlsZHJlbiwgY2FsbGJhY2spIHtcblx0aWYgKGVsZW1lbnQubGVuZ3RoID4gLTEpXG5cdFx0aWYgKCFlbGVtZW50LnJldHVybilcblx0XHRcdHN3aXRjaCAoZWxlbWVudC50eXBlKSB7XG5cdFx0XHRcdGNhc2UgREVDTEFSQVRJT046IGVsZW1lbnQucmV0dXJuID0gcHJlZml4KGVsZW1lbnQudmFsdWUsIGVsZW1lbnQubGVuZ3RoLCBjaGlsZHJlbilcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0Y2FzZSBLRVlGUkFNRVM6XG5cdFx0XHRcdFx0cmV0dXJuIHNlcmlhbGl6ZShbY29weShlbGVtZW50LCB7dmFsdWU6IHJlcGxhY2UoZWxlbWVudC52YWx1ZSwgJ0AnLCAnQCcgKyBXRUJLSVQpfSldLCBjYWxsYmFjaylcblx0XHRcdFx0Y2FzZSBSVUxFU0VUOlxuXHRcdFx0XHRcdGlmIChlbGVtZW50Lmxlbmd0aClcblx0XHRcdFx0XHRcdHJldHVybiBjb21iaW5lKGNoaWxkcmVuID0gZWxlbWVudC5wcm9wcywgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdHN3aXRjaCAobWF0Y2godmFsdWUsIGNhbGxiYWNrID0gLyg6OnBsYWNcXHcrfDpyZWFkLVxcdyspLykpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyA6cmVhZC0ob25seXx3cml0ZSlcblx0XHRcdFx0XHRcdFx0XHRjYXNlICc6cmVhZC1vbmx5JzogY2FzZSAnOnJlYWQtd3JpdGUnOlxuXHRcdFx0XHRcdFx0XHRcdFx0bGlmdChjb3B5KGVsZW1lbnQsIHtwcm9wczogW3JlcGxhY2UodmFsdWUsIC86KHJlYWQtXFx3KykvLCAnOicgKyBNT1ogKyAnJDEnKV19KSlcblx0XHRcdFx0XHRcdFx0XHRcdGxpZnQoY29weShlbGVtZW50LCB7cHJvcHM6IFt2YWx1ZV19KSlcblx0XHRcdFx0XHRcdFx0XHRcdGFzc2lnbihlbGVtZW50LCB7cHJvcHM6IGZpbHRlcihjaGlsZHJlbiwgY2FsbGJhY2spfSlcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0Ly8gOnBsYWNlaG9sZGVyXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnOjpwbGFjZWhvbGRlcic6XG5cdFx0XHRcdFx0XHRcdFx0XHRsaWZ0KGNvcHkoZWxlbWVudCwge3Byb3BzOiBbcmVwbGFjZSh2YWx1ZSwgLzoocGxhY1xcdyspLywgJzonICsgV0VCS0lUICsgJ2lucHV0LSQxJyldfSkpXG5cdFx0XHRcdFx0XHRcdFx0XHRsaWZ0KGNvcHkoZWxlbWVudCwge3Byb3BzOiBbcmVwbGFjZSh2YWx1ZSwgLzoocGxhY1xcdyspLywgJzonICsgTU9aICsgJyQxJyldfSkpXG5cdFx0XHRcdFx0XHRcdFx0XHRsaWZ0KGNvcHkoZWxlbWVudCwge3Byb3BzOiBbcmVwbGFjZSh2YWx1ZSwgLzoocGxhY1xcdyspLywgTVMgKyAnaW5wdXQtJDEnKV19KSlcblx0XHRcdFx0XHRcdFx0XHRcdGxpZnQoY29weShlbGVtZW50LCB7cHJvcHM6IFt2YWx1ZV19KSlcblx0XHRcdFx0XHRcdFx0XHRcdGFzc2lnbihlbGVtZW50LCB7cHJvcHM6IGZpbHRlcihjaGlsZHJlbiwgY2FsbGJhY2spfSlcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gJydcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtvYmplY3RbXX0gY2hpbGRyZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5hbWVzcGFjZSAoZWxlbWVudCkge1xuXHRzd2l0Y2ggKGVsZW1lbnQudHlwZSkge1xuXHRcdGNhc2UgUlVMRVNFVDpcblx0XHRcdGVsZW1lbnQucHJvcHMgPSBlbGVtZW50LnByb3BzLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIGNvbWJpbmUodG9rZW5pemUodmFsdWUpLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBjaGlsZHJlbikge1xuXHRcdFx0XHRcdHN3aXRjaCAoY2hhcmF0KHZhbHVlLCAwKSkge1xuXHRcdFx0XHRcdFx0Ly8gXFxmXG5cdFx0XHRcdFx0XHRjYXNlIDEyOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc3Vic3RyKHZhbHVlLCAxLCBzdHJsZW4odmFsdWUpKVxuXHRcdFx0XHRcdFx0Ly8gXFwwICggKyA+IH5cblx0XHRcdFx0XHRcdGNhc2UgMDogY2FzZSA0MDogY2FzZSA0MzogY2FzZSA2MjogY2FzZSAxMjY6XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0XHRcdFx0Ly8gOlxuXHRcdFx0XHRcdFx0Y2FzZSA1ODpcblx0XHRcdFx0XHRcdFx0aWYgKGNoaWxkcmVuWysraW5kZXhdID09PSAnZ2xvYmFsJylcblx0XHRcdFx0XHRcdFx0XHRjaGlsZHJlbltpbmRleF0gPSAnJywgY2hpbGRyZW5bKytpbmRleF0gPSAnXFxmJyArIHN1YnN0cihjaGlsZHJlbltpbmRleF0sIGluZGV4ID0gMSwgLTEpXG5cdFx0XHRcdFx0XHQvLyBcXHNcblx0XHRcdFx0XHRcdGNhc2UgMzI6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBpbmRleCA9PT0gMSA/ICcnIDogdmFsdWVcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdHN3aXRjaCAoaW5kZXgpIHtcblx0XHRcdFx0XHRcdFx0XHRjYXNlIDA6IGVsZW1lbnQgPSB2YWx1ZVxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHNpemVvZihjaGlsZHJlbikgPiAxID8gJycgOiB2YWx1ZVxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgaW5kZXggPSBzaXplb2YoY2hpbGRyZW4pIC0gMTogY2FzZSAyOlxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGluZGV4ID09PSAyID8gdmFsdWUgKyBlbGVtZW50ICsgZWxlbWVudCA6IHZhbHVlICsgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdH0pXG5cdH1cbn1cbiJdLCJuYW1lcyI6WyJNUyIsIk1PWiIsIldFQktJVCIsIlJVTEVTRVQiLCJLRVlGUkFNRVMiLCJERUNMQVJBVElPTiIsIm1hdGNoIiwiY2hhcmF0Iiwic3Vic3RyIiwic3RybGVuIiwic2l6ZW9mIiwicmVwbGFjZSIsImNvbWJpbmUiLCJmaWx0ZXIiLCJhc3NpZ24iLCJjb3B5IiwibGlmdCIsInRva2VuaXplIiwic2VyaWFsaXplIiwicHJlZml4IiwibWlkZGxld2FyZSIsImNvbGxlY3Rpb24iLCJsZW5ndGgiLCJlbGVtZW50IiwiaW5kZXgiLCJjaGlsZHJlbiIsImNhbGxiYWNrIiwib3V0cHV0IiwiaSIsInJ1bGVzaGVldCIsInJvb3QiLCJyZXR1cm4iLCJwcmVmaXhlciIsInR5cGUiLCJ2YWx1ZSIsInByb3BzIiwibmFtZXNwYWNlIiwibWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/stylis/src/Middleware.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/stylis/src/Parser.js":
/*!*******************************************!*\
  !*** ./node_modules/stylis/src/Parser.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   comment: function() { return /* binding */ comment; },\n/* harmony export */   compile: function() { return /* binding */ compile; },\n/* harmony export */   declaration: function() { return /* binding */ declaration; },\n/* harmony export */   parse: function() { return /* binding */ parse; },\n/* harmony export */   ruleset: function() { return /* binding */ ruleset; }\n/* harmony export */ });\n/* harmony import */ var _Enum_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Enum.js */ \"(app-pages-browser)/./node_modules/stylis/src/Enum.js\");\n/* harmony import */ var _Utility_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utility.js */ \"(app-pages-browser)/./node_modules/stylis/src/Utility.js\");\n/* harmony import */ var _Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tokenizer.js */ \"(app-pages-browser)/./node_modules/stylis/src/Tokenizer.js\");\n\n\n\n/**\n * @param {string} value\n * @return {object[]}\n */ function compile(value) {\n    return (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.dealloc)(parse(\"\", null, null, null, [\n        \"\"\n    ], value = (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.alloc)(value), 0, [\n        0\n    ], value));\n}\n/**\n * @param {string} value\n * @param {object} root\n * @param {object?} parent\n * @param {string[]} rule\n * @param {string[]} rules\n * @param {string[]} rulesets\n * @param {number[]} pseudo\n * @param {number[]} points\n * @param {string[]} declarations\n * @return {object}\n */ function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {\n    var index = 0;\n    var offset = 0;\n    var length = pseudo;\n    var atrule = 0;\n    var property = 0;\n    var previous = 0;\n    var variable = 1;\n    var scanning = 1;\n    var ampersand = 1;\n    var character = 0;\n    var type = \"\";\n    var props = rules;\n    var children = rulesets;\n    var reference = rule;\n    var characters = type;\n    while(scanning)switch(previous = character, character = (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.next)()){\n        // (\n        case 40:\n            if (previous != 108 && (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.charat)(characters, length - 1) == 58) {\n                if ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.indexof)(characters += (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.replace)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.delimit)(character), \"&\", \"&\\f\"), \"&\\f\", (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.abs)(index ? points[index - 1] : 0)) != -1) ampersand = -1;\n                break;\n            }\n        // \" ' [\n        case 34:\n        case 39:\n        case 91:\n            characters += (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.delimit)(character);\n            break;\n        // \\t \\n \\r \\s\n        case 9:\n        case 10:\n        case 13:\n        case 32:\n            characters += (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.whitespace)(previous);\n            break;\n        // \\\n        case 92:\n            characters += (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.escaping)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.caret)() - 1, 7);\n            continue;\n        // /\n        case 47:\n            switch((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.peek)()){\n                case 42:\n                case 47:\n                    (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.append)(comment((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.commenter)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.next)(), (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.caret)()), root, parent, declarations), declarations);\n                    break;\n                default:\n                    characters += \"/\";\n            }\n            break;\n        // {\n        case 123 * variable:\n            points[index++] = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.strlen)(characters) * ampersand;\n        // } ; \\0\n        case 125 * variable:\n        case 59:\n        case 0:\n            switch(character){\n                // \\0 }\n                case 0:\n                case 125:\n                    scanning = 0;\n                // ;\n                case 59 + offset:\n                    if (ampersand == -1) characters = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.replace)(characters, /\\f/g, \"\");\n                    if (property > 0 && (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.strlen)(characters) - length) (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.append)(property > 32 ? declaration(characters + \";\", rule, parent, length - 1, declarations) : declaration((0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.replace)(characters, \" \", \"\") + \";\", rule, parent, length - 2, declarations), declarations);\n                    break;\n                // @ ;\n                case 59:\n                    characters += \";\";\n                // { rule/at-rule\n                default:\n                    (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.append)(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length, rulesets), rulesets);\n                    if (character === 123) if (offset === 0) parse(characters, root, reference, reference, props, rulesets, length, points, children);\n                    else switch(atrule === 99 && (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.charat)(characters, 3) === 110 ? 100 : atrule){\n                        // d l m s\n                        case 100:\n                        case 108:\n                        case 109:\n                        case 115:\n                            parse(value, reference, reference, rule && (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.append)(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length, children), children), rules, children, length, points, rule ? props : children);\n                            break;\n                        default:\n                            parse(characters, reference, reference, reference, [\n                                \"\"\n                            ], children, 0, points, children);\n                    }\n            }\n            index = offset = property = 0, variable = ampersand = 1, type = characters = \"\", length = pseudo;\n            break;\n        // :\n        case 58:\n            length = 1 + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.strlen)(characters), property = previous;\n        default:\n            if (variable < 1) {\n                if (character == 123) --variable;\n                else if (character == 125 && variable++ == 0 && (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.prev)() == 125) continue;\n            }\n            switch(characters += (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.from)(character), character * variable){\n                // &\n                case 38:\n                    ampersand = offset > 0 ? 1 : (characters += \"\\f\", -1);\n                    break;\n                // ,\n                case 44:\n                    points[index++] = ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.strlen)(characters) - 1) * ampersand, ampersand = 1;\n                    break;\n                // @\n                case 64:\n                    // -\n                    if ((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.peek)() === 45) characters += (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.delimit)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.next)());\n                    atrule = (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.peek)(), offset = length = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.strlen)(type = characters += (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.identifier)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.caret)())), character++;\n                    break;\n                // -\n                case 45:\n                    if (previous === 45 && (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.strlen)(characters) == 2) variable = 0;\n            }\n    }\n    return rulesets;\n}\n/**\n * @param {string} value\n * @param {object} root\n * @param {object?} parent\n * @param {number} index\n * @param {number} offset\n * @param {string[]} rules\n * @param {number[]} points\n * @param {string} type\n * @param {string[]} props\n * @param {string[]} children\n * @param {number} length\n * @param {object[]} siblings\n * @return {object}\n */ function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length, siblings) {\n    var post = offset - 1;\n    var rule = offset === 0 ? rules : [\n        \"\"\n    ];\n    var size = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.sizeof)(rule);\n    for(var i = 0, j = 0, k = 0; i < index; ++i)for(var x = 0, y = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.substr)(value, post + 1, post = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.abs)(j = points[i])), z = value; x < size; ++x)if (z = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.trim)(j > 0 ? rule[x] + \" \" + y : (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.replace)(y, /&\\f/g, rule[x]))) props[k++] = z;\n    return (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.node)(value, root, parent, offset === 0 ? _Enum_js__WEBPACK_IMPORTED_MODULE_2__.RULESET : type, props, children, length, siblings);\n}\n/**\n * @param {number} value\n * @param {object} root\n * @param {object?} parent\n * @param {object[]} siblings\n * @return {object}\n */ function comment(value, root, parent, siblings) {\n    return (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.node)(value, root, parent, _Enum_js__WEBPACK_IMPORTED_MODULE_2__.COMMENT, (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.from)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.char)()), (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.substr)(value, 2, -2), 0, siblings);\n}\n/**\n * @param {string} value\n * @param {object} root\n * @param {object?} parent\n * @param {number} length\n * @param {object[]} siblings\n * @return {object}\n */ function declaration(value, root, parent, length, siblings) {\n    return (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.node)(value, root, parent, _Enum_js__WEBPACK_IMPORTED_MODULE_2__.DECLARATION, (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.substr)(value, 0, length), (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.substr)(value, length + 1, -1), length, siblings);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsaXMvc3JjL1BhcnNlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF1RDtBQUMrQztBQUNrQztBQUV4STs7O0NBR0MsR0FDTSxTQUFTMEIsUUFBU0MsS0FBSztJQUM3QixPQUFPUCxzREFBT0EsQ0FBQ1EsTUFBTSxJQUFJLE1BQU0sTUFBTSxNQUFNO1FBQUM7S0FBRyxFQUFFRCxRQUFRUixvREFBS0EsQ0FBQ1EsUUFBUSxHQUFHO1FBQUM7S0FBRSxFQUFFQTtBQUNoRjtBQUVBOzs7Ozs7Ozs7OztDQVdDLEdBQ00sU0FBU0MsTUFBT0QsS0FBSyxFQUFFRSxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFlBQVk7SUFDOUYsSUFBSUMsUUFBUTtJQUNaLElBQUlDLFNBQVM7SUFDYixJQUFJQyxTQUFTTDtJQUNiLElBQUlNLFNBQVM7SUFDYixJQUFJQyxXQUFXO0lBQ2YsSUFBSUMsV0FBVztJQUNmLElBQUlDLFdBQVc7SUFDZixJQUFJQyxXQUFXO0lBQ2YsSUFBSUMsWUFBWTtJQUNoQixJQUFJQyxZQUFZO0lBQ2hCLElBQUlDLE9BQU87SUFDWCxJQUFJQyxRQUFRaEI7SUFDWixJQUFJaUIsV0FBV2hCO0lBQ2YsSUFBSWlCLFlBQVluQjtJQUNoQixJQUFJb0IsYUFBYUo7SUFFakIsTUFBT0gsU0FDTixPQUFRRixXQUFXSSxXQUFXQSxZQUFZOUIsbURBQUlBO1FBQzdDLElBQUk7UUFDSixLQUFLO1lBQ0osSUFBSTBCLFlBQVksT0FBT3RDLG1EQUFNQSxDQUFDK0MsWUFBWVosU0FBUyxNQUFNLElBQUk7Z0JBQzVELElBQUkzQixvREFBT0EsQ0FBQ3VDLGNBQWN4QyxvREFBT0EsQ0FBQ1Usc0RBQU9BLENBQUN5QixZQUFZLEtBQUssUUFBUSxPQUFPM0MsZ0RBQUdBLENBQUNrQyxRQUFRRixNQUFNLENBQUNFLFFBQVEsRUFBRSxHQUFHLE9BQU8sQ0FBQyxHQUNqSFEsWUFBWSxDQUFDO2dCQUNkO1lBQ0Q7UUFDRCxRQUFRO1FBQ1IsS0FBSztRQUFJLEtBQUs7UUFBSSxLQUFLO1lBQ3RCTSxjQUFjOUIsc0RBQU9BLENBQUN5QjtZQUN0QjtRQUNELGNBQWM7UUFDZCxLQUFLO1FBQUcsS0FBSztRQUFJLEtBQUs7UUFBSSxLQUFLO1lBQzlCSyxjQUFjN0IseURBQVVBLENBQUNvQjtZQUN6QjtRQUNELElBQUk7UUFDSixLQUFLO1lBQ0pTLGNBQWM1Qix1REFBUUEsQ0FBQ0wsb0RBQUtBLEtBQUssR0FBRztZQUNwQztRQUNELElBQUk7UUFDSixLQUFLO1lBQ0osT0FBUUQsbURBQUlBO2dCQUNYLEtBQUs7Z0JBQUksS0FBSztvQkFDYlAsbURBQU1BLENBQUMwQyxRQUFRM0Isd0RBQVNBLENBQUNULG1EQUFJQSxJQUFJRSxvREFBS0EsS0FBS1csTUFBTUMsUUFBUU0sZUFBZUE7b0JBQ3hFO2dCQUNEO29CQUNDZSxjQUFjO1lBQ2hCO1lBQ0E7UUFDRCxJQUFJO1FBQ0osS0FBSyxNQUFNUjtZQUNWUixNQUFNLENBQUNFLFFBQVEsR0FBRzdCLG1EQUFNQSxDQUFDMkMsY0FBY047UUFDeEMsU0FBUztRQUNULEtBQUssTUFBTUY7UUFBVSxLQUFLO1FBQUksS0FBSztZQUNsQyxPQUFRRztnQkFDUCxPQUFPO2dCQUNQLEtBQUs7Z0JBQUcsS0FBSztvQkFBS0YsV0FBVztnQkFDN0IsSUFBSTtnQkFDSixLQUFLLEtBQUtOO29CQUFRLElBQUlPLGFBQWEsQ0FBQyxHQUFHTSxhQUFheEMsb0RBQU9BLENBQUN3QyxZQUFZLE9BQU87b0JBQzlFLElBQUlWLFdBQVcsS0FBTWpDLG1EQUFNQSxDQUFDMkMsY0FBY1osUUFDekM3QixtREFBTUEsQ0FBQytCLFdBQVcsS0FBS1ksWUFBWUYsYUFBYSxLQUFLcEIsTUFBTUQsUUFBUVMsU0FBUyxHQUFHSCxnQkFBZ0JpQixZQUFZMUMsb0RBQU9BLENBQUN3QyxZQUFZLEtBQUssTUFBTSxLQUFLcEIsTUFBTUQsUUFBUVMsU0FBUyxHQUFHSCxlQUFlQTtvQkFDekw7Z0JBQ0QsTUFBTTtnQkFDTixLQUFLO29CQUFJZSxjQUFjO2dCQUN2QixpQkFBaUI7Z0JBQ2pCO29CQUNDekMsbURBQU1BLENBQUN3QyxZQUFZSSxRQUFRSCxZQUFZdEIsTUFBTUMsUUFBUU8sT0FBT0MsUUFBUU4sT0FBT0csUUFBUVksTUFBTUMsUUFBUSxFQUFFLEVBQUVDLFdBQVcsRUFBRSxFQUFFVixRQUFRTixXQUFXQTtvQkFFdkksSUFBSWEsY0FBYyxLQUNqQixJQUFJUixXQUFXLEdBQ2RWLE1BQU11QixZQUFZdEIsTUFBTXFCLFdBQVdBLFdBQVdGLE9BQU9mLFVBQVVNLFFBQVFKLFFBQVFjO3lCQUUvRSxPQUFRVCxXQUFXLE1BQU1wQyxtREFBTUEsQ0FBQytDLFlBQVksT0FBTyxNQUFNLE1BQU1YO3dCQUM5RCxVQUFVO3dCQUNWLEtBQUs7d0JBQUssS0FBSzt3QkFBSyxLQUFLO3dCQUFLLEtBQUs7NEJBQ2xDWixNQUFNRCxPQUFPdUIsV0FBV0EsV0FBV25CLFFBQVFyQixtREFBTUEsQ0FBQzRDLFFBQVEzQixPQUFPdUIsV0FBV0EsV0FBVyxHQUFHLEdBQUdsQixPQUFPRyxRQUFRWSxNQUFNZixPQUFPZ0IsUUFBUSxFQUFFLEVBQUVULFFBQVFVLFdBQVdBLFdBQVdqQixPQUFPaUIsVUFBVVYsUUFBUUosUUFBUUosT0FBT2lCLFFBQVFDOzRCQUNuTjt3QkFDRDs0QkFDQ3JCLE1BQU11QixZQUFZRCxXQUFXQSxXQUFXQSxXQUFXO2dDQUFDOzZCQUFHLEVBQUVELFVBQVUsR0FBR2QsUUFBUWM7b0JBQ2hGO1lBQ0o7WUFFQVosUUFBUUMsU0FBU0csV0FBVyxHQUFHRSxXQUFXRSxZQUFZLEdBQUdFLE9BQU9JLGFBQWEsSUFBSVosU0FBU0w7WUFDMUY7UUFDRCxJQUFJO1FBQ0osS0FBSztZQUNKSyxTQUFTLElBQUkvQixtREFBTUEsQ0FBQzJDLGFBQWFWLFdBQVdDO1FBQzdDO1lBQ0MsSUFBSUMsV0FBVyxHQUNkO2dCQUFBLElBQUlHLGFBQWEsS0FDaEIsRUFBRUg7cUJBQ0UsSUFBSUcsYUFBYSxPQUFPSCxjQUFjLEtBQUs1QixtREFBSUEsTUFBTSxLQUN6RDtZQUFPO1lBRVQsT0FBUW9DLGNBQWM3QyxpREFBSUEsQ0FBQ3dDLFlBQVlBLFlBQVlIO2dCQUNsRCxJQUFJO2dCQUNKLEtBQUs7b0JBQ0pFLFlBQVlQLFNBQVMsSUFBSSxJQUFLYSxDQUFBQSxjQUFjLE1BQU0sQ0FBQztvQkFDbkQ7Z0JBQ0QsSUFBSTtnQkFDSixLQUFLO29CQUNKaEIsTUFBTSxDQUFDRSxRQUFRLEdBQUcsQ0FBQzdCLG1EQUFNQSxDQUFDMkMsY0FBYyxLQUFLTixXQUFXQSxZQUFZO29CQUNwRTtnQkFDRCxJQUFJO2dCQUNKLEtBQUs7b0JBQ0osSUFBSTtvQkFDSixJQUFJNUIsbURBQUlBLE9BQU8sSUFDZGtDLGNBQWM5QixzREFBT0EsQ0FBQ0wsbURBQUlBO29CQUUzQndCLFNBQVN2QixtREFBSUEsSUFBSXFCLFNBQVNDLFNBQVMvQixtREFBTUEsQ0FBQ3VDLE9BQU9JLGNBQWMzQix5REFBVUEsQ0FBQ04sb0RBQUtBLE1BQU00QjtvQkFDckY7Z0JBQ0QsSUFBSTtnQkFDSixLQUFLO29CQUNKLElBQUlKLGFBQWEsTUFBTWxDLG1EQUFNQSxDQUFDMkMsZUFBZSxHQUM1Q1IsV0FBVztZQUNkO0lBQ0Y7SUFFRCxPQUFPVjtBQUNSO0FBRUE7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDTSxTQUFTcUIsUUFBUzNCLEtBQUssRUFBRUUsSUFBSSxFQUFFQyxNQUFNLEVBQUVPLEtBQUssRUFBRUMsTUFBTSxFQUFFTixLQUFLLEVBQUVHLE1BQU0sRUFBRVksSUFBSSxFQUFFQyxLQUFLLEVBQUVDLFFBQVEsRUFBRVYsTUFBTSxFQUFFZ0IsUUFBUTtJQUNsSCxJQUFJQyxPQUFPbEIsU0FBUztJQUNwQixJQUFJUCxPQUFPTyxXQUFXLElBQUlOLFFBQVE7UUFBQztLQUFHO0lBQ3RDLElBQUl5QixPQUFPbEQsbURBQU1BLENBQUN3QjtJQUVsQixJQUFLLElBQUkyQixJQUFJLEdBQUdDLElBQUksR0FBR0MsSUFBSSxHQUFHRixJQUFJckIsT0FBTyxFQUFFcUIsRUFDMUMsSUFBSyxJQUFJRyxJQUFJLEdBQUdDLElBQUlyRCxtREFBTUEsQ0FBQ2tCLE9BQU82QixPQUFPLEdBQUdBLE9BQU9yRCxnREFBR0EsQ0FBQ3dELElBQUl4QixNQUFNLENBQUN1QixFQUFFLElBQUlLLElBQUlwQyxPQUFPa0MsSUFBSUosTUFBTSxFQUFFSSxFQUM5RixJQUFJRSxJQUFJMUQsaURBQUlBLENBQUNzRCxJQUFJLElBQUk1QixJQUFJLENBQUM4QixFQUFFLEdBQUcsTUFBTUMsSUFBSW5ELG9EQUFPQSxDQUFDbUQsR0FBRyxRQUFRL0IsSUFBSSxDQUFDOEIsRUFBRSxJQUNsRWIsS0FBSyxDQUFDWSxJQUFJLEdBQUdHO0lBRWhCLE9BQU9sRCxtREFBSUEsQ0FBQ2MsT0FBT0UsTUFBTUMsUUFBUVEsV0FBVyxJQUFJckMsNkNBQU9BLEdBQUc4QyxNQUFNQyxPQUFPQyxVQUFVVixRQUFRZ0I7QUFDMUY7QUFFQTs7Ozs7O0NBTUMsR0FDTSxTQUFTSCxRQUFTekIsS0FBSyxFQUFFRSxJQUFJLEVBQUVDLE1BQU0sRUFBRXlCLFFBQVE7SUFDckQsT0FBTzFDLG1EQUFJQSxDQUFDYyxPQUFPRSxNQUFNQyxRQUFROUIsNkNBQU9BLEVBQUVNLGlEQUFJQSxDQUFDUSxtREFBSUEsS0FBS0wsbURBQU1BLENBQUNrQixPQUFPLEdBQUcsQ0FBQyxJQUFJLEdBQUc0QjtBQUNsRjtBQUVBOzs7Ozs7O0NBT0MsR0FDTSxTQUFTRixZQUFhMUIsS0FBSyxFQUFFRSxJQUFJLEVBQUVDLE1BQU0sRUFBRVMsTUFBTSxFQUFFZ0IsUUFBUTtJQUNqRSxPQUFPMUMsbURBQUlBLENBQUNjLE9BQU9FLE1BQU1DLFFBQVE1QixpREFBV0EsRUFBRU8sbURBQU1BLENBQUNrQixPQUFPLEdBQUdZLFNBQVM5QixtREFBTUEsQ0FBQ2tCLE9BQU9ZLFNBQVMsR0FBRyxDQUFDLElBQUlBLFFBQVFnQjtBQUNoSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc3R5bGlzL3NyYy9QYXJzZXIuanM/ZmRkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NPTU1FTlQsIFJVTEVTRVQsIERFQ0xBUkFUSU9OfSBmcm9tICcuL0VudW0uanMnXG5pbXBvcnQge2FicywgY2hhcmF0LCB0cmltLCBmcm9tLCBzaXplb2YsIHN0cmxlbiwgc3Vic3RyLCBhcHBlbmQsIHJlcGxhY2UsIGluZGV4b2Z9IGZyb20gJy4vVXRpbGl0eS5qcydcbmltcG9ydCB7bm9kZSwgY2hhciwgcHJldiwgbmV4dCwgcGVlaywgY2FyZXQsIGFsbG9jLCBkZWFsbG9jLCBkZWxpbWl0LCB3aGl0ZXNwYWNlLCBlc2NhcGluZywgaWRlbnRpZmllciwgY29tbWVudGVyfSBmcm9tICcuL1Rva2VuaXplci5qcydcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge29iamVjdFtdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZSAodmFsdWUpIHtcblx0cmV0dXJuIGRlYWxsb2MocGFyc2UoJycsIG51bGwsIG51bGwsIG51bGwsIFsnJ10sIHZhbHVlID0gYWxsb2ModmFsdWUpLCAwLCBbMF0sIHZhbHVlKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7b2JqZWN0fSByb290XG4gKiBAcGFyYW0ge29iamVjdD99IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmdbXX0gcnVsZVxuICogQHBhcmFtIHtzdHJpbmdbXX0gcnVsZXNcbiAqIEBwYXJhbSB7c3RyaW5nW119IHJ1bGVzZXRzXG4gKiBAcGFyYW0ge251bWJlcltdfSBwc2V1ZG9cbiAqIEBwYXJhbSB7bnVtYmVyW119IHBvaW50c1xuICogQHBhcmFtIHtzdHJpbmdbXX0gZGVjbGFyYXRpb25zXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZSAodmFsdWUsIHJvb3QsIHBhcmVudCwgcnVsZSwgcnVsZXMsIHJ1bGVzZXRzLCBwc2V1ZG8sIHBvaW50cywgZGVjbGFyYXRpb25zKSB7XG5cdHZhciBpbmRleCA9IDBcblx0dmFyIG9mZnNldCA9IDBcblx0dmFyIGxlbmd0aCA9IHBzZXVkb1xuXHR2YXIgYXRydWxlID0gMFxuXHR2YXIgcHJvcGVydHkgPSAwXG5cdHZhciBwcmV2aW91cyA9IDBcblx0dmFyIHZhcmlhYmxlID0gMVxuXHR2YXIgc2Nhbm5pbmcgPSAxXG5cdHZhciBhbXBlcnNhbmQgPSAxXG5cdHZhciBjaGFyYWN0ZXIgPSAwXG5cdHZhciB0eXBlID0gJydcblx0dmFyIHByb3BzID0gcnVsZXNcblx0dmFyIGNoaWxkcmVuID0gcnVsZXNldHNcblx0dmFyIHJlZmVyZW5jZSA9IHJ1bGVcblx0dmFyIGNoYXJhY3RlcnMgPSB0eXBlXG5cblx0d2hpbGUgKHNjYW5uaW5nKVxuXHRcdHN3aXRjaCAocHJldmlvdXMgPSBjaGFyYWN0ZXIsIGNoYXJhY3RlciA9IG5leHQoKSkge1xuXHRcdFx0Ly8gKFxuXHRcdFx0Y2FzZSA0MDpcblx0XHRcdFx0aWYgKHByZXZpb3VzICE9IDEwOCAmJiBjaGFyYXQoY2hhcmFjdGVycywgbGVuZ3RoIC0gMSkgPT0gNTgpIHtcblx0XHRcdFx0XHRpZiAoaW5kZXhvZihjaGFyYWN0ZXJzICs9IHJlcGxhY2UoZGVsaW1pdChjaGFyYWN0ZXIpLCAnJicsICcmXFxmJyksICcmXFxmJywgYWJzKGluZGV4ID8gcG9pbnRzW2luZGV4IC0gMV0gOiAwKSkgIT0gLTEpXG5cdFx0XHRcdFx0XHRhbXBlcnNhbmQgPSAtMVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdC8vIFwiICcgW1xuXHRcdFx0Y2FzZSAzNDogY2FzZSAzOTogY2FzZSA5MTpcblx0XHRcdFx0Y2hhcmFjdGVycyArPSBkZWxpbWl0KGNoYXJhY3Rlcilcblx0XHRcdFx0YnJlYWtcblx0XHRcdC8vIFxcdCBcXG4gXFxyIFxcc1xuXHRcdFx0Y2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxuXHRcdFx0XHRjaGFyYWN0ZXJzICs9IHdoaXRlc3BhY2UocHJldmlvdXMpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHQvLyBcXFxuXHRcdFx0Y2FzZSA5Mjpcblx0XHRcdFx0Y2hhcmFjdGVycyArPSBlc2NhcGluZyhjYXJldCgpIC0gMSwgNylcblx0XHRcdFx0Y29udGludWVcblx0XHRcdC8vIC9cblx0XHRcdGNhc2UgNDc6XG5cdFx0XHRcdHN3aXRjaCAocGVlaygpKSB7XG5cdFx0XHRcdFx0Y2FzZSA0MjogY2FzZSA0Nzpcblx0XHRcdFx0XHRcdGFwcGVuZChjb21tZW50KGNvbW1lbnRlcihuZXh0KCksIGNhcmV0KCkpLCByb290LCBwYXJlbnQsIGRlY2xhcmF0aW9ucyksIGRlY2xhcmF0aW9ucylcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNoYXJhY3RlcnMgKz0gJy8nXG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWtcblx0XHRcdC8vIHtcblx0XHRcdGNhc2UgMTIzICogdmFyaWFibGU6XG5cdFx0XHRcdHBvaW50c1tpbmRleCsrXSA9IHN0cmxlbihjaGFyYWN0ZXJzKSAqIGFtcGVyc2FuZFxuXHRcdFx0Ly8gfSA7IFxcMFxuXHRcdFx0Y2FzZSAxMjUgKiB2YXJpYWJsZTogY2FzZSA1OTogY2FzZSAwOlxuXHRcdFx0XHRzd2l0Y2ggKGNoYXJhY3Rlcikge1xuXHRcdFx0XHRcdC8vIFxcMCB9XG5cdFx0XHRcdFx0Y2FzZSAwOiBjYXNlIDEyNTogc2Nhbm5pbmcgPSAwXG5cdFx0XHRcdFx0Ly8gO1xuXHRcdFx0XHRcdGNhc2UgNTkgKyBvZmZzZXQ6IGlmIChhbXBlcnNhbmQgPT0gLTEpIGNoYXJhY3RlcnMgPSByZXBsYWNlKGNoYXJhY3RlcnMsIC9cXGYvZywgJycpXG5cdFx0XHRcdFx0XHRpZiAocHJvcGVydHkgPiAwICYmIChzdHJsZW4oY2hhcmFjdGVycykgLSBsZW5ndGgpKVxuXHRcdFx0XHRcdFx0XHRhcHBlbmQocHJvcGVydHkgPiAzMiA/IGRlY2xhcmF0aW9uKGNoYXJhY3RlcnMgKyAnOycsIHJ1bGUsIHBhcmVudCwgbGVuZ3RoIC0gMSwgZGVjbGFyYXRpb25zKSA6IGRlY2xhcmF0aW9uKHJlcGxhY2UoY2hhcmFjdGVycywgJyAnLCAnJykgKyAnOycsIHJ1bGUsIHBhcmVudCwgbGVuZ3RoIC0gMiwgZGVjbGFyYXRpb25zKSwgZGVjbGFyYXRpb25zKVxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHQvLyBAIDtcblx0XHRcdFx0XHRjYXNlIDU5OiBjaGFyYWN0ZXJzICs9ICc7J1xuXHRcdFx0XHRcdC8vIHsgcnVsZS9hdC1ydWxlXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGFwcGVuZChyZWZlcmVuY2UgPSBydWxlc2V0KGNoYXJhY3RlcnMsIHJvb3QsIHBhcmVudCwgaW5kZXgsIG9mZnNldCwgcnVsZXMsIHBvaW50cywgdHlwZSwgcHJvcHMgPSBbXSwgY2hpbGRyZW4gPSBbXSwgbGVuZ3RoLCBydWxlc2V0cyksIHJ1bGVzZXRzKVxuXG5cdFx0XHRcdFx0XHRpZiAoY2hhcmFjdGVyID09PSAxMjMpXG5cdFx0XHRcdFx0XHRcdGlmIChvZmZzZXQgPT09IDApXG5cdFx0XHRcdFx0XHRcdFx0cGFyc2UoY2hhcmFjdGVycywgcm9vdCwgcmVmZXJlbmNlLCByZWZlcmVuY2UsIHByb3BzLCBydWxlc2V0cywgbGVuZ3RoLCBwb2ludHMsIGNoaWxkcmVuKVxuXHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0c3dpdGNoIChhdHJ1bGUgPT09IDk5ICYmIGNoYXJhdChjaGFyYWN0ZXJzLCAzKSA9PT0gMTEwID8gMTAwIDogYXRydWxlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBkIGwgbSBzXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlIDEwMDogY2FzZSAxMDg6IGNhc2UgMTA5OiBjYXNlIDExNTpcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2UodmFsdWUsIHJlZmVyZW5jZSwgcmVmZXJlbmNlLCBydWxlICYmIGFwcGVuZChydWxlc2V0KHZhbHVlLCByZWZlcmVuY2UsIHJlZmVyZW5jZSwgMCwgMCwgcnVsZXMsIHBvaW50cywgdHlwZSwgcnVsZXMsIHByb3BzID0gW10sIGxlbmd0aCwgY2hpbGRyZW4pLCBjaGlsZHJlbiksIHJ1bGVzLCBjaGlsZHJlbiwgbGVuZ3RoLCBwb2ludHMsIHJ1bGUgPyBwcm9wcyA6IGNoaWxkcmVuKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2UoY2hhcmFjdGVycywgcmVmZXJlbmNlLCByZWZlcmVuY2UsIHJlZmVyZW5jZSwgWycnXSwgY2hpbGRyZW4sIDAsIHBvaW50cywgY2hpbGRyZW4pXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aW5kZXggPSBvZmZzZXQgPSBwcm9wZXJ0eSA9IDAsIHZhcmlhYmxlID0gYW1wZXJzYW5kID0gMSwgdHlwZSA9IGNoYXJhY3RlcnMgPSAnJywgbGVuZ3RoID0gcHNldWRvXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHQvLyA6XG5cdFx0XHRjYXNlIDU4OlxuXHRcdFx0XHRsZW5ndGggPSAxICsgc3RybGVuKGNoYXJhY3RlcnMpLCBwcm9wZXJ0eSA9IHByZXZpb3VzXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRpZiAodmFyaWFibGUgPCAxKVxuXHRcdFx0XHRcdGlmIChjaGFyYWN0ZXIgPT0gMTIzKVxuXHRcdFx0XHRcdFx0LS12YXJpYWJsZVxuXHRcdFx0XHRcdGVsc2UgaWYgKGNoYXJhY3RlciA9PSAxMjUgJiYgdmFyaWFibGUrKyA9PSAwICYmIHByZXYoKSA9PSAxMjUpXG5cdFx0XHRcdFx0XHRjb250aW51ZVxuXG5cdFx0XHRcdHN3aXRjaCAoY2hhcmFjdGVycyArPSBmcm9tKGNoYXJhY3RlciksIGNoYXJhY3RlciAqIHZhcmlhYmxlKSB7XG5cdFx0XHRcdFx0Ly8gJlxuXHRcdFx0XHRcdGNhc2UgMzg6XG5cdFx0XHRcdFx0XHRhbXBlcnNhbmQgPSBvZmZzZXQgPiAwID8gMSA6IChjaGFyYWN0ZXJzICs9ICdcXGYnLCAtMSlcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0Ly8gLFxuXHRcdFx0XHRcdGNhc2UgNDQ6XG5cdFx0XHRcdFx0XHRwb2ludHNbaW5kZXgrK10gPSAoc3RybGVuKGNoYXJhY3RlcnMpIC0gMSkgKiBhbXBlcnNhbmQsIGFtcGVyc2FuZCA9IDFcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0Ly8gQFxuXHRcdFx0XHRcdGNhc2UgNjQ6XG5cdFx0XHRcdFx0XHQvLyAtXG5cdFx0XHRcdFx0XHRpZiAocGVlaygpID09PSA0NSlcblx0XHRcdFx0XHRcdFx0Y2hhcmFjdGVycyArPSBkZWxpbWl0KG5leHQoKSlcblxuXHRcdFx0XHRcdFx0YXRydWxlID0gcGVlaygpLCBvZmZzZXQgPSBsZW5ndGggPSBzdHJsZW4odHlwZSA9IGNoYXJhY3RlcnMgKz0gaWRlbnRpZmllcihjYXJldCgpKSksIGNoYXJhY3RlcisrXG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdC8vIC1cblx0XHRcdFx0XHRjYXNlIDQ1OlxuXHRcdFx0XHRcdFx0aWYgKHByZXZpb3VzID09PSA0NSAmJiBzdHJsZW4oY2hhcmFjdGVycykgPT0gMilcblx0XHRcdFx0XHRcdFx0dmFyaWFibGUgPSAwXG5cdFx0XHRcdH1cblx0XHR9XG5cblx0cmV0dXJuIHJ1bGVzZXRzXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge29iamVjdH0gcm9vdFxuICogQHBhcmFtIHtvYmplY3Q/fSBwYXJlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtzdHJpbmdbXX0gcnVsZXNcbiAqIEBwYXJhbSB7bnVtYmVyW119IHBvaW50c1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nW119IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBjaGlsZHJlblxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICogQHBhcmFtIHtvYmplY3RbXX0gc2libGluZ3NcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bGVzZXQgKHZhbHVlLCByb290LCBwYXJlbnQsIGluZGV4LCBvZmZzZXQsIHJ1bGVzLCBwb2ludHMsIHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgbGVuZ3RoLCBzaWJsaW5ncykge1xuXHR2YXIgcG9zdCA9IG9mZnNldCAtIDFcblx0dmFyIHJ1bGUgPSBvZmZzZXQgPT09IDAgPyBydWxlcyA6IFsnJ11cblx0dmFyIHNpemUgPSBzaXplb2YocnVsZSlcblxuXHRmb3IgKHZhciBpID0gMCwgaiA9IDAsIGsgPSAwOyBpIDwgaW5kZXg7ICsraSlcblx0XHRmb3IgKHZhciB4ID0gMCwgeSA9IHN1YnN0cih2YWx1ZSwgcG9zdCArIDEsIHBvc3QgPSBhYnMoaiA9IHBvaW50c1tpXSkpLCB6ID0gdmFsdWU7IHggPCBzaXplOyArK3gpXG5cdFx0XHRpZiAoeiA9IHRyaW0oaiA+IDAgPyBydWxlW3hdICsgJyAnICsgeSA6IHJlcGxhY2UoeSwgLyZcXGYvZywgcnVsZVt4XSkpKVxuXHRcdFx0XHRwcm9wc1trKytdID0gelxuXG5cdHJldHVybiBub2RlKHZhbHVlLCByb290LCBwYXJlbnQsIG9mZnNldCA9PT0gMCA/IFJVTEVTRVQgOiB0eXBlLCBwcm9wcywgY2hpbGRyZW4sIGxlbmd0aCwgc2libGluZ3MpXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge29iamVjdH0gcm9vdFxuICogQHBhcmFtIHtvYmplY3Q/fSBwYXJlbnRcbiAqIEBwYXJhbSB7b2JqZWN0W119IHNpYmxpbmdzXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21tZW50ICh2YWx1ZSwgcm9vdCwgcGFyZW50LCBzaWJsaW5ncykge1xuXHRyZXR1cm4gbm9kZSh2YWx1ZSwgcm9vdCwgcGFyZW50LCBDT01NRU5ULCBmcm9tKGNoYXIoKSksIHN1YnN0cih2YWx1ZSwgMiwgLTIpLCAwLCBzaWJsaW5ncylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7b2JqZWN0fSByb290XG4gKiBAcGFyYW0ge29iamVjdD99IHBhcmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICogQHBhcmFtIHtvYmplY3RbXX0gc2libGluZ3NcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY2xhcmF0aW9uICh2YWx1ZSwgcm9vdCwgcGFyZW50LCBsZW5ndGgsIHNpYmxpbmdzKSB7XG5cdHJldHVybiBub2RlKHZhbHVlLCByb290LCBwYXJlbnQsIERFQ0xBUkFUSU9OLCBzdWJzdHIodmFsdWUsIDAsIGxlbmd0aCksIHN1YnN0cih2YWx1ZSwgbGVuZ3RoICsgMSwgLTEpLCBsZW5ndGgsIHNpYmxpbmdzKVxufVxuIl0sIm5hbWVzIjpbIkNPTU1FTlQiLCJSVUxFU0VUIiwiREVDTEFSQVRJT04iLCJhYnMiLCJjaGFyYXQiLCJ0cmltIiwiZnJvbSIsInNpemVvZiIsInN0cmxlbiIsInN1YnN0ciIsImFwcGVuZCIsInJlcGxhY2UiLCJpbmRleG9mIiwibm9kZSIsImNoYXIiLCJwcmV2IiwibmV4dCIsInBlZWsiLCJjYXJldCIsImFsbG9jIiwiZGVhbGxvYyIsImRlbGltaXQiLCJ3aGl0ZXNwYWNlIiwiZXNjYXBpbmciLCJpZGVudGlmaWVyIiwiY29tbWVudGVyIiwiY29tcGlsZSIsInZhbHVlIiwicGFyc2UiLCJyb290IiwicGFyZW50IiwicnVsZSIsInJ1bGVzIiwicnVsZXNldHMiLCJwc2V1ZG8iLCJwb2ludHMiLCJkZWNsYXJhdGlvbnMiLCJpbmRleCIsIm9mZnNldCIsImxlbmd0aCIsImF0cnVsZSIsInByb3BlcnR5IiwicHJldmlvdXMiLCJ2YXJpYWJsZSIsInNjYW5uaW5nIiwiYW1wZXJzYW5kIiwiY2hhcmFjdGVyIiwidHlwZSIsInByb3BzIiwiY2hpbGRyZW4iLCJyZWZlcmVuY2UiLCJjaGFyYWN0ZXJzIiwiY29tbWVudCIsImRlY2xhcmF0aW9uIiwicnVsZXNldCIsInNpYmxpbmdzIiwicG9zdCIsInNpemUiLCJpIiwiaiIsImsiLCJ4IiwieSIsInoiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/stylis/src/Parser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/stylis/src/Prefixer.js":
/*!*********************************************!*\
  !*** ./node_modules/stylis/src/Prefixer.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   prefix: function() { return /* binding */ prefix; }\n/* harmony export */ });\n/* harmony import */ var _Enum_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Enum.js */ \"(app-pages-browser)/./node_modules/stylis/src/Enum.js\");\n/* harmony import */ var _Utility_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utility.js */ \"(app-pages-browser)/./node_modules/stylis/src/Utility.js\");\n\n\n/**\n * @param {string} value\n * @param {number} length\n * @param {object[]} children\n * @return {string}\n */ function prefix(value, length, children) {\n    switch((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.hash)(value, length)){\n        // color-adjust\n        case 5103:\n            return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + \"print-\" + value + value;\n        // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)\n        case 5737:\n        case 4201:\n        case 3177:\n        case 3433:\n        case 1641:\n        case 4457:\n        case 2921:\n        // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break\n        case 5572:\n        case 6356:\n        case 5844:\n        case 3191:\n        case 6645:\n        case 3005:\n        // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,\n        case 6391:\n        case 5879:\n        case 5623:\n        case 6135:\n        case 4599:\n        case 4855:\n        // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)\n        case 4215:\n        case 6389:\n        case 5109:\n        case 5365:\n        case 5621:\n        case 3829:\n            return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + value;\n        // tab-size\n        case 4789:\n            return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MOZ + value + value;\n        // appearance, user-select, transform, hyphens, text-size-adjust\n        case 5349:\n        case 4246:\n        case 4810:\n        case 6968:\n        case 2756:\n            return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MOZ + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + value + value;\n        // writing-mode\n        case 5936:\n            switch((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, length + 11)){\n                // vertical-l(r)\n                case 114:\n                    return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /[svh]\\w+-[tblr]{2}/, \"tb\") + value;\n                // vertical-r(l)\n                case 108:\n                    return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /[svh]\\w+-[tblr]{2}/, \"tb-rl\") + value;\n                // horizontal(-)tb\n                case 45:\n                    return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /[svh]\\w+-[tblr]{2}/, \"lr\") + value;\n            }\n        // flex, flex-direction, scroll-snap-type, writing-mode\n        case 6828:\n        case 4268:\n        case 2903:\n            return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + value + value;\n        // order\n        case 6165:\n            return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + \"flex-\" + value + value;\n        // align-items\n        case 5187:\n            return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(\\w+).+(:[^]+)/, _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + \"box-$1$2\" + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + \"flex-$1$2\") + value;\n        // align-self\n        case 5443:\n            return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + \"flex-item-\" + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /flex-|-self/g, \"\") + (!(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.match)(value, /flex-|baseline/) ? _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + \"grid-row-\" + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /flex-|-self/g, \"\") : \"\") + value;\n        // align-content\n        case 4675:\n            return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + \"flex-line-pack\" + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /align-content|flex-|-self/g, \"\") + value;\n        // flex-shrink\n        case 5548:\n            return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, \"shrink\", \"negative\") + value;\n        // flex-basis\n        case 5292:\n            return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, \"basis\", \"preferred-size\") + value;\n        // flex-grow\n        case 6060:\n            return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + \"box-\" + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, \"-grow\", \"\") + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, \"grow\", \"positive\") + value;\n        // transition\n        case 4554:\n            return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /([^-])(transform)/g, \"$1\" + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + \"$2\") + value;\n        // cursor\n        case 6187:\n            return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(zoom-|grab)/, _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + \"$1\"), /(image-set)/, _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + \"$1\"), value, \"\") + value;\n        // background, background-image\n        case 5495:\n        case 3959:\n            return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(image-set\\([^]*)/, _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + \"$1\" + \"$`$1\");\n        // justify-content\n        case 4968:\n            return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(.+:)(flex-)?(.*)/, _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + \"box-pack:$3\" + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + \"flex-pack:$3\"), /s.+-b[^;]+/, \"justify\") + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + value;\n        // justify-self\n        case 4200:\n            if (!(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.match)(value, /flex-|baseline/)) return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + \"grid-column-align\" + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.substr)(value, length) + value;\n            break;\n        // grid-template-(columns|rows)\n        case 2592:\n        case 3360:\n            return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, \"template-\", \"\") + value;\n        // grid-(row|column)-start\n        case 4384:\n        case 3616:\n            if (children && children.some(function(element, index) {\n                return length = index, (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.match)(element.props, /grid-\\w+-end/);\n            })) {\n                return ~(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.indexof)(value + (children = children[length].value), \"span\", 0) ? value : _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, \"-start\", \"\") + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + \"grid-row-span:\" + (~(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.indexof)(children, \"span\", 0) ? (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.match)(children, /\\d+/) : +(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.match)(children, /\\d+/) - +(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.match)(value, /\\d+/)) + \";\";\n            }\n            return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, \"-start\", \"\") + value;\n        // grid-(row|column)-end\n        case 4896:\n        case 4128:\n            return children && children.some(function(element) {\n                return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.match)(element.props, /grid-\\w+-start/);\n            }) ? value : _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, \"-end\", \"-span\"), \"span \", \"\") + value;\n        // (margin|padding)-inline-(start|end)\n        case 4095:\n        case 3583:\n        case 4068:\n        case 2532:\n            return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(.+)-inline(.+)/, _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + \"$1$2\") + value;\n        // (min|max)?(width|height|inline-size|block-size)\n        case 8116:\n        case 7059:\n        case 5753:\n        case 5535:\n        case 5445:\n        case 5701:\n        case 4933:\n        case 4677:\n        case 5533:\n        case 5789:\n        case 5021:\n        case 4765:\n            // stretch, max-content, min-content, fill-available\n            if ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.strlen)(value) - 1 - length > 6) switch((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, length + 1)){\n                // (m)ax-content, (m)in-content\n                case 109:\n                    // -\n                    if ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, length + 4) !== 45) break;\n                // (f)ill-available, (f)it-content\n                case 102:\n                    return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(.+:)(.+)-([^]+)/, \"$1\" + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + \"$2-$3\" + \"$1\" + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MOZ + ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, length + 3) == 108 ? \"$3\" : \"$2-$3\")) + value;\n                // (s)tretch\n                case 115:\n                    return ~(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.indexof)(value, \"stretch\", 0) ? prefix((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, \"stretch\", \"fill-available\"), length, children) + value : value;\n            }\n            break;\n        // grid-(column|row)\n        case 5152:\n        case 5920:\n            return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(.+?):(\\d+)(\\s*\\/\\s*(span)?\\s*(\\d+))?(.*)/, function(_, a, b, c, d, e, f) {\n                return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + a + \":\" + b + f + (c ? _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + a + \"-span:\" + (d ? e : +e - +b) + f : \"\") + value;\n            });\n        // position: sticky\n        case 4949:\n            // stick(y)?\n            if ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, length + 6) === 121) return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, \":\", \":\" + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT) + value;\n            break;\n        // display: (flex|inline-flex|grid|inline-grid)\n        case 6444:\n            switch((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, 14) === 45 ? 18 : 11)){\n                // (inline-)?fle(x)\n                case 120:\n                    return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(.+:)([^;\\s!]+)(;|(\\s+)?!.+)?/, \"$1\" + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, 14) === 45 ? \"inline-\" : \"\") + \"box$3\" + \"$1\" + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + \"$2$3\" + \"$1\" + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + \"$2box$3\") + value;\n                // (inline-)?gri(d)\n                case 100:\n                    return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, \":\", \":\" + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS) + value;\n            }\n            break;\n        // scroll-margin, scroll-margin-(top|right|bottom|left)\n        case 5719:\n        case 2647:\n        case 2135:\n        case 3927:\n        case 2391:\n            return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, \"scroll-\", \"scroll-snap-\") + value;\n    }\n    return value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsaXMvc3JjL1ByZWZpeGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5QztBQUN5QztBQUVsRjs7Ozs7Q0FLQyxHQUNNLFNBQVNVLE9BQVFDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxRQUFRO0lBQzlDLE9BQVFWLGlEQUFJQSxDQUFDUSxPQUFPQztRQUNuQixlQUFlO1FBQ2YsS0FBSztZQUNKLE9BQU9WLDRDQUFNQSxHQUFHLFdBQVdTLFFBQVFBO1FBQ3BDLDRHQUE0RztRQUM1RyxLQUFLO1FBQU0sS0FBSztRQUFNLEtBQUs7UUFBTSxLQUFLO1FBQU0sS0FBSztRQUFNLEtBQUs7UUFBTSxLQUFLO1FBQ3ZFLHdGQUF3RjtRQUN4RixLQUFLO1FBQU0sS0FBSztRQUFNLEtBQUs7UUFBTSxLQUFLO1FBQU0sS0FBSztRQUFNLEtBQUs7UUFDNUQsZ0dBQWdHO1FBQ2hHLEtBQUs7UUFBTSxLQUFLO1FBQU0sS0FBSztRQUFNLEtBQUs7UUFBTSxLQUFLO1FBQU0sS0FBSztRQUM1RCxxR0FBcUc7UUFDckcsS0FBSztRQUFNLEtBQUs7UUFBTSxLQUFLO1FBQU0sS0FBSztRQUFNLEtBQUs7UUFBTSxLQUFLO1lBQzNELE9BQU9ULDRDQUFNQSxHQUFHUyxRQUFRQTtRQUN6QixXQUFXO1FBQ1gsS0FBSztZQUNKLE9BQU9WLHlDQUFHQSxHQUFHVSxRQUFRQTtRQUN0QixnRUFBZ0U7UUFDaEUsS0FBSztRQUFNLEtBQUs7UUFBTSxLQUFLO1FBQU0sS0FBSztRQUFNLEtBQUs7WUFDaEQsT0FBT1QsNENBQU1BLEdBQUdTLFFBQVFWLHlDQUFHQSxHQUFHVSxRQUFRWCx3Q0FBRUEsR0FBR1csUUFBUUE7UUFDcEQsZUFBZTtRQUNmLEtBQUs7WUFDSixPQUFRUCxtREFBTUEsQ0FBQ08sT0FBT0MsU0FBUztnQkFDOUIsZ0JBQWdCO2dCQUNoQixLQUFLO29CQUNKLE9BQU9WLDRDQUFNQSxHQUFHUyxRQUFRWCx3Q0FBRUEsR0FB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QSxDQUFDSSxPQUFPLEtBQUssTUFBTVQsNENBQU1BLElBQUlTO1lBQzVDO1FBQ0QsK0NBQStDO1FBQy9DLEtBQUs7WUFDSixPQUFRUCxtREFBTUEsQ0FBQ08sT0FBT1AsbURBQU1BLENBQUNPLE9BQU8sUUFBUSxLQUFLLEtBQUs7Z0JBQ3JELG1CQUFtQjtnQkFDbkIsS0FBSztvQkFDSixPQUFPSixvREFBT0EsQ0FBQ0ksT0FBTyxpQ0FBaUMsT0FBT1QsNENBQU1BLEdBQUlFLENBQUFBLG1EQUFNQSxDQUFDTyxPQUFPLFFBQVEsS0FBSyxZQUFZLEVBQUMsSUFBSyxVQUFVLE9BQU9ULDRDQUFNQSxHQUFHLFNBQVMsT0FBT0Ysd0NBQUVBLEdBQUcsYUFBYVc7Z0JBQ2xMLG1CQUFtQjtnQkFDbkIsS0FBSztvQkFDSixPQUFPSixvREFBT0EsQ0FBQ0ksT0FBTyxLQUFLLE1BQU1YLHdDQUFFQSxJQUFJVztZQUN6QztZQUNBO1FBQ0QsdURBQXVEO1FBQ3ZELEtBQUs7UUFBTSxLQUFLO1FBQU0sS0FBSztRQUFNLEtBQUs7UUFBTSxLQUFLO1lBQ2hELE9BQU9KLG9EQUFPQSxDQUFDSSxPQUFPLFdBQVcsa0JBQWtCQTtJQUNyRDtJQUVBLE9BQU9BO0FBQ1IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0eWxpcy9zcmMvUHJlZml4ZXIuanM/YjY1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge01TLCBNT1osIFdFQktJVH0gZnJvbSAnLi9FbnVtLmpzJ1xuaW1wb3J0IHtoYXNoLCBjaGFyYXQsIHN0cmxlbiwgaW5kZXhvZiwgcmVwbGFjZSwgc3Vic3RyLCBtYXRjaH0gZnJvbSAnLi9VdGlsaXR5LmpzJ1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICogQHBhcmFtIHtvYmplY3RbXX0gY2hpbGRyZW5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZWZpeCAodmFsdWUsIGxlbmd0aCwgY2hpbGRyZW4pIHtcblx0c3dpdGNoIChoYXNoKHZhbHVlLCBsZW5ndGgpKSB7XG5cdFx0Ly8gY29sb3ItYWRqdXN0XG5cdFx0Y2FzZSA1MTAzOlxuXHRcdFx0cmV0dXJuIFdFQktJVCArICdwcmludC0nICsgdmFsdWUgKyB2YWx1ZVxuXHRcdC8vIGFuaW1hdGlvbiwgYW5pbWF0aW9uLShkZWxheXxkaXJlY3Rpb258ZHVyYXRpb258ZmlsbC1tb2RlfGl0ZXJhdGlvbi1jb3VudHxuYW1lfHBsYXktc3RhdGV8dGltaW5nLWZ1bmN0aW9uKVxuXHRcdGNhc2UgNTczNzogY2FzZSA0MjAxOiBjYXNlIDMxNzc6IGNhc2UgMzQzMzogY2FzZSAxNjQxOiBjYXNlIDQ0NTc6IGNhc2UgMjkyMTpcblx0XHQvLyB0ZXh0LWRlY29yYXRpb24sIGZpbHRlciwgY2xpcC1wYXRoLCBiYWNrZmFjZS12aXNpYmlsaXR5LCBjb2x1bW4sIGJveC1kZWNvcmF0aW9uLWJyZWFrXG5cdFx0Y2FzZSA1NTcyOiBjYXNlIDYzNTY6IGNhc2UgNTg0NDogY2FzZSAzMTkxOiBjYXNlIDY2NDU6IGNhc2UgMzAwNTpcblx0XHQvLyBtYXNrLCBtYXNrLWltYWdlLCBtYXNrLShtb2RlfGNsaXB8c2l6ZSksIG1hc2stKHJlcGVhdHxvcmlnaW4pLCBtYXNrLXBvc2l0aW9uLCBtYXNrLWNvbXBvc2l0ZSxcblx0XHRjYXNlIDYzOTE6IGNhc2UgNTg3OTogY2FzZSA1NjIzOiBjYXNlIDYxMzU6IGNhc2UgNDU5OTogY2FzZSA0ODU1OlxuXHRcdC8vIGJhY2tncm91bmQtY2xpcCwgY29sdW1ucywgY29sdW1uLShjb3VudHxmaWxsfGdhcHxydWxlfHJ1bGUtY29sb3J8cnVsZS1zdHlsZXxydWxlLXdpZHRofHNwYW58d2lkdGgpXG5cdFx0Y2FzZSA0MjE1OiBjYXNlIDYzODk6IGNhc2UgNTEwOTogY2FzZSA1MzY1OiBjYXNlIDU2MjE6IGNhc2UgMzgyOTpcblx0XHRcdHJldHVybiBXRUJLSVQgKyB2YWx1ZSArIHZhbHVlXG5cdFx0Ly8gdGFiLXNpemVcblx0XHRjYXNlIDQ3ODk6XG5cdFx0XHRyZXR1cm4gTU9aICsgdmFsdWUgKyB2YWx1ZVxuXHRcdC8vIGFwcGVhcmFuY2UsIHVzZXItc2VsZWN0LCB0cmFuc2Zvcm0sIGh5cGhlbnMsIHRleHQtc2l6ZS1hZGp1c3Rcblx0XHRjYXNlIDUzNDk6IGNhc2UgNDI0NjogY2FzZSA0ODEwOiBjYXNlIDY5Njg6IGNhc2UgMjc1Njpcblx0XHRcdHJldHVybiBXRUJLSVQgKyB2YWx1ZSArIE1PWiArIHZhbHVlICsgTVMgKyB2YWx1ZSArIHZhbHVlXG5cdFx0Ly8gd3JpdGluZy1tb2RlXG5cdFx0Y2FzZSA1OTM2OlxuXHRcdFx0c3dpdGNoIChjaGFyYXQodmFsdWUsIGxlbmd0aCArIDExKSkge1xuXHRcdFx0XHQvLyB2ZXJ0aWNhbC1sKHIpXG5cdFx0XHRcdGNhc2UgMTE0OlxuXHRcdFx0XHRcdHJldHVybiBXRUJLSVQgKyB2YWx1ZSArIE1TICsgcmVwbGFjZSh2YWx1ZSwgL1tzdmhdXFx3Ky1bdGJscl17Mn0vLCAndGInKSArIHZhbHVlXG5cdFx0XHRcdC8vIHZlcnRpY2FsLXIobClcblx0XHRcdFx0Y2FzZSAxMDg6XG5cdFx0XHRcdFx0cmV0dXJuIFdFQktJVCArIHZhbHVlICsgTVMgKyByZXBsYWNlKHZhbHVlLCAvW3N2aF1cXHcrLVt0YmxyXXsyfS8sICd0Yi1ybCcpICsgdmFsdWVcblx0XHRcdFx0Ly8gaG9yaXpvbnRhbCgtKXRiXG5cdFx0XHRcdGNhc2UgNDU6XG5cdFx0XHRcdFx0cmV0dXJuIFdFQktJVCArIHZhbHVlICsgTVMgKyByZXBsYWNlKHZhbHVlLCAvW3N2aF1cXHcrLVt0YmxyXXsyfS8sICdscicpICsgdmFsdWVcblx0XHRcdFx0Ly8gZGVmYXVsdDogZmFsbHRocm91Z2ggdG8gYmVsb3dcblx0XHRcdH1cblx0XHQvLyBmbGV4LCBmbGV4LWRpcmVjdGlvbiwgc2Nyb2xsLXNuYXAtdHlwZSwgd3JpdGluZy1tb2RlXG5cdFx0Y2FzZSA2ODI4OiBjYXNlIDQyNjg6IGNhc2UgMjkwMzpcblx0XHRcdHJldHVybiBXRUJLSVQgKyB2YWx1ZSArIE1TICsgdmFsdWUgKyB2YWx1ZVxuXHRcdC8vIG9yZGVyXG5cdFx0Y2FzZSA2MTY1OlxuXHRcdFx0cmV0dXJuIFdFQktJVCArIHZhbHVlICsgTVMgKyAnZmxleC0nICsgdmFsdWUgKyB2YWx1ZVxuXHRcdC8vIGFsaWduLWl0ZW1zXG5cdFx0Y2FzZSA1MTg3OlxuXHRcdFx0cmV0dXJuIFdFQktJVCArIHZhbHVlICsgcmVwbGFjZSh2YWx1ZSwgLyhcXHcrKS4rKDpbXl0rKS8sIFdFQktJVCArICdib3gtJDEkMicgKyBNUyArICdmbGV4LSQxJDInKSArIHZhbHVlXG5cdFx0Ly8gYWxpZ24tc2VsZlxuXHRcdGNhc2UgNTQ0Mzpcblx0XHRcdHJldHVybiBXRUJLSVQgKyB2YWx1ZSArIE1TICsgJ2ZsZXgtaXRlbS0nICsgcmVwbGFjZSh2YWx1ZSwgL2ZsZXgtfC1zZWxmL2csICcnKSArICghbWF0Y2godmFsdWUsIC9mbGV4LXxiYXNlbGluZS8pID8gTVMgKyAnZ3JpZC1yb3ctJyArIHJlcGxhY2UodmFsdWUsIC9mbGV4LXwtc2VsZi9nLCAnJykgOiAnJykgKyB2YWx1ZVxuXHRcdC8vIGFsaWduLWNvbnRlbnRcblx0XHRjYXNlIDQ2NzU6XG5cdFx0XHRyZXR1cm4gV0VCS0lUICsgdmFsdWUgKyBNUyArICdmbGV4LWxpbmUtcGFjaycgKyByZXBsYWNlKHZhbHVlLCAvYWxpZ24tY29udGVudHxmbGV4LXwtc2VsZi9nLCAnJykgKyB2YWx1ZVxuXHRcdC8vIGZsZXgtc2hyaW5rXG5cdFx0Y2FzZSA1NTQ4OlxuXHRcdFx0cmV0dXJuIFdFQktJVCArIHZhbHVlICsgTVMgKyByZXBsYWNlKHZhbHVlLCAnc2hyaW5rJywgJ25lZ2F0aXZlJykgKyB2YWx1ZVxuXHRcdC8vIGZsZXgtYmFzaXNcblx0XHRjYXNlIDUyOTI6XG5cdFx0XHRyZXR1cm4gV0VCS0lUICsgdmFsdWUgKyBNUyArIHJlcGxhY2UodmFsdWUsICdiYXNpcycsICdwcmVmZXJyZWQtc2l6ZScpICsgdmFsdWVcblx0XHQvLyBmbGV4LWdyb3dcblx0XHRjYXNlIDYwNjA6XG5cdFx0XHRyZXR1cm4gV0VCS0lUICsgJ2JveC0nICsgcmVwbGFjZSh2YWx1ZSwgJy1ncm93JywgJycpICsgV0VCS0lUICsgdmFsdWUgKyBNUyArIHJlcGxhY2UodmFsdWUsICdncm93JywgJ3Bvc2l0aXZlJykgKyB2YWx1ZVxuXHRcdC8vIHRyYW5zaXRpb25cblx0XHRjYXNlIDQ1NTQ6XG5cdFx0XHRyZXR1cm4gV0VCS0lUICsgcmVwbGFjZSh2YWx1ZSwgLyhbXi1dKSh0cmFuc2Zvcm0pL2csICckMScgKyBXRUJLSVQgKyAnJDInKSArIHZhbHVlXG5cdFx0Ly8gY3Vyc29yXG5cdFx0Y2FzZSA2MTg3OlxuXHRcdFx0cmV0dXJuIHJlcGxhY2UocmVwbGFjZShyZXBsYWNlKHZhbHVlLCAvKHpvb20tfGdyYWIpLywgV0VCS0lUICsgJyQxJyksIC8oaW1hZ2Utc2V0KS8sIFdFQktJVCArICckMScpLCB2YWx1ZSwgJycpICsgdmFsdWVcblx0XHQvLyBiYWNrZ3JvdW5kLCBiYWNrZ3JvdW5kLWltYWdlXG5cdFx0Y2FzZSA1NDk1OiBjYXNlIDM5NTk6XG5cdFx0XHRyZXR1cm4gcmVwbGFjZSh2YWx1ZSwgLyhpbWFnZS1zZXRcXChbXl0qKS8sIFdFQktJVCArICckMScgKyAnJGAkMScpXG5cdFx0Ly8ganVzdGlmeS1jb250ZW50XG5cdFx0Y2FzZSA0OTY4OlxuXHRcdFx0cmV0dXJuIHJlcGxhY2UocmVwbGFjZSh2YWx1ZSwgLyguKzopKGZsZXgtKT8oLiopLywgV0VCS0lUICsgJ2JveC1wYWNrOiQzJyArIE1TICsgJ2ZsZXgtcGFjazokMycpLCAvcy4rLWJbXjtdKy8sICdqdXN0aWZ5JykgKyBXRUJLSVQgKyB2YWx1ZSArIHZhbHVlXG5cdFx0Ly8ganVzdGlmeS1zZWxmXG5cdFx0Y2FzZSA0MjAwOlxuXHRcdFx0aWYgKCFtYXRjaCh2YWx1ZSwgL2ZsZXgtfGJhc2VsaW5lLykpIHJldHVybiBNUyArICdncmlkLWNvbHVtbi1hbGlnbicgKyBzdWJzdHIodmFsdWUsIGxlbmd0aCkgKyB2YWx1ZVxuXHRcdFx0YnJlYWtcblx0XHQvLyBncmlkLXRlbXBsYXRlLShjb2x1bW5zfHJvd3MpXG5cdFx0Y2FzZSAyNTkyOiBjYXNlIDMzNjA6XG5cdFx0XHRyZXR1cm4gTVMgKyByZXBsYWNlKHZhbHVlLCAndGVtcGxhdGUtJywgJycpICsgdmFsdWVcblx0XHQvLyBncmlkLShyb3d8Y29sdW1uKS1zdGFydFxuXHRcdGNhc2UgNDM4NDogY2FzZSAzNjE2OlxuXHRcdFx0aWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7IHJldHVybiBsZW5ndGggPSBpbmRleCwgbWF0Y2goZWxlbWVudC5wcm9wcywgL2dyaWQtXFx3Ky1lbmQvKSB9KSkge1xuXHRcdFx0XHRyZXR1cm4gfmluZGV4b2YodmFsdWUgKyAoY2hpbGRyZW4gPSBjaGlsZHJlbltsZW5ndGhdLnZhbHVlKSwgJ3NwYW4nLCAwKSA/IHZhbHVlIDogKE1TICsgcmVwbGFjZSh2YWx1ZSwgJy1zdGFydCcsICcnKSArIHZhbHVlICsgTVMgKyAnZ3JpZC1yb3ctc3BhbjonICsgKH5pbmRleG9mKGNoaWxkcmVuLCAnc3BhbicsIDApID8gbWF0Y2goY2hpbGRyZW4sIC9cXGQrLykgOiArbWF0Y2goY2hpbGRyZW4sIC9cXGQrLykgLSArbWF0Y2godmFsdWUsIC9cXGQrLykpICsgJzsnKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE1TICsgcmVwbGFjZSh2YWx1ZSwgJy1zdGFydCcsICcnKSArIHZhbHVlXG5cdFx0Ly8gZ3JpZC0ocm93fGNvbHVtbiktZW5kXG5cdFx0Y2FzZSA0ODk2OiBjYXNlIDQxMjg6XG5cdFx0XHRyZXR1cm4gKGNoaWxkcmVuICYmIGNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIG1hdGNoKGVsZW1lbnQucHJvcHMsIC9ncmlkLVxcdystc3RhcnQvKSB9KSkgPyB2YWx1ZSA6IE1TICsgcmVwbGFjZShyZXBsYWNlKHZhbHVlLCAnLWVuZCcsICctc3BhbicpLCAnc3BhbiAnLCAnJykgKyB2YWx1ZVxuXHRcdC8vIChtYXJnaW58cGFkZGluZyktaW5saW5lLShzdGFydHxlbmQpXG5cdFx0Y2FzZSA0MDk1OiBjYXNlIDM1ODM6IGNhc2UgNDA2ODogY2FzZSAyNTMyOlxuXHRcdFx0cmV0dXJuIHJlcGxhY2UodmFsdWUsIC8oLispLWlubGluZSguKykvLCBXRUJLSVQgKyAnJDEkMicpICsgdmFsdWVcblx0XHQvLyAobWlufG1heCk/KHdpZHRofGhlaWdodHxpbmxpbmUtc2l6ZXxibG9jay1zaXplKVxuXHRcdGNhc2UgODExNjogY2FzZSA3MDU5OiBjYXNlIDU3NTM6IGNhc2UgNTUzNTpcblx0XHRjYXNlIDU0NDU6IGNhc2UgNTcwMTogY2FzZSA0OTMzOiBjYXNlIDQ2Nzc6XG5cdFx0Y2FzZSA1NTMzOiBjYXNlIDU3ODk6IGNhc2UgNTAyMTogY2FzZSA0NzY1OlxuXHRcdFx0Ly8gc3RyZXRjaCwgbWF4LWNvbnRlbnQsIG1pbi1jb250ZW50LCBmaWxsLWF2YWlsYWJsZVxuXHRcdFx0aWYgKHN0cmxlbih2YWx1ZSkgLSAxIC0gbGVuZ3RoID4gNilcblx0XHRcdFx0c3dpdGNoIChjaGFyYXQodmFsdWUsIGxlbmd0aCArIDEpKSB7XG5cdFx0XHRcdFx0Ly8gKG0pYXgtY29udGVudCwgKG0paW4tY29udGVudFxuXHRcdFx0XHRcdGNhc2UgMTA5OlxuXHRcdFx0XHRcdFx0Ly8gLVxuXHRcdFx0XHRcdFx0aWYgKGNoYXJhdCh2YWx1ZSwgbGVuZ3RoICsgNCkgIT09IDQ1KVxuXHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdC8vIChmKWlsbC1hdmFpbGFibGUsIChmKWl0LWNvbnRlbnRcblx0XHRcdFx0XHRjYXNlIDEwMjpcblx0XHRcdFx0XHRcdHJldHVybiByZXBsYWNlKHZhbHVlLCAvKC4rOikoLispLShbXl0rKS8sICckMScgKyBXRUJLSVQgKyAnJDItJDMnICsgJyQxJyArIE1PWiArIChjaGFyYXQodmFsdWUsIGxlbmd0aCArIDMpID09IDEwOCA/ICckMycgOiAnJDItJDMnKSkgKyB2YWx1ZVxuXHRcdFx0XHRcdC8vIChzKXRyZXRjaFxuXHRcdFx0XHRcdGNhc2UgMTE1OlxuXHRcdFx0XHRcdFx0cmV0dXJuIH5pbmRleG9mKHZhbHVlLCAnc3RyZXRjaCcsIDApID8gcHJlZml4KHJlcGxhY2UodmFsdWUsICdzdHJldGNoJywgJ2ZpbGwtYXZhaWxhYmxlJyksIGxlbmd0aCwgY2hpbGRyZW4pICsgdmFsdWUgOiB2YWx1ZVxuXHRcdFx0XHR9XG5cdFx0XHRicmVha1xuXHRcdC8vIGdyaWQtKGNvbHVtbnxyb3cpXG5cdFx0Y2FzZSA1MTUyOiBjYXNlIDU5MjA6XG5cdFx0XHRyZXR1cm4gcmVwbGFjZSh2YWx1ZSwgLyguKz8pOihcXGQrKShcXHMqXFwvXFxzKihzcGFuKT9cXHMqKFxcZCspKT8oLiopLywgZnVuY3Rpb24gKF8sIGEsIGIsIGMsIGQsIGUsIGYpIHsgcmV0dXJuIChNUyArIGEgKyAnOicgKyBiICsgZikgKyAoYyA/IChNUyArIGEgKyAnLXNwYW46JyArIChkID8gZSA6ICtlIC0gK2IpKSArIGYgOiAnJykgKyB2YWx1ZSB9KVxuXHRcdC8vIHBvc2l0aW9uOiBzdGlja3lcblx0XHRjYXNlIDQ5NDk6XG5cdFx0XHQvLyBzdGljayh5KT9cblx0XHRcdGlmIChjaGFyYXQodmFsdWUsIGxlbmd0aCArIDYpID09PSAxMjEpXG5cdFx0XHRcdHJldHVybiByZXBsYWNlKHZhbHVlLCAnOicsICc6JyArIFdFQktJVCkgKyB2YWx1ZVxuXHRcdFx0YnJlYWtcblx0XHQvLyBkaXNwbGF5OiAoZmxleHxpbmxpbmUtZmxleHxncmlkfGlubGluZS1ncmlkKVxuXHRcdGNhc2UgNjQ0NDpcblx0XHRcdHN3aXRjaCAoY2hhcmF0KHZhbHVlLCBjaGFyYXQodmFsdWUsIDE0KSA9PT0gNDUgPyAxOCA6IDExKSkge1xuXHRcdFx0XHQvLyAoaW5saW5lLSk/ZmxlKHgpXG5cdFx0XHRcdGNhc2UgMTIwOlxuXHRcdFx0XHRcdHJldHVybiByZXBsYWNlKHZhbHVlLCAvKC4rOikoW147XFxzIV0rKSg7fChcXHMrKT8hLispPy8sICckMScgKyBXRUJLSVQgKyAoY2hhcmF0KHZhbHVlLCAxNCkgPT09IDQ1ID8gJ2lubGluZS0nIDogJycpICsgJ2JveCQzJyArICckMScgKyBXRUJLSVQgKyAnJDIkMycgKyAnJDEnICsgTVMgKyAnJDJib3gkMycpICsgdmFsdWVcblx0XHRcdFx0Ly8gKGlubGluZS0pP2dyaShkKVxuXHRcdFx0XHRjYXNlIDEwMDpcblx0XHRcdFx0XHRyZXR1cm4gcmVwbGFjZSh2YWx1ZSwgJzonLCAnOicgKyBNUykgKyB2YWx1ZVxuXHRcdFx0fVxuXHRcdFx0YnJlYWtcblx0XHQvLyBzY3JvbGwtbWFyZ2luLCBzY3JvbGwtbWFyZ2luLSh0b3B8cmlnaHR8Ym90dG9tfGxlZnQpXG5cdFx0Y2FzZSA1NzE5OiBjYXNlIDI2NDc6IGNhc2UgMjEzNTogY2FzZSAzOTI3OiBjYXNlIDIzOTE6XG5cdFx0XHRyZXR1cm4gcmVwbGFjZSh2YWx1ZSwgJ3Njcm9sbC0nLCAnc2Nyb2xsLXNuYXAtJykgKyB2YWx1ZVxuXHR9XG5cblx0cmV0dXJuIHZhbHVlXG59XG4iXSwibmFtZXMiOlsiTVMiLCJNT1oiLCJXRUJLSVQiLCJoYXNoIiwiY2hhcmF0Iiwic3RybGVuIiwiaW5kZXhvZiIsInJlcGxhY2UiLCJzdWJzdHIiLCJtYXRjaCIsInByZWZpeCIsInZhbHVlIiwibGVuZ3RoIiwiY2hpbGRyZW4iLCJzb21lIiwiZWxlbWVudCIsImluZGV4IiwicHJvcHMiLCJfIiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/stylis/src/Prefixer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/stylis/src/Serializer.js":
/*!***********************************************!*\
  !*** ./node_modules/stylis/src/Serializer.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   serialize: function() { return /* binding */ serialize; },\n/* harmony export */   stringify: function() { return /* binding */ stringify; }\n/* harmony export */ });\n/* harmony import */ var _Enum_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Enum.js */ \"(app-pages-browser)/./node_modules/stylis/src/Enum.js\");\n/* harmony import */ var _Utility_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utility.js */ \"(app-pages-browser)/./node_modules/stylis/src/Utility.js\");\n\n\n/**\n * @param {object[]} children\n * @param {function} callback\n * @return {string}\n */ function serialize(children, callback) {\n    var output = \"\";\n    for(var i = 0; i < children.length; i++)output += callback(children[i], i, children, callback) || \"\";\n    return output;\n}\n/**\n * @param {object} element\n * @param {number} index\n * @param {object[]} children\n * @param {function} callback\n * @return {string}\n */ function stringify(element, index, children, callback) {\n    switch(element.type){\n        case _Enum_js__WEBPACK_IMPORTED_MODULE_0__.LAYER:\n            if (element.children.length) break;\n        case _Enum_js__WEBPACK_IMPORTED_MODULE_0__.IMPORT:\n        case _Enum_js__WEBPACK_IMPORTED_MODULE_0__.DECLARATION:\n            return element.return = element.return || element.value;\n        case _Enum_js__WEBPACK_IMPORTED_MODULE_0__.COMMENT:\n            return \"\";\n        case _Enum_js__WEBPACK_IMPORTED_MODULE_0__.KEYFRAMES:\n            return element.return = element.value + \"{\" + serialize(element.children, callback) + \"}\";\n        case _Enum_js__WEBPACK_IMPORTED_MODULE_0__.RULESET:\n            if (!(0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.strlen)(element.value = element.props.join(\",\"))) return \"\";\n    }\n    return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.strlen)(children = serialize(element.children, callback)) ? element.return = element.value + \"{\" + children + \"}\" : \"\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsaXMvc3JjL1NlcmlhbGl6ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpRjtBQUM5QztBQUVuQzs7OztDQUlDLEdBQ00sU0FBU08sVUFBV0MsUUFBUSxFQUFFQyxRQUFRO0lBQzVDLElBQUlDLFNBQVM7SUFFYixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsU0FBU0ksTUFBTSxFQUFFRCxJQUNwQ0QsVUFBVUQsU0FBU0QsUUFBUSxDQUFDRyxFQUFFLEVBQUVBLEdBQUdILFVBQVVDLGFBQWE7SUFFM0QsT0FBT0M7QUFDUjtBQUVBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNHLFVBQVdDLE9BQU8sRUFBRUMsS0FBSyxFQUFFUCxRQUFRLEVBQUVDLFFBQVE7SUFDNUQsT0FBUUssUUFBUUUsSUFBSTtRQUNuQixLQUFLZiwyQ0FBS0E7WUFBRSxJQUFJYSxRQUFRTixRQUFRLENBQUNJLE1BQU0sRUFBRTtRQUN6QyxLQUFLWiw0Q0FBTUE7UUFBRSxLQUFLSSxpREFBV0E7WUFBRSxPQUFPVSxRQUFRRyxNQUFNLEdBQUdILFFBQVFHLE1BQU0sSUFBSUgsUUFBUUksS0FBSztRQUN0RixLQUFLaEIsNkNBQU9BO1lBQUUsT0FBTztRQUNyQixLQUFLRywrQ0FBU0E7WUFBRSxPQUFPUyxRQUFRRyxNQUFNLEdBQUdILFFBQVFJLEtBQUssR0FBRyxNQUFNWCxVQUFVTyxRQUFRTixRQUFRLEVBQUVDLFlBQVk7UUFDdEcsS0FBS04sNkNBQU9BO1lBQUUsSUFBSSxDQUFDRyxtREFBTUEsQ0FBQ1EsUUFBUUksS0FBSyxHQUFHSixRQUFRSyxLQUFLLENBQUNDLElBQUksQ0FBQyxPQUFPLE9BQU87SUFDNUU7SUFFQSxPQUFPZCxtREFBTUEsQ0FBQ0UsV0FBV0QsVUFBVU8sUUFBUU4sUUFBUSxFQUFFQyxhQUFhSyxRQUFRRyxNQUFNLEdBQUdILFFBQVFJLEtBQUssR0FBRyxNQUFNVixXQUFXLE1BQU07QUFDM0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0eWxpcy9zcmMvU2VyaWFsaXplci5qcz9iMGViIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SU1QT1JULCBMQVlFUiwgQ09NTUVOVCwgUlVMRVNFVCwgREVDTEFSQVRJT04sIEtFWUZSQU1FU30gZnJvbSAnLi9FbnVtLmpzJ1xuaW1wb3J0IHtzdHJsZW59IGZyb20gJy4vVXRpbGl0eS5qcydcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdFtdfSBjaGlsZHJlblxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZSAoY2hpbGRyZW4sIGNhbGxiYWNrKSB7XG5cdHZhciBvdXRwdXQgPSAnJ1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG5cdFx0b3V0cHV0ICs9IGNhbGxiYWNrKGNoaWxkcmVuW2ldLCBpLCBjaGlsZHJlbiwgY2FsbGJhY2spIHx8ICcnXG5cblx0cmV0dXJuIG91dHB1dFxufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7b2JqZWN0W119IGNoaWxkcmVuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5IChlbGVtZW50LCBpbmRleCwgY2hpbGRyZW4sIGNhbGxiYWNrKSB7XG5cdHN3aXRjaCAoZWxlbWVudC50eXBlKSB7XG5cdFx0Y2FzZSBMQVlFUjogaWYgKGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoKSBicmVha1xuXHRcdGNhc2UgSU1QT1JUOiBjYXNlIERFQ0xBUkFUSU9OOiByZXR1cm4gZWxlbWVudC5yZXR1cm4gPSBlbGVtZW50LnJldHVybiB8fCBlbGVtZW50LnZhbHVlXG5cdFx0Y2FzZSBDT01NRU5UOiByZXR1cm4gJydcblx0XHRjYXNlIEtFWUZSQU1FUzogcmV0dXJuIGVsZW1lbnQucmV0dXJuID0gZWxlbWVudC52YWx1ZSArICd7JyArIHNlcmlhbGl6ZShlbGVtZW50LmNoaWxkcmVuLCBjYWxsYmFjaykgKyAnfSdcblx0XHRjYXNlIFJVTEVTRVQ6IGlmICghc3RybGVuKGVsZW1lbnQudmFsdWUgPSBlbGVtZW50LnByb3BzLmpvaW4oJywnKSkpIHJldHVybiAnJ1xuXHR9XG5cblx0cmV0dXJuIHN0cmxlbihjaGlsZHJlbiA9IHNlcmlhbGl6ZShlbGVtZW50LmNoaWxkcmVuLCBjYWxsYmFjaykpID8gZWxlbWVudC5yZXR1cm4gPSBlbGVtZW50LnZhbHVlICsgJ3snICsgY2hpbGRyZW4gKyAnfScgOiAnJ1xufVxuIl0sIm5hbWVzIjpbIklNUE9SVCIsIkxBWUVSIiwiQ09NTUVOVCIsIlJVTEVTRVQiLCJERUNMQVJBVElPTiIsIktFWUZSQU1FUyIsInN0cmxlbiIsInNlcmlhbGl6ZSIsImNoaWxkcmVuIiwiY2FsbGJhY2siLCJvdXRwdXQiLCJpIiwibGVuZ3RoIiwic3RyaW5naWZ5IiwiZWxlbWVudCIsImluZGV4IiwidHlwZSIsInJldHVybiIsInZhbHVlIiwicHJvcHMiLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/stylis/src/Serializer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/stylis/src/Tokenizer.js":
/*!**********************************************!*\
  !*** ./node_modules/stylis/src/Tokenizer.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   alloc: function() { return /* binding */ alloc; },\n/* harmony export */   caret: function() { return /* binding */ caret; },\n/* harmony export */   char: function() { return /* binding */ char; },\n/* harmony export */   character: function() { return /* binding */ character; },\n/* harmony export */   characters: function() { return /* binding */ characters; },\n/* harmony export */   column: function() { return /* binding */ column; },\n/* harmony export */   commenter: function() { return /* binding */ commenter; },\n/* harmony export */   copy: function() { return /* binding */ copy; },\n/* harmony export */   dealloc: function() { return /* binding */ dealloc; },\n/* harmony export */   delimit: function() { return /* binding */ delimit; },\n/* harmony export */   delimiter: function() { return /* binding */ delimiter; },\n/* harmony export */   escaping: function() { return /* binding */ escaping; },\n/* harmony export */   identifier: function() { return /* binding */ identifier; },\n/* harmony export */   length: function() { return /* binding */ length; },\n/* harmony export */   lift: function() { return /* binding */ lift; },\n/* harmony export */   line: function() { return /* binding */ line; },\n/* harmony export */   next: function() { return /* binding */ next; },\n/* harmony export */   node: function() { return /* binding */ node; },\n/* harmony export */   peek: function() { return /* binding */ peek; },\n/* harmony export */   position: function() { return /* binding */ position; },\n/* harmony export */   prev: function() { return /* binding */ prev; },\n/* harmony export */   slice: function() { return /* binding */ slice; },\n/* harmony export */   token: function() { return /* binding */ token; },\n/* harmony export */   tokenize: function() { return /* binding */ tokenize; },\n/* harmony export */   tokenizer: function() { return /* binding */ tokenizer; },\n/* harmony export */   whitespace: function() { return /* binding */ whitespace; }\n/* harmony export */ });\n/* harmony import */ var _Utility_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utility.js */ \"(app-pages-browser)/./node_modules/stylis/src/Utility.js\");\n\nvar line = 1;\nvar column = 1;\nvar length = 0;\nvar position = 0;\nvar character = 0;\nvar characters = \"\";\n/**\n * @param {string} value\n * @param {object | null} root\n * @param {object | null} parent\n * @param {string} type\n * @param {string[] | string} props\n * @param {object[] | string} children\n * @param {object[]} siblings\n * @param {number} length\n */ function node(value, root, parent, type, props, children, length, siblings) {\n    return {\n        value: value,\n        root: root,\n        parent: parent,\n        type: type,\n        props: props,\n        children: children,\n        line: line,\n        column: column,\n        length: length,\n        return: \"\",\n        siblings: siblings\n    };\n}\n/**\n * @param {object} root\n * @param {object} props\n * @return {object}\n */ function copy(root, props) {\n    return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.assign)(node(\"\", null, null, \"\", null, null, 0, root.siblings), root, {\n        length: -root.length\n    }, props);\n}\n/**\n * @param {object} root\n */ function lift(root) {\n    while(root.root)root = copy(root.root, {\n        children: [\n            root\n        ]\n    });\n    (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.append)(root, root.siblings);\n}\n/**\n * @return {number}\n */ function char() {\n    return character;\n}\n/**\n * @return {number}\n */ function prev() {\n    character = position > 0 ? (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(characters, --position) : 0;\n    if (column--, character === 10) column = 1, line--;\n    return character;\n}\n/**\n * @return {number}\n */ function next() {\n    character = position < length ? (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(characters, position++) : 0;\n    if (column++, character === 10) column = 1, line++;\n    return character;\n}\n/**\n * @return {number}\n */ function peek() {\n    return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(characters, position);\n}\n/**\n * @return {number}\n */ function caret() {\n    return position;\n}\n/**\n * @param {number} begin\n * @param {number} end\n * @return {string}\n */ function slice(begin, end) {\n    return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.substr)(characters, begin, end);\n}\n/**\n * @param {number} type\n * @return {number}\n */ function token(type) {\n    switch(type){\n        // \\0 \\t \\n \\r \\s whitespace token\n        case 0:\n        case 9:\n        case 10:\n        case 13:\n        case 32:\n            return 5;\n        // ! + , / > @ ~ isolate token\n        case 33:\n        case 43:\n        case 44:\n        case 47:\n        case 62:\n        case 64:\n        case 126:\n        // ; { } breakpoint token\n        case 59:\n        case 123:\n        case 125:\n            return 4;\n        // : accompanied token\n        case 58:\n            return 3;\n        // \" ' ( [ opening delimit token\n        case 34:\n        case 39:\n        case 40:\n        case 91:\n            return 2;\n        // ) ] closing delimit token\n        case 41:\n        case 93:\n            return 1;\n    }\n    return 0;\n}\n/**\n * @param {string} value\n * @return {any[]}\n */ function alloc(value) {\n    return line = column = 1, length = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.strlen)(characters = value), position = 0, [];\n}\n/**\n * @param {any} value\n * @return {any}\n */ function dealloc(value) {\n    return characters = \"\", value;\n}\n/**\n * @param {number} type\n * @return {string}\n */ function delimit(type) {\n    return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.trim)(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));\n}\n/**\n * @param {string} value\n * @return {string[]}\n */ function tokenize(value) {\n    return dealloc(tokenizer(alloc(value)));\n}\n/**\n * @param {number} type\n * @return {string}\n */ function whitespace(type) {\n    while(character = peek())if (character < 33) next();\n    else break;\n    return token(type) > 2 || token(character) > 3 ? \"\" : \" \";\n}\n/**\n * @param {string[]} children\n * @return {string[]}\n */ function tokenizer(children) {\n    while(next())switch(token(character)){\n        case 0:\n            (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.append)(identifier(position - 1), children);\n            break;\n        case 2:\n            (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.append)(delimit(character), children);\n            break;\n        default:\n            (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.append)((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.from)(character), children);\n    }\n    return children;\n}\n/**\n * @param {number} index\n * @param {number} count\n * @return {string}\n */ function escaping(index, count) {\n    while(--count && next())// not 0-9 A-F a-f\n    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97) break;\n    return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));\n}\n/**\n * @param {number} type\n * @return {number}\n */ function delimiter(type) {\n    while(next())switch(character){\n        // ] ) \" '\n        case type:\n            return position;\n        // \" '\n        case 34:\n        case 39:\n            if (type !== 34 && type !== 39) delimiter(character);\n            break;\n        // (\n        case 40:\n            if (type === 41) delimiter(type);\n            break;\n        // \\\n        case 92:\n            next();\n            break;\n    }\n    return position;\n}\n/**\n * @param {number} type\n * @param {number} index\n * @return {number}\n */ function commenter(type, index) {\n    while(next())// //\n    if (type + character === 47 + 10) break;\n    else if (type + character === 42 + 42 && peek() === 47) break;\n    return \"/*\" + slice(index, position - 1) + \"*\" + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.from)(type === 47 ? type : next());\n}\n/**\n * @param {number} index\n * @return {string}\n */ function identifier(index) {\n    while(!token(peek()))next();\n    return slice(index, position);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsaXMvc3JjL1Rva2VuaXplci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0U7QUFFeEUsSUFBSU8sT0FBTyxFQUFDO0FBQ1osSUFBSUMsU0FBUyxFQUFDO0FBQ2QsSUFBSUMsU0FBUyxFQUFDO0FBQ2QsSUFBSUMsV0FBVyxFQUFDO0FBQ2hCLElBQUlDLFlBQVksRUFBQztBQUNqQixJQUFJQyxhQUFhLEdBQUU7QUFFMUI7Ozs7Ozs7OztDQVNDLEdBQ00sU0FBU0MsS0FBTUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLFFBQVEsRUFBRVYsTUFBTSxFQUFFVyxRQUFRO0lBQ2pGLE9BQU87UUFBQ04sT0FBT0E7UUFBT0MsTUFBTUE7UUFBTUMsUUFBUUE7UUFBUUMsTUFBTUE7UUFBTUMsT0FBT0E7UUFBT0MsVUFBVUE7UUFBVVosTUFBTUE7UUFBTUMsUUFBUUE7UUFBUUMsUUFBUUE7UUFBUVksUUFBUTtRQUFJRCxVQUFVQTtJQUFRO0FBQzNLO0FBRUE7Ozs7Q0FJQyxHQUNNLFNBQVNFLEtBQU1QLElBQUksRUFBRUcsS0FBSztJQUNoQyxPQUFPWixtREFBTUEsQ0FBQ08sS0FBSyxJQUFJLE1BQU0sTUFBTSxJQUFJLE1BQU0sTUFBTSxHQUFHRSxLQUFLSyxRQUFRLEdBQUdMLE1BQU07UUFBQ04sUUFBUSxDQUFDTSxLQUFLTixNQUFNO0lBQUEsR0FBR1M7QUFDckc7QUFFQTs7Q0FFQyxHQUNNLFNBQVNLLEtBQU1SLElBQUk7SUFDekIsTUFBT0EsS0FBS0EsSUFBSSxDQUNmQSxPQUFPTyxLQUFLUCxLQUFLQSxJQUFJLEVBQUU7UUFBQ0ksVUFBVTtZQUFDSjtTQUFLO0lBQUE7SUFFekNWLG1EQUFNQSxDQUFDVSxNQUFNQSxLQUFLSyxRQUFRO0FBQzNCO0FBRUE7O0NBRUMsR0FDTSxTQUFTSTtJQUNmLE9BQU9i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QUM3RztJQUVGLE9BQU9rQixNQUFNYSxPQUFPZCxVQUFXZSxDQUFBQSxRQUFRLEtBQUtoQixVQUFVLE1BQU1ELFVBQVUsRUFBQztBQUN4RTtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNVLFVBQVduQixJQUFJO0lBQzlCLE1BQU9TLE9BQ04sT0FBUWY7UUFDUCxVQUFVO1FBQ1YsS0FBS007WUFDSixPQUFPUDtRQUNSLE1BQU07UUFDTixLQUFLO1FBQUksS0FBSztZQUNiLElBQUlPLFNBQVMsTUFBTUEsU0FBUyxJQUMzQm1CLFVBQVV6QjtZQUNYO1FBQ0QsSUFBSTtRQUNKLEtBQUs7WUFDSixJQUFJTSxTQUFTLElBQ1ptQixVQUFVbkI7WUFDWDtRQUNELElBQUk7UUFDSixLQUFLO1lBQ0pTO1lBQ0E7SUFDRjtJQUVELE9BQU9oQjtBQUNSO0FBRUE7Ozs7Q0FJQyxHQUNNLFNBQVNrQyxVQUFXM0IsSUFBSSxFQUFFeUIsS0FBSztJQUNyQyxNQUFPaEIsT0FDTixLQUFLO0lBQ0wsSUFBSVQsT0FBT04sY0FBYyxLQUFLLElBQzdCO1NBRUksSUFBSU0sT0FBT04sY0FBYyxLQUFLLE1BQU1nQixXQUFXLElBQ25EO0lBRUYsT0FBTyxPQUFPRSxNQUFNYSxPQUFPaEMsV0FBVyxLQUFLLE1BQU1WLGlEQUFJQSxDQUFDaUIsU0FBUyxLQUFLQSxPQUFPUztBQUM1RTtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNjLFdBQVlFLEtBQUs7SUFDaEMsTUFBTyxDQUFDVixNQUFNTCxRQUNiRDtJQUVELE9BQU9HLE1BQU1hLE9BQU9oQztBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc3R5bGlzL3NyYy9Ub2tlbml6ZXIuanM/M2ZjNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2Zyb20sIHRyaW0sIGNoYXJhdCwgc3RybGVuLCBzdWJzdHIsIGFwcGVuZCwgYXNzaWdufSBmcm9tICcuL1V0aWxpdHkuanMnXG5cbmV4cG9ydCB2YXIgbGluZSA9IDFcbmV4cG9ydCB2YXIgY29sdW1uID0gMVxuZXhwb3J0IHZhciBsZW5ndGggPSAwXG5leHBvcnQgdmFyIHBvc2l0aW9uID0gMFxuZXhwb3J0IHZhciBjaGFyYWN0ZXIgPSAwXG5leHBvcnQgdmFyIGNoYXJhY3RlcnMgPSAnJ1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtvYmplY3QgfCBudWxsfSByb290XG4gKiBAcGFyYW0ge29iamVjdCB8IG51bGx9IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nW10gfCBzdHJpbmd9IHByb3BzXG4gKiBAcGFyYW0ge29iamVjdFtdIHwgc3RyaW5nfSBjaGlsZHJlblxuICogQHBhcmFtIHtvYmplY3RbXX0gc2libGluZ3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vZGUgKHZhbHVlLCByb290LCBwYXJlbnQsIHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgbGVuZ3RoLCBzaWJsaW5ncykge1xuXHRyZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgcm9vdDogcm9vdCwgcGFyZW50OiBwYXJlbnQsIHR5cGU6IHR5cGUsIHByb3BzOiBwcm9wcywgY2hpbGRyZW46IGNoaWxkcmVuLCBsaW5lOiBsaW5lLCBjb2x1bW46IGNvbHVtbiwgbGVuZ3RoOiBsZW5ndGgsIHJldHVybjogJycsIHNpYmxpbmdzOiBzaWJsaW5nc31cbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gcm9vdFxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5IChyb290LCBwcm9wcykge1xuXHRyZXR1cm4gYXNzaWduKG5vZGUoJycsIG51bGwsIG51bGwsICcnLCBudWxsLCBudWxsLCAwLCByb290LnNpYmxpbmdzKSwgcm9vdCwge2xlbmd0aDogLXJvb3QubGVuZ3RofSwgcHJvcHMpXG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IHJvb3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpZnQgKHJvb3QpIHtcblx0d2hpbGUgKHJvb3Qucm9vdClcblx0XHRyb290ID0gY29weShyb290LnJvb3QsIHtjaGlsZHJlbjogW3Jvb3RdfSlcblxuXHRhcHBlbmQocm9vdCwgcm9vdC5zaWJsaW5ncylcbn1cblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGFyICgpIHtcblx0cmV0dXJuIGNoYXJhY3RlclxufVxuXG4vKipcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXYgKCkge1xuXHRjaGFyYWN0ZXIgPSBwb3NpdGlvbiA+IDAgPyBjaGFyYXQoY2hhcmFjdGVycywgLS1wb3NpdGlvbikgOiAwXG5cblx0aWYgKGNvbHVtbi0tLCBjaGFyYWN0ZXIgPT09IDEwKVxuXHRcdGNvbHVtbiA9IDEsIGxpbmUtLVxuXG5cdHJldHVybiBjaGFyYWN0ZXJcbn1cblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuZXh0ICgpIHtcblx0Y2hhcmFjdGVyID0gcG9zaXRpb24gPCBsZW5ndGggPyBjaGFyYXQoY2hhcmFjdGVycywgcG9zaXRpb24rKykgOiAwXG5cblx0aWYgKGNvbHVtbisrLCBjaGFyYWN0ZXIgPT09IDEwKVxuXHRcdGNvbHVtbiA9IDEsIGxpbmUrK1xuXG5cdHJldHVybiBjaGFyYWN0ZXJcbn1cblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwZWVrICgpIHtcblx0cmV0dXJuIGNoYXJhdChjaGFyYWN0ZXJzLCBwb3NpdGlvbilcbn1cblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYXJldCAoKSB7XG5cdHJldHVybiBwb3NpdGlvblxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBiZWdpblxuICogQHBhcmFtIHtudW1iZXJ9IGVuZFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xpY2UgKGJlZ2luLCBlbmQpIHtcblx0cmV0dXJuIHN1YnN0cihjaGFyYWN0ZXJzLCBiZWdpbiwgZW5kKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b2tlbiAodHlwZSkge1xuXHRzd2l0Y2ggKHR5cGUpIHtcblx0XHQvLyBcXDAgXFx0IFxcbiBcXHIgXFxzIHdoaXRlc3BhY2UgdG9rZW5cblx0XHRjYXNlIDA6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcblx0XHRcdHJldHVybiA1XG5cdFx0Ly8gISArICwgLyA+IEAgfiBpc29sYXRlIHRva2VuXG5cdFx0Y2FzZSAzMzogY2FzZSA0MzogY2FzZSA0NDogY2FzZSA0NzogY2FzZSA2MjogY2FzZSA2NDogY2FzZSAxMjY6XG5cdFx0Ly8gOyB7IH0gYnJlYWtwb2ludCB0b2tlblxuXHRcdGNhc2UgNTk6IGNhc2UgMTIzOiBjYXNlIDEyNTpcblx0XHRcdHJldHVybiA0XG5cdFx0Ly8gOiBhY2NvbXBhbmllZCB0b2tlblxuXHRcdGNhc2UgNTg6XG5cdFx0XHRyZXR1cm4gM1xuXHRcdC8vIFwiICcgKCBbIG9wZW5pbmcgZGVsaW1pdCB0b2tlblxuXHRcdGNhc2UgMzQ6IGNhc2UgMzk6IGNhc2UgNDA6IGNhc2UgOTE6XG5cdFx0XHRyZXR1cm4gMlxuXHRcdC8vICkgXSBjbG9zaW5nIGRlbGltaXQgdG9rZW5cblx0XHRjYXNlIDQxOiBjYXNlIDkzOlxuXHRcdFx0cmV0dXJuIDFcblx0fVxuXG5cdHJldHVybiAwXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHthbnlbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFsbG9jICh2YWx1ZSkge1xuXHRyZXR1cm4gbGluZSA9IGNvbHVtbiA9IDEsIGxlbmd0aCA9IHN0cmxlbihjaGFyYWN0ZXJzID0gdmFsdWUpLCBwb3NpdGlvbiA9IDAsIFtdXG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJuIHthbnl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWFsbG9jICh2YWx1ZSkge1xuXHRyZXR1cm4gY2hhcmFjdGVycyA9ICcnLCB2YWx1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxpbWl0ICh0eXBlKSB7XG5cdHJldHVybiB0cmltKHNsaWNlKHBvc2l0aW9uIC0gMSwgZGVsaW1pdGVyKHR5cGUgPT09IDkxID8gdHlwZSArIDIgOiB0eXBlID09PSA0MCA/IHR5cGUgKyAxIDogdHlwZSkpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7c3RyaW5nW119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b2tlbml6ZSAodmFsdWUpIHtcblx0cmV0dXJuIGRlYWxsb2ModG9rZW5pemVyKGFsbG9jKHZhbHVlKSkpXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdoaXRlc3BhY2UgKHR5cGUpIHtcblx0d2hpbGUgKGNoYXJhY3RlciA9IHBlZWsoKSlcblx0XHRpZiAoY2hhcmFjdGVyIDwgMzMpXG5cdFx0XHRuZXh0KClcblx0XHRlbHNlXG5cdFx0XHRicmVha1xuXG5cdHJldHVybiB0b2tlbih0eXBlKSA+IDIgfHwgdG9rZW4oY2hhcmFjdGVyKSA+IDMgPyAnJyA6ICcgJ1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nW119IGNoaWxkcmVuXG4gKiBAcmV0dXJuIHtzdHJpbmdbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRva2VuaXplciAoY2hpbGRyZW4pIHtcblx0d2hpbGUgKG5leHQoKSlcblx0XHRzd2l0Y2ggKHRva2VuKGNoYXJhY3RlcikpIHtcblx0XHRcdGNhc2UgMDogYXBwZW5kKGlkZW50aWZpZXIocG9zaXRpb24gLSAxKSwgY2hpbGRyZW4pXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6IGFwcGVuZChkZWxpbWl0KGNoYXJhY3RlciksIGNoaWxkcmVuKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0ZGVmYXVsdDogYXBwZW5kKGZyb20oY2hhcmFjdGVyKSwgY2hpbGRyZW4pXG5cdFx0fVxuXG5cdHJldHVybiBjaGlsZHJlblxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGluZyAoaW5kZXgsIGNvdW50KSB7XG5cdHdoaWxlICgtLWNvdW50ICYmIG5leHQoKSlcblx0XHQvLyBub3QgMC05IEEtRiBhLWZcblx0XHRpZiAoY2hhcmFjdGVyIDwgNDggfHwgY2hhcmFjdGVyID4gMTAyIHx8IChjaGFyYWN0ZXIgPiA1NyAmJiBjaGFyYWN0ZXIgPCA2NSkgfHwgKGNoYXJhY3RlciA+IDcwICYmIGNoYXJhY3RlciA8IDk3KSlcblx0XHRcdGJyZWFrXG5cblx0cmV0dXJuIHNsaWNlKGluZGV4LCBjYXJldCgpICsgKGNvdW50IDwgNiAmJiBwZWVrKCkgPT0gMzIgJiYgbmV4dCgpID09IDMyKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVsaW1pdGVyICh0eXBlKSB7XG5cdHdoaWxlIChuZXh0KCkpXG5cdFx0c3dpdGNoIChjaGFyYWN0ZXIpIHtcblx0XHRcdC8vIF0gKSBcIiAnXG5cdFx0XHRjYXNlIHR5cGU6XG5cdFx0XHRcdHJldHVybiBwb3NpdGlvblxuXHRcdFx0Ly8gXCIgJ1xuXHRcdFx0Y2FzZSAzNDogY2FzZSAzOTpcblx0XHRcdFx0aWYgKHR5cGUgIT09IDM0ICYmIHR5cGUgIT09IDM5KVxuXHRcdFx0XHRcdGRlbGltaXRlcihjaGFyYWN0ZXIpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHQvLyAoXG5cdFx0XHRjYXNlIDQwOlxuXHRcdFx0XHRpZiAodHlwZSA9PT0gNDEpXG5cdFx0XHRcdFx0ZGVsaW1pdGVyKHR5cGUpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHQvLyBcXFxuXHRcdFx0Y2FzZSA5Mjpcblx0XHRcdFx0bmV4dCgpXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdHJldHVybiBwb3NpdGlvblxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbW1lbnRlciAodHlwZSwgaW5kZXgpIHtcblx0d2hpbGUgKG5leHQoKSlcblx0XHQvLyAvL1xuXHRcdGlmICh0eXBlICsgY2hhcmFjdGVyID09PSA0NyArIDEwKVxuXHRcdFx0YnJlYWtcblx0XHQvLyAvKlxuXHRcdGVsc2UgaWYgKHR5cGUgKyBjaGFyYWN0ZXIgPT09IDQyICsgNDIgJiYgcGVlaygpID09PSA0Nylcblx0XHRcdGJyZWFrXG5cblx0cmV0dXJuICcvKicgKyBzbGljZShpbmRleCwgcG9zaXRpb24gLSAxKSArICcqJyArIGZyb20odHlwZSA9PT0gNDcgPyB0eXBlIDogbmV4dCgpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpZmllciAoaW5kZXgpIHtcblx0d2hpbGUgKCF0b2tlbihwZWVrKCkpKVxuXHRcdG5leHQoKVxuXG5cdHJldHVybiBzbGljZShpbmRleCwgcG9zaXRpb24pXG59XG4iXSwibmFtZXMiOlsiZnJvbSIsInRyaW0iLCJjaGFyYXQiLCJzdHJsZW4iLCJzdWJzdHIiLCJhcHBlbmQiLCJhc3NpZ24iLCJsaW5lIiwiY29sdW1uIiwibGVuZ3RoIiwicG9zaXRpb24iLCJjaGFyYWN0ZXIiLCJjaGFyYWN0ZXJzIiwibm9kZSIsInZhbHVlIiwicm9vdCIsInBhcmVudCIsInR5cGUiLCJwcm9wcyIsImNoaWxkcmVuIiwic2libGluZ3MiLCJyZXR1cm4iLCJjb3B5IiwibGlmdCIsImNoYXIiLCJwcmV2IiwibmV4dCIsInBlZWsiLCJjYXJldCIsInNsaWNlIiwiYmVnaW4iLCJlbmQiLCJ0b2tlbiIsImFsbG9jIiwiZGVhbGxvYyIsImRlbGltaXQiLCJkZWxpbWl0ZXIiLCJ0b2tlbml6ZSIsInRva2VuaXplciIsIndoaXRlc3BhY2UiLCJpZGVudGlmaWVyIiwiZXNjYXBpbmciLCJpbmRleCIsImNvdW50IiwiY29tbWVudGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/stylis/src/Tokenizer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/stylis/src/Utility.js":
/*!********************************************!*\
  !*** ./node_modules/stylis/src/Utility.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abs: function() { return /* binding */ abs; },\n/* harmony export */   append: function() { return /* binding */ append; },\n/* harmony export */   assign: function() { return /* binding */ assign; },\n/* harmony export */   charat: function() { return /* binding */ charat; },\n/* harmony export */   combine: function() { return /* binding */ combine; },\n/* harmony export */   filter: function() { return /* binding */ filter; },\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   indexof: function() { return /* binding */ indexof; },\n/* harmony export */   match: function() { return /* binding */ match; },\n/* harmony export */   replace: function() { return /* binding */ replace; },\n/* harmony export */   sizeof: function() { return /* binding */ sizeof; },\n/* harmony export */   strlen: function() { return /* binding */ strlen; },\n/* harmony export */   substr: function() { return /* binding */ substr; },\n/* harmony export */   trim: function() { return /* binding */ trim; }\n/* harmony export */ });\n/**\n * @param {number}\n * @return {number}\n */ var abs = Math.abs;\n/**\n * @param {number}\n * @return {string}\n */ var from = String.fromCharCode;\n/**\n * @param {object}\n * @return {object}\n */ var assign = Object.assign;\n/**\n * @param {string} value\n * @param {number} length\n * @return {number}\n */ function hash(value, length) {\n    return charat(value, 0) ^ 45 ? (((length << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;\n}\n/**\n * @param {string} value\n * @return {string}\n */ function trim(value) {\n    return value.trim();\n}\n/**\n * @param {string} value\n * @param {RegExp} pattern\n * @return {string?}\n */ function match(value, pattern) {\n    return (value = pattern.exec(value)) ? value[0] : value;\n}\n/**\n * @param {string} value\n * @param {(string|RegExp)} pattern\n * @param {string} replacement\n * @return {string}\n */ function replace(value, pattern, replacement) {\n    return value.replace(pattern, replacement);\n}\n/**\n * @param {string} value\n * @param {string} search\n * @param {number} position\n * @return {number}\n */ function indexof(value, search, position) {\n    return value.indexOf(search, position);\n}\n/**\n * @param {string} value\n * @param {number} index\n * @return {number}\n */ function charat(value, index) {\n    return value.charCodeAt(index) | 0;\n}\n/**\n * @param {string} value\n * @param {number} begin\n * @param {number} end\n * @return {string}\n */ function substr(value, begin, end) {\n    return value.slice(begin, end);\n}\n/**\n * @param {string} value\n * @return {number}\n */ function strlen(value) {\n    return value.length;\n}\n/**\n * @param {any[]} value\n * @return {number}\n */ function sizeof(value) {\n    return value.length;\n}\n/**\n * @param {any} value\n * @param {any[]} array\n * @return {any}\n */ function append(value, array) {\n    return array.push(value), value;\n}\n/**\n * @param {string[]} array\n * @param {function} callback\n * @return {string}\n */ function combine(array, callback) {\n    return array.map(callback).join(\"\");\n}\n/**\n * @param {string[]} array\n * @param {RegExp} pattern\n * @return {string[]}\n */ function filter(array, pattern) {\n    return array.filter(function(value) {\n        return !match(value, pattern);\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsaXMvc3JjL1V0aWxpdHkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBQ00sSUFBSUEsTUFBTUMsS0FBS0QsR0FBRztBQUV6Qjs7O0NBR0MsR0FDTSxJQUFJRSxPQUFPQyxPQUFPQyxZQUFZO0FBRXJDOzs7Q0FHQyxHQUNNLElBQUlDLFNBQVNDLE9BQU9ELE1BQU07QUFFakM7Ozs7Q0FJQyxHQUNNLFNBQVNFLEtBQU1DLEtBQUssRUFBRUMsTUFBTTtJQUNsQyxPQUFPQyxPQUFPRixPQUFPLEtBQUssS0FBSyxDQUFFLENBQUUsQ0FBRSxVQUFXLElBQUtFLE9BQU9GLE9BQU8sRUFBQyxLQUFNLElBQUtFLE9BQU9GLE9BQU8sRUFBQyxLQUFNLElBQUtFLE9BQU9GLE9BQU8sRUFBQyxLQUFNLElBQUtFLE9BQU9GLE9BQU8sS0FBSztBQUN2SjtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNHLEtBQU1ILEtBQUs7SUFDMUIsT0FBT0EsTUFBTUcsSUFBSTtBQUNsQjtBQUVBOzs7O0NBSUMsR0FDTSxTQUFTQyxNQUFPSixLQUFLLEVBQUVLLE9BQU87SUFDcEMsT0FBTyxDQUFDTCxRQUFRSyxRQUFRQyxJQUFJLENBQUNOLE1BQUssSUFBS0EsS0FBSyxDQUFDLEVBQUUsR0FBR0E7QUFDbkQ7QUFFQTs7Ozs7Q0FLQyxHQUNNLFNBQVNPLFFBQVNQLEtBQUssRUFBRUssT0FBTyxFQUFFRyxXQUFXO0lBQ25ELE9BQU9SLE1BQU1PLE9BQU8sQ0FBQ0YsU0FBU0c7QUFDL0I7QUFFQTs7Ozs7Q0FLQyxHQUNNLFNBQVNDLFFBQVNULEtBQUssRUFBRVUsTUFBTSxFQUFFQyxRQUFRO0lBQy9DLE9BQU9YLE1BQU1ZLE9BQU8sQ0FBQ0YsUUFBUUM7QUFDOUI7QUFFQTs7OztDQUlDLEdBQ00sU0FBU1QsT0FBUUYsS0FBSyxFQUFFYSxLQUFLO0lBQ25DLE9BQU9iLE1BQU1jLFVBQVUsQ0FBQ0QsU0FBUztBQUNsQztBQUVBOzs7OztDQUtDLEdBQ00sU0FBU0UsT0FBUWYsS0FBSyxFQUFFZ0IsS0FBSyxFQUFFQyxHQUFHO0lBQ3hDLE9BQU9qQixNQUFNa0IsS0FBSyxDQUFDRixPQUFPQztBQUMzQjtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNFLE9BQVFuQixLQUFLO0lBQzVCLE9BQU9BLE1BQU1DLE1BQU07QUFDcEI7QUFFQTs7O0NBR0MsR0FDTSxTQUFTbUIsT0FBUXBCLEtBQUs7SUFDNUIsT0FBT0EsTUFBTUMsTUFBTTtBQUNwQjtBQUVBOzs7O0NBSUMsR0FDTSxTQUFTb0IsT0FBUXJCLEtBQUssRUFBRXNCLEtBQUs7SUFDbkMsT0FBT0EsTUFBTUMsSUFBSSxDQUFDdkIsUUFBUUE7QUFDM0I7QUFFQTs7OztDQUlDLEdBQ00sU0FBU3dCLFFBQVNGLEtBQUssRUFBRUcsUUFBUTtJQUN2QyxPQUFPSCxNQUFNSSxHQUFHLENBQUNELFVBQVVFLElBQUksQ0FBQztBQUNqQztBQUVBOzs7O0NBSUMsR0FDTSxTQUFTQyxPQUFRTixLQUFLLEVBQUVqQixPQUFPO0lBQ3JDLE9BQU9pQixNQUFNTSxNQUFNLENBQUMsU0FBVTVCLEtBQUs7UUFBSSxPQUFPLENBQUNJLE1BQU1KLE9BQU9LO0lBQVM7QUFDdEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0eWxpcy9zcmMvVXRpbGl0eS5qcz85YjQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgYWJzID0gTWF0aC5hYnNcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBmcm9tID0gU3RyaW5nLmZyb21DaGFyQ29kZVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5leHBvcnQgdmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ25cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2ggKHZhbHVlLCBsZW5ndGgpIHtcblx0cmV0dXJuIGNoYXJhdCh2YWx1ZSwgMCkgXiA0NSA/ICgoKCgoKChsZW5ndGggPDwgMikgXiBjaGFyYXQodmFsdWUsIDApKSA8PCAyKSBeIGNoYXJhdCh2YWx1ZSwgMSkpIDw8IDIpIF4gY2hhcmF0KHZhbHVlLCAyKSkgPDwgMikgXiBjaGFyYXQodmFsdWUsIDMpIDogMFxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbSAodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlLnRyaW0oKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtSZWdFeHB9IHBhdHRlcm5cbiAqIEByZXR1cm4ge3N0cmluZz99XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaCAodmFsdWUsIHBhdHRlcm4pIHtcblx0cmV0dXJuICh2YWx1ZSA9IHBhdHRlcm4uZXhlYyh2YWx1ZSkpID8gdmFsdWVbMF0gOiB2YWx1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHsoc3RyaW5nfFJlZ0V4cCl9IHBhdHRlcm5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZXBsYWNlbWVudFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZSAodmFsdWUsIHBhdHRlcm4sIHJlcGxhY2VtZW50KSB7XG5cdHJldHVybiB2YWx1ZS5yZXBsYWNlKHBhdHRlcm4sIHJlcGxhY2VtZW50KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFxuICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmRleG9mICh2YWx1ZSwgc2VhcmNoLCBwb3NpdGlvbikge1xuXHRyZXR1cm4gdmFsdWUuaW5kZXhPZihzZWFyY2gsIHBvc2l0aW9uKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGFyYXQgKHZhbHVlLCBpbmRleCkge1xuXHRyZXR1cm4gdmFsdWUuY2hhckNvZGVBdChpbmRleCkgfCAwXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gYmVnaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnN0ciAodmFsdWUsIGJlZ2luLCBlbmQpIHtcblx0cmV0dXJuIHZhbHVlLnNsaWNlKGJlZ2luLCBlbmQpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJsZW4gKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZS5sZW5ndGhcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueVtdfSB2YWx1ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2l6ZW9mICh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUubGVuZ3RoXG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge2FueVtdfSBhcnJheVxuICogQHJldHVybiB7YW55fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kICh2YWx1ZSwgYXJyYXkpIHtcblx0cmV0dXJuIGFycmF5LnB1c2godmFsdWUpLCB2YWx1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFycmF5XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZSAoYXJyYXksIGNhbGxiYWNrKSB7XG5cdHJldHVybiBhcnJheS5tYXAoY2FsbGJhY2spLmpvaW4oJycpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gYXJyYXlcbiAqIEBwYXJhbSB7UmVnRXhwfSBwYXR0ZXJuXG4gKiBAcmV0dXJuIHtzdHJpbmdbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlciAoYXJyYXksIHBhdHRlcm4pIHtcblx0cmV0dXJuIGFycmF5LmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICFtYXRjaCh2YWx1ZSwgcGF0dGVybikgfSlcbn1cbiJdLCJuYW1lcyI6WyJhYnMiLCJNYXRoIiwiZnJvbSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFzc2lnbiIsIk9iamVjdCIsImhhc2giLCJ2YWx1ZSIsImxlbmd0aCIsImNoYXJhdCIsInRyaW0iLCJtYXRjaCIsInBhdHRlcm4iLCJleGVjIiwicmVwbGFjZSIsInJlcGxhY2VtZW50IiwiaW5kZXhvZiIsInNlYXJjaCIsInBvc2l0aW9uIiwiaW5kZXhPZiIsImluZGV4IiwiY2hhckNvZGVBdCIsInN1YnN0ciIsImJlZ2luIiwiZW5kIiwic2xpY2UiLCJzdHJsZW4iLCJzaXplb2YiLCJhcHBlbmQiLCJhcnJheSIsInB1c2giLCJjb21iaW5lIiwiY2FsbGJhY2siLCJtYXAiLCJqb2luIiwiZmlsdGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/stylis/src/Utility.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fhongseungjae%2FDesktop%2Flearning.js%2Fdaedongyourmap%2Fapp%2Fcomponents%2Fmap%2FmapLayout.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);